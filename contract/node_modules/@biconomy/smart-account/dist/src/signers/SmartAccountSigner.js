"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartAccountSigner = void 0;
const ethers_1 = require("ethers");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
class SmartAccountSigner extends abstract_signer_1.Signer {
    constructor(provider, defaultChainId) {
        super();
        this.provider = provider;
        this.defaultChainId = defaultChainId;
        //this.sender = new JsonRpcSender(provider)
    }
    /**
     * Note: When you do getAddress it could use provider.getAddress / provider.getSmartAccountAddress or directly access SmartAccountAPI
     */
    async getAddress() {
        if (this._address)
            return this._address;
        const accounts = await this.provider.send('eth_accounts', []);
        this._address = accounts[0];
        return ethers_1.ethers.utils.getAddress(this._address);
    }
    async getChainId() {
        return (await this.provider.getNetwork()).chainId;
    }
    async signTransaction(transaction) {
        if (!this.provider) {
            throw new Error('missing provider');
        }
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        const signature = await this.provider.send('eth_signTransaction', [transaction]);
        return signature;
    }
    // signMessage matches implementation from ethers JsonRpcSigner for compatibility
    async signMessage(message) {
        if (!this.provider) {
            throw new Error('missing provider');
        }
        const data = typeof message === 'string' ? ethers_1.ethers.utils.toUtf8Bytes(message) : message;
        const address = await this.getAddress();
        return await this.provider.send('personal_sign', [ethers_1.ethers.utils.hexlify(data), address]);
    }
    // signTypedData matches implementation from ethers JsonRpcSigner for compatibility
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    async signTypedData(domain, types, message, chainId) {
        const activeChainId = chainId ? chainId : await this.getChainId();
        const domainChainId = domain.chainId ? ethers_1.BigNumber.from(domain.chainId).toNumber() : undefined;
        if (domainChainId && domainChainId !== activeChainId) {
            throw new Error('Domain chainId is different from active chainId.');
        }
        return await this.provider.send('eth_signTypedData_v4', [
            await this.getAddress(),
            JSON.stringify(ethers_1.ethers.utils._TypedDataEncoder.getPayload(domain, types, message))
        ]);
    }
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    async _signTypedData(domain, types, message, chainId) {
        return this.signTypedData(domain, types, message, chainId);
    }
    connectUnchecked() {
        throw new Error('connectUnchecked is unsupported');
    }
    connect(_provider) {
        if (_provider) {
            return new SmartAccountSigner(_provider);
        }
        throw new Error('unsupported: cannot get JSON-RPC Signer connection');
    }
}
exports.SmartAccountSigner = SmartAccountSigner;
//# sourceMappingURL=SmartAccountSigner.js.map