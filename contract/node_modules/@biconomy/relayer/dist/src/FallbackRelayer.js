"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _FallbackRelayer_relayServiceBaseUrl, _FallbackRelayer_relayerServiceUrl, _FallbackRelayer_dappAPIKey;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FallbackRelayer = void 0;
const ethers_1 = require("ethers");
const common_1 = require("@biconomy/common");
const HttpRequests_1 = require("./utils/HttpRequests");
const gasless_messaging_sdk_1 = require("@biconomy/gasless-messaging-sdk");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const utils_1 = require("ethers/lib/utils");
/**
 * Relayer class that would be used via REST API to execute transactions
 */
class FallbackRelayer {
    constructor(options) {
        _FallbackRelayer_relayServiceBaseUrl.set(this, void 0);
        _FallbackRelayer_relayerServiceUrl.set(this, void 0);
        _FallbackRelayer_dappAPIKey.set(this, void 0);
        const { url, relayerServiceUrl, dappAPIKey } = options;
        this.relayerNodeEthersProvider = {};
        __classPrivateFieldSet(this, _FallbackRelayer_relayServiceBaseUrl, url, "f");
        __classPrivateFieldSet(this, _FallbackRelayer_relayerServiceUrl, relayerServiceUrl, "f");
        __classPrivateFieldSet(this, _FallbackRelayer_dappAPIKey, dappAPIKey, "f");
    }
    setRelayerNodeEthersProvider(chainId) {
        if (!this.relayerNodeEthersProvider[chainId]) {
            this.relayerNodeEthersProvider[chainId] = new ethers_1.ethers.providers.JsonRpcProvider(__classPrivateFieldGet(this, _FallbackRelayer_relayServiceBaseUrl, "f"), {
                name: 'Not actually connected to network, only talking to the Relayer!',
                chainId: chainId
            });
        }
    }
    async relay(relayTransaction, engine) {
        const relayerServiceUrl = __classPrivateFieldGet(this, _FallbackRelayer_relayerServiceUrl, "f");
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(relayerServiceUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
            try {
                await clientMessenger.connect();
                common_1.Logger.log('socket connection success');
            }
            catch (err) {
                common_1.Logger.error('socket connection failure', err);
            }
        }
        const { config, signedTx, gasLimit } = relayTransaction;
        const { address } = config;
        const finalRawRx = signedTx.rawTx;
        // based on the flag make rpc call to relayer code service with necessary rawTx data
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        const response = await (0, HttpRequests_1.sendRequest)({
            url: `${__classPrivateFieldGet(this, _FallbackRelayer_relayServiceBaseUrl, "f")}`,
            method: HttpRequests_1.HttpMethod.Post,
            body: {
                method: 'eth_sendGaslessFallbackTransaction',
                params: [
                    {
                        ...finalRawRx,
                        gasLimit: (gasLimit === null || gasLimit === void 0 ? void 0 : gasLimit.hex) || '',
                        walletInfo: {
                            address: address
                        },
                        metaData: {
                            dappAPIKey: __classPrivateFieldGet(this, _FallbackRelayer_dappAPIKey, "f")
                        }
                    }
                ],
                id: 1234,
                jsonrpc: '2.0'
            }
        });
        common_1.Logger.log('rest relayer: ', response);
        if (response.data) {
            const transactionId = response.data.transactionId;
            const waitPromise = new Promise((resolve, reject) => {
                if (clientMessenger && clientMessenger.socketClient.isConnected()) {
                    clientMessenger.createTransactionNotifier(transactionId, {
                        /* eslint-disable  @typescript-eslint/no-explicit-any */
                        onMined: (tx) => {
                            const txId = tx.transactionId;
                            clientMessenger.unsubscribe(txId);
                            common_1.Logger.log('Tx Hash mined message received at client', {
                                transactionId: txId,
                                hash: tx.transactionHash,
                                receipt: tx.receipt
                            });
                            const receipt = tx.receipt;
                            engine &&
                                engine.emit('txMined', {
                                    msg: 'txn mined',
                                    id: txId,
                                    hash: tx.transactionHash,
                                    receipt: tx.receipt
                                });
                            resolve(receipt);
                        },
                        /* eslint-disable  @typescript-eslint/no-explicit-any */
                        onError: async (err) => {
                            reject(err);
                        }
                    });
                }
            });
            clientMessenger.createTransactionNotifier(transactionId, {
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onMined: (tx) => {
                    const txId = tx.transactionId;
                    clientMessenger.unsubscribe(txId);
                    common_1.Logger.log('Tx Hash mined message received at client', {
                        transactionId: txId,
                        hash: tx.transactionHash,
                        receipt: tx.receipt
                    });
                    engine.emit('txMined', {
                        msg: 'txn mined',
                        id: txId,
                        hash: tx.transactionHash,
                        receipt: tx.receipt
                    });
                },
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onHashGenerated: async (tx) => {
                    const txHash = tx.transactionHash;
                    const txId = tx.transactionId;
                    common_1.Logger.log('Tx Hash generated message received at client', {
                        transactionId: txId,
                        hash: txHash
                    });
                    common_1.Logger.log(`Receive time for transaction id ${txId}: ${Date.now()}`);
                    engine.emit('txHashGenerated', {
                        id: tx.transactionId,
                        hash: tx.transactionHash,
                        msg: 'txn hash generated'
                    });
                },
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onHashChanged: async (tx) => {
                    if (tx) {
                        const txHash = tx.transactionHash;
                        const txId = tx.transactionId;
                        common_1.Logger.log('Tx Hash changed message received at client', {
                            transactionId: txId,
                            hash: txHash
                        });
                        engine.emit('txHashChanged', {
                            id: tx.transactionId,
                            hash: tx.transactionHash,
                            msg: 'txn hash changed'
                        });
                    }
                },
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onError: async (tx) => {
                    common_1.Logger.error('Error message received at client', tx);
                    const err = tx.error;
                    const txId = tx.transactionId;
                    clientMessenger.unsubscribe(txId);
                    engine.emit('error', {
                        id: tx.transactionId,
                        error: err,
                        msg: 'error in txn'
                    });
                }
            });
            return {
                hash: transactionId,
                confirmations: 0,
                from: signedTx.rawTx.from || '',
                nonce: Number(signedTx.rawTx.nonce),
                gasLimit: ethers_1.BigNumber.from(signedTx.rawTx.gasLimit || 0),
                value: ethers_1.BigNumber.from(0),
                data: (0, utils_1.hexValue)(signedTx.rawTx.data || '0x'),
                chainId: signedTx.rawTx.chainId,
                wait: async (confirmations) => {
                    common_1.Logger.log('wait confirmations', confirmations);
                    const transactionReceipt = waitPromise.then((receipt) => {
                        return receipt;
                    });
                    return transactionReceipt;
                }
            };
        }
        else {
            throw new Error(response.error || 'transaction failed');
        }
    }
}
exports.FallbackRelayer = FallbackRelayer;
_FallbackRelayer_relayServiceBaseUrl = new WeakMap(), _FallbackRelayer_relayerServiceUrl = new WeakMap(), _FallbackRelayer_dappAPIKey = new WeakMap();
//# sourceMappingURL=FallbackRelayer.js.map