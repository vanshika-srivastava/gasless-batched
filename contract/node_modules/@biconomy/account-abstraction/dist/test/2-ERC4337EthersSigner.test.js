"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@biconomy/common/dist/src/types");
const hardhat_1 = require("hardhat");
const src_1 = require("../src");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const ethers_lib_1 = require("@biconomy/ethers-lib");
const provider = hardhat_1.ethers.provider;
const signer = provider.getSigner();
const fallBackHandlerAddress = '0xF05217199F1C25604c67993F11a81461Bc97F3Ab'; // temp
describe('ERC4337EthersSigner, Provider', function () {
    let owner;
    let aaProvider;
    let entryPoint;
    let beneficiary;
    let recipient;
    let walletAddress;
    let baseWalletContract;
    let walletFactoryContract;
    let walletDeployed = false;
    let userSCW;
    let expectedSCW;
    let chainId;
    before('init', async () => {
        const deployRecipient = await new types_1.SampleRecipient__factory(signer).deploy();
        chainId = (await provider.getNetwork()).chainId;
        console.log(chainId);
        entryPoint = await new ethers_lib_1.EntryPointFactoryContractV100(signer).deploy();
        console.log('entryPoint ', entryPoint.address);
        beneficiary = await signer.getAddress();
        recipient = await new types_1.SampleRecipient__factory(signer).deploy();
        owner = ethers_1.Wallet.createRandom();
        console.log('EOA address? ', owner.address);
        baseWalletContract = await new ethers_lib_1.SmartWalletFactoryV100(signer).deploy(entryPoint.address);
        console.log('base wallet deployed at ', baseWalletContract.address);
        walletFactoryContract = await new ethers_lib_1.SmartWalletContractFactoryV100(signer).deploy(baseWalletContract.address);
        console.log('wallet factory deployed at ', walletFactoryContract.address);
        expectedSCW = await walletFactoryContract.getAddressForCounterFactualAccount(owner.address, 0);
        console.log('expectedSCW address ', expectedSCW);
        userSCW = baseWalletContract.attach(expectedSCW);
        const clientConfig = {
            dappAPIKey: '',
            chainId: chainId,
            entryPointAddress: entryPoint.address,
            biconomySigningServiceUrl: 'https://paymaster-signing-service.staging.biconomy.io/api/v1/sign',
            socketServerUrl: 'wss://sdk-testing-ws.staging.biconomy.io/connection/websocket',
            bundlerUrl: 'https://sdk-relayer.staging.biconomy.io/api/v1/relay',
            txServiceUrl: 'https://sdk-backend.staging.biconomy.io/v1'
        };
        aaProvider = await (0, src_1.newProvider)(provider, clientConfig, signer, expectedSCW, baseWalletContract.address, fallBackHandlerAddress, walletFactoryContract.address);
        // for testing: bypass sending through a bundler, and send directly to our entrypoint..
        aaProvider.httpRpcClient.sendUserOpToBundler = async (userOp) => {
            try {
                await entryPoint.handleOps([userOp], beneficiary);
            }
            catch (e) {
                // doesn't report error unless called with callStatic
                await entryPoint.callStatic.handleOps([userOp], beneficiary).catch((e) => {
                    // eslint-disable-next-line
                    const message = e.errorArgs != null ? `${e.errorName}(${e.errorArgs.join(',')})` : e.message;
                    throw new Error(message);
                });
            }
        };
        recipient = deployRecipient.connect(aaProvider.getSigner());
    });
    it('should fail to send before funding', async () => {
        try {
            await recipient.something('hello', { gasLimit: 1e6 });
            throw new Error('should revert');
        }
        catch (e) {
            console.log(e.message);
            // expect(e.message).to.eq(
            //   "FailedOp(0,0x0000000000000000000000000000000000000000,wallet didn't pay prefund)"
            // )
            // TODO: fix this
            (0, chai_1.expect)(e.message).to.eq('No Chain Found Against Supplied Id');
        }
    });
});
//# sourceMappingURL=2-ERC4337EthersSigner.test.js.map