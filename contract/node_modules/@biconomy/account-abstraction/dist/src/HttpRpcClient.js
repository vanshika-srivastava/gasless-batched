"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpRpcClient = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const httpRequests_1 = require("./utils/httpRequests");
const debug_1 = __importDefault(require("debug"));
const common_1 = require("@biconomy/common");
const debug = (0, debug_1.default)('aa.rpc');
class HttpRpcClient {
    // initializing: Promise<void>
    constructor(bundlerUrl, entryPointAddress, chainId, dappAPIKey // added by Biconomy
    ) {
        this.bundlerUrl = bundlerUrl;
        this.entryPointAddress = entryPointAddress;
        this.chainId = chainId;
        this.dappAPIKey = dappAPIKey;
        this.userOpJsonRpcProvider = new ethers_1.ethers.providers.JsonRpcProvider(this.bundlerUrl, {
            name: 'Not actually connected to network, only talking to the Bundler!',
            chainId
        });
        // this.initializing = this.validateChainId()
    }
    // review : bundler needs to support this
    async validateChainId() {
        // validate chainId is in sync with expected chainid
        const chain = await this.userOpJsonRpcProvider.send('eth_chainId', []);
        const bundlerChain = parseInt(chain);
        if (bundlerChain !== this.chainId) {
            throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);
        }
    }
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    async sendUserOpToBundler(userOp1) {
        // await this.initializing
        const hexifiedUserOp = (0, common_1.deepHexlify)(await (0, utils_1.resolveProperties)(userOp1));
        // const jsonRequestData: [UserOperation, string] = [hexifiedUserOp, this.entryPointAddress]
        // await this.printUserOperation('eth_sendUserOperation', jsonRequestData)
        let params;
        if (this.dappAPIKey && this.dappAPIKey !== '') {
            const metaData = {
                dappAPIKey: this.dappAPIKey
            };
            params = [hexifiedUserOp, this.entryPointAddress, this.chainId, metaData];
        }
        else {
            params = [hexifiedUserOp, this.entryPointAddress, this.chainId];
        }
        const response = await (0, httpRequests_1.sendRequest)({
            url: `${this.bundlerUrl}`,
            method: httpRequests_1.HttpMethod.Post,
            body: {
                method: 'eth_sendUserOperation',
                params: params,
                id: 1234,
                jsonrpc: '2.0'
            }
        });
        common_1.Logger.log('rest relayer : response', response);
        if (response && response.data) {
            const transactionId = response.data.transactionId;
            const connectionUrl = response.data.connectionUrl;
            return {
                connectionUrl: connectionUrl,
                transactionId: transactionId
            };
        }
        else {
            return {
                error: response.error || 'transaction failed'
            };
        }
    }
    async estimateUserOpGas(userOp1) {
        // await this.initializing
        const hexifiedUserOp = (0, common_1.deepHexlify)(await (0, utils_1.resolveProperties)(userOp1));
        // const jsonRequestData: [UserOperation, string] = [hexifiedUserOp, this.entryPointAddress]
        // await this.printUserOperation('eth_estimateUserOperationGas', jsonRequestData)
        return await this.userOpJsonRpcProvider.send('eth_estimateUserOperationGas', [
            hexifiedUserOp,
            this.entryPointAddress
        ]);
    }
    async printUserOperation(method, [userOp1, entryPointAddress]) {
        const userOp = await (0, utils_1.resolveProperties)(userOp1);
        debug('sending', method, {
            ...userOp
            // initCode: (userOp.initCode ?? '').length,
            // callData: (userOp.callData ?? '').length
        }, entryPointAddress);
    }
}
exports.HttpRpcClient = HttpRpcClient;
//# sourceMappingURL=HttpRpcClient.js.map