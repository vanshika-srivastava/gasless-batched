"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartAccountAPI = exports.DefaultGasLimits = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const BaseAccountAPI_1 = require("./BaseAccountAPI");
const BiconomyPaymasterAPI_1 = require("./BiconomyPaymasterAPI");
const utils_2 = require("ethers/lib/utils");
const calcPreVerificationGas_1 = require("./calcPreVerificationGas");
const common_1 = require("@biconomy/common");
exports.DefaultGasLimits = {
    validateUserOpGas: 71943,
    validatePaymasterUserOpGas: 25101,
    postOpGas: 10877
};
/**
 * An implementation of the BaseAccountAPI using the (biconomy) SmartAccount contract.
 * - contract deployer gets "entrypoint", "owner" addresses and "index" nonce
 * - owner signs requests using normal "Ethereum Signed Message" (ether's signer.signMessage())
 * - nonce method is "nonce()"
 */
class SmartAccountAPI extends BaseAccountAPI_1.BaseAccountAPI {
    /**
     * base constructor.
     * subclass SHOULD add parameters that define the owner (signer) of this wallet
     * @param provider - read-only provider for view calls
     * @param entryPointAddress - the entryPoint to send requests through (used to calculate the request-id, and for gas estimations)
     * @param walletAddress optional wallet address, if connecting to an existing contract.
     * @param owner the signer object for the wallet owner
     * @param factoryAddress address of contract "factory" to deploy new contracts
     * @param index nonce value used when creating multiple wallets for the same owner
     */
    constructor(provider, entryPoint, clientConfig, accountAddress, implementationAddress, owner, handlerAddress, factoryAddress, index = 0, overheads) {
        super(provider, entryPoint, clientConfig, accountAddress, overheads);
        this.entryPoint = entryPoint;
        this.clientConfig = clientConfig;
        this.implementationAddress = implementationAddress;
        this.owner = owner;
        this.handlerAddress = handlerAddress;
        this.factoryAddress = factoryAddress;
        this.index = index;
        if (!clientConfig.dappAPIKey || clientConfig.dappAPIKey === '') {
            this.paymasterAPI = undefined;
        }
        else if (clientConfig.customPaymasterAPI) {
            this.paymasterAPI = clientConfig.customPaymasterAPI;
        }
        else {
            this.paymasterAPI = new BiconomyPaymasterAPI_1.BiconomyPaymasterAPI({
                signingServiceUrl: clientConfig.biconomySigningServiceUrl,
                dappAPIKey: clientConfig.dappAPIKey,
                strictSponsorshipMode: clientConfig.strictSponsorshipMode
                    ? clientConfig.strictSponsorshipMode
                    : false
            });
        }
    }
    /**
     * return the value to put into the "initCode" field, if the wallet is not yet deployed.
     * this value holds the "factory" address, followed by this wallet's information
     */
    async getAccountInitCode() {
        const deployWalletCallData = await (0, common_1.deployCounterFactualEncodedData)({
            chainId: (await this.provider.getNetwork()).chainId,
            owner: await this.owner.getAddress(),
            txServiceUrl: this.clientConfig.txServiceUrl,
            index: this.index
        });
        return (0, utils_1.hexConcat)([this.factoryAddress, deployWalletCallData]);
    }
    async nonce() {
        common_1.Logger.log('checking nonce');
        if (!(await this.checkAccountDeployed())) {
            return ethers_1.BigNumber.from(0);
        }
        const walletContract = await this._getSmartAccountContract();
        const nonce = await walletContract.nonce();
        return nonce;
    }
    /**
     * should cover cost of putting calldata on-chain, and some overhead.
     * actual overhead depends on the expected bundle size
     */
    async getPreVerificationGas(userOp) {
        const p = await (0, utils_2.resolveProperties)(userOp);
        return (0, calcPreVerificationGas_1.calcPreVerificationGas)(p, this.overheads);
    }
    /**
     * return maximum gas used for verification.
     * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.
     */
    async getVerificationGasLimit() {
        // Verification gas should be max(initGas(wallet deployment) + validateUserOp + validatePaymasterUserOp , postOp)
        const initCode = await this.getInitCode();
        const initGas = await this.estimateCreationGas(initCode);
        console.log('initgas estimated is ', initGas);
        let verificationGasLimit = initGas;
        const validateUserOpGas = exports.DefaultGasLimits.validatePaymasterUserOpGas + exports.DefaultGasLimits.validateUserOpGas;
        const postOpGas = exports.DefaultGasLimits.postOpGas;
        verificationGasLimit = ethers_1.BigNumber.from(validateUserOpGas).add(initGas);
        if (ethers_1.BigNumber.from(postOpGas).gt(verificationGasLimit)) {
            verificationGasLimit = postOpGas;
        }
        return verificationGasLimit;
    }
    async encodeExecuteCall(target, value, data) {
        const walletContract = await this._getSmartAccountContract();
        return walletContract.interface.encodeFunctionData('executeCall', [target, value, data]);
    }
    async encodeExecuteBatchCall(target, value, data) {
        const walletContract = await this._getSmartAccountContract();
        const encodeData = walletContract.interface.encodeFunctionData('executeBatchCall', [
            target,
            value,
            data
        ]);
        common_1.Logger.log('encodeData ', encodeData);
        return encodeData;
    }
    /**
     * create a UserOperation, filling all details (except signature)
     * - if wallet is not yet created, add initCode to deploy it.
     * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the wallet is created)
     * @param info
     */
    async createUnsignedUserOp(info) {
        var _a, _b, _c, _d, _e, _f;
        const { callData, callGasLimit } = await this.encodeUserOpCallDataAndGasLimit(info);
        console.log(callData, callGasLimit);
        const initCode = await this.getInitCode();
        const verificationGasLimit = ethers_1.BigNumber.from(await this.getVerificationGasLimit());
        let { maxFeePerGas, maxPriorityFeePerGas } = info;
        // Note: Custom should be equal if it's for non EIP1559
        if (maxFeePerGas == null || maxPriorityFeePerGas == null) {
            const feeData = await this.provider.getFeeData();
            common_1.Logger.log('EIP1559 feeData', feeData);
            const chainId = this.clientConfig.chainId;
            common_1.Logger.log('chainId is', chainId);
            // Can do based on non EIP1559 chainId
            if (common_1.EIP1559_UNSUPPORTED_NETWORKS.includes(chainId)) {
                maxFeePerGas = (_b = (_a = feeData.gasPrice) !== null && _a !== void 0 ? _a : (await this.provider.getGasPrice())) !== null && _b !== void 0 ? _b : undefined;
                maxPriorityFeePerGas = (_d = (_c = feeData.gasPrice) !== null && _c !== void 0 ? _c : (await this.provider.getGasPrice())) !== null && _d !== void 0 ? _d : undefined;
            }
            if (maxFeePerGas == null) {
                maxFeePerGas = (_e = feeData.maxFeePerGas) !== null && _e !== void 0 ? _e : undefined; // ethers.BigNumber.from('100000000000')
            }
            if (maxPriorityFeePerGas == null) {
                maxPriorityFeePerGas = (_f = feeData.maxPriorityFeePerGas) !== null && _f !== void 0 ? _f : undefined; // ethers.BigNumber.from('35000000000')
            }
        }
        if (!maxFeePerGas || !maxPriorityFeePerGas) {
            throw new Error('maxFeePerGas or maxPriorityFeePerGas values cannot be null');
        }
        common_1.Logger.log('fees being used: maxFeePerGas ', maxFeePerGas);
        common_1.Logger.log('fees being used: maxPriorityFeePerGas ', maxPriorityFeePerGas);
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        const partialUserOp = {
            sender: await this.getAccountAddress(),
            nonce: await this.nonce(),
            initCode,
            callData,
            callGasLimit,
            verificationGasLimit,
            maxFeePerGas,
            maxPriorityFeePerGas
        };
        partialUserOp.paymasterAndData = '0x';
        const preVerificationGas = await this.getPreVerificationGas(partialUserOp);
        partialUserOp.preVerificationGas = preVerificationGas;
        partialUserOp.paymasterAndData = !this.paymasterAPI
            ? '0x'
            : await this.paymasterAPI.getPaymasterAndData(partialUserOp);
        return {
            ...partialUserOp,
            signature: ''
        };
    }
    async signUserOpHash(userOpHash) {
        return await this.owner.signMessage((0, utils_1.arrayify)(userOpHash));
    }
}
exports.SmartAccountAPI = SmartAccountAPI;
//# sourceMappingURL=SmartAccountAPI.js.map