import { BigNumber, BigNumberish } from 'ethers';
import { EntryPoint } from '@account-abstraction/contracts';
import { ClientConfig } from './ClientConfig';
import { Signer } from '@ethersproject/abstract-signer';
import { TransactionDetailsForBatchUserOp } from './TransactionDetailsForUserOp';
import { UserOperation } from '@biconomy/core-types';
import { BaseApiParams, BaseAccountAPI } from './BaseAccountAPI';
import { Provider } from '@ethersproject/providers';
import { GasOverheads } from './calcPreVerificationGas';
export interface SmartAccountApiParams extends BaseApiParams {
    owner: Signer;
    factoryAddress?: string;
    index?: number;
}
export interface VerificationGasLimits {
    /**
     * per userOp gasLimit for validateUserOp()
     * called from entrypoint to the account
     * should consider max execution
     */
    validateUserOpGas: number;
    /**
     * per userOp gasLimit for validatePaymasterUserOp()
     * called from entrypoint to the paymaster
     * should consider max execution
     */
    validatePaymasterUserOpGas: number;
    /**
     * per userOp gasLimit for postOp()
     * called from entrypoint to the paymaster
     * should consider max execution for paymaster/s this account may use
     */
    postOpGas: number;
}
export declare const DefaultGasLimits: VerificationGasLimits;
/**
 * An implementation of the BaseAccountAPI using the (biconomy) SmartAccount contract.
 * - contract deployer gets "entrypoint", "owner" addresses and "index" nonce
 * - owner signs requests using normal "Ethereum Signed Message" (ether's signer.signMessage())
 * - nonce method is "nonce()"
 */
export declare class SmartAccountAPI extends BaseAccountAPI {
    readonly entryPoint: EntryPoint;
    readonly clientConfig: ClientConfig;
    readonly implementationAddress: string;
    readonly owner: Signer;
    readonly handlerAddress: string;
    readonly factoryAddress: string;
    readonly index: number;
    /**
     * base constructor.
     * subclass SHOULD add parameters that define the owner (signer) of this wallet
     * @param provider - read-only provider for view calls
     * @param entryPointAddress - the entryPoint to send requests through (used to calculate the request-id, and for gas estimations)
     * @param walletAddress optional wallet address, if connecting to an existing contract.
     * @param owner the signer object for the wallet owner
     * @param factoryAddress address of contract "factory" to deploy new contracts
     * @param index nonce value used when creating multiple wallets for the same owner
     */
    constructor(provider: Provider, entryPoint: EntryPoint, clientConfig: ClientConfig, accountAddress: string | undefined, implementationAddress: string, owner: Signer, handlerAddress: string, factoryAddress: string, index?: number, overheads?: Partial<GasOverheads>);
    factory?: string;
    /**
     * return the value to put into the "initCode" field, if the wallet is not yet deployed.
     * this value holds the "factory" address, followed by this wallet's information
     */
    getAccountInitCode(): Promise<string>;
    nonce(): Promise<BigNumber>;
    /**
     * should cover cost of putting calldata on-chain, and some overhead.
     * actual overhead depends on the expected bundle size
     */
    getPreVerificationGas(userOp: Partial<UserOperation>): Promise<number>;
    /**
     * return maximum gas used for verification.
     * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.
     */
    getVerificationGasLimit(): Promise<BigNumberish>;
    encodeExecuteCall(target: string, value: BigNumberish, data: string): Promise<string>;
    encodeExecuteBatchCall(target: string[], value: BigNumberish[], data: string[]): Promise<string>;
    /**
     * create a UserOperation, filling all details (except signature)
     * - if wallet is not yet created, add initCode to deploy it.
     * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the wallet is created)
     * @param info
     */
    createUnsignedUserOp(info: TransactionDetailsForBatchUserOp): Promise<UserOperation>;
    signUserOpHash(userOpHash: string): Promise<string>;
}
