"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC4337EthersProvider = void 0;
const providers_1 = require("@ethersproject/providers");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const common_1 = require("@biconomy/common");
const ERC4337EthersSigner_1 = require("./ERC4337EthersSigner");
const UserOperationEventListener_1 = require("./UserOperationEventListener");
const gasless_messaging_sdk_1 = require("@biconomy/gasless-messaging-sdk");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const common_2 = require("@biconomy/common");
class ERC4337EthersProvider extends providers_1.BaseProvider {
    constructor(config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI // instead of here we could actually make one in SmartAccount.ts and provide
    ) {
        super({
            name: 'ERC-4337 Custom Network',
            chainId: config.chainId
        });
        this.config = config;
        this.originalSigner = originalSigner;
        this.originalProvider = originalProvider;
        this.httpRpcClient = httpRpcClient;
        this.entryPoint = entryPoint;
        this.smartAccountAPI = smartAccountAPI;
        this.signer = new ERC4337EthersSigner_1.ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);
    }
    async init() {
        // await this.httpRpcClient.validateChainId()
        this.initializedBlockNumber = await this.originalProvider.getBlockNumber();
        await this.smartAccountAPI.init();
        return this;
    }
    getSigner() {
        return this.signer;
    }
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    async perform(method, params) {
        if (method === 'sendTransaction' || method === 'getTransactionReceipt') {
            throw new Error('Should not get here. Investigate.');
        }
        return await this.originalProvider.perform(method, params);
    }
    async getTransaction(transactionHash) {
        return await super.getTransaction(transactionHash);
    }
    async getTransactionReceipt(transactionHash) {
        const userOpHash = await transactionHash;
        const sender = await this.getSenderAccountAddress();
        return await new Promise((resolve, reject) => {
            new UserOperationEventListener_1.UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();
        });
    }
    async getSenderAccountAddress() {
        return await this.smartAccountAPI.getAccountAddress();
    }
    async waitForTransaction(transactionHash, confirmations, timeout) {
        common_2.Logger.log('waitForTransaction', { transactionHash, confirmations, timeout });
        const sender = await this.getSenderAccountAddress();
        return await new Promise((resolve, reject) => {
            const listener = new UserOperationEventListener_1.UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, undefined, timeout);
            listener.start();
        });
    }
    // fabricate a response (using messaging SDK) in a format usable by ethers users...
    async constructUserOpTransactionResponse(userOp1, transactionId, engine // EventEmitter
    ) {
        const socketServerUrl = this.config.socketServerUrl;
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
            try {
                await clientMessenger.connect();
                common_2.Logger.log('socket connection success', { socketServerUrl });
            }
            catch (err) {
                common_2.Logger.error('socket connection failure', err);
            }
        }
        const userOp = await (0, utils_1.resolveProperties)(userOp1);
        const userOpHash = (0, common_1.getUserOpHash)(userOp, this.config.entryPointAddress, this.config.chainId);
        const waitPromise = new Promise((resolve, reject) => {
            if (clientMessenger && clientMessenger.socketClient.isConnected()) {
                clientMessenger.createTransactionNotifier(transactionId, {
                    onMined: (tx) => {
                        const txId = tx.transactionId;
                        clientMessenger.unsubscribe(txId);
                        common_2.Logger.log('Tx Hash mined message received at client', {
                            transactionId: txId,
                            hash: tx.transactionHash,
                            receipt: tx.receipt
                        });
                        const receipt = tx.receipt;
                        engine &&
                            engine.emit('txMined', {
                                msg: 'txn mined',
                                id: txId,
                                hash: tx.transactionHash,
                                receipt: tx.receipt
                            });
                        resolve(receipt);
                    },
                    onError: async (err) => {
                        reject(err);
                    }
                });
            }
        });
        return {
            hash: userOpHash,
            confirmations: 0,
            from: userOp.sender,
            nonce: ethers_1.BigNumber.from(userOp.nonce).toNumber(),
            gasLimit: ethers_1.BigNumber.from(userOp.callGasLimit),
            value: ethers_1.BigNumber.from(0),
            data: (0, utils_1.hexValue)(userOp.callData),
            chainId: this.config.chainId,
            wait: async (confirmations) => {
                common_2.Logger.log('wait confirmations', { confirmations });
                const transactionReceipt = waitPromise.then((receipt) => {
                    return receipt;
                });
                if (userOp.initCode.length !== 0) {
                    // checking if the wallet has been deployed by the transaction; it must be if we are here
                    await this.smartAccountAPI.checkAccountDeployed();
                }
                return transactionReceipt;
            }
        };
    }
    async detectNetwork() {
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        return this.originalProvider.detectNetwork();
    }
}
exports.ERC4337EthersProvider = ERC4337EthersProvider;
//# sourceMappingURL=ERC4337EthersProvider.js.map