"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeTransferFrom = exports.encodeTransfer = exports.Erc20Interface = exports.Erc20 = exports.getSignatureParameters = exports.getBalance = exports.createWalletOwner = exports.FIVE_ETH = exports.TWO_ETH = exports.ONE_ETH = exports.HashZero = exports.AddressZero = void 0;
const utils_1 = require("ethers/lib/utils");
const ethers_1 = require("ethers");
const ethereumjs_util_1 = require("ethereumjs-util");
exports.AddressZero = ethers_1.ethers.constants.AddressZero;
exports.HashZero = ethers_1.ethers.constants.HashZero;
exports.ONE_ETH = (0, utils_1.parseEther)('1');
exports.TWO_ETH = (0, utils_1.parseEther)('2');
exports.FIVE_ETH = (0, utils_1.parseEther)('5');
let counter = 0;
// create non-random account, so gas calculations are deterministic
function createWalletOwner() {
    const privateKey = (0, ethereumjs_util_1.keccak256)(Buffer.from((0, utils_1.arrayify)(ethers_1.BigNumber.from(++counter))));
    return new ethers_1.ethers.Wallet(privateKey, ethers_1.ethers.providers.getDefaultProvider());
}
exports.createWalletOwner = createWalletOwner;
async function getBalance(address) {
    const balance = await ethers_1.ethers.providers.getDefaultProvider().getBalance(address);
    return parseInt(balance.toString());
}
exports.getBalance = getBalance;
function getSignatureParameters(signature) {
    if (!ethers_1.ethers.utils.isHexString(signature)) {
        throw new Error('Given value "'.concat(signature, '" is not a valid hex string.'));
    }
    const r = signature.slice(0, 66);
    const s = '0x'.concat(signature.slice(66, 130));
    let v = ethers_1.ethers.BigNumber.from('0x'.concat(signature.slice(130, 132))).toNumber();
    if (![27, 28].includes(v))
        v += 27;
    return {
        r: r,
        s: s,
        v: v
    };
}
exports.getSignatureParameters = getSignatureParameters;
exports.Erc20 = [
    'function transfer(address _receiver, uint256 _value) public returns (bool success)',
    'function transferFrom(address, address, uint) public returns (bool)',
    'function approve(address _spender, uint256 _value) public returns (bool success)',
    'function allowance(address _owner, address _spender) public view returns (uint256 remaining)',
    'function balanceOf(address _owner) public view returns (uint256 balance)',
    'event Approval(address indexed _owner, address indexed _spender, uint256 _value)'
];
exports.Erc20Interface = new ethers_1.ethers.utils.Interface(exports.Erc20);
const encodeTransfer = (target, amount) => {
    return exports.Erc20Interface.encodeFunctionData('transfer', [target, amount]);
};
exports.encodeTransfer = encodeTransfer;
const encodeTransferFrom = (from, target, amount) => {
    return exports.Erc20Interface.encodeFunctionData('transferFrom', [from, target, amount]);
};
exports.encodeTransferFrom = encodeTransferFrom;
//# sourceMappingURL=AccountUtils.js.map