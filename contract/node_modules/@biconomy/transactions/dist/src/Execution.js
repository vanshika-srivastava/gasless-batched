"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSmartAccountTransaction = exports.executeContractCallWithSigners = exports.executeTxWithSigners = exports.buildContractCall = exports.populateExecuteTx = exports.executeTx = exports.buildSignatureBytes = exports.smartAccountSignMessage = exports.signHash = exports.smartAccountSignTypedData = exports.calculateSmartAccountMessageHash = exports.calculateSmartAccountTransactionHash = exports.preimageWalletTransactionHash = exports.calculateSmartAccountDomainSeparator = exports.EIP712_SMART_ACCOUNT_MESSAGE_TYPE = exports.EIP712_ACCOUNT_TX_TYPE = exports.EIP_DOMAIN = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("@ethersproject/constants");
exports.EIP_DOMAIN = {
    EIP712Domain: [
        { type: 'uint256', name: 'chainId' },
        { type: 'address', name: 'verifyingContract' }
    ]
};
exports.EIP712_ACCOUNT_TX_TYPE = {
    // "AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)"
    AccountTx: [
        { type: 'address', name: 'to' },
        { type: 'uint256', name: 'value' },
        { type: 'bytes', name: 'data' },
        { type: 'uint8', name: 'operation' },
        { type: 'uint256', name: 'targetTxGas' },
        { type: 'uint256', name: 'baseGas' },
        { type: 'uint256', name: 'gasPrice' },
        { type: 'uint256', name: 'tokenGasPriceFactor' },
        { type: 'address', name: 'gasToken' },
        { type: 'address', name: 'refundReceiver' },
        { type: 'uint256', name: 'nonce' }
    ]
};
exports.EIP712_SMART_ACCOUNT_MESSAGE_TYPE = {
    // "SmartAccountMessage(bytes message)"
    SmartAccountMessage: [{ type: 'bytes', name: 'message' }]
};
const calculateSmartAccountDomainSeparator = (wallet, chainId) => {
    return ethers_1.utils._TypedDataEncoder.hashDomain({
        verifyingContract: wallet.address,
        chainId
    });
};
exports.calculateSmartAccountDomainSeparator = calculateSmartAccountDomainSeparator;
const preimageWalletTransactionHash = (wallet, SmartAccountTx, chainId) => {
    return ethers_1.utils._TypedDataEncoder.encode({ verifyingContract: wallet.address, chainId }, exports.EIP712_ACCOUNT_TX_TYPE, SmartAccountTx);
};
exports.preimageWalletTransactionHash = preimageWalletTransactionHash;
const calculateSmartAccountTransactionHash = (wallet, SmartAccountTx, chainId) => {
    return ethers_1.utils._TypedDataEncoder.hash({ verifyingContract: wallet.address, chainId }, exports.EIP712_ACCOUNT_TX_TYPE, SmartAccountTx);
};
exports.calculateSmartAccountTransactionHash = calculateSmartAccountTransactionHash;
const calculateSmartAccountMessageHash = (wallet, message, chainId) => {
    return ethers_1.utils._TypedDataEncoder.hash({ verifyingContract: wallet.address, chainId }, exports.EIP712_SMART_ACCOUNT_MESSAGE_TYPE, { message });
};
exports.calculateSmartAccountMessageHash = calculateSmartAccountMessageHash;
const smartAccountSignTypedData = async (signer, wallet, SmartAccountTx, chainId) => {
    var _a;
    if (!chainId && !(signer === null || signer === void 0 ? void 0 : signer.provider))
        throw Error('Provider required to retrieve chainId');
    /* eslint-disable  @typescript-eslint/no-non-null-assertion */
    const cid = chainId !== null && chainId !== void 0 ? chainId : (_a = (await signer.provider.getNetwork())) === null || _a === void 0 ? void 0 : _a.chainId;
    const signerAddress = await signer.getAddress();
    return {
        signer: signerAddress,
        data: await signer._signTypedData({ verifyingContract: wallet.address, chainId: cid }, exports.EIP712_ACCOUNT_TX_TYPE, SmartAccountTx)
    };
};
exports.smartAccountSignTypedData = smartAccountSignTypedData;
const signHash = async (signer, hash) => {
    const typedDataHash = ethers_1.utils.arrayify(hash);
    const signerAddress = await signer.getAddress();
    return {
        signer: signerAddress,
        data: (await signer.signMessage(typedDataHash)).replace(/1b$/, '1f').replace(/1c$/, '20')
    };
};
exports.signHash = signHash;
const smartAccountSignMessage = async (signer, wallet, SmartAccountTx, chainId) => {
    if (!chainId && !(signer === null || signer === void 0 ? void 0 : signer.provider))
        throw Error('Provider required to retrieve chainId');
    const cid = chainId !== null && chainId !== void 0 ? chainId : (await signer.provider.getNetwork()).chainId;
    if (!cid) {
        throw Error('smartAccountSignMessage: Chain Id Not Found');
    }
    return (0, exports.signHash)(signer, (0, exports.calculateSmartAccountTransactionHash)(wallet, SmartAccountTx, cid));
};
exports.smartAccountSignMessage = smartAccountSignMessage;
const buildSignatureBytes = (signatures) => {
    signatures.sort((left, right) => left.signer.toLowerCase().localeCompare(right.signer.toLowerCase()));
    let signatureBytes = '0x';
    for (const sig of signatures) {
        signatureBytes += sig.data.slice(2);
    }
    return signatureBytes;
};
exports.buildSignatureBytes = buildSignatureBytes;
/* eslint-disable  @typescript-eslint/no-explicit-any */
const executeTx = async (wallet, SmartAccountTx, signatures, overrides) => {
    const signatureBytes = (0, exports.buildSignatureBytes)(signatures);
    const transaction = {
        to: SmartAccountTx.to,
        value: SmartAccountTx.value,
        data: SmartAccountTx.data,
        operation: SmartAccountTx.operation,
        targetTxGas: SmartAccountTx.targetTxGas
    };
    const refundInfo = {
        baseGas: SmartAccountTx.baseGas,
        gasPrice: SmartAccountTx.gasPrice,
        tokenGasPriceFactor: SmartAccountTx.tokenGasPriceFactor,
        gasToken: SmartAccountTx.gasToken,
        refundReceiver: SmartAccountTx.refundReceiver
    };
    return wallet.execTransaction(transaction, refundInfo, signatureBytes, overrides || {});
};
exports.executeTx = executeTx;
/* eslint-disable  @typescript-eslint/no-explicit-any */
const populateExecuteTx = async (wallet, SmartAccountTx, signatures, overrides) => {
    const signatureBytes = (0, exports.buildSignatureBytes)(signatures);
    const transaction = {
        to: SmartAccountTx.to,
        value: SmartAccountTx.value,
        data: SmartAccountTx.data,
        operation: SmartAccountTx.operation,
        targetTxGas: SmartAccountTx.targetTxGas
    };
    const refundInfo = {
        baseGas: SmartAccountTx.baseGas,
        gasPrice: SmartAccountTx.gasPrice,
        tokenGasPriceFactor: SmartAccountTx.tokenGasPriceFactor,
        gasToken: SmartAccountTx.gasToken,
        refundReceiver: SmartAccountTx.refundReceiver
    };
    return wallet.populateTransaction.execTransaction(transaction, refundInfo, signatureBytes, overrides || {});
};
exports.populateExecuteTx = populateExecuteTx;
/* eslint-disable  @typescript-eslint/no-explicit-any */
const buildContractCall = (contract, method, params, nonce, delegateCall, overrides) => {
    const data = contract.interface.encodeFunctionData(method, params);
    return (0, exports.buildSmartAccountTransaction)(Object.assign({
        to: contract.address,
        data,
        operation: delegateCall ? 1 : 0,
        nonce
    }, overrides));
};
exports.buildContractCall = buildContractCall;
/* eslint-disable  @typescript-eslint/no-explicit-any */
const executeTxWithSigners = async (wallet, tx, signers, overrides) => {
    const sigs = await Promise.all(signers.map((signer) => (0, exports.smartAccountSignTypedData)(signer, wallet, tx)));
    return (0, exports.executeTx)(wallet, tx, sigs, overrides);
};
exports.executeTxWithSigners = executeTxWithSigners;
/* eslint-disable  @typescript-eslint/no-explicit-any */
const executeContractCallWithSigners = async (wallet, contract, method, params, signers, delegateCall, overrides) => {
    const tx = (0, exports.buildContractCall)(contract, method, params, await wallet.getNonce(0), //default batchId @review
    delegateCall, overrides);
    return (0, exports.executeTxWithSigners)(wallet, tx, signers);
};
exports.executeContractCallWithSigners = executeContractCallWithSigners;
const buildSmartAccountTransaction = (template) => {
    return {
        to: template.to,
        value: template.value || 0,
        data: template.data || '0x',
        operation: template.operation || 0,
        targetTxGas: template.targetTxGas || 0,
        baseGas: template.baseGas || 0,
        gasPrice: template.gasPrice || 0,
        tokenGasPriceFactor: template.tokenGasPriceFactor || 1,
        gasToken: template.gasToken || constants_1.AddressZero,
        refundReceiver: template.refundReceiver || constants_1.AddressZero,
        nonce: template.nonce
    };
};
exports.buildSmartAccountTransaction = buildSmartAccountTransaction;
//# sourceMappingURL=Execution.js.map