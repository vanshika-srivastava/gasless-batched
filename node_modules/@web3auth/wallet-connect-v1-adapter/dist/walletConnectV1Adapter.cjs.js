/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "WalletConnectV1Adapter": () => (/* reexport */ WalletConnectV1Adapter)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/asyncToGenerator"
const asyncToGenerator_namespaceObject = require("@babel/runtime/helpers/asyncToGenerator");
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/classCallCheck"
const classCallCheck_namespaceObject = require("@babel/runtime/helpers/classCallCheck");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/createClass"
const createClass_namespaceObject = require("@babel/runtime/helpers/createClass");
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/assertThisInitialized"
const assertThisInitialized_namespaceObject = require("@babel/runtime/helpers/assertThisInitialized");
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/get"
const get_namespaceObject = require("@babel/runtime/helpers/get");
var get_default = /*#__PURE__*/__webpack_require__.n(get_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/inherits"
const inherits_namespaceObject = require("@babel/runtime/helpers/inherits");
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/possibleConstructorReturn"
const possibleConstructorReturn_namespaceObject = require("@babel/runtime/helpers/possibleConstructorReturn");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/getPrototypeOf"
const getPrototypeOf_namespaceObject = require("@babel/runtime/helpers/getPrototypeOf");
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/regenerator"
const regenerator_namespaceObject = require("@babel/runtime/regenerator");
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator_namespaceObject);
;// CONCATENATED MODULE: external "@walletconnect/client"
const client_namespaceObject = require("@walletconnect/client");
var client_default = /*#__PURE__*/__webpack_require__.n(client_namespaceObject);
;// CONCATENATED MODULE: external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// CONCATENATED MODULE: external "@web3auth/base-evm-adapter"
const base_evm_adapter_namespaceObject = require("@web3auth/base-evm-adapter");
;// CONCATENATED MODULE: external "@web3auth/ethereum-provider"
const ethereum_provider_namespaceObject = require("@web3auth/ethereum-provider");
;// CONCATENATED MODULE: ./src/config.ts

var WALLET_CONNECT_EXTENSION_ADAPTERS = [{
  name: "Rainbow",
  chains: [base_namespaceObject.CHAIN_NAMESPACES.EIP155],
  logo: "https://images.web3auth.io/login-rainbow.svg",
  mobile: {
    native: "rainbow:",
    universal: "https://rnbwapp.com"
  },
  desktop: {
    native: "",
    universal: ""
  }
}, {
  name: "MetaMask",
  chains: [base_namespaceObject.CHAIN_NAMESPACES.EIP155],
  logo: "https://images.web3auth.io/login-metamask.svg",
  mobile: {
    native: "metamask:",
    universal: "https://metamask.app.link"
  },
  desktop: {
    native: "",
    universal: ""
  }
}];
;// CONCATENATED MODULE: ./src/walletConnectV1adapter.ts










function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var WalletConnectV1Adapter = /*#__PURE__*/function (_BaseEvmAdapter) {
  inherits_default()(WalletConnectV1Adapter, _BaseEvmAdapter);
  var _super = _createSuper(WalletConnectV1Adapter);
  function WalletConnectV1Adapter(options) {
    var _this;
    classCallCheck_default()(this, WalletConnectV1Adapter);
    _this = _super.call(this, options);
    defineProperty_default()(assertThisInitialized_default()(_this), "name", base_namespaceObject.WALLET_ADAPTERS.WALLET_CONNECT_V1);
    defineProperty_default()(assertThisInitialized_default()(_this), "adapterNamespace", base_namespaceObject.ADAPTER_NAMESPACES.EIP155);
    defineProperty_default()(assertThisInitialized_default()(_this), "currentChainNamespace", base_namespaceObject.CHAIN_NAMESPACES.EIP155);
    defineProperty_default()(assertThisInitialized_default()(_this), "type", base_namespaceObject.ADAPTER_CATEGORY.EXTERNAL);
    defineProperty_default()(assertThisInitialized_default()(_this), "adapterOptions", void 0);
    defineProperty_default()(assertThisInitialized_default()(_this), "status", base_namespaceObject.ADAPTER_STATUS.NOT_READY);
    defineProperty_default()(assertThisInitialized_default()(_this), "adapterData", {
      uri: "",
      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS
    });
    defineProperty_default()(assertThisInitialized_default()(_this), "connector", null);
    defineProperty_default()(assertThisInitialized_default()(_this), "wcProvider", null);
    defineProperty_default()(assertThisInitialized_default()(_this), "rehydrated", false);
    _this.adapterOptions = _objectSpread({}, options);
    _this.chainConfig = options.chainConfig || null;
    _this.sessionTime = options.sessionTime || 86400;
    return _this;
  }
  createClass_default()(WalletConnectV1Adapter, [{
    key: "connected",
    get: function get() {
      var _this$connector;
      return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);
    }
  }, {
    key: "provider",
    get: function get() {
      var _this$wcProvider;
      return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;
    },
    set: function set(_) {
      throw new Error("Not implemented");
    }
  }, {
    key: "init",
    value: function () {
      var _init = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee() {
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                get_default()(getPrototypeOf_default()(WalletConnectV1Adapter.prototype), "checkInitializationRequirements", this).call(this);
                if (!this.chainConfig) {
                  this.chainConfig = (0,base_namespaceObject.getChainConfig)(base_namespaceObject.CHAIN_NAMESPACES.EIP155, 1);
                }
                // Create a connector
                this.connector = this.getWalletConnectInstance();
                this.wcProvider = new ethereum_provider_namespaceObject.WalletConnectProvider({
                  config: {
                    chainConfig: this.chainConfig
                  },
                  connector: this.connector
                });
                this.emit(base_namespaceObject.ADAPTER_EVENTS.READY, base_namespaceObject.WALLET_ADAPTERS.WALLET_CONNECT_V1);
                this.status = base_namespaceObject.ADAPTER_STATUS.READY;
                base_namespaceObject.log.debug("initializing wallet connect v1 adapter");
                if (!this.connector.connected) {
                  _context.next = 11;
                  break;
                }
                this.rehydrated = true;
                _context.next = 11;
                return this.onConnectHandler({
                  accounts: this.connector.accounts,
                  chainId: this.connector.chainId
                });
              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "connect",
    value: function () {
      var _connect = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee4() {
        var _this2 = this;
        var _this$adapterOptions$, _this$adapterOptions$2;
        return regenerator_default().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                get_default()(getPrototypeOf_default()(WalletConnectV1Adapter.prototype), "checkConnectionRequirements", this).call(this);
                if (this.connector) {
                  _context4.next = 3;
                  break;
                }
                throw base_namespaceObject.WalletInitializationError.notReady("Wallet adapter is not ready yet");
              case 3:
                if (!this.connected) {
                  _context4.next = 7;
                  break;
                }
                _context4.next = 6;
                return this.onConnectHandler({
                  accounts: this.connector.accounts,
                  chainId: this.connector.chainId
                });
              case 6:
                return _context4.abrupt("return", this.provider);
              case 7:
                if (!(this.status !== base_namespaceObject.ADAPTER_STATUS.CONNECTING)) {
                  _context4.next = 13;
                  break;
                }
                // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open
                // modal again on existing instance if connection is pending.
                if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {
                  this.connector = this.getWalletConnectInstance();
                  this.wcProvider = new ethereum_provider_namespaceObject.WalletConnectProvider({
                    config: {
                      chainConfig: this.chainConfig,
                      // network switching can be skipped with custom ui
                      skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching
                    },
                    connector: this.connector
                  });
                }
                _context4.next = 11;
                return this.createNewSession();
              case 11:
                this.status = base_namespaceObject.ADAPTER_STATUS.CONNECTING;
                this.emit(base_namespaceObject.ADAPTER_EVENTS.CONNECTING, {
                  adapter: base_namespaceObject.WALLET_ADAPTERS.WALLET_CONNECT_V1
                });
              case 13:
                return _context4.abrupt("return", new Promise(function (resolve, reject) {
                  if (!_this2.connector) {
                    reject(base_namespaceObject.WalletInitializationError.notReady("Wallet adapter is not ready yet"));
                    return;
                  }
                  // for wallet connect default modal.
                  _this2.connector.on("modal_closed", /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee2() {
                    return regenerator_default().wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _this2.status = base_namespaceObject.ADAPTER_STATUS.READY;
                            _this2.emit(base_namespaceObject.ADAPTER_EVENTS.READY, base_namespaceObject.WALLET_ADAPTERS.WALLET_CONNECT_V1);
                            return _context2.abrupt("return", reject(new Error("User closed modal")));
                          case 3:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  })));
                  try {
                    // Subscribe to session connection
                    _this2.connector.on("connect", /*#__PURE__*/function () {
                      var _ref2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee3(error, payload) {
                        return regenerator_default().wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                if (error) {
                                  _this2.emit(base_namespaceObject.ADAPTER_EVENTS.ERRORED, error);
                                }
                                base_namespaceObject.log.debug("connected event emitted by web3auth");
                                _context3.next = 4;
                                return _this2.onConnectHandler(payload.params[0]);
                              case 4:
                                return _context3.abrupt("return", resolve(_this2.provider));
                              case 5:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3);
                      }));
                      return function (_x, _x2) {
                        return _ref2.apply(this, arguments);
                      };
                    }());
                  } catch (error) {
                    base_namespaceObject.log.error("Wallet connect v1 adapter error while connecting", error);
                    // ready again to be connected
                    _this2.status = base_namespaceObject.ADAPTER_STATUS.READY;
                    _this2.rehydrated = true;
                    _this2.emit(base_namespaceObject.ADAPTER_EVENTS.ERRORED, error);
                    reject(error instanceof base_namespaceObject.Web3AuthError ? error : base_namespaceObject.WalletLoginError.connectionError("Failed to login with wallet connect: ".concat((error === null || error === void 0 ? void 0 : error.message) || "")));
                  }
                }));
              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
      function connect() {
        return _connect.apply(this, arguments);
      }
      return connect;
    }()
  }, {
    key: "setAdapterSettings",
    value: function setAdapterSettings(options) {
      if (this.status === base_namespaceObject.ADAPTER_STATUS.READY) return;
      if (options !== null && options !== void 0 && options.sessionTime) {
        this.sessionTime = options.sessionTime;
      }
      if (options !== null && options !== void 0 && options.clientId) {
        this.clientId = options.clientId;
      }
    }
  }, {
    key: "getUserInfo",
    value: function () {
      var _getUserInfo = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee5() {
        return regenerator_default().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this.connected) {
                  _context5.next = 2;
                  break;
                }
                throw base_namespaceObject.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
              case 2:
                return _context5.abrupt("return", {});
              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function getUserInfo() {
        return _getUserInfo.apply(this, arguments);
      }
      return getUserInfo;
    }()
  }, {
    key: "disconnect",
    value: function () {
      var _disconnect = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee6() {
        var options,
          cleanup,
          _args6 = arguments;
        return regenerator_default().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {
                  cleanup: false
                };
                cleanup = options.cleanup;
                if (!(!this.connector || !this.connected)) {
                  _context6.next = 4;
                  break;
                }
                throw base_namespaceObject.WalletLoginError.notConnectedError("Not connected with wallet");
              case 4:
                _context6.next = 6;
                return get_default()(getPrototypeOf_default()(WalletConnectV1Adapter.prototype), "disconnect", this).call(this);
              case 6:
                _context6.next = 8;
                return this.connector.killSession();
              case 8:
                this.rehydrated = false;
                if (cleanup) {
                  this.connector = null;
                  this.status = base_namespaceObject.ADAPTER_STATUS.NOT_READY;
                  this.wcProvider = null;
                } else {
                  // ready to connect again
                  this.status = base_namespaceObject.ADAPTER_STATUS.READY;
                }
                this.emit(base_namespaceObject.ADAPTER_EVENTS.DISCONNECTED);
              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function disconnect() {
        return _disconnect.apply(this, arguments);
      }
      return disconnect;
    }()
  }, {
    key: "addChain",
    value: function () {
      var _addChain = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee7(chainConfig) {
        var _this$adapterOptions$3, networkSwitch;
        return regenerator_default().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                if (this.wcProvider) {
                  _context7.next = 3;
                  break;
                }
                throw base_namespaceObject.WalletInitializationError.notReady("Wallet adapter is not ready yet");
              case 3:
                networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;
                if (!networkSwitch) {
                  _context7.next = 7;
                  break;
                }
                _context7.next = 7;
                return networkSwitch.addNetwork({
                  chainConfig: chainConfig,
                  appOrigin: window.location.hostname
                });
              case 7:
                _context7.next = 9;
                return this.wcProvider.addChain(chainConfig);
              case 9:
                _context7.next = 14;
                break;
              case 11:
                _context7.prev = 11;
                _context7.t0 = _context7["catch"](0);
                base_namespaceObject.log.error(_context7.t0);
              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[0, 11]]);
      }));
      function addChain(_x3) {
        return _addChain.apply(this, arguments);
      }
      return addChain;
    }()
  }, {
    key: "switchChain",
    value: function () {
      var _switchChain = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee8(connectedChainConfig, chainConfig) {
        var _this$adapterOptions$4;
        var networkSwitch;
        return regenerator_default().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this.wcProvider) {
                  _context8.next = 2;
                  break;
                }
                throw base_namespaceObject.WalletInitializationError.notReady("Wallet adapter is not ready yet");
              case 2:
                networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;
                if (!networkSwitch) {
                  _context8.next = 6;
                  break;
                }
                _context8.next = 6;
                return networkSwitch.switchNetwork({
                  currentChainConfig: chainConfig,
                  newChainConfig: connectedChainConfig,
                  appOrigin: window.location.hostname
                });
              case 6:
                _context8.next = 8;
                return this.wcProvider.switchChain({
                  chainId: chainConfig.chainId,
                  lookup: false,
                  addChain: false
                });
              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function switchChain(_x4, _x5) {
        return _switchChain.apply(this, arguments);
      }
      return switchChain;
    }()
  }, {
    key: "createNewSession",
    value: function () {
      var _createNewSession = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee10() {
        var _this$adapterOptions,
          _this$adapterOptions$5,
          _this3 = this;
        var opts,
          _this$chainConfig,
          _args10 = arguments;
        return regenerator_default().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                opts = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : {
                  forceNewSession: false
                };
                if (this.connector) {
                  _context10.next = 3;
                  break;
                }
                throw base_namespaceObject.WalletInitializationError.notReady("Wallet adapter is not ready yet");
              case 3:
                if (!(opts.forceNewSession && this.connector.pending)) {
                  _context10.next = 6;
                  break;
                }
                _context10.next = 6;
                return this.connector.killSession();
              case 6:
                if (!((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal)) {
                  _context10.next = 10;
                  break;
                }
                _context10.next = 9;
                return this.connector.createSession({
                  chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || "0x1", 16)
                });
              case 9:
                return _context10.abrupt("return");
              case 10:
                return _context10.abrupt("return", new Promise(function (resolve, reject) {
                  var _this3$chainConfig;
                  if (!_this3.connector) {
                    reject(base_namespaceObject.WalletInitializationError.notReady("Wallet adapter is not ready yet"));
                    return;
                  }
                  base_namespaceObject.log.debug("creating new session for web3auth wallet connect");
                  _this3.connector.on("display_uri", /*#__PURE__*/function () {
                    var _ref3 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee9(err, payload) {
                      var _this3$connector;
                      var uri;
                      return regenerator_default().wrap(function _callee9$(_context9) {
                        while (1) {
                          switch (_context9.prev = _context9.next) {
                            case 0:
                              if (!err) {
                                _context9.next = 3;
                                break;
                              }
                              _this3.emit(base_namespaceObject.ADAPTER_EVENTS.ERRORED, base_namespaceObject.WalletLoginError.connectionError("Failed to display wallet connect qr code"));
                              return _context9.abrupt("return", reject(err));
                            case 3:
                              uri = payload.params[0];
                              _this3.updateAdapterData({
                                uri: uri,
                                extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS
                              });
                              (_this3$connector = _this3.connector) === null || _this3$connector === void 0 ? void 0 : _this3$connector.off("display_uri");
                              return _context9.abrupt("return", resolve());
                            case 7:
                            case "end":
                              return _context9.stop();
                          }
                        }
                      }, _callee9);
                    }));
                    return function (_x6, _x7) {
                      return _ref3.apply(this, arguments);
                    };
                  }());
                  _this3.connector.createSession({
                    chainId: parseInt(((_this3$chainConfig = _this3.chainConfig) === null || _this3$chainConfig === void 0 ? void 0 : _this3$chainConfig.chainId) || "0x1", 16)
                  }).catch(function (error) {
                    base_namespaceObject.log.error("error while creating new wallet connect session", error);
                    _this3.emit(base_namespaceObject.ADAPTER_EVENTS.ERRORED, error);
                    return reject(error);
                  });
                }));
              case 11:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));
      function createNewSession() {
        return _createNewSession.apply(this, arguments);
      }
      return createNewSession;
    }()
  }, {
    key: "onConnectHandler",
    value: function () {
      var _onConnectHandler = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee11(params) {
        var chainId, _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3, connectedChainConfig, isCustomUi;
        return regenerator_default().wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(!this.connector || !this.wcProvider)) {
                  _context11.next = 2;
                  break;
                }
                throw base_namespaceObject.WalletInitializationError.notReady("Wallet adapter is not ready yet");
              case 2:
                if (this.chainConfig) {
                  _context11.next = 4;
                  break;
                }
                throw base_namespaceObject.WalletInitializationError.invalidParams("Chain config is not set");
              case 4:
                chainId = params.chainId;
                base_namespaceObject.log.debug("connected chainId in hex");
                if (!(chainId !== parseInt(this.chainConfig.chainId, 16))) {
                  _context11.next = 27;
                  break;
                }
                connectedChainConfig = (0,base_namespaceObject.getChainConfig)(base_namespaceObject.CHAIN_NAMESPACES.EIP155, chainId) || {
                  chainId: "0x".concat(chainId.toString(16)),
                  displayName: "Unknown Network"
                };
                isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal; // skipping network is not allowed in default ui. We are use network switching modal for default ui.
                if (!(!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching))) {
                  _context11.next = 27;
                  break;
                }
                _context11.prev = 10;
                _context11.next = 13;
                return this.addChain(this.chainConfig);
              case 13:
                _context11.next = 15;
                return this.switchChain(connectedChainConfig, this.chainConfig);
              case 15:
                this.connector = this.getWalletConnectInstance();
                _context11.next = 27;
                break;
              case 18:
                _context11.prev = 18;
                _context11.t0 = _context11["catch"](10);
                base_namespaceObject.log.error("error while chain switching", _context11.t0);
                // we need to create a new session since old session is already used and
                // user needs to login again with correct chain with new qr code.
                _context11.next = 23;
                return this.createNewSession({
                  forceNewSession: true
                });
              case 23:
                this.emit(base_namespaceObject.ADAPTER_EVENTS.ERRORED, base_namespaceObject.WalletInitializationError.fromCode(5000, "Not connected to correct network. Expected: ".concat(this.chainConfig.displayName, ", Current: ").concat((connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId, ", Please switch to correct network from wallet")));
                this.status = base_namespaceObject.ADAPTER_STATUS.READY;
                this.rehydrated = true;
                return _context11.abrupt("return");
              case 27:
                _context11.next = 29;
                return this.wcProvider.setupProvider(this.connector);
              case 29:
                this.subscribeEvents(this.connector);
                this.status = base_namespaceObject.ADAPTER_STATUS.CONNECTED;
                this.emit(base_namespaceObject.ADAPTER_EVENTS.CONNECTED, {
                  adapter: base_namespaceObject.WALLET_ADAPTERS.WALLET_CONNECT_V1,
                  reconnected: this.rehydrated
                });
              case 32:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[10, 18]]);
      }));
      function onConnectHandler(_x8) {
        return _onConnectHandler.apply(this, arguments);
      }
      return onConnectHandler;
    }()
  }, {
    key: "subscribeEvents",
    value: function subscribeEvents(connector) {
      var _this4 = this;
      connector.on("session_update", /*#__PURE__*/function () {
        var _ref4 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee12(error) {
          return regenerator_default().wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  if (error) {
                    _this4.emit(base_namespaceObject.ADAPTER_EVENTS.ERRORED, error);
                  }
                case 1:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }));
        return function (_x9) {
          return _ref4.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "getWalletConnectInstance",
    value: function getWalletConnectInstance() {
      var walletConnectOptions = this.adapterOptions.adapterSettings || {};
      walletConnectOptions.bridge = walletConnectOptions.bridge || "https://bridge.walletconnect.org";
      // Create a connector
      return new (client_default())(walletConnectOptions);
    }
  }]);
  return WalletConnectV1Adapter;
}(base_evm_adapter_namespaceObject.BaseEvmAdapter);

;// CONCATENATED MODULE: ./src/index.ts


module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=walletConnectV1Adapter.cjs.js.map