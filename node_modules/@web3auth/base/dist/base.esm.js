import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';
import { CustomError } from 'ts-custom-error';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { post } from '@toruslabs/http-helpers';
import JwtDecode from 'jwt-decode';
import loglevel from 'loglevel';

var CHAIN_NAMESPACES = {
  EIP155: "eip155",
  SOLANA: "solana",
  OTHER: "other"
};
var ADAPTER_NAMESPACES = {
  EIP155: "eip155",
  SOLANA: "solana",
  MULTICHAIN: "multichain"
};

var getDefaultNetworkId = function getDefaultNetworkId(chainNamespace) {
  if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
    return 1;
  } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
    return 1;
  }
  throw new Error("Chain namespace ".concat(chainNamespace, " is not supported"));
};
var getEvmChainConfig = function getEvmChainConfig(chainId) {
  var chainNamespace = CHAIN_NAMESPACES.EIP155;
  if (chainId === 1) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x1",
      rpcTarget: "https://rpc.ankr.com/eth",
      displayName: "Ethereum Mainnet",
      blockExplorer: "https://etherscan.io/",
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 3) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x3",
      rpcTarget: "https://rpc.ankr.com/eth_ropsten",
      displayName: "Ropsten Testnet",
      blockExplorer: "https://ropsten.etherscan.io/",
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 4) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x4",
      rpcTarget: "https://rpc.ankr.com/eth_rinkeby",
      displayName: "Rinkeby Testnet",
      blockExplorer: "https://rinkeby.etherscan.io/",
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 5) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x5",
      rpcTarget: "https://rpc.ankr.com/eth_goerli",
      displayName: "Goerli Testnet",
      blockExplorer: "https://goerli.etherscan.io/",
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 137) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x89",
      rpcTarget: "https://rpc.ankr.com/polygon",
      displayName: "Polygon Mainnet",
      blockExplorer: "https://polygonscan.com",
      ticker: "MATIC",
      tickerName: "Polygon"
    };
  }
  if (chainId === 80001) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x13881",
      rpcTarget: "https://rpc.ankr.com/polygon_mumbai",
      displayName: "Polygon Mumbai Testnet",
      blockExplorer: "https://mumbai.polygonscan.com/",
      ticker: "MATIC",
      tickerName: "Polygon"
    };
  }
  if (chainId === 56) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x38",
      rpcTarget: "https://rpc.ankr.com/bsc",
      displayName: "Binance SmartChain Mainnet",
      blockExplorer: "https://bscscan.com",
      ticker: "BNB",
      tickerName: "Binance SmartChain"
    };
  }
  if (chainId === 97) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x61",
      rpcTarget: "https://rpc.ankr.com/bsc_testnet_chapel",
      displayName: "Binance SmartChain Testnet",
      blockExplorer: "https://testnet.bscscan.com",
      ticker: "BNB",
      tickerName: "Binance SmartChain"
    };
  }
  if (chainId === 25) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x19",
      rpcTarget: "https://rpc.cronos.org",
      displayName: "Cronos Mainnet",
      blockExplorer: "https://cronoscan.com/",
      ticker: "CRO",
      tickerName: "Cronos"
    };
  }
  if (chainId === 338) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x152",
      rpcTarget: "https://rpc-t3.cronos.org/",
      displayName: "Cronos Testnet",
      blockExplorer: "https://cronoscan.com/",
      ticker: "CRO",
      tickerName: "Cronos"
    };
  }
  if (chainId === 8217) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x2019",
      rpcTarget: "https://public-node-api.klaytnapi.com/v1/cypress",
      displayName: "Klaytn Mainnet",
      blockExplorer: "https://scope.klaytn.com",
      ticker: "KLAY",
      tickerName: "Klaytn"
    };
  }
  return null;
};
var getSolanaChainConfig = function getSolanaChainConfig(chainId) {
  var chainNamespace = CHAIN_NAMESPACES.SOLANA;
  if (chainId === 1) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x1",
      rpcTarget: "https://rpc.ankr.com/solana",
      displayName: "Solana Mainnet",
      blockExplorer: "https://explorer.solana.com",
      ticker: "SOL",
      tickerName: "Solana"
    };
  } else if (chainId === 2) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x2",
      rpcTarget: "https://api.testnet.solana.com",
      displayName: "Solana Testnet",
      blockExplorer: "https://explorer.solana.com?cluster=testnet",
      ticker: "SOL",
      tickerName: "Solana"
    };
  } else if (chainId === 3) {
    return {
      chainNamespace: chainNamespace,
      chainId: "0x3",
      rpcTarget: "https://api.devnet.solana.com",
      displayName: "Solana Devnet",
      blockExplorer: "https://explorer.solana.com?cluster=devnet",
      ticker: "SOL",
      tickerName: "Solana"
    };
  }
  return null;
};
var getChainConfig = function getChainConfig(chainNamespace, chainId) {
  if (chainNamespace === CHAIN_NAMESPACES.OTHER) return null;
  var finalChainId = chainId ? typeof chainId === "number" ? chainId : parseInt(chainId, 16) : getDefaultNetworkId(chainNamespace);
  if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
    return getEvmChainConfig(finalChainId);
  } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
    return getSolanaChainConfig(finalChainId);
  }
  return null;
};

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var Web3AuthError = /*#__PURE__*/function (_CustomError) {
  _inherits(Web3AuthError, _CustomError);
  var _super = _createSuper$1(Web3AuthError);
  function Web3AuthError(code, message) {
    var _this;
    _classCallCheck(this, Web3AuthError);
    // takes care of stack and proto
    _this = _super.call(this, message);
    _defineProperty(_assertThisInitialized(_this), "code", void 0);
    _defineProperty(_assertThisInitialized(_this), "message", void 0);
    _this.code = code;
    _this.message = message || "";
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(_assertThisInitialized(_this), "name", {
      value: "Web3AuthError"
    });
    return _this;
  }
  _createClass(Web3AuthError, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        code: this.code,
        message: this.message
      };
    }
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this.toJSON());
    }
  }]);
  return Web3AuthError;
}(CustomError);
var WalletInitializationError = /*#__PURE__*/function (_Web3AuthError) {
  _inherits(WalletInitializationError, _Web3AuthError);
  var _super2 = _createSuper$1(WalletInitializationError);
  function WalletInitializationError(code, message) {
    var _this2;
    _classCallCheck(this, WalletInitializationError);
    // takes care of stack and proto
    _this2 = _super2.call(this, code, message);
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(_assertThisInitialized(_this2), "name", {
      value: "WalletInitializationError"
    });
    return _this2;
  }
  _createClass(WalletInitializationError, null, [{
    key: "fromCode",
    value: function fromCode(code) {
      var extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      return new WalletInitializationError(code, "".concat(WalletInitializationError.messages[code], ", ").concat(extraMessage));
    }
    // Custom methods
  }, {
    key: "notFound",
    value: function notFound() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5001, extraMessage);
    }
  }, {
    key: "notInstalled",
    value: function notInstalled() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5002, extraMessage);
    }
  }, {
    key: "notReady",
    value: function notReady() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5003, extraMessage);
    }
  }, {
    key: "windowBlocked",
    value: function windowBlocked() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5004, extraMessage);
    }
  }, {
    key: "windowClosed",
    value: function windowClosed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5005, extraMessage);
    }
  }, {
    key: "incompatibleChainNameSpace",
    value: function incompatibleChainNameSpace() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5006, extraMessage);
    }
  }, {
    key: "duplicateAdapterError",
    value: function duplicateAdapterError() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5007, extraMessage);
    }
  }, {
    key: "invalidProviderConfigError",
    value: function invalidProviderConfigError() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5008, extraMessage);
    }
  }, {
    key: "providerNotReadyError",
    value: function providerNotReadyError() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5009, extraMessage);
    }
  }, {
    key: "rpcConnectionError",
    value: function rpcConnectionError() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5010, extraMessage);
    }
  }, {
    key: "invalidParams",
    value: function invalidParams() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5011, extraMessage);
    }
  }, {
    key: "invalidNetwork",
    value: function invalidNetwork() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletInitializationError.fromCode(5013, extraMessage);
    }
  }]);
  return WalletInitializationError;
}(Web3AuthError);
/**
 * wallet login errors
 */
_defineProperty(WalletInitializationError, "messages", {
  5000: "Custom",
  5001: "Wallet is not found",
  5002: "Wallet is not installed",
  5003: "Wallet is not ready yet",
  5004: "Wallet window is blocked",
  5005: "Wallet window has been closed by the user",
  5006: "Incompatible chain namespace provided",
  5007: "Adapter has already been included",
  5008: "Invalid provider Config",
  5009: "Provider is not ready yet",
  5010: "Failed to connect with rpc url",
  5011: "Invalid params passed in",
  5013: "Invalid network provided"
});
var WalletLoginError = /*#__PURE__*/function (_Web3AuthError2) {
  _inherits(WalletLoginError, _Web3AuthError2);
  var _super3 = _createSuper$1(WalletLoginError);
  function WalletLoginError(code, message) {
    var _this3;
    _classCallCheck(this, WalletLoginError);
    // takes care of stack and proto
    _this3 = _super3.call(this, code, message);
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(_assertThisInitialized(_this3), "name", {
      value: "WalletLoginError"
    });
    return _this3;
  }
  _createClass(WalletLoginError, null, [{
    key: "fromCode",
    value: function fromCode(code) {
      var extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      return new WalletLoginError(code, "".concat(WalletLoginError.messages[code]).concat(extraMessage));
    }
  }, {
    key: "connectionError",
    value: function connectionError() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletLoginError.fromCode(5111, extraMessage);
    }
  }, {
    key: "disconnectionError",
    value: function disconnectionError() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletLoginError.fromCode(5112, extraMessage);
    }
  }, {
    key: "notConnectedError",
    value: function notConnectedError() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletLoginError.fromCode(5113, extraMessage);
    }
  }, {
    key: "popupClosed",
    value: function popupClosed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletLoginError.fromCode(5114, extraMessage);
    }
  }, {
    key: "mfaEnabled",
    value: function mfaEnabled() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return WalletLoginError.fromCode(5115, extraMessage);
    }
  }]);
  return WalletLoginError;
}(Web3AuthError);
_defineProperty(WalletLoginError, "messages", {
  5000: "Custom",
  5111: "Failed to connect with wallet",
  5112: "Failed to disconnect from wallet",
  5113: "Wallet is not connected",
  5114: "Wallet popup has been closed by the user",
  5115: "User has already enabled mfa, please use the @web3auth/web3auth-web sdk for login with mfa"
});

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var MULTI_CHAIN_ADAPTERS = {
  OPENLOGIN: "openlogin",
  WALLET_CONNECT_V1: "wallet-connect-v1",
  WALLET_CONNECT_V2: "wallet-connect-v2"
};
var SOLANA_ADAPTERS = _objectSpread$1({
  TORUS_SOLANA: "torus-solana",
  PHANTOM: "phantom",
  SOLLET: "sollet",
  SOLLET_EXTENSION: "sollet-extension",
  SOLFLARE: "solflare",
  SLOPE: "slope"
}, MULTI_CHAIN_ADAPTERS);
var EVM_ADAPTERS = _objectSpread$1({
  TORUS_EVM: "torus-evm",
  METAMASK: "metamask",
  COINBASE: "coinbase"
}, MULTI_CHAIN_ADAPTERS);
var WALLET_ADAPTERS = _objectSpread$1(_objectSpread$1({}, EVM_ADAPTERS), SOLANA_ADAPTERS);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var ADAPTER_CATEGORY = {
  EXTERNAL: "external",
  IN_APP: "in_app"
};
var ADAPTER_STATUS = {
  NOT_READY: "not_ready",
  READY: "ready",
  CONNECTING: "connecting",
  CONNECTED: "connected",
  DISCONNECTED: "disconnected",
  ERRORED: "errored"
};
var ADAPTER_EVENTS = _objectSpread(_objectSpread({}, ADAPTER_STATUS), {}, {
  ADAPTER_DATA_UPDATED: "adapter_data_updated"
});
var BaseAdapter = /*#__PURE__*/function (_SafeEventEmitter) {
  _inherits(BaseAdapter, _SafeEventEmitter);
  var _super = _createSuper(BaseAdapter);
  function BaseAdapter() {
    var _this;
    _classCallCheck(this, BaseAdapter);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "adapterData", {});
    _defineProperty(_assertThisInitialized(_this), "sessionTime", 86400);
    _defineProperty(_assertThisInitialized(_this), "chainConfig", null);
    return _this;
  }
  _createClass(BaseAdapter, [{
    key: "chainConfigProxy",
    get: function get() {
      return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;
    }
  }, {
    key: "setChainConfig",
    value: function setChainConfig(customChainConfig) {
      if (this.status === ADAPTER_STATUS.READY) return;
      if (!customChainConfig.chainNamespace) throw WalletInitializationError.notReady("ChainNamespace is required while setting chainConfig");
      var defaultChainConfig = getChainConfig(customChainConfig.chainNamespace, customChainConfig.chainId);
      this.chainConfig = _objectSpread(_objectSpread({}, defaultChainConfig), customChainConfig);
    }
  }, {
    key: "setAdapterSettings",
    value: function setAdapterSettings(_) {}
  }, {
    key: "checkConnectionRequirements",
    value: function checkConnectionRequirements() {
      // we reconnect without killing existing wallet connect session on calling connect again.
      if (this.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.status === ADAPTER_STATUS.CONNECTING) return;else if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady("Already connecting");
      if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletLoginError.connectionError("Already connected");
      if (this.status !== ADAPTER_STATUS.READY) throw WalletLoginError.connectionError("Wallet adapter is not ready yet, Please wait for init function to resolve before calling connect/connectTo function");
      if (!this.clientId) throw WalletLoginError.connectionError("Please initialize Web3Auth with a valid clientId in constructor");
    }
  }, {
    key: "checkInitializationRequirements",
    value: function checkInitializationRequirements() {
      if (this.status === ADAPTER_STATUS.NOT_READY) return;
      if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady("Already connected");
      if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady("Adapter is already initialized");
    }
  }, {
    key: "updateAdapterData",
    value: function updateAdapterData(data) {
      this.adapterData = data;
      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, {
        adapterName: this.name,
        data: data
      });
    }
  }]);
  return BaseAdapter;
}(SafeEventEmitter);
var BaseNetworkSwitch = /*#__PURE__*/_createClass(function BaseNetworkSwitch() {
  _classCallCheck(this, BaseNetworkSwitch);
});

var authServer = "https://authjs.web3auth.io";

var log = loglevel.getLogger("web3auth-logger");

function storageAvailable(type) {
  var storageExists = false;
  var storageLength = 0;
  var storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    var x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    var _error = error;
    return !!(_error && (
    // everything except Firefox
    _error.code === 22 ||
    // Firefox
    _error.code === 1014 ||
    // test name field too, because code might not be present
    // everything except Firefox
    _error.name === "QuotaExceededError" ||
    // Firefox
    _error.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
    // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0);
  }
}
var isHexStrict = function isHexStrict(hex) {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
};

var checkIfTokenIsExpired = function checkIfTokenIsExpired(token) {
  var decoded = JwtDecode(token);
  if (!decoded.exp) {
    return true;
  }
  if (decoded.exp < Math.floor(Date.now() / 1000)) {
    return true;
  }
  return false;
};
var signChallenge = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(payload, chainNamespace) {
    var t, header, network, data, res;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            t = chainNamespace === "solana" ? "sip99" : "eip191";
            header = {
              t: t
            };
            network = chainNamespace === "solana" ? "solana" : "ethereum";
            data = {
              payload: payload,
              header: header,
              network: network
            };
            _context.next = 6;
            return post("".concat(authServer, "/siww/get"), data);
          case 6:
            res = _context.sent;
            if (res.success) {
              _context.next = 9;
              break;
            }
            throw new Error("Failed to authenticate user, Please reach out to Web3Auth Support team");
          case 9:
            return _context.abrupt("return", res.challenge);
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return function signChallenge(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var verifySignedChallenge = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chainNamespace, signedMessage, challenge, issuer, sessionTime, clientId) {
    var t, sigData, idTokenRes;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            t = chainNamespace === "solana" ? "sip99" : "eip191";
            sigData = {
              signature: {
                s: signedMessage,
                t: t
              },
              message: challenge,
              issuer: issuer,
              audience: window.location.hostname,
              timeout: sessionTime
            };
            _context2.next = 4;
            return post("".concat(authServer, "/siww/verify"), sigData, {
              headers: {
                client_id: clientId,
                wallet_provider: issuer
              }
            });
          case 4:
            idTokenRes = _context2.sent;
            if (idTokenRes.success) {
              _context2.next = 8;
              break;
            }
            log.error("Failed to authenticate user, ,message verification failed", idTokenRes.error);
            throw new Error("Failed to authenticate user, ,message verification failed");
          case 8:
            return _context2.abrupt("return", idTokenRes.token);
          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return function verifySignedChallenge(_x3, _x4, _x5, _x6, _x7, _x8) {
    return _ref2.apply(this, arguments);
  };
}();
var getSavedToken = function getSavedToken(userAddress, issuer) {
  if (storageAvailable("localStorage")) {
    return localStorage.getItem("".concat(userAddress.toLowerCase(), "_").concat(issuer));
  }
  return null;
};
var saveToken = function saveToken(userAddress, issuer, token) {
  if (storageAvailable("localStorage")) {
    return localStorage.setItem("".concat(userAddress.toLowerCase(), "_").concat(issuer), token);
  }
  return null;
};
var clearToken = function clearToken(userAddress, issuer) {
  if (storageAvailable("localStorage")) {
    return localStorage.removeItem("".concat(userAddress.toLowerCase(), "_").concat(issuer));
  }
  return null;
};

var PROVIDER_EVENTS = {
  INITIALIZED: "initialized",
  ERRORED: "errored"
};

export { ADAPTER_CATEGORY, ADAPTER_EVENTS, ADAPTER_NAMESPACES, ADAPTER_STATUS, BaseAdapter, BaseNetworkSwitch, CHAIN_NAMESPACES, EVM_ADAPTERS, MULTI_CHAIN_ADAPTERS, PROVIDER_EVENTS, SOLANA_ADAPTERS, WALLET_ADAPTERS, WalletInitializationError, WalletLoginError, Web3AuthError, authServer, checkIfTokenIsExpired, clearToken, getChainConfig, getEvmChainConfig, getSavedToken, getSolanaChainConfig, isHexStrict, log, saveToken, signChallenge, storageAvailable, verifySignedChallenge };
//# sourceMappingURL=base.esm.js.map
