import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _get from '@babel/runtime/helpers/get';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';
import { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';
import { CHAIN_NAMESPACES, log, WalletInitializationError, isHexStrict, WalletLoginError, getChainConfig } from '@web3auth/base';
import { BaseProvider } from '@web3auth/base-provider';
import { ethErrors } from 'eth-rpc-errors';
import { TransactionFactory } from '@ethereumjs/tx';
import { stripHexPrefix, isValidAddress, privateToAddress, addHexPrefix } from '@ethereumjs/util';
import { SignTypedDataVersion, TYPED_MESSAGE_SCHEMA, typedSignatureHash, personalSign, signTypedData, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';
import _typeof from '@babel/runtime/helpers/typeof';
import { get } from '@toruslabs/http-helpers';
import assert from 'assert';
import jsonschema from 'jsonschema';
import BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';
import { Hardfork, Common } from '@ethereumjs/common';
import BN from 'bn.js';

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function resemblesAddress(str) {
  // hex prefix 2 + 20 bytes
  return str.length === 2 + 20 * 2;
}
function createWalletMiddleware(_ref) {
  var getAccounts = _ref.getAccounts,
    getPrivateKey = _ref.getPrivateKey,
    processDecryptMessage = _ref.processDecryptMessage,
    processEncryptionPublicKey = _ref.processEncryptionPublicKey,
    processEthSignMessage = _ref.processEthSignMessage,
    processPersonalMessage = _ref.processPersonalMessage,
    processTransaction = _ref.processTransaction,
    processSignTransaction = _ref.processSignTransaction,
    processTypedMessage = _ref.processTypedMessage,
    processTypedMessageV3 = _ref.processTypedMessageV3,
    processTypedMessageV4 = _ref.processTypedMessageV4;
  if (!getAccounts) {
    throw new Error("opts.getAccounts is required");
  }
  //
  // utility
  //
  /**
   * Validates the keyholder address, and returns a normalized (i.e. lowercase)
   * copy of it.
   *
   * an error
   */
  function validateAndNormalizeKeyholder(_x, _x2) {
    return _validateAndNormalizeKeyholder.apply(this, arguments);
  } //
  // account lookups
  //
  function _validateAndNormalizeKeyholder() {
    _validateAndNormalizeKeyholder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address, req) {
      var accounts, normalizedAccounts, normalizedAddress;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof address === "string" && address.length > 0)) {
                _context.next = 8;
                break;
              }
              _context.next = 3;
              return getAccounts(req);
            case 3:
              accounts = _context.sent;
              normalizedAccounts = accounts.map(function (_address) {
                return _address.toLowerCase();
              });
              normalizedAddress = address.toLowerCase();
              if (!normalizedAccounts.includes(normalizedAddress)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", normalizedAddress);
            case 8:
              throw ethErrors.rpc.invalidParams({
                message: "Invalid parameters: must provide an Ethereum address."
              });
            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _validateAndNormalizeKeyholder.apply(this, arguments);
  }
  function lookupAccounts(_x3, _x4) {
    return _lookupAccounts.apply(this, arguments);
  }
  function _lookupAccounts() {
    _lookupAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res) {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return getAccounts(req);
            case 2:
              res.result = _context2.sent;
            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _lookupAccounts.apply(this, arguments);
  }
  function lookupDefaultAccount(_x5, _x6) {
    return _lookupDefaultAccount.apply(this, arguments);
  } //
  // transaction signatures
  //
  function _lookupDefaultAccount() {
    _lookupDefaultAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(req, res) {
      var accounts;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return getAccounts(req);
            case 2:
              accounts = _context3.sent;
              res.result = accounts[0] || null;
            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _lookupDefaultAccount.apply(this, arguments);
  }
  function sendTransaction(_x7, _x8) {
    return _sendTransaction.apply(this, arguments);
  }
  function _sendTransaction() {
    _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(req, res) {
      var txParams;
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (processTransaction) {
                _context4.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              txParams = req.params[0] || {
                from: ""
              };
              _context4.next = 5;
              return validateAndNormalizeKeyholder(txParams.from, req);
            case 5:
              txParams.from = _context4.sent;
              _context4.next = 8;
              return processTransaction(txParams, req);
            case 8:
              res.result = _context4.sent;
            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendTransaction.apply(this, arguments);
  }
  function signTransaction(_x9, _x10) {
    return _signTransaction.apply(this, arguments);
  } //
  // message signatures
  //
  function _signTransaction() {
    _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(req, res) {
      var txParams;
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (processSignTransaction) {
                _context5.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              txParams = req.params[0] || {
                from: ""
              };
              _context5.next = 5;
              return validateAndNormalizeKeyholder(txParams.from, req);
            case 5:
              txParams.from = _context5.sent;
              _context5.next = 8;
              return processSignTransaction(txParams, req);
            case 8:
              res.result = _context5.sent;
            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _signTransaction.apply(this, arguments);
  }
  function ethSign(_x11, _x12) {
    return _ethSign.apply(this, arguments);
  }
  function _ethSign() {
    _ethSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(req, res) {
      var address, message, extraParams, msgParams;
      return _regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (processEthSignMessage) {
                _context6.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              _context6.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context6.sent;
              message = req.params[1];
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context6.next = 10;
              return processEthSignMessage(msgParams, req);
            case 10:
              res.result = _context6.sent;
            case 11:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));
    return _ethSign.apply(this, arguments);
  }
  function signTypedData(_x13, _x14) {
    return _signTypedData.apply(this, arguments);
  }
  function _signTypedData() {
    _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(req, res) {
      var message, address, version, extraParams, msgParams;
      return _regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (processTypedMessage) {
                _context7.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              message = req.params[0];
              _context7.next = 5;
              return validateAndNormalizeKeyholder(req.params[1], req);
            case 5:
              address = _context7.sent;
              version = "V1";
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context7.next = 11;
              return processTypedMessage(msgParams, req, version);
            case 11:
              res.result = _context7.sent;
            case 12:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));
    return _signTypedData.apply(this, arguments);
  }
  function signTypedDataV3(_x15, _x16) {
    return _signTypedDataV.apply(this, arguments);
  }
  function _signTypedDataV() {
    _signTypedDataV = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(req, res) {
      var address, message, version, msgParams;
      return _regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (processTypedMessageV3) {
                _context8.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              _context8.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context8.sent;
              message = req.params[1];
              version = "V3";
              msgParams = {
                data: message,
                from: address,
                version: version
              };
              _context8.next = 10;
              return processTypedMessageV3(msgParams, req, version);
            case 10:
              res.result = _context8.sent;
            case 11:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));
    return _signTypedDataV.apply(this, arguments);
  }
  function signTypedDataV4(_x17, _x18) {
    return _signTypedDataV2.apply(this, arguments);
  }
  function _signTypedDataV2() {
    _signTypedDataV2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(req, res) {
      var address, message, version, msgParams;
      return _regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (processTypedMessageV4) {
                _context9.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              _context9.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context9.sent;
              message = req.params[1];
              version = "V4";
              msgParams = {
                data: message,
                from: address,
                version: version
              };
              _context9.next = 10;
              return processTypedMessageV4(msgParams, req, version);
            case 10:
              res.result = _context9.sent;
            case 11:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));
    return _signTypedDataV2.apply(this, arguments);
  }
  function personalSign(_x19, _x20) {
    return _personalSign.apply(this, arguments);
  }
  function _personalSign() {
    _personalSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(req, res) {
      var firstParam, secondParam, extraParams, address, message, warning, msgParams;
      return _regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (processPersonalMessage) {
                _context10.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              // process normally
              firstParam = req.params[0];
              secondParam = req.params[1]; // non-standard "extraParams" to be appended to our "msgParams" obj
              extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.
              // To gracefully respect users who adopted this API early,
              // we are currently gracefully recovering from the wrong param order
              // when it is clearly identifiable.
              //
              // That means when the first param is definitely an address,
              // and the second param is definitely not, but is hex.
              if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
                warning = "The eth_personalSign method requires params ordered ";
                warning += "[message, address]. This was previously handled incorrectly, ";
                warning += "and has been corrected automatically. ";
                warning += "Please switch this param order for smooth behavior in the future.";
                res.warning = warning;
                address = firstParam;
                message = secondParam;
              } else {
                message = firstParam;
                address = secondParam;
              }
              _context10.next = 8;
              return validateAndNormalizeKeyholder(address, req);
            case 8:
              address = _context10.sent;
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              }); // eslint-disable-next-line require-atomic-updates
              _context10.next = 12;
              return processPersonalMessage(msgParams, req);
            case 12:
              res.result = _context10.sent;
            case 13:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));
    return _personalSign.apply(this, arguments);
  }
  function encryptionPublicKey(_x21, _x22) {
    return _encryptionPublicKey.apply(this, arguments);
  }
  function _encryptionPublicKey() {
    _encryptionPublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(req, res) {
      var address;
      return _regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (processEncryptionPublicKey) {
                _context11.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              _context11.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context11.sent;
              _context11.next = 7;
              return processEncryptionPublicKey(address, req);
            case 7:
              res.result = _context11.sent;
            case 8:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));
    return _encryptionPublicKey.apply(this, arguments);
  }
  function decryptMessage(_x23, _x24) {
    return _decryptMessage.apply(this, arguments);
  }
  function _decryptMessage() {
    _decryptMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(req, res) {
      var ciphertext, address, extraParams, msgParams;
      return _regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (processDecryptMessage) {
                _context12.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              ciphertext = req.params[0];
              _context12.next = 5;
              return validateAndNormalizeKeyholder(req.params[1], req);
            case 5:
              address = _context12.sent;
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: ciphertext
              });
              res.result = processDecryptMessage(msgParams, req);
            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));
    return _decryptMessage.apply(this, arguments);
  }
  function fetchPrivateKey(_x25, _x26) {
    return _fetchPrivateKey.apply(this, arguments);
  }
  function _fetchPrivateKey() {
    _fetchPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(req, res) {
      return _regeneratorRuntime.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (getPrivateKey) {
                _context13.next = 2;
                break;
              }
              throw ethErrors.rpc.methodNotSupported();
            case 2:
              res.result = getPrivateKey(req);
            case 3:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));
    return _fetchPrivateKey.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    // account lookups
    eth_accounts: createAsyncMiddleware(lookupAccounts),
    eth_private_key: createAsyncMiddleware(fetchPrivateKey),
    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),
    // tx signatures
    eth_sendTransaction: createAsyncMiddleware(sendTransaction),
    eth_signTransaction: createAsyncMiddleware(signTransaction),
    // message signatures
    eth_sign: createAsyncMiddleware(ethSign),
    eth_signTypedData: createAsyncMiddleware(signTypedData),
    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),
    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),
    personal_sign: createAsyncMiddleware(personalSign),
    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),
    eth_decrypt: createAsyncMiddleware(decryptMessage)
  });
}

function createEthMiddleware(providerHandlers) {
  var getAccounts = providerHandlers.getAccounts,
    getPrivateKey = providerHandlers.getPrivateKey,
    processTransaction = providerHandlers.processTransaction,
    processSignTransaction = providerHandlers.processSignTransaction,
    processEthSignMessage = providerHandlers.processEthSignMessage,
    processTypedMessage = providerHandlers.processTypedMessage,
    processTypedMessageV3 = providerHandlers.processTypedMessageV3,
    processTypedMessageV4 = providerHandlers.processTypedMessageV4,
    processPersonalMessage = providerHandlers.processPersonalMessage,
    processEncryptionPublicKey = providerHandlers.processEncryptionPublicKey,
    processDecryptMessage = providerHandlers.processDecryptMessage;
  var ethMiddleware = mergeMiddleware([createScaffoldMiddleware({
    eth_syncing: false
  }), createWalletMiddleware({
    getAccounts: getAccounts,
    getPrivateKey: getPrivateKey,
    processTransaction: processTransaction,
    processEthSignMessage: processEthSignMessage,
    processSignTransaction: processSignTransaction,
    processTypedMessage: processTypedMessage,
    processTypedMessageV3: processTypedMessageV3,
    processTypedMessageV4: processTypedMessageV4,
    processPersonalMessage: processPersonalMessage,
    processEncryptionPublicKey: processEncryptionPublicKey,
    processDecryptMessage: processDecryptMessage
  })]);
  return ethMiddleware;
}
function createChainSwitchMiddleware(_ref) {
  var addChain = _ref.addChain,
    switchChain = _ref.switchChain;
  function addNewChain(_x, _x2) {
    return _addNewChain.apply(this, arguments);
  }
  function _addNewChain() {
    _addNewChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res) {
      var _req$params;
      var chainParams;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;
              if (chainParams) {
                _context.next = 3;
                break;
              }
              throw ethErrors.rpc.invalidParams("Missing chain params");
            case 3:
              if (chainParams.chainId) {
                _context.next = 5;
                break;
              }
              throw ethErrors.rpc.invalidParams("Missing chainId in chainParams");
            case 5:
              if (!(!chainParams.rpcUrls || chainParams.rpcUrls.length === 0)) {
                _context.next = 7;
                break;
              }
              throw ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");
            case 7:
              if (chainParams.nativeCurrency) {
                _context.next = 9;
                break;
              }
              throw ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");
            case 9:
              _context.next = 11;
              return addChain(chainParams);
            case 11:
              res.result = _context.sent;
            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _addNewChain.apply(this, arguments);
  }
  function updateChain(_x3, _x4) {
    return _updateChain.apply(this, arguments);
  }
  function _updateChain() {
    _updateChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res) {
      var _req$params2;
      var chainParams;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;
              if (chainParams) {
                _context2.next = 3;
                break;
              }
              throw ethErrors.rpc.invalidParams("Missing chainId");
            case 3:
              _context2.next = 5;
              return switchChain(chainParams);
            case 5:
              res.result = _context2.sent;
            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _updateChain.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),
    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)
  });
}
// #region account middlewares
function createAccountMiddleware(_ref2) {
  var updatePrivatekey = _ref2.updatePrivatekey;
  function updateAccount(_x5, _x6) {
    return _updateAccount.apply(this, arguments);
  }
  function _updateAccount() {
    _updateAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(req, res) {
      var _req$params3;
      var accountParams;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;
              if (accountParams !== null && accountParams !== void 0 && accountParams.privateKey) {
                _context3.next = 3;
                break;
              }
              throw ethErrors.rpc.invalidParams("Missing privateKey");
            case 3:
              _context3.next = 5;
              return updatePrivatekey(accountParams);
            case 5:
              res.result = _context3.sent;
            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _updateAccount.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    wallet_updateAccount: createAsyncMiddleware(updateAccount)
  });
}
// #endregion account middlewares

function createChainIdMiddleware(chainId) {
  return function (req, res, next, end) {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return function (req, res, next, end) {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  var chainId = providerConfig.chainId,
    rpcTarget = providerConfig.rpcTarget;
  var fetchMiddleware = createFetchMiddleware({
    rpcTarget: rpcTarget
  });
  var networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware: networkMiddleware,
    fetchMiddleware: fetchMiddleware
  };
}

function getProviderHandlers$1(_ref) {
  var connector = _ref.connector;
  return {
    getPrivateKey: function () {
      var _getPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw ethErrors.rpc.methodNotSupported();
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function getPrivateKey() {
        return _getPrivateKey.apply(this, arguments);
      }
      return getPrivateKey;
    }(),
    getAccounts: function () {
      var _getAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_) {
        var accounts;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                accounts = connector.accounts;
                if (!(accounts && accounts.length)) {
                  _context2.next = 3;
                  break;
                }
                return _context2.abrupt("return", accounts);
              case 3:
                throw new Error("Failed to get accounts");
              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      function getAccounts(_x) {
        return _getAccounts.apply(this, arguments);
      }
      return getAccounts;
    }(),
    processTransaction: function () {
      var _processTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(txParams, _) {
        var result;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return connector.sendTransaction(txParams);
              case 2:
                result = _context3.sent;
                return _context3.abrupt("return", result);
              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function processTransaction(_x2, _x3) {
        return _processTransaction.apply(this, arguments);
      }
      return processTransaction;
    }(),
    processSignTransaction: function () {
      var _processSignTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(txParams, _) {
        var result;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return connector.signTransaction(txParams);
              case 2:
                result = _context4.sent;
                return _context4.abrupt("return", result);
              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function processSignTransaction(_x4, _x5) {
        return _processSignTransaction.apply(this, arguments);
      }
      return processSignTransaction;
    }(),
    processEthSignMessage: function () {
      var _processEthSignMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(msgParams, _) {
        var result;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return connector.signMessage([msgParams.from, msgParams.data]);
              case 2:
                result = _context5.sent;
                return _context5.abrupt("return", result);
              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      function processEthSignMessage(_x6, _x7) {
        return _processEthSignMessage.apply(this, arguments);
      }
      return processEthSignMessage;
    }(),
    processPersonalMessage: function () {
      var _processPersonalMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(msgParams, _) {
        var result;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return connector.signPersonalMessage([msgParams.data, msgParams.from]);
              case 2:
                result = _context6.sent;
                return _context6.abrupt("return", result);
              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      function processPersonalMessage(_x8, _x9) {
        return _processPersonalMessage.apply(this, arguments);
      }
      return processPersonalMessage;
    }(),
    processTypedMessage: function () {
      var _processTypedMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(msgParams, _) {
        var result;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context7.sent;
                return _context7.abrupt("return", result);
              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      function processTypedMessage(_x10, _x11) {
        return _processTypedMessage.apply(this, arguments);
      }
      return processTypedMessage;
    }(),
    processTypedMessageV3: function () {
      var _processTypedMessageV = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(msgParams) {
        var result;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context8.sent;
                return _context8.abrupt("return", result);
              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));
      function processTypedMessageV3(_x12) {
        return _processTypedMessageV.apply(this, arguments);
      }
      return processTypedMessageV3;
    }(),
    processTypedMessageV4: function () {
      var _processTypedMessageV2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(msgParams) {
        var result;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context9.sent;
                return _context9.abrupt("return", result);
              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      function processTypedMessageV4(_x13) {
        return _processTypedMessageV2.apply(this, arguments);
      }
      return processTypedMessageV4;
    }(),
    processEncryptionPublicKey: function () {
      var _processEncryptionPublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(_) {
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                throw ethErrors.rpc.methodNotSupported();
              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));
      function processEncryptionPublicKey(_x14) {
        return _processEncryptionPublicKey.apply(this, arguments);
      }
      return processEncryptionPublicKey;
    }(),
    processDecryptMessage: function processDecryptMessage(_) {
      throw ethErrors.rpc.methodNotSupported();
    }
  };
}

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var WalletConnectProvider = /*#__PURE__*/function (_BaseProvider) {
  _inherits(WalletConnectProvider, _BaseProvider);
  var _super = _createSuper$1(WalletConnectProvider);
  function WalletConnectProvider(_ref) {
    var _this;
    var config = _ref.config,
      state = _ref.state,
      connector = _ref.connector;
    _classCallCheck(this, WalletConnectProvider);
    _this = _super.call(this, {
      config: {
        chainConfig: _objectSpread$4(_objectSpread$4({}, config.chainConfig), {}, {
          chainNamespace: CHAIN_NAMESPACES.EIP155
        }),
        skipLookupNetwork: !!config.skipLookupNetwork
      },
      state: _objectSpread$4(_objectSpread$4({}, state || {}), {}, {
        chainId: "loading",
        accounts: []
      })
    });
    _defineProperty(_assertThisInitialized(_this), "connector", null);
    _this.connector = connector || null;
    return _this;
  }
  _createClass(WalletConnectProvider, [{
    key: "enable",
    value: function () {
      var _enable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.connector) {
                  _context.next = 2;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Connector is not initialized, pass wallet connect connector in constructor",
                  code: 4902
                });
              case 2:
                _context.next = 4;
                return this.setupProvider(this.connector);
              case 4:
                return _context.abrupt("return", this._providerEngineProxy.request({
                  method: "eth_accounts"
                }));
              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function enable() {
        return _enable.apply(this, arguments);
      }
      return enable;
    }()
  }, {
    key: "setupProvider",
    value: function () {
      var _setupProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connector) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.onConnectorStateUpdate(connector);
                _context2.next = 3;
                return this.setupEngine(connector);
              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function setupProvider(_x) {
        return _setupProvider.apply(this, arguments);
      }
      return setupProvider;
    }()
  }, {
    key: "switchChain",
    value: function () {
      var _switchChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref2) {
        var chainId, _ref2$addChain, addChain, _ref2$lookup, lookup, currentChainConfig, rpcTarget, displayName;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                chainId = _ref2.chainId, _ref2$addChain = _ref2.addChain, addChain = _ref2$addChain === void 0 ? true : _ref2$addChain, _ref2$lookup = _ref2.lookup, lookup = _ref2$lookup === void 0 ? true : _ref2$lookup;
                if (this.connector) {
                  _context3.next = 3;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Connector is not initialized, pass wallet connect connector in constructor",
                  code: 4902
                });
              case 3:
                currentChainConfig = this.getChainConfig(chainId);
                this.update({
                  chainId: "loading"
                });
                rpcTarget = currentChainConfig.rpcTarget, displayName = currentChainConfig.displayName;
                if (!addChain) {
                  _context3.next = 15;
                  break;
                }
                _context3.prev = 7;
                _context3.next = 10;
                return this.connector.sendCustomRequest({
                  method: "wallet_addEthereumChain",
                  params: [{
                    chainId: chainId,
                    chainName: displayName,
                    rpcUrls: [rpcTarget]
                  }]
                });
              case 10:
                _context3.next = 15;
                break;
              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](7);
                log.error(_context3.t0);
              case 15:
                _context3.prev = 15;
                _context3.next = 18;
                return this.connector.sendCustomRequest({
                  method: "wallet_switchEthereumChain",
                  params: [{
                    chainId: chainId
                  }]
                });
              case 18:
                _context3.next = 25;
                break;
              case 20:
                _context3.prev = 20;
                _context3.t1 = _context3["catch"](15);
                log.error(_context3.t1);
                // ignore this error because metamask & others return provider.result as null
                // wallet connect thinks this is wrong
                if (!(_context3.t1.message !== "JSON RPC response format is invalid")) {
                  _context3.next = 25;
                  break;
                }
                throw _context3.t1;
              case 25:
                this.configure({
                  chainConfig: currentChainConfig
                });
                if (!lookup) {
                  _context3.next = 29;
                  break;
                }
                _context3.next = 29;
                return this.lookupNetwork(this.connector);
              case 29:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[7, 12], [15, 20]]);
      }));
      function switchChain(_x2) {
        return _switchChain.apply(this, arguments);
      }
      return switchChain;
    }()
  }, {
    key: "addChain",
    value: function () {
      var _addChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(chainConfig) {
        var rpcTarget, displayName;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this.connector) {
                  _context4.next = 2;
                  break;
                }
                throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
              case 2:
                rpcTarget = chainConfig.rpcTarget, displayName = chainConfig.displayName;
                _context4.prev = 3;
                _context4.next = 6;
                return this.connector.sendCustomRequest({
                  method: "wallet_addEthereumChain",
                  params: [{
                    chainId: chainConfig.chainId,
                    chainName: displayName,
                    rpcUrls: [rpcTarget]
                  }]
                });
              case 6:
                _get(_getPrototypeOf(WalletConnectProvider.prototype), "addChain", this).call(this, chainConfig);
                _context4.next = 13;
                break;
              case 9:
                _context4.prev = 9;
                _context4.t0 = _context4["catch"](3);
                log.error(_context4.t0);
                throw _context4.t0;
              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 9]]);
      }));
      function addChain(_x3) {
        return _addChain.apply(this, arguments);
      }
      return addChain;
    }()
  }, {
    key: "lookupNetwork",
    value: function () {
      var _lookupNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connector) {
        var chainId, connectedHexChainId;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (connector.connected) {
                  _context5.next = 2;
                  break;
                }
                throw WalletLoginError.notConnectedError("Wallet connect connector is not connected");
              case 2:
                if (this.provider) {
                  _context5.next = 4;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 4:
                chainId = this.config.chainConfig.chainId;
                connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : "0x".concat(connector.chainId.toString(16));
                if (!(chainId !== connectedHexChainId)) {
                  _context5.next = 8;
                  break;
                }
                throw WalletInitializationError.rpcConnectionError("Invalid network, net_version is: ".concat(connectedHexChainId, ", expected: ").concat(chainId));
              case 8:
                this.provider.emit("connect", {
                  chainId: chainId
                });
                this.provider.emit("chainChanged", this.state.chainId);
                return _context5.abrupt("return", connectedHexChainId);
              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function lookupNetwork(_x4) {
        return _lookupNetwork.apply(this, arguments);
      }
      return lookupNetwork;
    }()
  }, {
    key: "setupEngine",
    value: function () {
      var _setupEngine = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(connector) {
        var providerHandlers, ethMiddleware, engine, _createJsonRpcClient, networkMiddleware, provider;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                providerHandlers = getProviderHandlers$1({
                  connector: connector
                });
                this.update({
                  accounts: connector.accounts || []
                });
                ethMiddleware = createEthMiddleware(providerHandlers);
                engine = new JRPCEngine();
                _createJsonRpcClient = createJsonRpcClient(this.config.chainConfig), networkMiddleware = _createJsonRpcClient.networkMiddleware;
                engine.push(ethMiddleware);
                engine.push(networkMiddleware);
                provider = providerFromEngine(engine);
                this.updateProviderEngineProxy(provider);
                if (this.config.skipLookupNetwork) {
                  _context6.next = 12;
                  break;
                }
                _context6.next = 12;
                return this.lookupNetwork(connector);
              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function setupEngine(_x5) {
        return _setupEngine.apply(this, arguments);
      }
      return setupEngine;
    }()
  }, {
    key: "onConnectorStateUpdate",
    value: function () {
      var _onConnectorStateUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(connector) {
        var _this2 = this;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                connector.on("session_update", /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(error, payload) {
                    var _payload$params$, accounts, connectedChainId, rpcUrl, connectedHexChainId, maybeConfig;
                    return _regeneratorRuntime.wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            if (_this2.provider) {
                              _context7.next = 2;
                              break;
                            }
                            throw WalletLoginError.notConnectedError("Wallet connect connector is not connected");
                          case 2:
                            if (!error) {
                              _context7.next = 5;
                              break;
                            }
                            _this2.provider.emit("error", error);
                            return _context7.abrupt("return");
                          case 5:
                            _payload$params$ = payload.params[0], accounts = _payload$params$.accounts, connectedChainId = _payload$params$.chainId, rpcUrl = _payload$params$.rpcUrl; // Check if accounts changed and trigger event
                            if (accounts !== null && accounts !== void 0 && accounts.length && _this2.state.accounts[0] !== accounts[0]) {
                              _this2.update({
                                accounts: accounts
                              });
                              // await this.setupEngine(connector);
                              _this2.provider.emit("accountsChanged", accounts);
                            }
                            connectedHexChainId = "0x".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event
                            if (!(connectedChainId && _this2.state.chainId !== connectedHexChainId)) {
                              _context7.next = 13;
                              break;
                            }
                            maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {}; // Handle rpcUrl update
                            _this2.configure({
                              chainConfig: _objectSpread$4(_objectSpread$4({}, maybeConfig), {}, {
                                chainId: connectedHexChainId,
                                rpcTarget: rpcUrl,
                                chainNamespace: CHAIN_NAMESPACES.EIP155
                              })
                            });
                            _context7.next = 13;
                            return _this2.setupEngine(connector);
                          case 13:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7);
                  }));
                  return function (_x7, _x8) {
                    return _ref3.apply(this, arguments);
                  };
                }());
              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));
      function onConnectorStateUpdate(_x6) {
        return _onConnectorStateUpdate.apply(this, arguments);
      }
      return onConnectorStateUpdate;
    }()
  }]);
  return WalletConnectProvider;
}(BaseProvider);
_defineProperty(WalletConnectProvider, "getProviderInstance", /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params) {
    var providerFactory;
    return _regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            providerFactory = new WalletConnectProvider({
              config: {
                chainConfig: params.chainConfig,
                skipLookupNetwork: params.skipLookupNetwork
              }
            });
            _context9.next = 3;
            return providerFactory.setupProvider(params.connector);
          case 3:
            return _context9.abrupt("return", providerFactory);
          case 4:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return function (_x9) {
    return _ref4.apply(this, arguments);
  };
}());

// Big Number Constants
var BIG_NUMBER_WEI_MULTIPLIER = new BigNumber("1e18");
var BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber("1e9");
var BIG_NUMBER_ETH_MULTIPLIER = new BigNumber("1");
// Setter Maps
var toBigNumber = {
  hex: function hex(n) {
    return typeof n === "string" ? new BigNumber(stripHexPrefix(n), 16) : new BigNumber(n, 16);
  },
  dec: function dec(n) {
    return new BigNumber(n, 10);
  }
};
var toNormalizedDenomination = {
  WEI: function WEI(bigNumber) {
    return bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER);
  },
  GWEI: function GWEI(bigNumber) {
    return bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER);
  },
  ETH: function ETH(bigNumber) {
    return bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER);
  }
};
var toSpecifiedDenomination = {
  WEI: function WEI(bigNumber) {
    return bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP);
  },
  GWEI: function GWEI(bigNumber) {
    return bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP);
  },
  ETH: function ETH(bigNumber) {
    return bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP);
  }
};
var baseChange = {
  hex: function hex(n) {
    return n.toString(16);
  },
  dec: function dec(n) {
    return new BigNumber(n).toString(10);
  }
};
var converter = function converter(params) {
  var value = params.value,
    fromNumericBase = params.fromNumericBase,
    fromDenomination = params.fromDenomination,
    toNumericBase = params.toNumericBase,
    toDenomination = params.toDenomination,
    numberOfDecimals = params.numberOfDecimals;
  var convertedValue = toBigNumber[fromNumericBase](value);
  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }
  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }
  if (numberOfDecimals) {
    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);
  }
  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }
  return convertedValue;
};
var conversionUtil = function conversionUtil(value, _ref) {
  var _ref$fromNumericBase = _ref.fromNumericBase,
    fromNumericBase = _ref$fromNumericBase === void 0 ? "hex" : _ref$fromNumericBase,
    toNumericBase = _ref.toNumericBase,
    fromDenomination = _ref.fromDenomination,
    toDenomination = _ref.toDenomination,
    numberOfDecimals = _ref.numberOfDecimals;
  return converter({
    fromNumericBase: fromNumericBase,
    toNumericBase: toNumericBase,
    fromDenomination: fromDenomination,
    toDenomination: toDenomination,
    numberOfDecimals: numberOfDecimals,
    value: value || "0"
  });
};
function decGWEIToHexWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
}
function hexWEIToDecGWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
}

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function normalizeGWEIDecimalNumbers(n) {
  var numberAsWEIHex = decGWEIToHexWEI(n);
  var numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);
  return numberAsGWEI;
}
function fetchEip1159GasEstimates(_x) {
  return _fetchEip1159GasEstimates.apply(this, arguments);
}
/**
 * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium
 * high values from that API.
 */
function _fetchEip1159GasEstimates() {
  _fetchEip1159GasEstimates = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {
    var estimates, normalizedEstimates;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return get(url);
          case 2:
            estimates = _context.sent;
            normalizedEstimates = _objectSpread$3(_objectSpread$3({}, estimates), {}, {
              estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
              low: _objectSpread$3(_objectSpread$3({}, estimates.low), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)
              }),
              medium: _objectSpread$3(_objectSpread$3({}, estimates.medium), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)
              }),
              high: _objectSpread$3(_objectSpread$3({}, estimates.high), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)
              })
            });
            return _context.abrupt("return", normalizedEstimates);
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchEip1159GasEstimates.apply(this, arguments);
}
function fetchLegacyGasPriceEstimates(_x2) {
  return _fetchLegacyGasPriceEstimates.apply(this, arguments);
}
function _fetchLegacyGasPriceEstimates() {
  _fetchLegacyGasPriceEstimates = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url) {
    var result;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return get(url, {
              referrer: url,
              referrerPolicy: "no-referrer-when-downgrade",
              method: "GET",
              mode: "cors"
            });
          case 2:
            result = _context2.sent;
            return _context2.abrupt("return", {
              low: result.SafeGasPrice,
              medium: result.ProposeGasPrice,
              high: result.FastGasPrice
            });
          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchLegacyGasPriceEstimates.apply(this, arguments);
}
var validateTypedMessageParams = function validateTypedMessageParams(parameters, activeChainId) {
  var _data$domain;
  try {
    assert.ok(parameters && _typeof(parameters) === "object", "Params must be an object.");
    assert.ok("data" in parameters, 'Params must include a "data" field.');
    assert.ok("from" in parameters, 'Params must include a "from" field.');
    assert.ok(typeof parameters.from === "string" && isValidAddress(parameters.from), '"from" field must be a valid, lowercase, hexadecimal Ethereum address string.');
    var data = null;
    var chainId = null;
    switch (parameters.version) {
      case SignTypedDataVersion.V1:
        if (typeof parameters.data === "string") {
          assert.doesNotThrow(function () {
            data = JSON.parse(parameters.data);
          }, '"data" must be a valid JSON string.');
        } else {
          // for backward compatiblity we validate for both string and object type.
          data = parameters.data;
        }
        assert.ok(Array.isArray(data), "params.data must be an array.");
        assert.doesNotThrow(function () {
          typedSignatureHash(data);
        }, "Signing data must be valid EIP-712 typed data.");
        break;
      case SignTypedDataVersion.V3:
      case SignTypedDataVersion.V4:
        if (typeof parameters.data === "string") {
          assert.doesNotThrow(function () {
            data = JSON.parse(parameters.data);
          }, '"data" must be a valid JSON string.');
        } else {
          // for backward compatiblity we validate for both string and object type.
          data = parameters.data;
        }
        assert.ok(data.primaryType in data.types, "Primary type of \"".concat(data.primaryType, "\" has no type definition."));
        var validation = jsonschema.validate(data, TYPED_MESSAGE_SCHEMA.properties);
        assert.strictEqual(validation.errors.length, 0, "Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.");
        chainId = (_data$domain = data.domain) === null || _data$domain === void 0 ? void 0 : _data$domain.chainId;
        if (chainId) {
          assert.ok(!Number.isNaN(activeChainId), "Cannot sign messages for chainId \"".concat(chainId, "\", because Web3Auth is switching networks."));
          if (typeof chainId === "string") {
            chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
          }
          assert.strictEqual(chainId, activeChainId, "Provided chainId \"".concat(chainId, "\" must match the active chainId \"").concat(activeChainId, "\""));
        }
        break;
      default:
        assert.fail("Unknown typed data version \"".concat(parameters.version, "\""));
    }
  } catch (error) {
    throw ethErrors.rpc.invalidInput({
      message: error === null || error === void 0 ? void 0 : error.message
    });
  }
};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function signTx(_x, _x2, _x3) {
  return _signTx.apply(this, arguments);
}
function _signTx() {
  _signTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(txParams, privKey, txFormatter) {
    var finalTxParams, common, unsignedEthTx, signedTx;
    return _regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return txFormatter.formatTransaction(txParams);
          case 2:
            finalTxParams = _context11.sent;
            _context11.next = 5;
            return txFormatter.getCommonConfiguration();
          case 5:
            common = _context11.sent;
            unsignedEthTx = TransactionFactory.fromTxData(finalTxParams, {
              common: common
            });
            signedTx = unsignedEthTx.sign(Buffer.from(privKey, "hex")).serialize();
            return _context11.abrupt("return", signedTx);
          case 9:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _signTx.apply(this, arguments);
}
function getProviderHandlers(_ref) {
  var txFormatter = _ref.txFormatter,
    privKey = _ref.privKey,
    getProviderEngineProxy = _ref.getProviderEngineProxy;
  return {
    getAccounts: function () {
      var _getAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", ["0x".concat(privateToAddress(Buffer.from(privKey, "hex")).toString("hex"))]);
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function getAccounts(_x4) {
        return _getAccounts.apply(this, arguments);
      }
      return getAccounts;
    }(),
    getPrivateKey: function () {
      var _getPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", privKey);
              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      function getPrivateKey(_x5) {
        return _getPrivateKey.apply(this, arguments);
      }
      return getPrivateKey;
    }(),
    processTransaction: function () {
      var _processTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(txParams, _) {
        var providerEngineProxy, signedTx, txHash;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context3.next = 3;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 3:
                _context3.next = 5;
                return signTx(txParams, privKey, txFormatter);
              case 5:
                signedTx = _context3.sent;
                _context3.next = 8;
                return providerEngineProxy.request({
                  method: "eth_sendRawTransaction",
                  params: ["0x".concat(signedTx.toString("hex"))]
                });
              case 8:
                txHash = _context3.sent;
                return _context3.abrupt("return", txHash);
              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function processTransaction(_x6, _x7) {
        return _processTransaction.apply(this, arguments);
      }
      return processTransaction;
    }(),
    processSignTransaction: function () {
      var _processSignTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(txParams, _) {
        var providerEngineProxy, signedTx;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context4.next = 3;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 3:
                _context4.next = 5;
                return signTx(txParams, privKey, txFormatter);
              case 5:
                signedTx = _context4.sent;
                return _context4.abrupt("return", "0x".concat(signedTx.toString("hex")));
              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function processSignTransaction(_x8, _x9) {
        return _processSignTransaction.apply(this, arguments);
      }
      return processSignTransaction;
    }(),
    processEthSignMessage: function () {
      var _processEthSignMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(msgParams, _) {
        var rawMessageSig;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                rawMessageSig = signMessage(privKey, msgParams.data);
                return _context5.abrupt("return", rawMessageSig);
              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      function processEthSignMessage(_x10, _x11) {
        return _processEthSignMessage.apply(this, arguments);
      }
      return processEthSignMessage;
    }(),
    processPersonalMessage: function () {
      var _processPersonalMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(msgParams, _) {
        var privKeyBuffer, sig;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                privKeyBuffer = Buffer.from(privKey, "hex");
                sig = personalSign({
                  privateKey: privKeyBuffer,
                  data: msgParams.data
                });
                return _context6.abrupt("return", sig);
              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      function processPersonalMessage(_x12, _x13) {
        return _processPersonalMessage.apply(this, arguments);
      }
      return processPersonalMessage;
    }(),
    processTypedMessage: function () {
      var _processTypedMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, params, data, sig;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                log.debug("processTypedMessage", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context7.next = 5;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context7.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context7.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                params = _objectSpread$2(_objectSpread$2({}, msgParams), {}, {
                  version: SignTypedDataVersion.V1
                });
                validateTypedMessageParams(params, finalChainId);
                data = typeof params.data === "string" ? JSON.parse(params.data) : params.data;
                sig = signTypedData({
                  privateKey: privKeyBuffer,
                  data: data,
                  version: SignTypedDataVersion.V1
                });
                return _context7.abrupt("return", sig);
              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      function processTypedMessage(_x14, _x15) {
        return _processTypedMessage.apply(this, arguments);
      }
      return processTypedMessage;
    }(),
    processTypedMessageV3: function () {
      var _processTypedMessageV = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, data, sig;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                log.debug("processTypedMessageV3", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context8.next = 5;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context8.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context8.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                validateTypedMessageParams(msgParams, finalChainId);
                data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
                sig = signTypedData({
                  privateKey: privKeyBuffer,
                  data: data,
                  version: SignTypedDataVersion.V3
                });
                return _context8.abrupt("return", sig);
              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));
      function processTypedMessageV3(_x16, _x17) {
        return _processTypedMessageV.apply(this, arguments);
      }
      return processTypedMessageV3;
    }(),
    processTypedMessageV4: function () {
      var _processTypedMessageV2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, data, sig;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                log.debug("processTypedMessageV4", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context9.next = 5;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context9.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context9.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                validateTypedMessageParams(msgParams, finalChainId);
                data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
                sig = signTypedData({
                  privateKey: privKeyBuffer,
                  data: data,
                  version: SignTypedDataVersion.V4
                });
                return _context9.abrupt("return", sig);
              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      function processTypedMessageV4(_x18, _x19) {
        return _processTypedMessageV2.apply(this, arguments);
      }
      return processTypedMessageV4;
    }(),
    processEncryptionPublicKey: function () {
      var _processEncryptionPublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(address, _) {
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                log.info("processEncryptionPublicKey", address);
                return _context10.abrupt("return", getEncryptionPublicKey(privKey));
              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));
      function processEncryptionPublicKey(_x20, _x21) {
        return _processEncryptionPublicKey.apply(this, arguments);
      }
      return processEncryptionPublicKey;
    }(),
    processDecryptMessage: function processDecryptMessage(msgParams, _) {
      log.info("processDecryptMessage", msgParams);
      var stripped = stripHexPrefix(msgParams.data);
      var buff = Buffer.from(stripped, "hex");
      var decrypted = decrypt({
        encryptedData: JSON.parse(buff.toString("utf8")),
        privateKey: privKey
      });
      return decrypted;
    }
  };
}

function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new BigNumber$1(a, 10).lt(b, 10);
}
function bnToHex(inputBn) {
  return addHexPrefix(inputBn.toString(16));
}
function hexToBn(inputHex) {
  if (BN.isBN(inputHex)) return inputHex;
  return new BN(stripHexPrefix(inputHex), 16);
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  var numberBN = new BN(numerator);
  var denomBN = new BN(denominator);
  return targetBN.mul(numberBN).div(denomBN);
}

var LegacyGasAPIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices";
var EIP1559APIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees";
var TRANSACTION_ENVELOPE_TYPES = {
  LEGACY: "0x0",
  ACCESS_LIST: "0x1",
  FEE_MARKET: "0x2"
};
var TRANSACTION_TYPES = {
  SENT_ETHER: "sentEther",
  CONTRACT_INTERACTION: "contractInteraction",
  DEPLOY_CONTRACT: "contractDeployment",
  STANDARD_TRANSACTION: "transaction"
};
var GAS_ESTIMATE_TYPES = {
  FEE_MARKET: "fee-market",
  LEGACY: "legacy",
  ETH_GASPRICE: "eth_gasPrice",
  NONE: "none"
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var TransactionFormatter = /*#__PURE__*/function () {
  function TransactionFormatter(_ref) {
    var getProviderEngineProxy = _ref.getProviderEngineProxy;
    _classCallCheck(this, TransactionFormatter);
    _defineProperty(this, "chainConfig", null);
    _defineProperty(this, "getProviderEngineProxy", void 0);
    _defineProperty(this, "isEIP1559Compatible", false);
    this.getProviderEngineProxy = getProviderEngineProxy;
  }
  _createClass(TransactionFormatter, [{
    key: "providerProxy",
    get: function get() {
      return this.getProviderEngineProxy();
    }
  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.providerProxy.request({
                  method: "eth_provider_config",
                  params: []
                });
              case 2:
                this.chainConfig = _context.sent;
                _context.next = 5;
                return this.getEIP1559Compatibility();
              case 5:
                this.isEIP1559Compatible = _context.sent;
              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "getCommonConfiguration",
    value: function () {
      var _getCommonConfiguration = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this$chainConfig, name, chainId, hardfork, customChainParams;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.chainConfig) {
                  _context2.next = 2;
                  break;
                }
                throw new Error("Chain config not initialized");
              case 2:
                _this$chainConfig = this.chainConfig, name = _this$chainConfig.displayName, chainId = _this$chainConfig.chainId;
                hardfork = this.isEIP1559Compatible ? Hardfork.London : Hardfork.Berlin;
                customChainParams = {
                  name: name,
                  chainId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
                  networkId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
                  defaultHardfork: hardfork
                };
                return _context2.abrupt("return", Common.custom(customChainParams));
              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function getCommonConfiguration() {
        return _getCommonConfiguration.apply(this, arguments);
      }
      return getCommonConfiguration;
    }()
  }, {
    key: "formatTransaction",
    value: function () {
      var _formatTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(txParams) {
        var clonedTxParams, defaultGasLimit, _defaultGasLimit, _yield$this$getDefaul, defaultGasPrice, defaultMaxFeePerGas, defaultMaxPriorityFeePerGas;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.chainConfig) {
                  _context3.next = 2;
                  break;
                }
                throw new Error("Chain config not initialized");
              case 2:
                clonedTxParams = _objectSpread$1({}, txParams);
                if (!(clonedTxParams.nonce === undefined)) {
                  _context3.next = 7;
                  break;
                }
                _context3.next = 6;
                return this.providerProxy.request({
                  method: "eth_getTransactionCount",
                  params: [txParams.from, "latest"]
                });
              case 6:
                clonedTxParams.nonce = _context3.sent;
              case 7:
                if (!(!this.isEIP1559Compatible && clonedTxParams.gasPrice)) {
                  _context3.next = 19;
                  break;
                }
                if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;
                if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas;
                // if gas is not provided explicitly, estimate it.
                if (clonedTxParams.gas) {
                  _context3.next = 17;
                  break;
                }
                _context3.next = 13;
                return this.getDefaultGasLimit(clonedTxParams);
              case 13:
                defaultGasLimit = _context3.sent;
                if (defaultGasLimit) {
                  clonedTxParams.gasLimit = defaultGasLimit;
                }
                _context3.next = 18;
                break;
              case 17:
                clonedTxParams.gasLimit = clonedTxParams.gas;
              case 18:
                return _context3.abrupt("return", clonedTxParams);
              case 19:
                if (clonedTxParams.gas) {
                  _context3.next = 26;
                  break;
                }
                _context3.next = 22;
                return this.getDefaultGasLimit(clonedTxParams);
              case 22:
                _defaultGasLimit = _context3.sent;
                if (_defaultGasLimit) {
                  clonedTxParams.gasLimit = _defaultGasLimit;
                }
                _context3.next = 27;
                break;
              case 26:
                clonedTxParams.gasLimit = clonedTxParams.gas;
              case 27:
                _context3.next = 29;
                return this.getDefaultGasFees(clonedTxParams);
              case 29:
                _yield$this$getDefaul = _context3.sent;
                defaultGasPrice = _yield$this$getDefaul.gasPrice;
                defaultMaxFeePerGas = _yield$this$getDefaul.maxFeePerGas;
                defaultMaxPriorityFeePerGas = _yield$this$getDefaul.maxPriorityFeePerGas;
                if (this.isEIP1559Compatible) {
                  // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
                  //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
                  if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                    clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;
                    clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === "string" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;
                  } else {
                    if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {
                      // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
                      // with the one returned by the gasFeeController, if that is available.
                      clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;
                    }
                    if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                      // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
                      // with the one returned by the gasFeeController, if that is available.
                      clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
                    }
                    if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {
                      // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
                      // then we set maxFeePerGas to the defaultGasPrice, assuming it is
                      // available.
                      clonedTxParams.maxFeePerGas = defaultGasPrice;
                    }
                    if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                      // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
                      // available  then we set maxPriorityFeePerGas to
                      // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
                      // set by the dapp, or the maxFeePerGas from the controller.
                      clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;
                    }
                  }
                  // We remove the gasPrice param entirely when on an eip1559 compatible network
                  delete clonedTxParams.gasPrice;
                } else {
                  // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
                  // when not on a EIP1559 compatible network
                  delete clonedTxParams.maxPriorityFeePerGas;
                  delete clonedTxParams.maxFeePerGas;
                }
                // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
                // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
                // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
                // were available from either the dapp or the network.
                if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {
                  clonedTxParams.gasPrice = defaultGasPrice;
                }
                clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;
                clonedTxParams.chainId = this.chainConfig.chainId;
                return _context3.abrupt("return", clonedTxParams);
              case 38:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function formatTransaction(_x) {
        return _formatTransaction.apply(this, arguments);
      }
      return formatTransaction;
    }()
  }, {
    key: "fetchEthGasPriceEstimate",
    value: function () {
      var _fetchEthGasPriceEstimate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var gasPrice;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.providerProxy.request({
                  method: "eth_gasPrice",
                  params: []
                });
              case 2:
                gasPrice = _context4.sent;
                return _context4.abrupt("return", {
                  gasPrice: hexWEIToDecGWEI(gasPrice).toString()
                });
              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
      function fetchEthGasPriceEstimate() {
        return _fetchEthGasPriceEstimate.apply(this, arguments);
      }
      return fetchEthGasPriceEstimate;
    }()
  }, {
    key: "getEIP1559Compatibility",
    value: function () {
      var _getEIP1559Compatibility = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var latestBlock, supportsEIP1559;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.providerProxy.request({
                  method: "eth_getBlockByNumber",
                  params: ["latest", false]
                });
              case 2:
                latestBlock = _context5.sent;
                supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
                return _context5.abrupt("return", !!supportsEIP1559);
              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function getEIP1559Compatibility() {
        return _getEIP1559Compatibility.apply(this, arguments);
      }
      return getEIP1559Compatibility;
    }()
  }, {
    key: "fetchGasFeeEstimateData",
    value: function () {
      var _fetchGasFeeEstimateData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var isLegacyGasAPICompatible, chainId, gasData, estimates, _estimates, _estimates2;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this.chainConfig) {
                  _context6.next = 2;
                  break;
                }
                throw new Error("Chain config not initialized");
              case 2:
                isLegacyGasAPICompatible = this.chainConfig.chainId === "0x1";
                chainId = Number.parseInt(this.chainConfig.chainId, 16);
                _context6.prev = 4;
                if (!this.isEIP1559Compatible) {
                  _context6.next = 12;
                  break;
                }
                _context6.next = 8;
                return fetchEip1159GasEstimates(EIP1559APIEndpoint.replace("<chain_id>", "".concat(chainId)));
              case 8:
                estimates = _context6.sent;
                gasData = {
                  gasFeeEstimates: estimates,
                  gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
                };
                _context6.next = 20;
                break;
              case 12:
                if (!isLegacyGasAPICompatible) {
                  _context6.next = 19;
                  break;
                }
                _context6.next = 15;
                return fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace("<chain_id>", "".concat(chainId)));
              case 15:
                _estimates = _context6.sent;
                gasData = {
                  gasFeeEstimates: _estimates,
                  gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
                };
                _context6.next = 20;
                break;
              case 19:
                throw new Error("Main gas fee/price estimation failed. Use fallback");
              case 20:
                _context6.next = 34;
                break;
              case 22:
                _context6.prev = 22;
                _context6.t0 = _context6["catch"](4);
                _context6.prev = 24;
                _context6.next = 27;
                return this.fetchEthGasPriceEstimate();
              case 27:
                _estimates2 = _context6.sent;
                gasData = {
                  gasFeeEstimates: _estimates2,
                  gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
                };
                _context6.next = 34;
                break;
              case 31:
                _context6.prev = 31;
                _context6.t1 = _context6["catch"](24);
                throw new Error("Gas fee/price estimation failed. Message: ".concat(_context6.t1.message));
              case 34:
                return _context6.abrupt("return", gasData);
              case 35:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[4, 22], [24, 31]]);
      }));
      function fetchGasFeeEstimateData() {
        return _fetchGasFeeEstimateData.apply(this, arguments);
      }
      return fetchGasFeeEstimateData;
    }()
  }, {
    key: "getDefaultGasFees",
    value: function () {
      var _getDefaultGasFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(txParams) {
        var _yield$this$fetchGasF, gasFeeEstimates, gasEstimateType, _gasFeeEstimates$medi, suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas, _yield$this$fetchEthG, gasPrice;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas)) {
                  _context7.next = 2;
                  break;
                }
                return _context7.abrupt("return", {});
              case 2:
                _context7.prev = 2;
                _context7.next = 5;
                return this.fetchGasFeeEstimateData();
              case 5:
                _yield$this$fetchGasF = _context7.sent;
                gasFeeEstimates = _yield$this$fetchGasF.gasFeeEstimates;
                gasEstimateType = _yield$this$fetchGasF.gasEstimateType;
                if (!(this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET)) {
                  _context7.next = 16;
                  break;
                }
                _gasFeeEstimates$medi = gasFeeEstimates.medium;
                _gasFeeEstimates$medi = _gasFeeEstimates$medi === void 0 ? {} : _gasFeeEstimates$medi;
                suggestedMaxPriorityFeePerGas = _gasFeeEstimates$medi.suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas = _gasFeeEstimates$medi.suggestedMaxFeePerGas;
                if (!(suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas)) {
                  _context7.next = 14;
                  break;
                }
                return _context7.abrupt("return", {
                  maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),
                  maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))
                });
              case 14:
                _context7.next = 22;
                break;
              case 16:
                if (!(gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY)) {
                  _context7.next = 20;
                  break;
                }
                return _context7.abrupt("return", {
                  gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.medium))
                });
              case 20:
                if (!(gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE)) {
                  _context7.next = 22;
                  break;
                }
                return _context7.abrupt("return", {
                  gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.gasPrice))
                });
              case 22:
                _context7.next = 27;
                break;
              case 24:
                _context7.prev = 24;
                _context7.t0 = _context7["catch"](2);
                log.error(_context7.t0);
              case 27:
                _context7.next = 29;
                return this.fetchEthGasPriceEstimate();
              case 29:
                _yield$this$fetchEthG = _context7.sent;
                gasPrice = _yield$this$fetchEthG.gasPrice;
                return _context7.abrupt("return", {
                  gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice))
                });
              case 32:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[2, 24]]);
      }));
      function getDefaultGasFees(_x2) {
        return _getDefaultGasFees.apply(this, arguments);
      }
      return getDefaultGasFees;
    }()
  }, {
    key: "estimateTxGas",
    value: function () {
      var _estimateTxGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(txMeta) {
        var txParams, gas;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                txParams = _objectSpread$1({}, txMeta); // `eth_estimateGas` can fail if the user has insufficient balance for the
                // value being sent, or for the gas cost. We don't want to check their
                // balance here, we just want the gas estimate. The gas price is removed
                // to skip those balance checks. We check balance elsewhere. We also delete
                // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.
                delete txParams.gasPrice;
                delete txParams.maxFeePerGas;
                delete txParams.maxPriorityFeePerGas;
                _context8.next = 6;
                return this.providerProxy.request({
                  method: "eth_estimateGas",
                  params: [txParams]
                });
              case 6:
                gas = _context8.sent;
                return _context8.abrupt("return", gas);
              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function estimateTxGas(_x3) {
        return _estimateTxGas.apply(this, arguments);
      }
      return estimateTxGas;
    }()
  }, {
    key: "analyzeGasUsage",
    value: function () {
      var _analyzeGasUsage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(txMeta) {
        var block, blockGasLimitBN, saferGasLimitBN, estimatedGasHex;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.providerProxy.request({
                  method: "eth_getBlockByNumber",
                  params: ["latest", false]
                });
              case 2:
                block = _context9.sent;
                // fallback to block gasLimit
                blockGasLimitBN = hexToBn(block.gasLimit);
                saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
                estimatedGasHex = bnToHex(saferGasLimitBN);
                _context9.prev = 6;
                _context9.next = 9;
                return this.estimateTxGas(txMeta);
              case 9:
                estimatedGasHex = _context9.sent;
                _context9.next = 15;
                break;
              case 12:
                _context9.prev = 12;
                _context9.t0 = _context9["catch"](6);
                log.warn(_context9.t0);
              case 15:
                return _context9.abrupt("return", {
                  blockGasLimit: block.gasLimit,
                  estimatedGasHex: estimatedGasHex
                });
              case 16:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[6, 12]]);
      }));
      function analyzeGasUsage(_x4) {
        return _analyzeGasUsage.apply(this, arguments);
      }
      return analyzeGasUsage;
    }()
  }, {
    key: "addGasBuffer",
    value: function addGasBuffer(initialGasLimitHex, blockGasLimitHex) {
      var multiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.5;
      var initialGasLimitBn = hexToBn(initialGasLimitHex);
      var blockGasLimitBn = hexToBn(blockGasLimitHex);
      var upperGasLimitBn = blockGasLimitBn.muln(0.9);
      var bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);
      // if initialGasLimit is above blockGasLimit, dont modify it
      if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn);
      // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
      if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn);
      // otherwise use blockGasLimit
      return bnToHex(upperGasLimitBn);
    }
  }, {
    key: "determineTransactionCategory",
    value: function () {
      var _determineTransactionCategory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(txParameters) {
        var data, to, code, txCategory, codeIsEmpty;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                data = txParameters.data, to = txParameters.to;
                code = "";
                if (!(data && !to)) {
                  _context10.next = 6;
                  break;
                }
                txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;
                _context10.next = 17;
                break;
              case 6:
                _context10.prev = 6;
                _context10.next = 9;
                return this.providerProxy.request({
                  method: "eth_getCode",
                  params: [to, "latest"]
                });
              case 9:
                code = _context10.sent;
                _context10.next = 15;
                break;
              case 12:
                _context10.prev = 12;
                _context10.t0 = _context10["catch"](6);
                log.warn(_context10.t0);
              case 15:
                codeIsEmpty = !code || code === "0x" || code === "0x0";
                txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;
              case 17:
                return _context10.abrupt("return", {
                  transactionCategory: txCategory,
                  code: code
                });
              case 18:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[6, 12]]);
      }));
      function determineTransactionCategory(_x5) {
        return _determineTransactionCategory.apply(this, arguments);
      }
      return determineTransactionCategory;
    }()
  }, {
    key: "getDefaultGasLimit",
    value: function () {
      var _getDefaultGasLimit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(txParams) {
        var _yield$this$determine, transactionCategory, TWENTY_ONE_THOUSAND, _yield$this$analyzeGa, blockGasLimit, estimatedGasHex, gasLimit;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.determineTransactionCategory(_objectSpread$1({}, txParams));
              case 2:
                _yield$this$determine = _context11.sent;
                transactionCategory = _yield$this$determine.transactionCategory;
                if (!txParams.gas) {
                  _context11.next = 6;
                  break;
                }
                return _context11.abrupt("return", txParams.gas);
              case 6:
                if (!(txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER)) {
                  _context11.next = 11;
                  break;
                }
                if (!txParams.data) {
                  _context11.next = 9;
                  break;
                }
                throw Error("TxGasUtil - Trying to call a function on a non-contract address");
              case 9:
                TWENTY_ONE_THOUSAND = 21000; // This is a standard ether simple send, gas requirement is exactly 21k
                return _context11.abrupt("return", addHexPrefix(TWENTY_ONE_THOUSAND.toString(16)));
              case 11:
                _context11.next = 13;
                return this.analyzeGasUsage(txParams);
              case 13:
                _yield$this$analyzeGa = _context11.sent;
                blockGasLimit = _yield$this$analyzeGa.blockGasLimit;
                estimatedGasHex = _yield$this$analyzeGa.estimatedGasHex;
                // add additional gas buffer to our estimation for safety
                gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit);
                return _context11.abrupt("return", gasLimit);
              case 18:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));
      function getDefaultGasLimit(_x6) {
        return _getDefaultGasLimit.apply(this, arguments);
      }
      return getDefaultGasLimit;
    }()
  }]);
  return TransactionFormatter;
}();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var EthereumPrivateKeyProvider = /*#__PURE__*/function (_BaseProvider) {
  _inherits(EthereumPrivateKeyProvider, _BaseProvider);
  var _super = _createSuper(EthereumPrivateKeyProvider);
  function EthereumPrivateKeyProvider(_ref) {
    var config = _ref.config,
      state = _ref.state;
    _classCallCheck(this, EthereumPrivateKeyProvider);
    return _super.call(this, {
      config: {
        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {
          chainNamespace: CHAIN_NAMESPACES.EIP155
        })
      },
      state: state
    });
  }
  _createClass(EthereumPrivateKeyProvider, [{
    key: "enable",
    value: function () {
      var _enable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.state.privateKey) {
                  _context.next = 2;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Private key is not found in state, plz pass it in constructor state param",
                  code: 4902
                });
              case 2:
                _context.next = 4;
                return this.setupProvider(this.state.privateKey);
              case 4:
                return _context.abrupt("return", this._providerEngineProxy.request({
                  method: "eth_accounts"
                }));
              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function enable() {
        return _enable.apply(this, arguments);
      }
      return enable;
    }()
  }, {
    key: "setupProvider",
    value: function () {
      var _setupProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(privKey) {
        var txFormatter, providerHandlers, ethMiddleware, chainSwitchMiddleware, engine, _createJsonRpcClient, networkMiddleware, provider;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                txFormatter = new TransactionFormatter({
                  getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
                });
                providerHandlers = getProviderHandlers({
                  txFormatter: txFormatter,
                  privKey: privKey,
                  getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
                });
                ethMiddleware = createEthMiddleware(providerHandlers);
                chainSwitchMiddleware = this.getChainSwitchMiddleware();
                engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor
                _createJsonRpcClient = createJsonRpcClient(this.config.chainConfig), networkMiddleware = _createJsonRpcClient.networkMiddleware;
                engine.push(ethMiddleware);
                engine.push(chainSwitchMiddleware);
                engine.push(this.getAccountMiddleware());
                engine.push(networkMiddleware);
                provider = providerFromEngine(engine);
                this.updateProviderEngineProxy(provider);
                _context2.next = 14;
                return txFormatter.init();
              case 14:
                _context2.next = 16;
                return this.lookupNetwork();
              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function setupProvider(_x) {
        return _setupProvider.apply(this, arguments);
      }
      return setupProvider;
    }()
  }, {
    key: "updateAccount",
    value: function () {
      var _updateAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {
        var existingKey;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this._providerEngineProxy) {
                  _context3.next = 2;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 2:
                _context3.next = 4;
                return this._providerEngineProxy.request({
                  method: "eth_private_key"
                });
              case 4:
                existingKey = _context3.sent;
                if (!(existingKey !== params.privateKey)) {
                  _context3.next = 14;
                  break;
                }
                _context3.next = 8;
                return this.setupProvider(params.privateKey);
              case 8:
                _context3.t0 = this._providerEngineProxy;
                _context3.next = 11;
                return this._providerEngineProxy.request({
                  method: "eth_accounts"
                });
              case 11:
                _context3.t1 = _context3.sent;
                _context3.t2 = {
                  accounts: _context3.t1
                };
                _context3.t0.emit.call(_context3.t0, "accountsChanged", _context3.t2);
              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function updateAccount(_x2) {
        return _updateAccount.apply(this, arguments);
      }
      return updateAccount;
    }()
  }, {
    key: "switchChain",
    value: function () {
      var _switchChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(params) {
        var chainConfig, privKey;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this._providerEngineProxy) {
                  _context4.next = 2;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 2:
                chainConfig = this.getChainConfig(params.chainId);
                this.update({
                  chainId: "loading"
                });
                this.configure({
                  chainConfig: chainConfig
                });
                _context4.next = 7;
                return this._providerEngineProxy.request({
                  method: "eth_private_key"
                });
              case 7:
                privKey = _context4.sent;
                _context4.next = 10;
                return this.setupProvider(privKey);
              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
      function switchChain(_x3) {
        return _switchChain.apply(this, arguments);
      }
      return switchChain;
    }()
  }, {
    key: "lookupNetwork",
    value: function () {
      var _lookupNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var chainId, network;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this._providerEngineProxy) {
                  _context5.next = 2;
                  break;
                }
                throw ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 2:
                chainId = this.config.chainConfig.chainId;
                if (chainId) {
                  _context5.next = 5;
                  break;
                }
                throw ethErrors.rpc.invalidParams("chainId is required while lookupNetwork");
              case 5:
                _context5.next = 7;
                return this._providerEngineProxy.request({
                  method: "net_version",
                  params: []
                });
              case 7:
                network = _context5.sent;
                if (!(parseInt(chainId, 16) !== parseInt(network, 10))) {
                  _context5.next = 10;
                  break;
                }
                throw ethErrors.provider.chainDisconnected("Invalid network, net_version is: ".concat(network));
              case 10:
                if (this.state.chainId !== chainId) {
                  this._providerEngineProxy.emit("chainChanged", chainId);
                  this._providerEngineProxy.emit("connect", {
                    chainId: chainId
                  });
                }
                this.update({
                  chainId: chainId
                });
                return _context5.abrupt("return", network);
              case 13:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function lookupNetwork() {
        return _lookupNetwork.apply(this, arguments);
      }
      return lookupNetwork;
    }()
  }, {
    key: "getChainSwitchMiddleware",
    value: function getChainSwitchMiddleware() {
      var _this = this;
      var chainSwitchHandlers = {
        addChain: function () {
          var _addChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(params) {
            var chainId, chainName, rpcUrls, blockExplorerUrls, nativeCurrency;
            return _regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    chainId = params.chainId, chainName = params.chainName, rpcUrls = params.rpcUrls, blockExplorerUrls = params.blockExplorerUrls, nativeCurrency = params.nativeCurrency;
                    _this.addChain({
                      chainNamespace: "eip155",
                      chainId: chainId,
                      ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "ETH",
                      tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Ether",
                      displayName: chainName,
                      rpcTarget: rpcUrls[0],
                      blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || ""
                    });
                  case 2:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));
          function addChain(_x4) {
            return _addChain.apply(this, arguments);
          }
          return addChain;
        }(),
        switchChain: function () {
          var _switchChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(params) {
            var chainId;
            return _regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    chainId = params.chainId;
                    _context7.next = 3;
                    return _this.switchChain({
                      chainId: chainId
                    });
                  case 3:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));
          function switchChain(_x5) {
            return _switchChain2.apply(this, arguments);
          }
          return switchChain;
        }()
      };
      var chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
      return chainSwitchMiddleware;
    }
  }, {
    key: "getAccountMiddleware",
    value: function getAccountMiddleware() {
      var _this2 = this;
      var accountHandlers = {
        updatePrivatekey: function () {
          var _updatePrivatekey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(params) {
            var privateKey;
            return _regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    privateKey = params.privateKey;
                    _context8.next = 3;
                    return _this2.updateAccount({
                      privateKey: privateKey
                    });
                  case 3:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          }));
          function updatePrivatekey(_x6) {
            return _updatePrivatekey.apply(this, arguments);
          }
          return updatePrivatekey;
        }()
      };
      return createAccountMiddleware(accountHandlers);
    }
  }]);
  return EthereumPrivateKeyProvider;
}(BaseProvider);
_defineProperty(EthereumPrivateKeyProvider, "getProviderInstance", /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params) {
    var providerFactory;
    return _regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            providerFactory = new EthereumPrivateKeyProvider({
              config: {
                chainConfig: params.chainConfig
              }
            });
            _context9.next = 3;
            return providerFactory.setupProvider(params.privKey);
          case 3:
            return _context9.abrupt("return", providerFactory);
          case 4:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return function (_x7) {
    return _ref2.apply(this, arguments);
  };
}());

export { EthereumPrivateKeyProvider, TransactionFormatter, WalletConnectProvider, getProviderHandlers };
//# sourceMappingURL=ethereumProvider.esm.js.map
