import _typeof from '@babel/runtime/helpers/typeof';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { Duplex } from 'readable-stream';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { randomId } from '@toruslabs/openlogin-utils';
import { EventEmitter } from 'events';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';
import stringify from 'fast-safe-stringify';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { serializeError } from 'eth-rpc-errors';
import eos from 'end-of-stream';
import once from 'once';
import pump from 'pump';

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function noop() {
  return undefined;
}
var SYN = "SYN";
var ACK = "ACK";
var BRK = "BRK";
var BasePostMessageStream = /*#__PURE__*/function (_Duplex) {
  _inherits(BasePostMessageStream, _Duplex);
  var _super = _createSuper$6(BasePostMessageStream);
  function BasePostMessageStream(_ref) {
    var _this;
    var name = _ref.name,
      target = _ref.target,
      _ref$targetWindow = _ref.targetWindow,
      targetWindow = _ref$targetWindow === void 0 ? window : _ref$targetWindow,
      _ref$targetOrigin = _ref.targetOrigin,
      targetOrigin = _ref$targetOrigin === void 0 ? "*" : _ref$targetOrigin;
    _classCallCheck(this, BasePostMessageStream);
    _this = _super.call(this, {
      objectMode: true
    });
    _defineProperty(_assertThisInitialized(_this), "_init", void 0);
    _defineProperty(_assertThisInitialized(_this), "_haveSyn", void 0);
    _defineProperty(_assertThisInitialized(_this), "_name", void 0);
    _defineProperty(_assertThisInitialized(_this), "_target", void 0);
    _defineProperty(_assertThisInitialized(_this), "_targetWindow", void 0);
    _defineProperty(_assertThisInitialized(_this), "_targetOrigin", void 0);
    _defineProperty(_assertThisInitialized(_this), "_onMessage", void 0);
    _defineProperty(_assertThisInitialized(_this), "_synIntervalId", void 0);
    if (!name || !target) {
      throw new Error("Invalid input.");
    }
    _this._init = false;
    _this._haveSyn = false;
    _this._name = name;
    _this._target = target; // target origin
    _this._targetWindow = targetWindow;
    _this._targetOrigin = targetOrigin;
    _this._onMessage = _this.onMessage.bind(_assertThisInitialized(_this));
    _this._synIntervalId = null;
    window.addEventListener("message", _this._onMessage, false);
    _this._handShake();
    return _this;
  }
  _createClass(BasePostMessageStream, [{
    key: "_break",
    value: function _break() {
      this.cork();
      this._write(BRK, null, noop);
      this._haveSyn = false;
      this._init = false;
    }
  }, {
    key: "_handShake",
    value: function _handShake() {
      this._write(SYN, null, noop);
      this.cork();
    }
  }, {
    key: "_onData",
    value: function _onData(data) {
      if (!this._init) {
        // listen for handshake
        if (data === SYN) {
          this._haveSyn = true;
          this._write(ACK, null, noop);
        } else if (data === ACK) {
          this._init = true;
          if (!this._haveSyn) {
            this._write(ACK, null, noop);
          }
          this.uncork();
        }
      } else if (data === BRK) {
        this._break();
      } else {
        // forward message
        try {
          this.push(data);
        } catch (err) {
          this.emit("error", err);
        }
      }
    }
  }, {
    key: "_postMessage",
    value: function _postMessage(data) {
      var originConstraint = this._targetOrigin;
      this._targetWindow.postMessage({
        target: this._target,
        data: data
      }, originConstraint);
    }
  }, {
    key: "onMessage",
    value: function onMessage(event) {
      var message = event.data;
      // validate message
      if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || _typeof(message) !== "object" || message.target !== this._name || !message.data) {
        return;
      }
      this._onData(message.data);
    }
  }, {
    key: "_read",
    value: function _read() {
      return undefined;
    }
  }, {
    key: "_write",
    value: function _write(data, _, cb) {
      this._postMessage(data);
      cb();
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      window.removeEventListener("message", this._onMessage, false);
    }
  }]);
  return BasePostMessageStream;
}(Duplex);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    // Throw error after timeout so as not to interrupt the stack
    setTimeout(function () {
      throw err;
    });
  }
}
function arrayClone(arr) {
  var n = arr.length;
  var copy = new Array(n);
  for (var i = 0; i < n; i += 1) {
    copy[i] = arr[i];
  }
  return copy;
}
var SafeEventEmitter = /*#__PURE__*/function (_EventEmitter) {
  _inherits(SafeEventEmitter, _EventEmitter);
  var _super = _createSuper$5(SafeEventEmitter);
  function SafeEventEmitter() {
    _classCallCheck(this, SafeEventEmitter);
    return _super.apply(this, arguments);
  }
  _createClass(SafeEventEmitter, [{
    key: "emit",
    value: function emit(type) {
      var doError = type === "error";
      var events = this._events;
      if (events !== undefined) {
        doError = doError && events.error === undefined;
      } else if (!doError) {
        return false;
      }
      // If there is no 'error' event listener then throw.
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (doError) {
        var er;
        if (args.length > 0) {
          er = args[0];
        }
        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error("Unhandled error.".concat(er ? " (".concat(er.message, ")") : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
      }

      var handler = events[type];
      if (handler === undefined) {
        return false;
      }
      if (typeof handler === "function") {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler);
        for (var i = 0; i < len; i += 1) {
          safeApply(listeners[i], this, args);
        }
      }
      return true;
    }
  }]);
  return SafeEventEmitter;
}(EventEmitter);

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var SerializableError = /*#__PURE__*/function (_Error) {
  _inherits(SerializableError, _Error);
  var _super = _createSuper$4(SerializableError);
  function SerializableError(_ref) {
    var _this;
    var code = _ref.code,
      message = _ref.message,
      data = _ref.data;
    _classCallCheck(this, SerializableError);
    if (!Number.isInteger(code)) {
      throw new Error("code must be an integer");
    }
    if (!message || typeof message !== "string") {
      throw new Error("message must be string");
    }
    _this = _super.call(this, message);
    _defineProperty(_assertThisInitialized(_this), "code", void 0);
    _defineProperty(_assertThisInitialized(_this), "data", void 0);
    _this.code = code;
    if (data !== undefined) {
      _this.data = data;
    }
    return _this;
  }
  _createClass(SerializableError, [{
    key: "toString",
    value: function toString() {
      return stringify({
        code: this.code,
        message: this.message,
        data: this.data,
        stack: this.stack
      });
    }
  }]);
  return SerializableError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {
  var unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return function (error, response) {
    if (error || response.error) {
      reject(error || response.error);
    } else if (!unwrapResult || Array.isArray(response)) {
      resolve(response);
    } else {
      resolve(response.result);
    }
  };
};
function createErrorMiddleware(log) {
  return function (req, res, next, end) {
    try {
      // json-rpc-engine will terminate the request when it notices this error
      if (typeof req.method !== "string" || !req.method) {
        res.error = new SerializableError({
          code: -32603,
          message: "invalid method"
        });
        end();
        return;
      }
      next(function (done) {
        var error = res.error;
        if (!error) {
          return done();
        }
        log.error("OpenLogin - RPC Error: ".concat(error.message), error);
        return done();
      });
    } catch (error) {
      log.error("OpenLogin - RPC Error thrown: ".concat(error.message), error);
      res.error = new SerializableError({
        code: -32603,
        message: error.message
      });
      end();
    }
  };
}
function createStreamMiddleware() {
  var idMap = {};
  function readNoop() {
    return false;
  }
  var events = new SafeEventEmitter();
  function processResponse(res) {
    var context = idMap[res.id];
    if (!context) {
      throw new Error("StreamMiddleware - Unknown response id \"".concat(res.id, "\""));
    }
    delete idMap[res.id];
    // copy whole res onto original res
    Object.assign(context.res, res);
    // run callback on empty stack,
    // prevent internal stream-handler from catching errors
    setTimeout(context.end);
  }
  function processNotification(res) {
    events.emit("notification", res);
  }
  function processMessage(res, _encoding, cb) {
    var err;
    try {
      var isNotification = !res.id;
      if (isNotification) {
        processNotification(res);
      } else {
        processResponse(res);
      }
    } catch (_err) {
      err = _err;
    }
    // continue processing stream
    cb(err);
  }
  var stream = new Duplex({
    objectMode: true,
    read: readNoop,
    write: processMessage
  });
  var middleware = function middleware(req, res, next, end) {
    // write req to stream
    stream.push(req);
    // register request on id map
    idMap[req.id] = {
      req: req,
      res: res,
      next: next,
      end: end
    };
  };
  return {
    events: events,
    middleware: middleware,
    stream: stream
  };
}
function createScaffoldMiddleware(handlers) {
  return function (req, res, next, end) {
    var handler = handlers[req.method];
    // if no handler, return
    if (handler === undefined) {
      return next();
    }
    // if handler is fn, call as middleware
    if (typeof handler === "function") {
      return handler(req, res, next, end);
    }
    // if handler is some other value, use as result
    res.result = handler;
    return end();
  };
}
function createIdRemapMiddleware() {
  return function (req, res, next, _end) {
    var originalId = req.id;
    var newId = randomId();
    req.id = newId;
    res.id = newId;
    next(function (done) {
      req.id = originalId;
      res.id = originalId;
      done();
    });
  };
}
function createLoggerMiddleware(logger) {
  return function (req, res, next, _) {
    logger.debug("REQ", req, "RES", res);
    next();
  };
}
function createAsyncMiddleware(asyncMiddleware) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {
      var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // nextPromise is the key to the implementation
              // it is resolved by the return handler passed to the
              // "next" function
              nextPromise = new Promise(function (resolve) {
                resolveNextPromise = resolve;
              });
              returnHandlerCallback = null;
              nextWasCalled = false; // This will be called by the consumer's async middleware.
              asyncNext = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
                  return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          nextWasCalled = true;
                          // We pass a return handler to next(). When it is called by the engine,
                          // the consumer's async middleware will resume executing.
                          next(function (runReturnHandlersCallback) {
                            // This callback comes from JRPCEngine._runReturnHandlers
                            returnHandlerCallback = runReturnHandlersCallback;
                            resolveNextPromise();
                          });
                          _context.next = 4;
                          return nextPromise;
                        case 4:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));
                return function asyncNext() {
                  return _ref2.apply(this, arguments);
                };
              }();
              _context2.prev = 4;
              _context2.next = 7;
              return asyncMiddleware(req, res, asyncNext);
            case 7:
              if (!nextWasCalled) {
                _context2.next = 13;
                break;
              }
              _context2.next = 10;
              return nextPromise;
            case 10:
              // we must wait until the return handler is called
              returnHandlerCallback(null);
              _context2.next = 14;
              break;
            case 13:
              end(null);
            case 14:
              _context2.next = 19;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](4);
              if (returnHandlerCallback) {
                returnHandlerCallback(_context2.t0);
              } else {
                end(_context2.t0);
              }
            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[4, 16]]);
    }));
    return function (_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();
}

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A JSON-RPC request and response processor.
 * Give it a stack of middleware, pass it requests, and get back responses.
 */
var JRPCEngine = /*#__PURE__*/function (_SafeEventEmitter) {
  _inherits(JRPCEngine, _SafeEventEmitter);
  var _super = _createSuper$3(JRPCEngine);
  function JRPCEngine() {
    var _this;
    _classCallCheck(this, JRPCEngine);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "_middleware", void 0);
    _this._middleware = [];
    return _this;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  _createClass(JRPCEngine, [{
    key: "push",
    value:
    /**
     * Add a middleware function to the engine's middleware stack.
     *
     * @param middleware - The middleware function to add.
     */
    function push(middleware) {
      this._middleware.push(middleware);
    }
  }, {
    key: "handle",
    value: function handle(req, cb) {
      if (cb && typeof cb !== "function") {
        throw new Error('"callback" must be a function if provided.');
      }
      if (Array.isArray(req)) {
        if (cb) {
          return this._handleBatch(req, cb);
        }
        return this._handleBatch(req);
      }
      if (cb) {
        return this._handle(req, cb);
      }
      return this._promiseHandle(req);
    }
    /**
     * Returns this engine as a middleware function that can be pushed to other
     * engines.
     *
     * @returns This engine as a middleware function.
     */
  }, {
    key: "asMiddleware",
    value: function asMiddleware() {
      var _this2 = this;
      return /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {
          var _yield$JRPCEngine$_ru, _yield$JRPCEngine$_ru2, middlewareError, isComplete, returnHandlers;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  _context2.next = 3;
                  return JRPCEngine._runAllMiddleware(req, res, _this2._middleware);
                case 3:
                  _yield$JRPCEngine$_ru = _context2.sent;
                  _yield$JRPCEngine$_ru2 = _slicedToArray(_yield$JRPCEngine$_ru, 3);
                  middlewareError = _yield$JRPCEngine$_ru2[0];
                  isComplete = _yield$JRPCEngine$_ru2[1];
                  returnHandlers = _yield$JRPCEngine$_ru2[2];
                  if (!isComplete) {
                    _context2.next = 12;
                    break;
                  }
                  _context2.next = 11;
                  return JRPCEngine._runReturnHandlers(returnHandlers);
                case 11:
                  return _context2.abrupt("return", end(middlewareError));
                case 12:
                  return _context2.abrupt("return", next( /*#__PURE__*/function () {
                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(handlerCallback) {
                      return _regeneratorRuntime.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _context.prev = 0;
                              _context.next = 3;
                              return JRPCEngine._runReturnHandlers(returnHandlers);
                            case 3:
                              _context.next = 8;
                              break;
                            case 5:
                              _context.prev = 5;
                              _context.t0 = _context["catch"](0);
                              return _context.abrupt("return", handlerCallback(_context.t0));
                            case 8:
                              return _context.abrupt("return", handlerCallback());
                            case 9:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, null, [[0, 5]]);
                    }));
                    return function (_x5) {
                      return _ref2.apply(this, arguments);
                    };
                  }()));
                case 15:
                  _context2.prev = 15;
                  _context2.t0 = _context2["catch"](0);
                  return _context2.abrupt("return", end(_context2.t0));
                case 18:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 15]]);
        }));
        return function (_x, _x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        };
      }();
    }
  }, {
    key: "_handleBatch",
    value: function () {
      var _handleBatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(reqs, cb) {
        var responses;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return Promise.all(
                // 1. Begin executing each request in the order received
                reqs.map(this._promiseHandle.bind(this)));
              case 3:
                responses = _context3.sent;
                if (!cb) {
                  _context3.next = 6;
                  break;
                }
                return _context3.abrupt("return", cb(null, responses));
              case 6:
                return _context3.abrupt("return", responses);
              case 9:
                _context3.prev = 9;
                _context3.t0 = _context3["catch"](0);
                if (!cb) {
                  _context3.next = 13;
                  break;
                }
                return _context3.abrupt("return", cb(_context3.t0));
              case 13:
                throw _context3.t0;
              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 9]]);
      }));
      function _handleBatch(_x6, _x7) {
        return _handleBatch2.apply(this, arguments);
      }
      return _handleBatch;
    }()
    /**
     * A promise-wrapped _handle.
     */
  }, {
    key: "_promiseHandle",
    value: function _promiseHandle(req) {
      var _this3 = this;
      return new Promise(function (resolve) {
        _this3._handle(req, function (_err, res) {
          // There will always be a response, and it will always have any error
          // that is caught and propagated.
          resolve(res);
        });
      });
    }
    /**
     * Ensures that the request object is valid, processes it, and passes any
     * error and the response object to the given callback.
     *
     * Does not reject.
     */
  }, {
    key: "_handle",
    value: function () {
      var _handle2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(callerReq, cb) {
        var _error2, _error3, req, res, error;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(!callerReq || Array.isArray(callerReq) || _typeof(callerReq) !== "object")) {
                  _context4.next = 3;
                  break;
                }
                _error2 = new SerializableError({
                  code: -32603,
                  message: "request must be plain object"
                });
                return _context4.abrupt("return", cb(_error2, {
                  id: undefined,
                  jsonrpc: "2.0",
                  error: _error2
                }));
              case 3:
                if (!(typeof callerReq.method !== "string")) {
                  _context4.next = 6;
                  break;
                }
                _error3 = new SerializableError({
                  code: -32603,
                  message: "method must be string"
                });
                return _context4.abrupt("return", cb(_error3, {
                  id: callerReq.id,
                  jsonrpc: "2.0",
                  error: _error3
                }));
              case 6:
                req = _objectSpread$1({}, callerReq);
                res = {
                  id: req.id,
                  jsonrpc: req.jsonrpc
                };
                error = null;
                _context4.prev = 9;
                _context4.next = 12;
                return this._processRequest(req, res);
              case 12:
                _context4.next = 17;
                break;
              case 14:
                _context4.prev = 14;
                _context4.t0 = _context4["catch"](9);
                // A request handler error, a re-thrown middleware error, or something
                // unexpected.
                error = _context4.t0;
              case 17:
                if (error) {
                  // Ensure no result is present on an errored response
                  delete res.result;
                  if (!res.error) {
                    res.error = serializeError(error);
                  }
                }
                return _context4.abrupt("return", cb(error, res));
              case 19:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[9, 14]]);
      }));
      function _handle(_x8, _x9) {
        return _handle2.apply(this, arguments);
      }
      return _handle;
    }()
    /**
     * For the given request and response, runs all middleware and their return
     * handlers, if any, and ensures that internal request processing semantics
     * are satisfied.
     */
  }, {
    key: "_processRequest",
    value: function () {
      var _processRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(req, res) {
        var _yield$JRPCEngine$_ru3, _yield$JRPCEngine$_ru4, error, isComplete, returnHandlers;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return JRPCEngine._runAllMiddleware(req, res, this._middleware);
              case 2:
                _yield$JRPCEngine$_ru3 = _context5.sent;
                _yield$JRPCEngine$_ru4 = _slicedToArray(_yield$JRPCEngine$_ru3, 3);
                error = _yield$JRPCEngine$_ru4[0];
                isComplete = _yield$JRPCEngine$_ru4[1];
                returnHandlers = _yield$JRPCEngine$_ru4[2];
                // Throw if "end" was not called, or if the response has neither a result
                // nor an error.
                JRPCEngine._checkForCompletion(req, res, isComplete);
                // The return handlers should run even if an error was encountered during
                // middleware processing.
                _context5.next = 10;
                return JRPCEngine._runReturnHandlers(returnHandlers);
              case 10:
                if (!error) {
                  _context5.next = 12;
                  break;
                }
                throw error;
              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function _processRequest(_x10, _x11) {
        return _processRequest2.apply(this, arguments);
      }
      return _processRequest;
    }()
  }], [{
    key: "_runAllMiddleware",
    value: function () {
      var _runAllMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(req, res, middlewareStack) {
        var returnHandlers, error, isComplete, _iterator, _step, middleware, _yield$JRPCEngine$_ru5, _yield$JRPCEngine$_ru6;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                returnHandlers = [];
                error = null;
                isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers
                _iterator = _createForOfIteratorHelper(middlewareStack);
                _context6.prev = 4;
                _iterator.s();
              case 6:
                if ((_step = _iterator.n()).done) {
                  _context6.next = 18;
                  break;
                }
                middleware = _step.value;
                _context6.next = 10;
                return JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);
              case 10:
                _yield$JRPCEngine$_ru5 = _context6.sent;
                _yield$JRPCEngine$_ru6 = _slicedToArray(_yield$JRPCEngine$_ru5, 2);
                error = _yield$JRPCEngine$_ru6[0];
                isComplete = _yield$JRPCEngine$_ru6[1];
                if (!isComplete) {
                  _context6.next = 16;
                  break;
                }
                return _context6.abrupt("break", 18);
              case 16:
                _context6.next = 6;
                break;
              case 18:
                _context6.next = 23;
                break;
              case 20:
                _context6.prev = 20;
                _context6.t0 = _context6["catch"](4);
                _iterator.e(_context6.t0);
              case 23:
                _context6.prev = 23;
                _iterator.f();
                return _context6.finish(23);
              case 26:
                return _context6.abrupt("return", [error, isComplete, returnHandlers.reverse()]);
              case 27:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[4, 20, 23, 26]]);
      }));
      function _runAllMiddleware(_x12, _x13, _x14) {
        return _runAllMiddleware2.apply(this, arguments);
      }
      return _runAllMiddleware;
    }()
    /**
     * Runs an individual middleware.
     *
     * @returns An array of any error encountered during middleware exection,
     * and a boolean indicating whether the request should end.
     */
  }, {
    key: "_runMiddleware",
    value: function _runMiddleware(req, res, middleware, returnHandlers) {
      return new Promise(function (resolve) {
        var end = function end(err) {
          var error = err || res.error;
          if (error) {
            res.error = serializeError(error);
          }
          // True indicates that the request should end
          resolve([error, true]);
        };
        var next = function next(returnHandler) {
          if (res.error) {
            end(res.error);
          } else {
            if (returnHandler) {
              if (typeof returnHandler !== "function") {
                end(new SerializableError({
                  code: -32603,
                  message: "JRPCEngine: 'next' return handlers must be functions"
                }));
              }
              returnHandlers.push(returnHandler);
            }
            // False indicates that the request should not end
            resolve([null, false]);
          }
        };
        try {
          middleware(req, res, next, end);
        } catch (error) {
          end(error);
        }
      });
    }
    /**
     * Serially executes array of return handlers. The request and response are
     * assumed to be in their scope.
     */
  }, {
    key: "_runReturnHandlers",
    value: function () {
      var _runReturnHandlers2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(handlers) {
        var _iterator2, _step2, _loop;
        return _regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelper(handlers);
                _context8.prev = 1;
                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
                  var handler;
                  return _regeneratorRuntime.wrap(function _loop$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          handler = _step2.value;
                          _context7.next = 3;
                          return new Promise(function (resolve, reject) {
                            handler(function (err) {
                              return err ? reject(err) : resolve();
                            });
                          });
                        case 3:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _loop);
                });
                _iterator2.s();
              case 4:
                if ((_step2 = _iterator2.n()).done) {
                  _context8.next = 8;
                  break;
                }
                return _context8.delegateYield(_loop(), "t0", 6);
              case 6:
                _context8.next = 4;
                break;
              case 8:
                _context8.next = 13;
                break;
              case 10:
                _context8.prev = 10;
                _context8.t1 = _context8["catch"](1);
                _iterator2.e(_context8.t1);
              case 13:
                _context8.prev = 13;
                _iterator2.f();
                return _context8.finish(13);
              case 16:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee7, null, [[1, 10, 13, 16]]);
      }));
      function _runReturnHandlers(_x15) {
        return _runReturnHandlers2.apply(this, arguments);
      }
      return _runReturnHandlers;
    }()
    /**
     * Throws an error if the response has neither a result nor an error, or if
     * the "isComplete" flag is falsy.
     */
  }, {
    key: "_checkForCompletion",
    value: function _checkForCompletion(req, res, isComplete) {
      if (!("result" in res) && !("error" in res)) {
        throw new SerializableError({
          code: -32603,
          message: "Response has no error or result for request"
        });
      }
      if (!isComplete) {
        throw new SerializableError({
          code: -32603,
          message: "Nothing ended request"
        });
      }
    }
  }]);
  return JRPCEngine;
}(SafeEventEmitter);
function mergeMiddleware(middlewareStack) {
  var engine = new JRPCEngine();
  middlewareStack.forEach(function (middleware) {
    return engine.push(middleware);
  });
  return engine.asMiddleware();
}
function createEngineStream(opts) {
  if (!opts || !opts.engine) {
    throw new Error("Missing engine parameter!");
  }
  var engine = opts.engine;
  // eslint-disable-next-line prefer-const
  var stream;
  function read() {
    return undefined;
  }
  function write(req, _encoding, cb) {
    engine.handle(req, function (_err, res) {
      stream.push(res);
    });
    cb();
  }
  stream = new Duplex({
    objectMode: true,
    read: read,
    write: write
  });
  // forward notifications
  if (engine.on) {
    engine.on("notification", function (message) {
      stream.push(message);
    });
  }
  return stream;
}

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var Substream = /*#__PURE__*/function (_Duplex) {
  _inherits(Substream, _Duplex);
  var _super = _createSuper$2(Substream);
  function Substream(_ref) {
    var _this;
    var parent = _ref.parent,
      name = _ref.name;
    _classCallCheck(this, Substream);
    _this = _super.call(this, {
      objectMode: true
    });
    _defineProperty(_assertThisInitialized(_this), "_parent", void 0);
    _defineProperty(_assertThisInitialized(_this), "_name", void 0);
    _this._parent = parent;
    _this._name = name;
    return _this;
  }
  /**
   * Explicitly sets read operations to a no-op.
   */
  _createClass(Substream, [{
    key: "_read",
    value: function _read() {
      return undefined;
    }
    /**
     * Called when data should be written to this writable stream.
     *
     * @param chunk - Arbitrary object to write
     * @param encoding - Encoding to use when writing payload
     * @param callback - Called when writing is complete or an error occurs
     */
  }, {
    key: "_write",
    value: function _write(chunk, _encoding, callback) {
      this._parent.push({
        name: this._name,
        data: chunk
      });
      callback();
    }
  }]);
  return Substream;
}(Duplex);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var IGNORE_SUBSTREAM = Symbol("IGNORE_SUBSTREAM");
var ObjectMultiplex = /*#__PURE__*/function (_Duplex) {
  _inherits(ObjectMultiplex, _Duplex);
  var _super = _createSuper$1(ObjectMultiplex);
  function ObjectMultiplex() {
    var _this;
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, ObjectMultiplex);
    _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {
      objectMode: true
    }));
    _defineProperty(_assertThisInitialized(_this), "_substreams", void 0);
    _defineProperty(_assertThisInitialized(_this), "getStream", void 0);
    _this._substreams = {};
    return _this;
  }
  _createClass(ObjectMultiplex, [{
    key: "createStream",
    value: function createStream(name) {
      // validate name
      if (!name) {
        throw new Error("ObjectMultiplex - name must not be empty");
      }
      if (this._substreams[name]) {
        throw new Error("ObjectMultiplex - Substream for name \"".concat(name, "\" already exists"));
      }
      // create substream
      var substream = new Substream({
        parent: this,
        name: name
      });
      this._substreams[name] = substream;
      // listen for parent stream to end
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      anyStreamEnd(this, function (_error) {
        return substream.destroy(_error || undefined);
      });
      return substream;
    }
    // ignore streams (dont display orphaned data warning)
  }, {
    key: "ignoreStream",
    value: function ignoreStream(name) {
      // validate name
      if (!name) {
        throw new Error("ObjectMultiplex - name must not be empty");
      }
      if (this._substreams[name]) {
        throw new Error("ObjectMultiplex - Substream for name \"".concat(name, "\" already exists"));
      }
      // set
      this._substreams[name] = IGNORE_SUBSTREAM;
    }
  }, {
    key: "_read",
    value: function _read() {
      return undefined;
    }
  }, {
    key: "_write",
    value: function _write(chunk, _encoding, callback) {
      var name = chunk.name,
        data = chunk.data;
      if (!name) {
        window.console.warn("ObjectMultiplex - malformed chunk without name \"".concat(chunk, "\""));
        return callback();
      }
      // get corresponding substream
      var substream = this._substreams[name];
      if (!substream) {
        window.console.warn("ObjectMultiplex - orphaned data for stream \"".concat(name, "\""));
        return callback();
      }
      // push data into substream
      if (substream !== IGNORE_SUBSTREAM) {
        substream.push(data);
      }
      return callback();
    }
  }]);
  return ObjectMultiplex;
}(Duplex);
// util
function anyStreamEnd(stream, _cb) {
  var cb = once(_cb);
  eos(stream, {
    readable: false
  }, cb);
  eos(stream, {
    writable: false
  }, cb);
}
function setupMultiplex(stream) {
  var mux = new ObjectMultiplex();
  mux.getStream = function streamHelper(name) {
    if (this._substreams[name]) {
      return this._substreams[name];
    }
    return this.createStream(name);
  };
  pump(stream, mux, stream, function (err) {
    if (err) window.console.error(err);
  });
  return mux;
}

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var PostMessageStream = /*#__PURE__*/function (_BasePostMessageStrea) {
  _inherits(PostMessageStream, _BasePostMessageStrea);
  var _super = _createSuper(PostMessageStream);
  function PostMessageStream() {
    _classCallCheck(this, PostMessageStream);
    return _super.apply(this, arguments);
  }
  _createClass(PostMessageStream, [{
    key: "_postMessage",
    value: function _postMessage(data) {
      var originConstraint = this._targetOrigin;
      if (_typeof(data) === "object") {
        var dataObj = data;
        if (_typeof(dataObj.data) === "object") {
          var dataObjData = dataObj.data;
          if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {
            var dataObjDataParam = dataObjData.params[0];
            if (dataObjDataParam._origin) {
              originConstraint = dataObjDataParam._origin;
            }
            // add a constraint for the response
            dataObjDataParam._origin = window.location.origin;
          }
        }
      }
      this._targetWindow.postMessage({
        target: this._target,
        data: data
      }, originConstraint);
    }
  }]);
  return PostMessageStream;
}(BasePostMessageStream);

export { BasePostMessageStream, IGNORE_SUBSTREAM, JRPCEngine, ObjectMultiplex, PostMessageStream, SafeEventEmitter, SerializableError, Substream, createAsyncMiddleware, createEngineStream, createErrorMiddleware, createIdRemapMiddleware, createLoggerMiddleware, createScaffoldMiddleware, createStreamMiddleware, getRpcPromiseCallback, mergeMiddleware, setupMultiplex };
//# sourceMappingURL=openloginJrpc.esm.js.map
