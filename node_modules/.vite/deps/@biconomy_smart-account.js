import {
  require_browser as require_browser2,
  require_src as require_src2
} from "./chunk-UNGKAARR.js";
import {
  require_assert,
  require_src2 as require_src
} from "./chunk-SKIYUWIC.js";
import {
  require_browser,
  require_buffer,
  require_elliptic,
  require_end_of_stream,
  require_events,
  require_js,
  require_lodash,
  require_pipeline,
  require_readable_browser,
  require_safe_buffer,
  require_stream_duplex,
  require_stream_passthrough,
  require_stream_readable,
  require_stream_transform,
  require_stream_writable,
  require_string_decoder,
  require_util,
  require_util2
} from "./chunk-3CFYJ5LS.js";
import {
  require_crypto
} from "./chunk-EG7FL5OY.js";
import {
  init_lib,
  init_lib10,
  init_lib11,
  init_lib12,
  init_lib13,
  init_lib14,
  init_lib15,
  init_lib16,
  init_lib17,
  init_lib18,
  init_lib19,
  init_lib2,
  init_lib20,
  init_lib21,
  init_lib22,
  init_lib23,
  init_lib24,
  init_lib25,
  init_lib26,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib6,
  init_lib7,
  init_lib8,
  init_lib9,
  lib_exports,
  lib_exports10,
  lib_exports11,
  lib_exports12,
  lib_exports13,
  lib_exports14,
  lib_exports15,
  lib_exports16,
  lib_exports17,
  lib_exports18,
  lib_exports19,
  lib_exports2,
  lib_exports20,
  lib_exports21,
  lib_exports22,
  lib_exports23,
  lib_exports24,
  lib_exports25,
  lib_exports26,
  lib_exports3,
  lib_exports4,
  lib_exports5,
  lib_exports6,
  lib_exports7,
  lib_exports8,
  lib_exports9,
  require_sha3
} from "./chunk-YHT3EI6P.js";
import {
  require_bn,
  require_inherits_browser
} from "./chunk-PZEDZEUW.js";
import {
  require_src as require_src3
} from "./chunk-FUAAV5LJ.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  init_buffer,
  init_process,
  process
} from "./chunk-ARAA7IXG.js";

// node_modules/@biconomy/common/package.json
var require_package = __commonJS({
  "node_modules/@biconomy/common/package.json"(exports2, module2) {
    module2.exports = {
      name: "@biconomy/common",
      version: "2.0.0",
      description: "common utils to be used for aa transactions",
      keywords: [
        "utils"
      ],
      author: "livingrockrises <chirag@biconomy.io>",
      homepage: "https://github.com/bcnmy/biconomy-client-sdk#readme",
      license: "MIT",
      main: "dist/src/index.js",
      files: [
        "dist/*",
        "README.md"
      ],
      publishConfig: {
        access: "public"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/bcnmy/biconomy-client-sdk.git"
      },
      scripts: {
        clear: "rm -rf dist artifacts cache src/types",
        "hardhat-compile": "yarn clear && hardhat compile",
        "hardhat-deploy": "hardhat deploy",
        "hardhat-node": "hardhat node",
        "lint-fix": "eslint -f unix . --fix",
        "watch-tsc": "tsc -w --preserveWatchOutput",
        tsc: "tsc",
        test: "hardhat test",
        unbuild: "rimraf dist *.tsbuildinfo",
        build: "rimraf dist && tsc && hardhat compile",
        format: 'prettier --write "{src,tests}/**/*.ts"',
        lint: "tslint -p tsconfig.json"
      },
      bugs: {
        url: "https://github.com/bcnmy/biconomy-client-sdk/issues"
      },
      dependencies: {
        "@account-abstraction/contracts": "^0.6.0",
        "@biconomy/core-types": "^2.0.0",
        "@biconomy/ethers-lib": "^2.0.0",
        "@biconomy/node-client": "^2.0.0",
        "@ethersproject/abi": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/providers": "^5.7.0",
        "@openzeppelin/contracts": "^4.7.3",
        debug: "^4.3.4",
        ethers: "^5.7.0"
      },
      devDependencies: {
        "@nomicfoundation/hardhat-toolbox": "^1.0.2",
        "@nomiclabs/hardhat-ethers": "^2.0.0",
        hardhat: "^2.11.0"
      },
      gitHead: "d2089c6bf5285f5bfefe29eef99b68f3266ec7df"
    };
  }
});

// node_modules/@biconomy/common/dist/src/Version.js
var require_Version = __commonJS({
  "node_modules/@biconomy/common/dist/src/Version.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.erc4337RuntimeVersion = void 0;
    exports2.erc4337RuntimeVersion = require_package().version;
  }
});

// node_modules/ethers/lib/utils.js
var require_utils = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatBytes32String = exports2.Utf8ErrorFuncs = exports2.toUtf8String = exports2.toUtf8CodePoints = exports2.toUtf8Bytes = exports2._toEscapedUtf8String = exports2.nameprep = exports2.hexDataSlice = exports2.hexDataLength = exports2.hexZeroPad = exports2.hexValue = exports2.hexStripZeros = exports2.hexConcat = exports2.isHexString = exports2.hexlify = exports2.base64 = exports2.base58 = exports2.TransactionDescription = exports2.LogDescription = exports2.Interface = exports2.SigningKey = exports2.HDNode = exports2.defaultPath = exports2.isBytesLike = exports2.isBytes = exports2.zeroPad = exports2.stripZeros = exports2.concat = exports2.arrayify = exports2.shallowCopy = exports2.resolveProperties = exports2.getStatic = exports2.defineReadOnly = exports2.deepCopy = exports2.checkProperties = exports2.poll = exports2.fetchJson = exports2._fetchData = exports2.RLP = exports2.Logger = exports2.checkResultErrors = exports2.FormatTypes = exports2.ParamType = exports2.FunctionFragment = exports2.EventFragment = exports2.ErrorFragment = exports2.ConstructorFragment = exports2.Fragment = exports2.defaultAbiCoder = exports2.AbiCoder = void 0;
    exports2.Indexed = exports2.Utf8ErrorReason = exports2.UnicodeNormalizationForm = exports2.SupportedAlgorithm = exports2.mnemonicToSeed = exports2.isValidMnemonic = exports2.entropyToMnemonic = exports2.mnemonicToEntropy = exports2.getAccountPath = exports2.verifyTypedData = exports2.verifyMessage = exports2.recoverPublicKey = exports2.computePublicKey = exports2.recoverAddress = exports2.computeAddress = exports2.getJsonWalletAddress = exports2.TransactionTypes = exports2.serializeTransaction = exports2.parseTransaction = exports2.accessListify = exports2.joinSignature = exports2.splitSignature = exports2.soliditySha256 = exports2.solidityKeccak256 = exports2.solidityPack = exports2.shuffled = exports2.randomBytes = exports2.sha512 = exports2.sha256 = exports2.ripemd160 = exports2.keccak256 = exports2.computeHmac = exports2.commify = exports2.parseUnits = exports2.formatUnits = exports2.parseEther = exports2.formatEther = exports2.isAddress = exports2.getCreate2Address = exports2.getContractAddress = exports2.getIcapAddress = exports2.getAddress = exports2._TypedDataEncoder = exports2.id = exports2.isValidName = exports2.namehash = exports2.hashMessage = exports2.dnsEncode = exports2.parseBytes32String = void 0;
    var abi_1 = (init_lib12(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports2, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports2, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports2, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports2, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports2, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports2, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports2, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports2, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports2, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports2, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports2, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports2, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports2, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports2, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib7(), __toCommonJS(lib_exports7));
    Object.defineProperty(exports2, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports2, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports2, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports2, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports2, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib10(), __toCommonJS(lib_exports10)));
    exports2.base64 = base64;
    var basex_1 = (init_lib16(), __toCommonJS(lib_exports16));
    Object.defineProperty(exports2, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), __toCommonJS(lib_exports2));
    Object.defineProperty(exports2, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports2, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports2, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports2, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports2, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports2, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports2, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports2, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports2, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports2, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports2, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports2, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports2, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports2, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports2, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib11(), __toCommonJS(lib_exports11));
    Object.defineProperty(exports2, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports2, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports2, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports2, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports2, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports2, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib18(), __toCommonJS(lib_exports18));
    Object.defineProperty(exports2, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports2, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports2, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports2, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports2, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports2, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports2, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib20(), __toCommonJS(lib_exports20));
    Object.defineProperty(exports2, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib5(), __toCommonJS(lib_exports5));
    Object.defineProperty(exports2, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib17(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports2, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports2, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib24(), __toCommonJS(lib_exports24));
    Object.defineProperty(exports2, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports2, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports2, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib19(), __toCommonJS(lib_exports19));
    Object.defineProperty(exports2, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports2, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib4(), __toCommonJS(lib_exports4));
    Object.defineProperty(exports2, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports2, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports2, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports2, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports2, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports2, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib6(), __toCommonJS(lib_exports6)));
    exports2.RLP = RLP;
    var signing_key_1 = (init_lib14(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports2, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports2, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports2, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports2, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports2, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports2, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports2, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports2, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports2, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports2, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports2, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib15(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports2, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports2, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports2, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports2, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports2, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports2, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib25(), __toCommonJS(lib_exports25));
    Object.defineProperty(exports2, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports2, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports2, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports2, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports2, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib21(), __toCommonJS(lib_exports21));
    Object.defineProperty(exports2, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports2, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib22(), __toCommonJS(lib_exports22));
    Object.defineProperty(exports2, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports2, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports2, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib17(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports2, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports2, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports2, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/@account-abstraction/contracts/artifacts/IEntryPoint.json
var require_IEntryPoint = __commonJS({
  "node_modules/@account-abstraction/contracts/artifacts/IEntryPoint.json"(exports2, module2) {
    module2.exports = {
      _format: "hh-sol-artifact-1",
      contractName: "IEntryPoint",
      sourceName: "contracts/interfaces/IEntryPoint.sol",
      abi: [
        {
          inputs: [
            {
              internalType: "uint256",
              name: "preOpGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "paid",
              type: "uint256"
            },
            {
              internalType: "uint48",
              name: "validAfter",
              type: "uint48"
            },
            {
              internalType: "uint48",
              name: "validUntil",
              type: "uint48"
            },
            {
              internalType: "bool",
              name: "targetSuccess",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "targetResult",
              type: "bytes"
            }
          ],
          name: "ExecutionResult",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "opIndex",
              type: "uint256"
            },
            {
              internalType: "string",
              name: "reason",
              type: "string"
            }
          ],
          name: "FailedOp",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "sender",
              type: "address"
            }
          ],
          name: "SenderAddressResult",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "aggregator",
              type: "address"
            }
          ],
          name: "SignatureValidationFailed",
          type: "error"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint256",
                  name: "preOpGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "prefund",
                  type: "uint256"
                },
                {
                  internalType: "bool",
                  name: "sigFailed",
                  type: "bool"
                },
                {
                  internalType: "uint48",
                  name: "validAfter",
                  type: "uint48"
                },
                {
                  internalType: "uint48",
                  name: "validUntil",
                  type: "uint48"
                },
                {
                  internalType: "bytes",
                  name: "paymasterContext",
                  type: "bytes"
                }
              ],
              internalType: "struct IEntryPoint.ReturnInfo",
              name: "returnInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "senderInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "factoryInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "paymasterInfo",
              type: "tuple"
            }
          ],
          name: "ValidationResult",
          type: "error"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint256",
                  name: "preOpGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "prefund",
                  type: "uint256"
                },
                {
                  internalType: "bool",
                  name: "sigFailed",
                  type: "bool"
                },
                {
                  internalType: "uint48",
                  name: "validAfter",
                  type: "uint48"
                },
                {
                  internalType: "uint48",
                  name: "validUntil",
                  type: "uint48"
                },
                {
                  internalType: "bytes",
                  name: "paymasterContext",
                  type: "bytes"
                }
              ],
              internalType: "struct IEntryPoint.ReturnInfo",
              name: "returnInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "senderInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "factoryInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "stake",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "unstakeDelaySec",
                  type: "uint256"
                }
              ],
              internalType: "struct IStakeManager.StakeInfo",
              name: "paymasterInfo",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "address",
                  name: "aggregator",
                  type: "address"
                },
                {
                  components: [
                    {
                      internalType: "uint256",
                      name: "stake",
                      type: "uint256"
                    },
                    {
                      internalType: "uint256",
                      name: "unstakeDelaySec",
                      type: "uint256"
                    }
                  ],
                  internalType: "struct IStakeManager.StakeInfo",
                  name: "stakeInfo",
                  type: "tuple"
                }
              ],
              internalType: "struct IEntryPoint.AggregatorStakeInfo",
              name: "aggregatorInfo",
              type: "tuple"
            }
          ],
          name: "ValidationResultWithAggregation",
          type: "error"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "userOpHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "factory",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "paymaster",
              type: "address"
            }
          ],
          name: "AccountDeployed",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [],
          name: "BeforeExecution",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "totalDeposit",
              type: "uint256"
            }
          ],
          name: "Deposited",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "aggregator",
              type: "address"
            }
          ],
          name: "SignatureAggregatorChanged",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "totalStaked",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "unstakeDelaySec",
              type: "uint256"
            }
          ],
          name: "StakeLocked",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "withdrawTime",
              type: "uint256"
            }
          ],
          name: "StakeUnlocked",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "withdrawAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "StakeWithdrawn",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "userOpHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "paymaster",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "nonce",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "actualGasCost",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "actualGasUsed",
              type: "uint256"
            }
          ],
          name: "UserOperationEvent",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "userOpHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "nonce",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "revertReason",
              type: "bytes"
            }
          ],
          name: "UserOperationRevertReason",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "withdrawAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "Withdrawn",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "uint32",
              name: "_unstakeDelaySec",
              type: "uint32"
            }
          ],
          name: "addStake",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "account",
              type: "address"
            }
          ],
          name: "balanceOf",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "account",
              type: "address"
            }
          ],
          name: "depositTo",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "account",
              type: "address"
            }
          ],
          name: "getDepositInfo",
          outputs: [
            {
              components: [
                {
                  internalType: "uint112",
                  name: "deposit",
                  type: "uint112"
                },
                {
                  internalType: "bool",
                  name: "staked",
                  type: "bool"
                },
                {
                  internalType: "uint112",
                  name: "stake",
                  type: "uint112"
                },
                {
                  internalType: "uint32",
                  name: "unstakeDelaySec",
                  type: "uint32"
                },
                {
                  internalType: "uint48",
                  name: "withdrawTime",
                  type: "uint48"
                }
              ],
              internalType: "struct IStakeManager.DepositInfo",
              name: "info",
              type: "tuple"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              internalType: "uint192",
              name: "key",
              type: "uint192"
            }
          ],
          name: "getNonce",
          outputs: [
            {
              internalType: "uint256",
              name: "nonce",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "initCode",
              type: "bytes"
            }
          ],
          name: "getSenderAddress",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "uint256",
                  name: "nonce",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "initCode",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "callData",
                  type: "bytes"
                },
                {
                  internalType: "uint256",
                  name: "callGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "verificationGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "preVerificationGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxPriorityFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "paymasterAndData",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                }
              ],
              internalType: "struct UserOperation",
              name: "userOp",
              type: "tuple"
            }
          ],
          name: "getUserOpHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "sender",
                      type: "address"
                    },
                    {
                      internalType: "uint256",
                      name: "nonce",
                      type: "uint256"
                    },
                    {
                      internalType: "bytes",
                      name: "initCode",
                      type: "bytes"
                    },
                    {
                      internalType: "bytes",
                      name: "callData",
                      type: "bytes"
                    },
                    {
                      internalType: "uint256",
                      name: "callGasLimit",
                      type: "uint256"
                    },
                    {
                      internalType: "uint256",
                      name: "verificationGasLimit",
                      type: "uint256"
                    },
                    {
                      internalType: "uint256",
                      name: "preVerificationGas",
                      type: "uint256"
                    },
                    {
                      internalType: "uint256",
                      name: "maxFeePerGas",
                      type: "uint256"
                    },
                    {
                      internalType: "uint256",
                      name: "maxPriorityFeePerGas",
                      type: "uint256"
                    },
                    {
                      internalType: "bytes",
                      name: "paymasterAndData",
                      type: "bytes"
                    },
                    {
                      internalType: "bytes",
                      name: "signature",
                      type: "bytes"
                    }
                  ],
                  internalType: "struct UserOperation[]",
                  name: "userOps",
                  type: "tuple[]"
                },
                {
                  internalType: "contract IAggregator",
                  name: "aggregator",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                }
              ],
              internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
              name: "opsPerAggregator",
              type: "tuple[]"
            },
            {
              internalType: "address payable",
              name: "beneficiary",
              type: "address"
            }
          ],
          name: "handleAggregatedOps",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "uint256",
                  name: "nonce",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "initCode",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "callData",
                  type: "bytes"
                },
                {
                  internalType: "uint256",
                  name: "callGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "verificationGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "preVerificationGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxPriorityFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "paymasterAndData",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                }
              ],
              internalType: "struct UserOperation[]",
              name: "ops",
              type: "tuple[]"
            },
            {
              internalType: "address payable",
              name: "beneficiary",
              type: "address"
            }
          ],
          name: "handleOps",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint192",
              name: "key",
              type: "uint192"
            }
          ],
          name: "incrementNonce",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "uint256",
                  name: "nonce",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "initCode",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "callData",
                  type: "bytes"
                },
                {
                  internalType: "uint256",
                  name: "callGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "verificationGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "preVerificationGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxPriorityFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "paymasterAndData",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                }
              ],
              internalType: "struct UserOperation",
              name: "op",
              type: "tuple"
            },
            {
              internalType: "address",
              name: "target",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "targetCallData",
              type: "bytes"
            }
          ],
          name: "simulateHandleOp",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "uint256",
                  name: "nonce",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "initCode",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "callData",
                  type: "bytes"
                },
                {
                  internalType: "uint256",
                  name: "callGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "verificationGasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "preVerificationGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxPriorityFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "paymasterAndData",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                }
              ],
              internalType: "struct UserOperation",
              name: "userOp",
              type: "tuple"
            }
          ],
          name: "simulateValidation",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "unlockStake",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address payable",
              name: "withdrawAddress",
              type: "address"
            }
          ],
          name: "withdrawStake",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address payable",
              name: "withdrawAddress",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "withdrawAmount",
              type: "uint256"
            }
          ],
          name: "withdrawTo",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ],
      bytecode: "0x",
      deployedBytecode: "0x",
      linkReferences: {},
      deployedLinkReferences: {}
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    init_process();
    init_buffer();
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    init_process();
    init_buffer();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@biconomy/common/dist/src/ERC4337Utils.js
var require_ERC4337Utils = __commonJS({
  "node_modules/@biconomy/common/dist/src/ERC4337Utils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deepHexlify = exports2.rethrowError = exports2.decodeErrorReason = exports2.getUserOpHash = exports2.packUserOp = exports2.EIP1559_UNSUPPORTED_NETWORKS = exports2.AddressZero = void 0;
    var utils_1 = require_utils();
    var IEntryPoint_json_1 = require_IEntryPoint();
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var debug_1 = __importDefault(require_browser3());
    var debug = (0, debug_1.default)("aa.utils");
    var validateUserOpMethod = "simulateValidation";
    var UserOpType = (_a = IEntryPoint_json_1.abi.find((entry) => entry.name === validateUserOpMethod)) === null || _a === void 0 ? void 0 : _a.inputs[0];
    if (UserOpType == null) {
      throw new Error(`unable to find method ${validateUserOpMethod} in EP ${IEntryPoint_json_1.abi.filter((x) => x.type === "function").map((x) => x.name).join(",")}`);
    }
    exports2.AddressZero = ethers_1.ethers.constants.AddressZero;
    exports2.EIP1559_UNSUPPORTED_NETWORKS = [97, 56, 1442, 1101];
    function packUserOp(op, forSignature = true) {
      if (forSignature) {
        return utils_1.defaultAbiCoder.encode([
          "address",
          "uint256",
          "bytes32",
          "bytes32",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "bytes32"
        ], [
          op.sender,
          op.nonce,
          (0, utils_1.keccak256)(op.initCode),
          (0, utils_1.keccak256)(op.callData),
          op.callGasLimit,
          op.verificationGasLimit,
          op.preVerificationGas,
          op.maxFeePerGas,
          op.maxPriorityFeePerGas,
          (0, utils_1.keccak256)(op.paymasterAndData)
        ]);
      } else {
        return utils_1.defaultAbiCoder.encode([
          "address",
          "uint256",
          "bytes",
          "bytes",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "bytes",
          "bytes"
        ], [
          op.sender,
          op.nonce,
          op.initCode,
          op.callData,
          op.callGasLimit,
          op.verificationGasLimit,
          op.preVerificationGas,
          op.maxFeePerGas,
          op.maxPriorityFeePerGas,
          op.paymasterAndData,
          op.signature
        ]);
      }
    }
    exports2.packUserOp = packUserOp;
    function getUserOpHash(op, entryPoint, chainId) {
      const userOpHash = (0, utils_1.keccak256)(packUserOp(op, true));
      const enc = utils_1.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, entryPoint, chainId]);
      return (0, utils_1.keccak256)(enc);
    }
    exports2.getUserOpHash = getUserOpHash;
    var ErrorSig = (0, utils_1.keccak256)(Buffer.from("Error(string)")).slice(0, 10);
    var FailedOpSig = (0, utils_1.keccak256)(Buffer.from("FailedOp(uint256,address,string)")).slice(0, 10);
    function decodeErrorReason(error) {
      debug("decoding", error);
      if (error.startsWith(ErrorSig)) {
        const [message] = utils_1.defaultAbiCoder.decode(["string"], "0x" + error.substring(10));
        return { message };
      } else if (error.startsWith(FailedOpSig)) {
        const resultSet = utils_1.defaultAbiCoder.decode(["uint256", "address", "string"], "0x" + error.substring(10));
        let [paymaster, message] = resultSet;
        const [opIndex] = resultSet;
        message = `FailedOp: ${message}`;
        if (paymaster.toString() !== ethers_1.ethers.constants.AddressZero) {
          message = `${message} (paymaster ${paymaster})`;
        } else {
          paymaster = void 0;
        }
        return {
          message,
          opIndex,
          paymaster
        };
      }
      return void 0;
    }
    exports2.decodeErrorReason = decodeErrorReason;
    function rethrowError(e) {
      let error = e;
      let parent = e;
      if ((error === null || error === void 0 ? void 0 : error.error) != null) {
        error = error.error;
      }
      while ((error === null || error === void 0 ? void 0 : error.data) != null) {
        parent = error;
        error = error.data;
      }
      const decoded = typeof error === "string" && error.length > 2 ? decodeErrorReason(error) : void 0;
      if (decoded != null) {
        e.message = decoded.message;
        if (decoded.opIndex != null) {
          const errorWithMsg = (0, utils_1.hexConcat)([
            ErrorSig,
            utils_1.defaultAbiCoder.encode(["string"], [decoded.message])
          ]);
          parent.data = errorWithMsg;
        }
      }
      throw e;
    }
    exports2.rethrowError = rethrowError;
    function deepHexlify(obj2) {
      if (typeof obj2 === "function") {
        return void 0;
      }
      if (obj2 == null || typeof obj2 === "string" || typeof obj2 === "boolean") {
        return obj2;
      } else if (obj2._isBigNumber != null || typeof obj2 !== "object") {
        return (0, utils_1.hexlify)(obj2).replace(/^0x0/, "0x");
      }
      if (Array.isArray(obj2)) {
        return obj2.map((member) => deepHexlify(member));
      }
      return Object.keys(obj2).reduce((set, key) => ({
        ...set,
        [key]: deepHexlify(obj2[key])
      }), {});
    }
    exports2.deepHexlify = deepHexlify;
  }
});

// node_modules/@biconomy/common/dist/src/Logger.js
var require_Logger = __commonJS({
  "node_modules/@biconomy/common/dist/src/Logger.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Logger = void 0;
    var Logger = class {
      /**
       * \x1b[0m is an escape sequence to reset the color of the text
       * All color codes used - 31 - Red, 33 - Yellow, 34 - Blue, 35 - Magenta, 36 - Cyan
       * log -   Magenta[time]               Cyan[message]:  [value]
       * warn -  Magenta[time] Yellow[WARN]: Cyan[message]:  [value]
       * error - Magenta[time] Red[ERROR]:   Cyan[message]:  [value]
       */
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      static log(message, value) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        const logMessage = `\x1B[35m[${timestamp}]\x1B[0m \x1B[36m${message}\x1B[0m:`;
        if (Logger.isDebug) {
          console.log(logMessage, value === void 0 ? "" : value);
        }
      }
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      static warn(message, value) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        const warnMessage = `\x1B[35m[${timestamp}]\x1B[0m \x1B[33mWARN\x1B[0m: \x1B[36m${message}\x1B[0m`;
        if (Logger.isDebug) {
          console.warn(warnMessage, value === void 0 ? "" : value);
        }
      }
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      static error(message, value) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        const errorMessage = `\x1B[35m[${timestamp}]\x1B[0m \x1B[31mERROR\x1B[0m: \x1B[36m${message}\x1B[0m`;
        if (Logger.isDebug) {
          console.error(errorMessage, value === void 0 ? "" : value);
        }
      }
    };
    exports2.Logger = Logger;
    Logger.isDebug = process.env.BICONOMY_SDK_DEBUG === "true" ? true : process.env.REACT_APP_BICONOMY_SDK_DEBUG === "true" ? true : false;
  }
});

// node_modules/@biconomy/common/dist/src/WalletFactoryApi.js
var require_WalletFactoryApi = __commonJS({
  "node_modules/@biconomy/common/dist/src/WalletFactoryApi.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deployCounterFactualEncodedData = exports2.getWalletInfo = void 0;
    var node_client_1 = __importDefault(require_src2());
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _ = __importStar(require_lodash());
    async function getWalletInfo(initializerDto) {
      const { chainId, owner, txServiceUrl } = initializerDto;
      const smartAccountInfo = await new node_client_1.default({ txServiceUrl }).getSmartAccountsByOwner({
        owner,
        chainId
      });
      if (!smartAccountInfo.data || smartAccountInfo.data.length == 0) {
        throw new Error("No Smart Account Found against supplied EOA");
      }
      const walletInfo = smartAccountInfo.data;
      if (walletInfo.length === 0)
        throw new Error("No Wallet Info Found against supplied data");
      const wallet = _.filter(walletInfo, { isDeployed: true });
      if (wallet.length > 0) {
        let walletLists = _.filter(wallet, { chainId });
        if (walletLists.length > 0) {
          return walletLists[0];
        }
        walletLists = wallet.sort((objA, objB) => objB.createdAt - objA.createdAt);
        return walletLists[0];
      }
      return walletInfo[0];
    }
    exports2.getWalletInfo = getWalletInfo;
    async function deployCounterFactualEncodedData(initializerDto) {
      let { index } = initializerDto;
      index = index ? index : 0;
      const walletInfo = await getWalletInfo(initializerDto);
      const factory = new ethers_1.Contract(walletInfo.factoryAddress, [
        "function deployCounterFactualAccount(address _owner, uint256 _index) returns(address)"
      ]);
      const encodedData = factory.interface.encodeFunctionData("deployCounterFactualAccount", [
        walletInfo.owner,
        index
      ]);
      return encodedData;
    }
    exports2.deployCounterFactualEncodedData = deployCounterFactualEncodedData;
  }
});

// node_modules/@biconomy/common/dist/src/EnodeSmartAccountUtils.js
var require_EnodeSmartAccountUtils = __commonJS({
  "node_modules/@biconomy/common/dist/src/EnodeSmartAccountUtils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fallbackHandlerEncodedData = exports2.updateImplementationEncodedData = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    async function updateImplementationEncodedData(newimplementationAddress) {
      const impInterface = new ethers_1.ethers.utils.Interface([
        "function updateImplementation(address _implementation)"
      ]);
      const encodedData = impInterface.encodeFunctionData("updateImplementation", [
        newimplementationAddress
      ]);
      return encodedData;
    }
    exports2.updateImplementationEncodedData = updateImplementationEncodedData;
    async function fallbackHandlerEncodedData(newhandler) {
      const impInterface = new ethers_1.ethers.utils.Interface(["function setFallbackHandler(address handler)"]);
      const encodedData = impInterface.encodeFunctionData("setFallbackHandler", [newhandler]);
      return encodedData;
    }
    exports2.fallbackHandlerEncodedData = fallbackHandlerEncodedData;
  }
});

// node_modules/@biconomy/common/dist/src/index.js
var require_src4 = __commonJS({
  "node_modules/@biconomy/common/dist/src/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Version(), exports2);
    __exportStar(require_ERC4337Utils(), exports2);
    __exportStar(require_Logger(), exports2);
    __exportStar(require_WalletFactoryApi(), exports2);
    __exportStar(require_EnodeSmartAccountUtils(), exports2);
  }
});

// node_modules/@biconomy/relayer/dist/src/utils/MultiSend.js
var require_MultiSend = __commonJS({
  "node_modules/@biconomy/relayer/dist/src/utils/MultiSend.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildMultiSendSmartAccountTx = exports2.encodeMultiSend = exports2.buildSmartAccountTransaction = exports2.buildContractCall = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var constants_1 = (init_lib8(), __toCommonJS(lib_exports8));
    var buildContractCall = (contract, method, params, nonce, delegateCall, overrides) => {
      const data = contract.interface.encodeFunctionData(method, params);
      return (0, exports2.buildSmartAccountTransaction)(Object.assign({
        to: contract.address,
        data,
        operation: delegateCall ? 1 : 0,
        nonce
      }, overrides));
    };
    exports2.buildContractCall = buildContractCall;
    var buildSmartAccountTransaction = (template) => {
      return {
        to: template.to,
        value: template.value || 0,
        data: template.data || "0x",
        operation: template.operation || 0,
        targetTxGas: template.targetTxGas || 0,
        baseGas: template.baseGas || 0,
        gasPrice: template.gasPrice || 0,
        gasToken: template.gasToken || constants_1.AddressZero,
        refundReceiver: template.refundReceiver || constants_1.AddressZero,
        nonce: template.nonce
      };
    };
    exports2.buildSmartAccountTransaction = buildSmartAccountTransaction;
    var encodeMetaTransaction = (tx) => {
      const data = ethers_1.utils.arrayify(tx.data);
      const encoded = ethers_1.utils.solidityPack(["uint8", "address", "uint256", "uint256", "bytes"], [tx.operation, tx.to, tx.value, data.length, data]);
      return encoded.slice(2);
    };
    var encodeMultiSend = (txs) => {
      return "0x" + txs.map((tx) => encodeMetaTransaction(tx)).join("");
    };
    exports2.encodeMultiSend = encodeMultiSend;
    var buildMultiSendSmartAccountTx = (multiSend, txs, nonce, overrides) => {
      return (0, exports2.buildContractCall)(multiSend, "multiSend", [(0, exports2.encodeMultiSend)(txs)], nonce, true, overrides);
    };
    exports2.buildMultiSendSmartAccountTx = buildMultiSendSmartAccountTx;
  }
});

// node_modules/@biconomy/relayer/dist/src/LocalRelayer.js
var require_LocalRelayer = __commonJS({
  "node_modules/@biconomy/relayer/dist/src/LocalRelayer.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LocalRelayer = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var common_1 = require_src4();
    var MultiSend_1 = require_MultiSend();
    var LocalRelayer = class {
      // private txnOptions: TransactionRequest
      constructor(signer) {
        if (!ethers_1.Signer.isSigner(signer))
          throw new Error("Signer must have a provider");
        this.signer = signer;
        if (!this.signer.provider)
          throw new Error("Signer must have a provider");
      }
      // Defines a type DeployWallet that takes config, context for SCW in this context
      async deployWallet(deployWallet) {
        const { config, context, index = 0 } = deployWallet;
        const { isDeployed } = config;
        if (isDeployed) {
          throw new Error("Smart Account is Already Deployed");
        }
        const walletDeployTxn = this.prepareWalletDeploy({ config, context, index });
        const tx = this.signer.sendTransaction({
          ...walletDeployTxn,
          gasLimit: ethers_1.ethers.constants.Two.pow(24)
        });
        return tx;
      }
      prepareWalletDeploy(deployWallet) {
        const { config, context, index = 0 } = deployWallet;
        const { walletFactory } = context;
        const { owner } = config;
        const factoryInterface = walletFactory.getInterface();
        return {
          to: walletFactory.getAddress(),
          data: factoryInterface.encodeFunctionData(factoryInterface.getFunction("deployCounterFactualAccount"), [owner, index])
        };
      }
      async relay(relayTransaction) {
        const { config, signedTx, context, gasLimit } = relayTransaction;
        const { isDeployed, address } = config;
        const { multiSendCall } = context;
        if (!isDeployed) {
          const prepareWalletDeploy = {
            config,
            context,
            index: 0
          };
          const { to, data } = this.prepareWalletDeploy(prepareWalletDeploy);
          const txs = [
            {
              to,
              value: 0,
              data,
              operation: 0
            },
            {
              to: address,
              value: 0,
              data: signedTx.rawTx.data || "",
              operation: 0
            }
          ];
          const txnData = multiSendCall.getInterface().encodeFunctionData("multiSend", [(0, MultiSend_1.encodeMultiSend)(txs)]);
          console;
          const finalRawRx = {
            to: multiSendCall.getAddress(),
            data: txnData
          };
          common_1.Logger.log("finalRawTx", finalRawRx);
          const tx2 = this.signer.sendTransaction({
            ...finalRawRx,
            gasLimit: gasLimit ? gasLimit.hex : ethers_1.ethers.constants.Two.pow(24)
          });
          return tx2;
        }
        const tx = this.signer.sendTransaction({
          ...signedTx.rawTx,
          gasLimit: gasLimit ? gasLimit.hex : ethers_1.ethers.constants.Two.pow(24)
        });
        return tx;
      }
      async getFeeOptions(chainId) {
        common_1.Logger.log("requested fee options for chain ", chainId);
        const feeOptions = {
          msg: "all ok",
          data: {
            chainId: 5,
            response: [
              {
                tokenGasPrice: 157718,
                symbol: "USDC",
                address: "0xb5B640E6414b6DeF4FC9B3C1EeF373925effeCcF",
                decimal: 6,
                logoUrl: "https://raw.githubusercontent.com/spothq/cryptocurrency-icons/master/128/color/usdc.png",
                offset: 1e6,
                feeTokenTransferGas: 22975,
                refundReceiver: "0xc1d3206324d806b6586cf15324178f8e8781a293"
              }
            ]
          }
        };
        return feeOptions;
      }
    };
    exports2.LocalRelayer = LocalRelayer;
  }
});

// node_modules/@biconomy/relayer/dist/src/utils/HttpRequests.js
var require_HttpRequests = __commonJS({
  "node_modules/@biconomy/relayer/dist/src/utils/HttpRequests.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sendRequest = exports2.HttpMethod = void 0;
    var node_fetch_1 = __importDefault(require_browser2());
    var common_1 = require_src4();
    var HttpMethod;
    (function(HttpMethod2) {
      HttpMethod2["Get"] = "get";
      HttpMethod2["Post"] = "post";
      HttpMethod2["Delete"] = "delete";
    })(HttpMethod = exports2.HttpMethod || (exports2.HttpMethod = {}));
    async function sendRequest({ url, method, body, headers = {} }) {
      const response = await (0, node_fetch_1.default)(url, {
        method,
        headers: {
          ...headers,
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      common_1.Logger.log("http response ", response);
      let jsonResponse;
      try {
        jsonResponse = await response.json();
      } catch (error) {
        common_1.Logger.log("error ", error);
        if (!response.ok) {
          common_1.Logger.error("http response ", response);
          throw new Error(response.statusText);
        }
      }
      if (response.ok) {
        return jsonResponse;
      }
      if (jsonResponse.error) {
        throw new Error(jsonResponse.error);
      }
      if (jsonResponse.message) {
        throw new Error(jsonResponse.message);
      }
      if (jsonResponse.msg) {
        throw new Error(jsonResponse.msg);
      }
      if (jsonResponse.data) {
        throw new Error(jsonResponse.data);
      }
      if (jsonResponse.detail) {
        throw new Error(jsonResponse.detail);
      }
      if (jsonResponse.message) {
        throw new Error(jsonResponse.message);
      }
      if (jsonResponse.nonFieldErrors) {
        throw new Error(jsonResponse.nonFieldErrors);
      }
      if (jsonResponse.delegate) {
        throw new Error(jsonResponse.delegate);
      }
      throw new Error(response.statusText);
    }
    exports2.sendRequest = sendRequest;
  }
});

// node_modules/centrifuge/dist/centrifuge.js
var require_centrifuge = __commonJS({
  "node_modules/centrifuge/dist/centrifuge.js"(exports2, module2) {
    init_process();
    init_buffer();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("Centrifuge", [], factory);
      else if (typeof exports2 === "object")
        exports2["Centrifuge"] = factory();
      else
        root["Centrifuge"] = factory();
    })(exports2, function() {
      return (
        /******/
        function() {
          "use strict";
          var __webpack_modules__ = {
            /***/
            382: (
              /***/
              function(__unused_webpack_module, exports3, __webpack_require__2) {
                Object.defineProperty(exports3, "__esModule", {
                  value: true
                });
                exports3.Centrifuge = void 0;
                var _events = _interopRequireDefault(__webpack_require__2(187));
                var _subscription = _interopRequireDefault(__webpack_require__2(471));
                var _json = __webpack_require__2(147);
                var _utils = __webpack_require__2(853);
                function _interopRequireDefault(obj2) {
                  return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
                }
                function _typeof(obj2) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj3) {
                      return typeof obj3;
                    };
                  } else {
                    _typeof = function _typeof2(obj3) {
                      return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
                    };
                  }
                  return _typeof(obj2);
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _createSuper(Derived) {
                  var hasNativeReflectConstruct = _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super = _getPrototypeOf(Derived), result;
                    if (hasNativeReflectConstruct) {
                      var NewTarget = _getPrototypeOf(this).constructor;
                      result = Reflect.construct(Super, arguments, NewTarget);
                    } else {
                      result = Super.apply(this, arguments);
                    }
                    return _possibleConstructorReturn(this, result);
                  };
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                  } else if (call !== void 0) {
                    throw new TypeError("Derived constructors may only return object or undefined");
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                var _errorTimeout = "timeout";
                var _errorConnectionClosed = "connection closed";
                var Centrifuge = function(_EventEmitter) {
                  _inherits(Centrifuge2, _EventEmitter);
                  var _super = _createSuper(Centrifuge2);
                  function Centrifuge2(url, options) {
                    var _this;
                    _classCallCheck(this, Centrifuge2);
                    _this = _super.call(this);
                    _this._url = url;
                    _this._websocket = null;
                    _this._sockjs = null;
                    _this._isSockjs = false;
                    _this._xmlhttprequest = null;
                    _this._binary = false;
                    _this._methodType = null;
                    _this._pushType = null;
                    _this._encoder = null;
                    _this._decoder = null;
                    _this._status = "disconnected";
                    _this._reconnect = true;
                    _this._reconnecting = false;
                    _this._transport = null;
                    _this._transportName = null;
                    _this._transportClosed = true;
                    _this._messageId = 0;
                    _this._clientID = null;
                    _this._refreshRequired = false;
                    _this._subs = {};
                    _this._serverSubs = {};
                    _this._lastSeq = {};
                    _this._lastGen = {};
                    _this._lastOffset = {};
                    _this._lastEpoch = {};
                    _this._messages = [];
                    _this._isBatching = false;
                    _this._isSubscribeBatching = false;
                    _this._privateChannels = {};
                    _this._numRefreshFailed = 0;
                    _this._refreshTimeout = null;
                    _this._pingTimeout = null;
                    _this._pongTimeout = null;
                    _this._subRefreshTimeouts = {};
                    _this._retries = 0;
                    _this._callbacks = {};
                    _this._latency = null;
                    _this._latencyStart = null;
                    _this._connectData = null;
                    _this._token = null;
                    _this._xhrID = 0;
                    _this._xhrs = {};
                    _this._dispatchPromise = Promise.resolve();
                    _this._protocol = "";
                    _this._config = {
                      protocol: "",
                      debug: false,
                      name: "js",
                      version: "",
                      websocket: null,
                      sockjs: null,
                      xmlhttprequest: null,
                      minRetry: 1e3,
                      maxRetry: 2e4,
                      timeout: 5e3,
                      ping: true,
                      pingInterval: 25e3,
                      pongWaitTimeout: 5e3,
                      privateChannelPrefix: "$",
                      onTransportClose: null,
                      sockjsServer: null,
                      sockjsTimeout: null,
                      sockjsTransports: ["websocket", "xdr-streaming", "xhr-streaming", "eventsource", "iframe-eventsource", "iframe-htmlfile", "xdr-polling", "xhr-polling", "iframe-xhr-polling", "jsonp-polling"],
                      refreshEndpoint: "/centrifuge/refresh",
                      refreshHeaders: {},
                      refreshParams: {},
                      refreshData: {},
                      refreshAttempts: null,
                      refreshInterval: 1e3,
                      onRefreshFailed: null,
                      onRefresh: null,
                      subscribeEndpoint: "/centrifuge/subscribe",
                      subscribeHeaders: {},
                      subscribeParams: {},
                      subRefreshInterval: 1e3,
                      onPrivateSubscribe: null,
                      disableWithCredentials: false
                    };
                    _this._configure(options);
                    return _this;
                  }
                  _createClass(Centrifuge2, [{
                    key: "setToken",
                    value: function setToken(token) {
                      this._token = token;
                    }
                  }, {
                    key: "setConnectData",
                    value: function setConnectData(data) {
                      this._connectData = data;
                    }
                  }, {
                    key: "setRefreshHeaders",
                    value: function setRefreshHeaders(headers) {
                      this._config.refreshHeaders = headers;
                    }
                  }, {
                    key: "setRefreshParams",
                    value: function setRefreshParams(params) {
                      this._config.refreshParams = params;
                    }
                  }, {
                    key: "setRefreshData",
                    value: function setRefreshData(data) {
                      this._config.refreshData = data;
                    }
                  }, {
                    key: "setSubscribeHeaders",
                    value: function setSubscribeHeaders(headers) {
                      this._config.subscribeHeaders = headers;
                    }
                  }, {
                    key: "setSubscribeParams",
                    value: function setSubscribeParams(params) {
                      this._config.subscribeParams = params;
                    }
                  }, {
                    key: "_ajax",
                    value: function _ajax(url, params, headers, data, callback) {
                      var _this2 = this;
                      var query = "";
                      this._debug("sending AJAX request to", url, "with data", JSON.stringify(data));
                      var xhr;
                      if (this._xmlhttprequest !== null) {
                        xhr = new this._xmlhttprequest();
                      } else {
                        xhr = __webpack_require__2.g.XMLHttpRequest ? new __webpack_require__2.g.XMLHttpRequest() : new __webpack_require__2.g.ActiveXObject("Microsoft.XMLHTTP");
                      }
                      for (var i in params) {
                        if (params.hasOwnProperty(i)) {
                          if (query.length > 0) {
                            query += "&";
                          }
                          query += encodeURIComponent(i) + "=" + encodeURIComponent(params[i]);
                        }
                      }
                      if (query.length > 0) {
                        query = "?" + query;
                      }
                      xhr.open("POST", url + query, true);
                      if ("withCredentials" in xhr) {
                        xhr.withCredentials = !this._config.disableWithCredentials;
                      }
                      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                      xhr.setRequestHeader("Content-Type", "application/json");
                      for (var headerName in headers) {
                        if (headers.hasOwnProperty(headerName)) {
                          xhr.setRequestHeader(headerName, headers[headerName]);
                        }
                      }
                      xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                          if (xhr.status === 200) {
                            var _data, parsed = false;
                            try {
                              _data = JSON.parse(xhr.responseText);
                              parsed = true;
                            } catch (e) {
                              callback({
                                error: "Invalid JSON. Data was: " + xhr.responseText,
                                status: 200,
                                data: null
                              });
                            }
                            if (parsed) {
                              callback({
                                data: _data,
                                status: 200
                              });
                            }
                          } else {
                            _this2._log("wrong status code in AJAX response", xhr.status);
                            callback({
                              status: xhr.status,
                              data: null
                            });
                          }
                        }
                      };
                      setTimeout(function() {
                        return xhr.send(JSON.stringify(data));
                      }, 20);
                      return xhr;
                    }
                  }, {
                    key: "_log",
                    value: function _log() {
                      (0, _utils.log)("info", arguments);
                    }
                  }, {
                    key: "_debug",
                    value: function _debug() {
                      if (this._config.debug === true) {
                        (0, _utils.log)("debug", arguments);
                      }
                    }
                  }, {
                    key: "_websocketSupported",
                    value: function _websocketSupported() {
                      if (this._config.websocket !== null) {
                        return true;
                      }
                      return !(typeof WebSocket !== "function" && (typeof WebSocket === "undefined" ? "undefined" : _typeof(WebSocket)) !== "object");
                    }
                  }, {
                    key: "_setFormat",
                    value: function _setFormat(format) {
                      if (this._formatOverride(format)) {
                        return;
                      }
                      if (format === "protobuf") {
                        throw new Error("not implemented by JSON only Centrifuge client – use client with Protobuf");
                      }
                      this._binary = false;
                      this._methodType = _json.JsonMethodType;
                      this._pushType = _json.JsonPushType;
                      this._encoder = new _json.JsonEncoder();
                      this._decoder = new _json.JsonDecoder();
                    }
                  }, {
                    key: "_formatOverride",
                    value: function _formatOverride(format) {
                      return false;
                    }
                  }, {
                    key: "_configure",
                    value: function _configure(configuration) {
                      if (!("Promise" in __webpack_require__2.g)) {
                        throw new Error("Promise polyfill required");
                      }
                      (0, _utils.extend)(this._config, configuration || {});
                      this._debug("centrifuge config", this._config);
                      if (!this._url) {
                        throw new Error("url required");
                      }
                      var isProtobufURL = (0, _utils.startsWith)(this._url, "ws") && this._url.indexOf("format=protobuf") > -1;
                      if (isProtobufURL || this._config.protocol === "protobuf") {
                        this._setFormat("protobuf");
                        this._protocol = "protobuf";
                      } else {
                        if (this._config.protocol !== "" && this._config.protocol !== "json") {
                          throw new Error("unsupported protocol " + this._config.protocol);
                        }
                        this._setFormat("json");
                      }
                      if ((0, _utils.startsWith)(this._url, "http")) {
                        this._debug("client will try to connect to SockJS endpoint");
                        if (this._config.sockjs !== null) {
                          this._debug("SockJS explicitly provided in options");
                          this._sockjs = this._config.sockjs;
                        } else {
                          if (typeof __webpack_require__2.g.SockJS === "undefined") {
                            throw new Error("SockJS not found, use ws:// in url or include SockJS");
                          }
                          this._debug("use globally defined SockJS");
                          this._sockjs = __webpack_require__2.g.SockJS;
                        }
                      } else {
                        this._debug("client will connect to websocket endpoint");
                      }
                      this._xmlhttprequest = this._config.xmlhttprequest;
                    }
                  }, {
                    key: "_setStatus",
                    value: function _setStatus(newStatus) {
                      if (this._status !== newStatus) {
                        this._debug("Status", this._status, "->", newStatus);
                        this._status = newStatus;
                      }
                    }
                  }, {
                    key: "_isDisconnected",
                    value: function _isDisconnected() {
                      return this._status === "disconnected";
                    }
                  }, {
                    key: "_isConnecting",
                    value: function _isConnecting() {
                      return this._status === "connecting";
                    }
                  }, {
                    key: "_isConnected",
                    value: function _isConnected() {
                      return this._status === "connected";
                    }
                  }, {
                    key: "_nextMessageId",
                    value: function _nextMessageId() {
                      return ++this._messageId;
                    }
                  }, {
                    key: "_resetRetry",
                    value: function _resetRetry() {
                      this._debug("reset retries count to 0");
                      this._retries = 0;
                    }
                  }, {
                    key: "_getRetryInterval",
                    value: function _getRetryInterval() {
                      var interval = (0, _utils.backoff)(this._retries, this._config.minRetry, this._config.maxRetry);
                      this._retries += 1;
                      return interval;
                    }
                  }, {
                    key: "_abortInflightXHRs",
                    value: function _abortInflightXHRs() {
                      for (var xhrID in this._xhrs) {
                        try {
                          this._xhrs[xhrID].abort();
                        } catch (e) {
                          this._debug("error aborting xhr", e);
                        }
                        delete this._xhrs[xhrID];
                      }
                    }
                  }, {
                    key: "_clearConnectedState",
                    value: function _clearConnectedState(reconnect) {
                      this._clientID = null;
                      this._stopPing();
                      for (var id in this._callbacks) {
                        if (this._callbacks.hasOwnProperty(id)) {
                          var callbacks = this._callbacks[id];
                          clearTimeout(callbacks.timeout);
                          var errback = callbacks.errback;
                          if (!errback) {
                            continue;
                          }
                          errback({
                            error: this._createErrorObject("disconnected")
                          });
                        }
                      }
                      this._callbacks = {};
                      for (var channel in this._subs) {
                        if (this._subs.hasOwnProperty(channel)) {
                          var sub = this._subs[channel];
                          if (reconnect) {
                            if (sub._isSuccess()) {
                              sub._triggerUnsubscribe();
                              sub._recover = true;
                            }
                            if (sub._shouldResubscribe()) {
                              sub._setSubscribing();
                            }
                          } else {
                            sub._setUnsubscribed();
                          }
                        }
                      }
                      this._abortInflightXHRs();
                      if (this._refreshTimeout !== null) {
                        clearTimeout(this._refreshTimeout);
                        this._refreshTimeout = null;
                      }
                      for (var _channel in this._subRefreshTimeouts) {
                        if (this._subRefreshTimeouts.hasOwnProperty(_channel) && this._subRefreshTimeouts[_channel]) {
                          this._clearSubRefreshTimeout(_channel);
                        }
                      }
                      this._subRefreshTimeouts = {};
                      if (!this._reconnect) {
                        this._subs = {};
                      }
                    }
                  }, {
                    key: "_isTransportOpen",
                    value: function _isTransportOpen() {
                      if (this._isSockjs) {
                        return this._transport && this._transport.transport && this._transport.transport.readyState === this._transport.transport.OPEN;
                      }
                      return this._transport && this._transport.readyState === this._transport.OPEN;
                    }
                  }, {
                    key: "_transportSend",
                    value: function _transportSend(commands) {
                      if (!commands.length) {
                        return true;
                      }
                      if (!this._isTransportOpen()) {
                        for (var command in commands) {
                          var id = command.id;
                          if (!(id in this._callbacks)) {
                            continue;
                          }
                          var callbacks = this._callbacks[id];
                          clearTimeout(this._callbacks[id].timeout);
                          delete this._callbacks[id];
                          var errback = callbacks.errback;
                          errback({
                            error: this._createErrorObject(_errorConnectionClosed, 0)
                          });
                        }
                        return false;
                      }
                      this._transport.send(this._encoder.encodeCommands(commands));
                      return true;
                    }
                  }, {
                    key: "_getSubProtocol",
                    value: function _getSubProtocol() {
                      if (!this._protocol) {
                        return "";
                      }
                      return "centrifuge-" + this._protocol;
                    }
                  }, {
                    key: "_setupTransport",
                    value: function _setupTransport() {
                      var _this3 = this;
                      this._isSockjs = false;
                      if (this._sockjs !== null) {
                        var sockjsOptions = {
                          transports: this._config.sockjsTransports
                        };
                        if (this._config.sockjsServer !== null) {
                          sockjsOptions.server = this._config.sockjsServer;
                        }
                        if (this._config.sockjsTimeout !== null) {
                          sockjsOptions.timeout = this._config.sockjsTimeout;
                        }
                        this._isSockjs = true;
                        this._transport = new this._sockjs(this._url, null, sockjsOptions);
                      } else {
                        if (!this._websocketSupported()) {
                          this._debug("No Websocket support and no SockJS configured, can not connect");
                          throw new Error("No Websocket support and no SockJS configured, can not connect");
                        }
                        if (this._config.websocket !== null) {
                          this._websocket = this._config.websocket;
                        } else {
                          this._websocket = WebSocket;
                        }
                        var subProtocol = this._getSubProtocol();
                        if (subProtocol !== "") {
                          this._transport = new this._websocket(this._url, subProtocol);
                        } else {
                          this._transport = new this._websocket(this._url);
                        }
                        if (this._binary === true) {
                          this._transport.binaryType = "arraybuffer";
                        }
                      }
                      this._transport.onopen = function() {
                        _this3._transportClosed = false;
                        if (_this3._isSockjs) {
                          _this3._transportName = "sockjs-" + _this3._transport.transport;
                          _this3._transport.onheartbeat = function() {
                            return _this3._restartPing();
                          };
                        } else {
                          _this3._transportName = "websocket";
                        }
                        var msg = {
                          // method: this._methodType.CONNECT
                        };
                        if (_this3._token || _this3._connectData || _this3._config.name || _this3._config.version) {
                          msg.params = {};
                        }
                        if (_this3._token) {
                          msg.params.token = _this3._token;
                        }
                        if (_this3._connectData) {
                          msg.params.data = _this3._connectData;
                        }
                        if (_this3._config.name) {
                          msg.params.name = _this3._config.name;
                        }
                        if (_this3._config.version) {
                          msg.params.version = _this3._config.version;
                        }
                        var subs = {};
                        var hasSubs = false;
                        for (var channel in _this3._serverSubs) {
                          if (_this3._serverSubs.hasOwnProperty(channel) && _this3._serverSubs[channel].recoverable) {
                            hasSubs = true;
                            var sub = {
                              "recover": true
                            };
                            if (_this3._serverSubs[channel].seq || _this3._serverSubs[channel].gen) {
                              if (_this3._serverSubs[channel].seq) {
                                sub["seq"] = _this3._serverSubs[channel].seq;
                              }
                              if (_this3._serverSubs[channel].gen) {
                                sub["gen"] = _this3._serverSubs[channel].gen;
                              }
                            } else {
                              if (_this3._serverSubs[channel].offset) {
                                sub["offset"] = _this3._serverSubs[channel].offset;
                              }
                            }
                            if (_this3._serverSubs[channel].epoch) {
                              sub["epoch"] = _this3._serverSubs[channel].epoch;
                            }
                            subs[channel] = sub;
                          }
                        }
                        if (hasSubs) {
                          if (!msg.params) {
                            msg.params = {};
                          }
                          msg.params.subs = subs;
                        }
                        _this3._latencyStart = /* @__PURE__ */ new Date();
                        _this3._call(msg).then(function(resolveCtx) {
                          _this3._connectResponse(_this3._decoder.decodeCommandResult(_this3._methodType.CONNECT, resolveCtx.result), hasSubs);
                          if (resolveCtx.next) {
                            resolveCtx.next();
                          }
                        }, function(rejectCtx) {
                          var err = rejectCtx.error;
                          if (err.code === 109) {
                            _this3._refreshRequired = true;
                          }
                          _this3._disconnect("connect error", true);
                          if (rejectCtx.next) {
                            rejectCtx.next();
                          }
                        });
                      };
                      this._transport.onerror = function(error) {
                        _this3._debug("transport level error", error);
                      };
                      this._transport.onclose = function(closeEvent) {
                        _this3._transportClosed = true;
                        var reason = _errorConnectionClosed;
                        var needReconnect = true;
                        if (closeEvent && "reason" in closeEvent && closeEvent.reason) {
                          try {
                            var advice = JSON.parse(closeEvent.reason);
                            _this3._debug("reason is an advice object", advice);
                            reason = advice.reason;
                            needReconnect = advice.reconnect;
                          } catch (e) {
                            reason = closeEvent.reason;
                            _this3._debug("reason is a plain string", reason);
                          }
                        }
                        if (_this3._config.onTransportClose !== null) {
                          _this3._config.onTransportClose({
                            event: closeEvent,
                            reason,
                            reconnect: needReconnect
                          });
                        }
                        _this3._disconnect(reason, needReconnect);
                        if (_this3._reconnect === true) {
                          _this3._reconnecting = true;
                          var interval = _this3._getRetryInterval();
                          _this3._debug("reconnect after " + interval + " milliseconds");
                          setTimeout(function() {
                            if (_this3._reconnect === true) {
                              if (_this3._refreshRequired) {
                                _this3._refresh();
                              } else {
                                _this3._connect();
                              }
                            }
                          }, interval);
                        }
                      };
                      this._transport.onmessage = function(event) {
                        _this3._dataReceived(event.data);
                      };
                    }
                  }, {
                    key: "rpc",
                    value: function rpc(data) {
                      return this._rpc("", data);
                    }
                  }, {
                    key: "namedRPC",
                    value: function namedRPC(method, data) {
                      return this._rpc(method, data);
                    }
                  }, {
                    key: "_rpc",
                    value: function _rpc(method, data) {
                      var params = {
                        data
                      };
                      if (method !== "") {
                        params.method = method;
                      }
                      ;
                      var msg = {
                        method: this._methodType.RPC,
                        params
                      };
                      return this._methodCall(msg, function(result) {
                        return result;
                      });
                    }
                  }, {
                    key: "send",
                    value: function send(data) {
                      var msg = {
                        method: this._methodType.SEND,
                        params: {
                          data
                        }
                      };
                      if (!this.isConnected()) {
                        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));
                      }
                      var sent = this._transportSend([msg]);
                      if (!sent) {
                        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));
                      }
                      ;
                      return Promise.resolve({});
                    }
                  }, {
                    key: "_getHistoryParams",
                    value: function _getHistoryParams(channel, options) {
                      var params = {
                        channel
                      };
                      if (options !== void 0) {
                        if (options.since) {
                          params["since"] = {
                            "offset": options.since.offset
                          };
                          if (options.since.epoch) {
                            params["since"]["epoch"] = options.since.epoch;
                          }
                        }
                        ;
                        if (options.limit !== void 0) {
                          params["limit"] = options.limit;
                        }
                        if (options.reverse === true) {
                          params["reverse"] = true;
                        }
                      }
                      ;
                      return params;
                    }
                  }, {
                    key: "_methodCall",
                    value: function _methodCall(msg, resultCB) {
                      var _this4 = this;
                      if (!this.isConnected()) {
                        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));
                      }
                      return new Promise(function(resolve, reject) {
                        _this4._call(msg).then(function(resolveCtx) {
                          resolve(resultCB(_this4._decoder.decodeCommandResult(msg.method, resolveCtx.result)));
                          if (resolveCtx.next) {
                            resolveCtx.next();
                          }
                        }, function(rejectCtx) {
                          reject(rejectCtx.error);
                          if (rejectCtx.next) {
                            rejectCtx.next();
                          }
                        });
                      });
                    }
                  }, {
                    key: "publish",
                    value: function publish(channel, data) {
                      var msg = {
                        method: this._methodType.PUBLISH,
                        params: {
                          channel,
                          data
                        }
                      };
                      return this._methodCall(msg, function() {
                        return {};
                      });
                    }
                  }, {
                    key: "history",
                    value: function history(channel, options) {
                      var params = this._getHistoryParams(channel, options);
                      var msg = {
                        method: this._methodType.HISTORY,
                        params
                      };
                      return this._methodCall(msg, function(result) {
                        return {
                          "publications": result.publications,
                          "epoch": result.epoch || "",
                          "offset": result.offset || 0
                        };
                      });
                    }
                  }, {
                    key: "presence",
                    value: function presence(channel) {
                      var msg = {
                        method: this._methodType.PRESENCE,
                        params: {
                          channel
                        }
                      };
                      return this._methodCall(msg, function(result) {
                        return {
                          "presence": result.presence
                        };
                      });
                    }
                  }, {
                    key: "presenceStats",
                    value: function presenceStats(channel) {
                      var msg = {
                        method: this._methodType.PRESENCE_STATS,
                        params: {
                          channel
                        }
                      };
                      return this._methodCall(msg, function(result) {
                        return {
                          "num_users": result.num_users,
                          "num_clients": result.num_clients
                        };
                      });
                    }
                  }, {
                    key: "_dataReceived",
                    value: function _dataReceived(data) {
                      var _this5 = this;
                      var replies = this._decoder.decodeReplies(data);
                      this._dispatchPromise = this._dispatchPromise.then(function() {
                        var finishDispatch;
                        _this5._dispatchPromise = new Promise(function(resolve) {
                          finishDispatch = resolve;
                        });
                        _this5._dispatchSynchronized(replies, finishDispatch);
                      });
                      this._restartPing();
                    }
                  }, {
                    key: "_dispatchSynchronized",
                    value: function _dispatchSynchronized(replies, finishDispatch) {
                      var _this6 = this;
                      var p = Promise.resolve();
                      var _loop = function _loop2(i2) {
                        if (replies.hasOwnProperty(i2)) {
                          p = p.then(function() {
                            return _this6._dispatchReply(replies[i2]);
                          });
                        }
                      };
                      for (var i in replies) {
                        _loop(i);
                      }
                      p = p.then(function() {
                        finishDispatch();
                      });
                    }
                  }, {
                    key: "_dispatchReply",
                    value: function _dispatchReply(reply) {
                      var next;
                      var p = new Promise(function(resolve) {
                        next = resolve;
                      });
                      if (reply === void 0 || reply === null) {
                        this._debug("dispatch: got undefined or null reply");
                        next();
                        return p;
                      }
                      var id = reply.id;
                      if (id && id > 0) {
                        this._handleReply(reply, next);
                      } else {
                        this._handlePush(reply.result, next);
                      }
                      return p;
                    }
                  }, {
                    key: "_call",
                    value: function _call(msg) {
                      var _this7 = this;
                      return new Promise(function(resolve, reject) {
                        var id = _this7._addMessage(msg);
                        _this7._registerCall(id, resolve, reject);
                      });
                    }
                  }, {
                    key: "_connect",
                    value: function _connect() {
                      if (this.isConnected()) {
                        this._debug("connect called when already connected");
                        return;
                      }
                      if (this._status === "connecting") {
                        return;
                      }
                      this._debug("start connecting");
                      this._setStatus("connecting");
                      this._clientID = null;
                      this._reconnect = true;
                      this._setupTransport();
                    }
                  }, {
                    key: "_disconnect",
                    value: function _disconnect(reason, shouldReconnect) {
                      var reconnect = shouldReconnect || false;
                      if (reconnect === false) {
                        this._reconnect = false;
                      }
                      if (this._isDisconnected()) {
                        if (!reconnect) {
                          this._clearConnectedState(reconnect);
                        }
                        return;
                      }
                      this._clearConnectedState(reconnect);
                      this._debug("disconnected:", reason, shouldReconnect);
                      this._setStatus("disconnected");
                      if (this._refreshTimeout) {
                        clearTimeout(this._refreshTimeout);
                        this._refreshTimeout = null;
                      }
                      if (this._reconnecting === false) {
                        for (var channel in this._serverSubs) {
                          if (this._serverSubs.hasOwnProperty(channel)) {
                            this.emit("unsubscribe", {
                              channel
                            });
                          }
                        }
                        this.emit("disconnect", {
                          reason,
                          reconnect
                        });
                      }
                      if (reconnect === false) {
                        this._subs = {};
                        this._serverSubs = {};
                      }
                      if (!this._transportClosed) {
                        this._transport.close();
                      }
                    }
                  }, {
                    key: "_refreshFailed",
                    value: function _refreshFailed() {
                      this._numRefreshFailed = 0;
                      if (!this._isDisconnected()) {
                        this._disconnect("refresh failed", false);
                      }
                      if (this._config.onRefreshFailed !== null) {
                        this._config.onRefreshFailed();
                      }
                    }
                  }, {
                    key: "_refresh",
                    value: function _refresh() {
                      var _this8 = this;
                      this._debug("refresh token");
                      if (this._config.refreshAttempts === 0) {
                        this._debug("refresh attempts set to 0, do not send refresh request at all");
                        this._refreshFailed();
                        return;
                      }
                      if (this._refreshTimeout !== null) {
                        clearTimeout(this._refreshTimeout);
                        this._refreshTimeout = null;
                      }
                      var clientID = this._clientID;
                      var xhrID = this._newXHRID();
                      var cb = function cb2(resp) {
                        if (xhrID in _this8._xhrs) {
                          delete _this8._xhrs[xhrID];
                        }
                        if (_this8._clientID !== clientID) {
                          return;
                        }
                        if (resp.error || resp.status !== 200) {
                          if (resp.error) {
                            _this8._debug("error refreshing connection token", resp.error);
                          } else {
                            _this8._debug("error refreshing connection token: wrong status code", resp.status);
                          }
                          _this8._numRefreshFailed++;
                          if (_this8._refreshTimeout !== null) {
                            clearTimeout(_this8._refreshTimeout);
                            _this8._refreshTimeout = null;
                          }
                          if (_this8._config.refreshAttempts !== null && _this8._numRefreshFailed >= _this8._config.refreshAttempts) {
                            _this8._refreshFailed();
                            return;
                          }
                          var jitter = Math.round(Math.random() * 1e3 * Math.max(_this8._numRefreshFailed, 20));
                          var interval = _this8._config.refreshInterval + jitter;
                          _this8._refreshTimeout = setTimeout(function() {
                            return _this8._refresh();
                          }, interval);
                          return;
                        }
                        _this8._numRefreshFailed = 0;
                        _this8._token = resp.data.token;
                        if (!_this8._token) {
                          _this8._refreshFailed();
                          return;
                        }
                        if (_this8._isDisconnected() && _this8._reconnect) {
                          _this8._debug("token refreshed, connect from scratch");
                          _this8._connect();
                        } else {
                          _this8._debug("send refreshed token");
                          var msg = {
                            method: _this8._methodType.REFRESH,
                            params: {
                              token: _this8._token
                            }
                          };
                          _this8._call(msg).then(function(resolveCtx) {
                            _this8._refreshResponse(_this8._decoder.decodeCommandResult(_this8._methodType.REFRESH, resolveCtx.result));
                            if (resolveCtx.next) {
                              resolveCtx.next();
                            }
                          }, function(rejectCtx) {
                            _this8._refreshError(rejectCtx.error);
                            if (rejectCtx.next) {
                              rejectCtx.next();
                            }
                          });
                        }
                      };
                      if (this._config.onRefresh !== null) {
                        var context = {};
                        this._config.onRefresh(context, cb);
                      } else {
                        var xhr = this._ajax(this._config.refreshEndpoint, this._config.refreshParams, this._config.refreshHeaders, this._config.refreshData, cb);
                        this._xhrs[xhrID] = xhr;
                      }
                    }
                  }, {
                    key: "_refreshError",
                    value: function _refreshError(err) {
                      var _this9 = this;
                      this._debug("refresh error", err);
                      if (this._refreshTimeout) {
                        clearTimeout(this._refreshTimeout);
                        this._refreshTimeout = null;
                      }
                      var interval = this._config.refreshInterval + Math.round(Math.random() * 1e3);
                      this._refreshTimeout = setTimeout(function() {
                        return _this9._refresh();
                      }, interval);
                    }
                  }, {
                    key: "_refreshResponse",
                    value: function _refreshResponse(result) {
                      var _this10 = this;
                      if (this._refreshTimeout) {
                        clearTimeout(this._refreshTimeout);
                        this._refreshTimeout = null;
                      }
                      if (result.expires) {
                        this._clientID = result.client;
                        this._refreshTimeout = setTimeout(function() {
                          return _this10._refresh();
                        }, this._getTTLMilliseconds(result.ttl));
                      }
                    }
                  }, {
                    key: "_newXHRID",
                    value: function _newXHRID() {
                      this._xhrID++;
                      return this._xhrID;
                    }
                  }, {
                    key: "_subRefresh",
                    value: function _subRefresh(channel) {
                      var _this11 = this;
                      this._debug("refresh subscription token for channel", channel);
                      if (this._subRefreshTimeouts[channel] !== void 0) {
                        this._clearSubRefreshTimeout(channel);
                      } else {
                        return;
                      }
                      var clientID = this._clientID;
                      var xhrID = this._newXHRID();
                      var cb = function cb2(resp) {
                        if (xhrID in _this11._xhrs) {
                          delete _this11._xhrs[xhrID];
                        }
                        if (resp.error || resp.status !== 200 || _this11._clientID !== clientID) {
                          return;
                        }
                        var channelsData = {};
                        if (resp.data.channels) {
                          for (var i in resp.data.channels) {
                            var channelData = resp.data.channels[i];
                            if (!channelData.channel) {
                              continue;
                            }
                            channelsData[channelData.channel] = channelData.token;
                          }
                        }
                        var token = channelsData[channel];
                        if (!token) {
                          return;
                        }
                        var msg = {
                          method: _this11._methodType.SUB_REFRESH,
                          params: {
                            channel,
                            token
                          }
                        };
                        var sub = _this11._getSub(channel);
                        if (sub === null) {
                          return;
                        }
                        _this11._call(msg).then(function(resolveCtx) {
                          _this11._subRefreshResponse(channel, _this11._decoder.decodeCommandResult(_this11._methodType.SUB_REFRESH, resolveCtx.result));
                          if (resolveCtx.next) {
                            resolveCtx.next();
                          }
                        }, function(rejectCtx) {
                          _this11._subRefreshError(channel, rejectCtx.error);
                          if (rejectCtx.next) {
                            rejectCtx.next();
                          }
                        });
                      };
                      var data = {
                        client: this._clientID,
                        channels: [channel]
                      };
                      if (this._config.onPrivateSubscribe !== null) {
                        this._config.onPrivateSubscribe({
                          data
                        }, cb);
                      } else {
                        var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);
                        this._xhrs[xhrID] = xhr;
                      }
                    }
                  }, {
                    key: "_clearSubRefreshTimeout",
                    value: function _clearSubRefreshTimeout(channel) {
                      if (this._subRefreshTimeouts[channel] !== void 0) {
                        clearTimeout(this._subRefreshTimeouts[channel]);
                        delete this._subRefreshTimeouts[channel];
                      }
                    }
                  }, {
                    key: "_subRefreshError",
                    value: function _subRefreshError(channel, err) {
                      var _this12 = this;
                      this._debug("subscription refresh error", channel, err);
                      this._clearSubRefreshTimeout(channel);
                      var sub = this._getSub(channel);
                      if (sub === null) {
                        return;
                      }
                      var jitter = Math.round(Math.random() * 1e3);
                      var subRefreshTimeout = setTimeout(function() {
                        return _this12._subRefresh(channel);
                      }, this._config.subRefreshInterval + jitter);
                      this._subRefreshTimeouts[channel] = subRefreshTimeout;
                      return;
                    }
                  }, {
                    key: "_subRefreshResponse",
                    value: function _subRefreshResponse(channel, result) {
                      var _this13 = this;
                      this._debug("subscription refresh success", channel);
                      this._clearSubRefreshTimeout(channel);
                      var sub = this._getSub(channel);
                      if (sub === null) {
                        return;
                      }
                      if (result.expires === true) {
                        var subRefreshTimeout = setTimeout(function() {
                          return _this13._subRefresh(channel);
                        }, this._getTTLMilliseconds(result.ttl));
                        this._subRefreshTimeouts[channel] = subRefreshTimeout;
                      }
                      return;
                    }
                  }, {
                    key: "_subscribe",
                    value: function _subscribe(sub, isResubscribe) {
                      var _this14 = this;
                      this._debug("subscribing on", sub.channel);
                      var channel = sub.channel;
                      if (!(channel in this._subs)) {
                        this._subs[channel] = sub;
                      }
                      if (!this.isConnected()) {
                        sub._setNew();
                        return;
                      }
                      sub._setSubscribing(isResubscribe);
                      var msg = {
                        method: this._methodType.SUBSCRIBE,
                        params: {
                          channel
                        }
                      };
                      if (sub._subscribeData) {
                        msg.params.data = sub._subscribeData;
                      }
                      if ((0, _utils.startsWith)(channel, this._config.privateChannelPrefix)) {
                        if (this._isSubscribeBatching) {
                          this._privateChannels[channel] = true;
                        } else {
                          this.startSubscribeBatching();
                          this._subscribe(sub);
                          this.stopSubscribeBatching();
                        }
                      } else {
                        var recover = sub._needRecover();
                        if (recover === true) {
                          msg.params.recover = true;
                          var seq = this._getLastSeq(channel);
                          var gen = this._getLastGen(channel);
                          if (seq || gen) {
                            if (seq) {
                              msg.params.seq = seq;
                            }
                            if (gen) {
                              msg.params.gen = gen;
                            }
                          } else {
                            var offset = this._getLastOffset(channel);
                            if (offset) {
                              msg.params.offset = offset;
                            }
                          }
                          var epoch = this._getLastEpoch(channel);
                          if (epoch) {
                            msg.params.epoch = epoch;
                          }
                        }
                        this._call(msg).then(function(resolveCtx) {
                          _this14._subscribeResponse(channel, recover, _this14._decoder.decodeCommandResult(_this14._methodType.SUBSCRIBE, resolveCtx.result));
                          if (resolveCtx.next) {
                            resolveCtx.next();
                          }
                        }, function(rejectCtx) {
                          _this14._subscribeError(channel, rejectCtx.error);
                          if (rejectCtx.next) {
                            rejectCtx.next();
                          }
                        });
                      }
                    }
                  }, {
                    key: "_unsubscribe",
                    value: function _unsubscribe(sub) {
                      delete this._subs[sub.channel];
                      delete this._lastOffset[sub.channel];
                      delete this._lastSeq[sub.channel];
                      delete this._lastGen[sub.channel];
                      if (this.isConnected()) {
                        this._addMessage({
                          method: this._methodType.UNSUBSCRIBE,
                          params: {
                            channel: sub.channel
                          }
                        });
                      }
                    }
                  }, {
                    key: "_getTTLMilliseconds",
                    value: function _getTTLMilliseconds(ttl) {
                      return Math.min(ttl * 1e3, 2147483647);
                    }
                  }, {
                    key: "getSub",
                    value: function getSub(channel) {
                      return this._getSub(channel);
                    }
                  }, {
                    key: "_getSub",
                    value: function _getSub(channel) {
                      var sub = this._subs[channel];
                      if (!sub) {
                        return null;
                      }
                      return sub;
                    }
                  }, {
                    key: "_isServerSub",
                    value: function _isServerSub(channel) {
                      return this._serverSubs[channel] !== void 0;
                    }
                  }, {
                    key: "_connectResponse",
                    value: function _connectResponse(result, isRecover) {
                      var _this15 = this;
                      var wasReconnecting = this._reconnecting;
                      this._reconnecting = false;
                      this._resetRetry();
                      this._refreshRequired = false;
                      if (this.isConnected()) {
                        return;
                      }
                      if (this._latencyStart !== null) {
                        this._latency = (/* @__PURE__ */ new Date()).getTime() - this._latencyStart.getTime();
                        this._latencyStart = null;
                      }
                      this._clientID = result.client;
                      this._setStatus("connected");
                      if (this._refreshTimeout) {
                        clearTimeout(this._refreshTimeout);
                      }
                      if (result.expires) {
                        this._refreshTimeout = setTimeout(function() {
                          return _this15._refresh();
                        }, this._getTTLMilliseconds(result.ttl));
                      }
                      this.startBatching();
                      this.startSubscribeBatching();
                      for (var channel in this._subs) {
                        if (this._subs.hasOwnProperty(channel)) {
                          var sub = this._subs[channel];
                          if (sub._shouldResubscribe()) {
                            this._subscribe(sub, wasReconnecting);
                          }
                        }
                      }
                      this.stopSubscribeBatching();
                      this.stopBatching();
                      this._startPing();
                      var ctx = {
                        client: result.client,
                        transport: this._transportName,
                        latency: this._latency
                      };
                      if (result.data) {
                        ctx.data = result.data;
                      }
                      this.emit("connect", ctx);
                      if (result.subs) {
                        this._processServerSubs(result.subs);
                      }
                    }
                  }, {
                    key: "_processServerSubs",
                    value: function _processServerSubs(subs) {
                      for (var channel in subs) {
                        if (subs.hasOwnProperty(channel)) {
                          var sub = subs[channel];
                          var isResubscribe = this._serverSubs[channel] !== void 0;
                          var subCtx = {
                            channel,
                            isResubscribe
                          };
                          subCtx = this._expandSubscribeContext(subCtx, sub);
                          this.emit("subscribe", subCtx);
                        }
                      }
                      for (var _channel2 in subs) {
                        if (subs.hasOwnProperty(_channel2)) {
                          var _sub = subs[_channel2];
                          if (_sub.recovered) {
                            var pubs = _sub.publications;
                            if (pubs && pubs.length > 0) {
                              if (pubs.length > 1 && (!pubs[0].offset || pubs[0].offset > pubs[1].offset)) {
                                pubs = pubs.reverse();
                              }
                              for (var i in pubs) {
                                if (pubs.hasOwnProperty(i)) {
                                  this._handlePublication(_channel2, pubs[i]);
                                }
                              }
                            }
                          }
                          this._serverSubs[_channel2] = {
                            "seq": _sub.seq,
                            "gen": _sub.gen,
                            "offset": _sub.offset,
                            "epoch": _sub.epoch,
                            "recoverable": _sub.recoverable
                          };
                        }
                      }
                    }
                  }, {
                    key: "_stopPing",
                    value: function _stopPing() {
                      if (this._pongTimeout !== null) {
                        clearTimeout(this._pongTimeout);
                        this._pongTimeout = null;
                      }
                      if (this._pingTimeout !== null) {
                        clearTimeout(this._pingTimeout);
                        this._pingTimeout = null;
                      }
                    }
                  }, {
                    key: "_startPing",
                    value: function _startPing() {
                      var _this16 = this;
                      if (this._config.ping !== true || this._config.pingInterval <= 0) {
                        return;
                      }
                      if (!this.isConnected()) {
                        return;
                      }
                      this._pingTimeout = setTimeout(function() {
                        if (!_this16.isConnected()) {
                          _this16._stopPing();
                          return;
                        }
                        _this16.ping();
                        _this16._pongTimeout = setTimeout(function() {
                          _this16._disconnect("no ping", true);
                        }, _this16._config.pongWaitTimeout);
                      }, this._config.pingInterval);
                    }
                  }, {
                    key: "_restartPing",
                    value: function _restartPing() {
                      this._stopPing();
                      this._startPing();
                    }
                  }, {
                    key: "_subscribeError",
                    value: function _subscribeError(channel, error) {
                      var sub = this._getSub(channel);
                      if (!sub) {
                        return;
                      }
                      if (!sub._isSubscribing()) {
                        return;
                      }
                      if (error.code === 0 && error.message === _errorTimeout) {
                        this._disconnect("timeout", true);
                        return;
                      }
                      sub._setSubscribeError(error);
                    }
                  }, {
                    key: "_expandSubscribeContext",
                    value: function _expandSubscribeContext(ctx, result) {
                      var recovered = false;
                      if ("recovered" in result) {
                        recovered = result.recovered;
                      }
                      ctx.recovered = recovered;
                      var positioned = false;
                      if ("positioned" in result) {
                        positioned = result.positioned;
                      }
                      var epoch = "";
                      if ("epoch" in result) {
                        epoch = result.epoch;
                      }
                      var offset = 0;
                      if ("offset" in result) {
                        offset = result.offset;
                      }
                      if (positioned) {
                        ctx.streamPosition = {
                          "offset": offset,
                          "epoch": epoch
                        };
                      }
                      ;
                      if (result.data) {
                        ctx.data = result.data;
                      }
                      return ctx;
                    }
                  }, {
                    key: "_subscribeResponse",
                    value: function _subscribeResponse(channel, isRecover, result) {
                      var _this17 = this;
                      var sub = this._getSub(channel);
                      if (!sub) {
                        return;
                      }
                      if (!sub._isSubscribing()) {
                        return;
                      }
                      sub._setSubscribeSuccess(result);
                      var pubs = result.publications;
                      if (pubs && pubs.length > 0) {
                        if (pubs.length >= 2 && !pubs[0].offset && !pubs[1].offset) {
                          pubs = pubs.reverse();
                        }
                        for (var i in pubs) {
                          if (pubs.hasOwnProperty(i)) {
                            this._handlePublication(channel, pubs[i]);
                          }
                        }
                      }
                      if (result.recoverable && (!isRecover || !result.recovered)) {
                        this._lastSeq[channel] = result.seq || 0;
                        this._lastGen[channel] = result.gen || 0;
                        this._lastOffset[channel] = result.offset || 0;
                      }
                      this._lastEpoch[channel] = result.epoch || "";
                      if (result.recoverable) {
                        sub._recoverable = true;
                      }
                      if (result.expires === true) {
                        var subRefreshTimeout = setTimeout(function() {
                          return _this17._subRefresh(channel);
                        }, this._getTTLMilliseconds(result.ttl));
                        this._subRefreshTimeouts[channel] = subRefreshTimeout;
                      }
                    }
                  }, {
                    key: "_handleReply",
                    value: function _handleReply(reply, next) {
                      var id = reply.id;
                      var result = reply.result;
                      if (!(id in this._callbacks)) {
                        next();
                        return;
                      }
                      var callbacks = this._callbacks[id];
                      clearTimeout(this._callbacks[id].timeout);
                      delete this._callbacks[id];
                      if (!(0, _utils.errorExists)(reply)) {
                        var callback = callbacks.callback;
                        if (!callback) {
                          return;
                        }
                        callback({
                          result,
                          next
                        });
                      } else {
                        var errback = callbacks.errback;
                        if (!errback) {
                          next();
                          return;
                        }
                        var error = reply.error;
                        errback({
                          error,
                          next
                        });
                      }
                    }
                  }, {
                    key: "_handleJoin",
                    value: function _handleJoin(channel, join) {
                      var ctx = {
                        "info": join.info
                      };
                      var sub = this._getSub(channel);
                      if (!sub) {
                        if (this._isServerSub(channel)) {
                          ctx.channel = channel;
                          this.emit("join", ctx);
                        }
                        return;
                      }
                      sub.emit("join", ctx);
                    }
                  }, {
                    key: "_handleLeave",
                    value: function _handleLeave(channel, leave) {
                      var ctx = {
                        "info": leave.info
                      };
                      var sub = this._getSub(channel);
                      if (!sub) {
                        if (this._isServerSub(channel)) {
                          ctx.channel = channel;
                          this.emit("leave", ctx);
                        }
                        return;
                      }
                      sub.emit("leave", ctx);
                    }
                  }, {
                    key: "_handleUnsub",
                    value: function _handleUnsub(channel, unsub) {
                      var ctx = {};
                      var sub = this._getSub(channel);
                      if (!sub) {
                        if (this._isServerSub(channel)) {
                          delete this._serverSubs[channel];
                          ctx.channel = channel;
                          this.emit("unsubscribe", ctx);
                        }
                        return;
                      }
                      sub.unsubscribe();
                      if (unsub.resubscribe === true) {
                        sub.subscribe();
                      }
                    }
                  }, {
                    key: "_handleSub",
                    value: function _handleSub(channel, sub) {
                      this._serverSubs[channel] = {
                        "seq": sub.seq,
                        "gen": sub.gen,
                        "offset": sub.offset,
                        "epoch": sub.epoch,
                        "recoverable": sub.recoverable
                      };
                      var ctx = {
                        "channel": channel,
                        isResubscribe: false
                      };
                      ctx = this._expandSubscribeContext(ctx, sub);
                      this.emit("subscribe", ctx);
                    }
                  }, {
                    key: "_handlePublication",
                    value: function _handlePublication(channel, pub) {
                      var sub = this._getSub(channel);
                      var ctx = {
                        "data": pub.data,
                        "seq": pub.seq,
                        "gen": pub.gen,
                        "offset": pub.offset
                      };
                      if (pub.info) {
                        ctx.info = pub.info;
                      }
                      if (!sub) {
                        if (this._isServerSub(channel)) {
                          if (pub.seq !== void 0) {
                            this._serverSubs[channel].seq = pub.seq;
                          }
                          if (pub.gen !== void 0) {
                            this._serverSubs[channel].gen = pub.gen;
                          }
                          if (pub.offset !== void 0) {
                            this._serverSubs[channel].offset = pub.offset;
                          }
                          ctx.channel = channel;
                          this.emit("publish", ctx);
                        }
                        return;
                      }
                      if (pub.seq !== void 0) {
                        this._lastSeq[channel] = pub.seq;
                      }
                      if (pub.gen !== void 0) {
                        this._lastGen[channel] = pub.gen;
                      }
                      if (pub.offset !== void 0) {
                        this._lastOffset[channel] = pub.offset;
                      }
                      sub.emit("publish", ctx);
                    }
                  }, {
                    key: "_handleMessage",
                    value: function _handleMessage(message) {
                      this.emit("message", message.data);
                    }
                  }, {
                    key: "_handlePush",
                    value: function _handlePush(data, next) {
                      var push = this._decoder.decodePush(data);
                      var type = 0;
                      if ("type" in push) {
                        type = push["type"];
                      }
                      var channel = push.channel;
                      if (type === this._pushType.PUBLICATION) {
                        var pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);
                        this._handlePublication(channel, pub);
                      } else if (type === this._pushType.MESSAGE) {
                        var message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);
                        this._handleMessage(message);
                      } else if (type === this._pushType.JOIN) {
                        var join = this._decoder.decodePushData(this._pushType.JOIN, push.data);
                        this._handleJoin(channel, join);
                      } else if (type === this._pushType.LEAVE) {
                        var leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);
                        this._handleLeave(channel, leave);
                      } else if (type === this._pushType.UNSUBSCRIBE) {
                        var unsub = this._decoder.decodePushData(this._pushType.UNSUBSCRIBE, push.data);
                        this._handleUnsub(channel, unsub);
                      } else if (type === this._pushType.SUBSCRIBE) {
                        var sub = this._decoder.decodePushData(this._pushType.UNSUBSCRIBE, push.data);
                        this._handleSub(channel, sub);
                      }
                      next();
                    }
                  }, {
                    key: "_flush",
                    value: function _flush() {
                      var messages = this._messages.slice(0);
                      this._messages = [];
                      this._transportSend(messages);
                    }
                  }, {
                    key: "_ping",
                    value: function _ping() {
                      var _this18 = this;
                      var msg = {
                        method: this._methodType.PING
                      };
                      this._call(msg).then(function(resolveCtx) {
                        _this18._pingResponse(_this18._decoder.decodeCommandResult(_this18._methodType.PING, resolveCtx.result));
                        if (resolveCtx.next) {
                          resolveCtx.next();
                        }
                      }, function(rejectCtx) {
                        _this18._debug("ping error", rejectCtx.error);
                        if (rejectCtx.next) {
                          rejectCtx.next();
                        }
                      });
                    }
                  }, {
                    key: "_pingResponse",
                    value: function _pingResponse(result) {
                      if (!this.isConnected()) {
                        return;
                      }
                      this._stopPing();
                      this._startPing();
                    }
                  }, {
                    key: "_getLastSeq",
                    value: function _getLastSeq(channel) {
                      var lastSeq = this._lastSeq[channel];
                      if (lastSeq) {
                        return lastSeq;
                      }
                      return 0;
                    }
                  }, {
                    key: "_getLastOffset",
                    value: function _getLastOffset(channel) {
                      var lastOffset = this._lastOffset[channel];
                      if (lastOffset) {
                        return lastOffset;
                      }
                      return 0;
                    }
                  }, {
                    key: "_getLastGen",
                    value: function _getLastGen(channel) {
                      var lastGen = this._lastGen[channel];
                      if (lastGen) {
                        return lastGen;
                      }
                      return 0;
                    }
                  }, {
                    key: "_getLastEpoch",
                    value: function _getLastEpoch(channel) {
                      var lastEpoch = this._lastEpoch[channel];
                      if (lastEpoch) {
                        return lastEpoch;
                      }
                      return "";
                    }
                  }, {
                    key: "_createErrorObject",
                    value: function _createErrorObject(message, code) {
                      var errObject = {
                        message,
                        code: code || 0
                      };
                      return errObject;
                    }
                  }, {
                    key: "_registerCall",
                    value: function _registerCall(id, callback, errback) {
                      var _this19 = this;
                      this._callbacks[id] = {
                        callback,
                        errback,
                        timeout: null
                      };
                      this._callbacks[id].timeout = setTimeout(function() {
                        delete _this19._callbacks[id];
                        if ((0, _utils.isFunction)(errback)) {
                          errback({
                            error: _this19._createErrorObject(_errorTimeout)
                          });
                        }
                      }, this._config.timeout);
                    }
                  }, {
                    key: "_addMessage",
                    value: function _addMessage(message) {
                      var id = this._nextMessageId();
                      message.id = id;
                      if (this._isBatching === true) {
                        this._messages.push(message);
                      } else {
                        this._transportSend([message]);
                      }
                      return id;
                    }
                  }, {
                    key: "isConnected",
                    value: function isConnected() {
                      return this._isConnected();
                    }
                  }, {
                    key: "connect",
                    value: function connect() {
                      this._connect();
                    }
                  }, {
                    key: "disconnect",
                    value: function disconnect() {
                      this._disconnect("client", false);
                    }
                  }, {
                    key: "ping",
                    value: function ping() {
                      return this._ping();
                    }
                  }, {
                    key: "startBatching",
                    value: function startBatching() {
                      this._isBatching = true;
                    }
                  }, {
                    key: "stopBatching",
                    value: function stopBatching() {
                      this._isBatching = false;
                      this._flush();
                    }
                  }, {
                    key: "startSubscribeBatching",
                    value: function startSubscribeBatching() {
                      this._isSubscribeBatching = true;
                    }
                  }, {
                    key: "stopSubscribeBatching",
                    value: function stopSubscribeBatching() {
                      var _this20 = this;
                      this._isSubscribeBatching = false;
                      var authChannels = this._privateChannels;
                      this._privateChannels = {};
                      var channels = [];
                      for (var channel in authChannels) {
                        if (authChannels.hasOwnProperty(channel)) {
                          var sub = this._getSub(channel);
                          if (!sub) {
                            continue;
                          }
                          channels.push(channel);
                        }
                      }
                      if (channels.length === 0) {
                        this._debug("no private channels found, no need to make request");
                        return;
                      }
                      var data = {
                        client: this._clientID,
                        channels
                      };
                      var clientID = this._clientID;
                      var xhrID = this._newXHRID();
                      var cb = function cb2(resp) {
                        if (xhrID in _this20._xhrs) {
                          delete _this20._xhrs[xhrID];
                        }
                        if (_this20._clientID !== clientID) {
                          return;
                        }
                        if (resp.error || resp.status !== 200) {
                          _this20._debug("authorization request failed");
                          for (var i in channels) {
                            if (channels.hasOwnProperty(i)) {
                              var _channel3 = channels[i];
                              _this20._subscribeError(_channel3, _this20._createErrorObject("authorization request failed"));
                            }
                          }
                          return;
                        }
                        var channelsData = {};
                        if (resp.data.channels) {
                          for (var _i in resp.data.channels) {
                            var channelData = resp.data.channels[_i];
                            if (!channelData.channel) {
                              continue;
                            }
                            channelsData[channelData.channel] = channelData.token;
                          }
                        }
                        var batch = false;
                        if (!_this20._isBatching) {
                          _this20.startBatching();
                          batch = true;
                        }
                        for (var _i2 in channels) {
                          if (channels.hasOwnProperty(_i2)) {
                            var _ret = function() {
                              var channel2 = channels[_i2];
                              var token = channelsData[channel2];
                              if (!token) {
                                _this20._subscribeError(channel2, _this20._createErrorObject("permission denied", 103));
                                return "continue";
                              } else {
                                var msg = {
                                  method: _this20._methodType.SUBSCRIBE,
                                  params: {
                                    channel: channel2,
                                    token
                                  }
                                };
                                var _sub2 = _this20._getSub(channel2);
                                if (_sub2 === null) {
                                  return "continue";
                                }
                                var recover = _sub2._needRecover();
                                if (recover === true) {
                                  msg.params.recover = true;
                                  var seq = _this20._getLastSeq(channel2);
                                  var gen = _this20._getLastGen(channel2);
                                  if (seq || gen) {
                                    if (seq) {
                                      msg.params.seq = seq;
                                    }
                                    if (gen) {
                                      msg.params.gen = gen;
                                    }
                                  } else {
                                    var offset = _this20._getLastOffset(channel2);
                                    if (offset) {
                                      msg.params.offset = offset;
                                    }
                                  }
                                  var epoch = _this20._getLastEpoch(channel2);
                                  if (epoch) {
                                    msg.params.epoch = epoch;
                                  }
                                }
                                _this20._call(msg).then(function(resolveCtx) {
                                  _this20._subscribeResponse(channel2, recover, _this20._decoder.decodeCommandResult(_this20._methodType.SUBSCRIBE, resolveCtx.result));
                                  if (resolveCtx.next) {
                                    resolveCtx.next();
                                  }
                                }, function(rejectCtx) {
                                  _this20._subscribeError(channel2, rejectCtx.error);
                                  if (rejectCtx.next) {
                                    rejectCtx.next();
                                  }
                                });
                              }
                            }();
                            if (_ret === "continue")
                              continue;
                          }
                        }
                        if (batch) {
                          _this20.stopBatching();
                        }
                      };
                      if (this._config.onPrivateSubscribe !== null) {
                        this._config.onPrivateSubscribe({
                          data
                        }, cb);
                      } else {
                        var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);
                        this._xhrs[xhrID] = xhr;
                      }
                    }
                  }, {
                    key: "_setSubscribeSince",
                    value: function _setSubscribeSince(sub, since) {
                      this._lastOffset[sub.channel] = since.offset;
                      this._lastEpoch[sub.channel] = since.epoch;
                      sub._setNeedRecover(true);
                    }
                  }, {
                    key: "subscribe",
                    value: function subscribe(channel, events, opts) {
                      var currentSub = this._getSub(channel);
                      if (currentSub !== null) {
                        currentSub._setEvents(events);
                        if (currentSub._isUnsubscribed()) {
                          currentSub.subscribe(opts);
                        }
                        return currentSub;
                      }
                      var sub = new _subscription["default"](this, channel, events);
                      this._subs[channel] = sub;
                      sub.subscribe(opts);
                      return sub;
                    }
                  }]);
                  return Centrifuge2;
                }(_events["default"]);
                exports3.Centrifuge = Centrifuge;
              }
            ),
            /***/
            579: (
              /***/
              function(module3, exports3, __webpack_require__2) {
                Object.defineProperty(exports3, "__esModule", {
                  value: true
                });
                exports3["default"] = void 0;
                var _centrifuge = __webpack_require__2(382);
                var _default = _centrifuge.Centrifuge;
                exports3["default"] = _default;
                module3.exports = exports3["default"];
              }
            ),
            /***/
            147: (
              /***/
              function(__unused_webpack_module, exports3) {
                Object.defineProperty(exports3, "__esModule", {
                  value: true
                });
                exports3.JsonPushType = exports3.JsonMethodType = exports3.JsonEncoder = exports3.JsonDecoder = void 0;
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                var JsonMethodType = {
                  CONNECT: 0,
                  SUBSCRIBE: 1,
                  UNSUBSCRIBE: 2,
                  PUBLISH: 3,
                  PRESENCE: 4,
                  PRESENCE_STATS: 5,
                  HISTORY: 6,
                  PING: 7,
                  SEND: 8,
                  RPC: 9,
                  REFRESH: 10,
                  SUB_REFRESH: 11
                };
                exports3.JsonMethodType = JsonMethodType;
                var JsonPushType = {
                  PUBLICATION: 0,
                  JOIN: 1,
                  LEAVE: 2,
                  UNSUBSCRIBE: 3,
                  MESSAGE: 4,
                  SUBSCRIBE: 5
                };
                exports3.JsonPushType = JsonPushType;
                var JsonEncoder = function() {
                  function JsonEncoder2() {
                    _classCallCheck(this, JsonEncoder2);
                  }
                  _createClass(JsonEncoder2, [{
                    key: "encodeCommands",
                    value: function encodeCommands(commands) {
                      return commands.map(function(c) {
                        return JSON.stringify(c);
                      }).join("\n");
                    }
                  }]);
                  return JsonEncoder2;
                }();
                exports3.JsonEncoder = JsonEncoder;
                var JsonDecoder = function() {
                  function JsonDecoder2() {
                    _classCallCheck(this, JsonDecoder2);
                  }
                  _createClass(JsonDecoder2, [{
                    key: "decodeReplies",
                    value: function decodeReplies(data) {
                      return data.split("\n").filter(function(r) {
                        return r !== "";
                      }).map(function(r) {
                        return JSON.parse(r);
                      });
                    }
                  }, {
                    key: "decodeCommandResult",
                    value: function decodeCommandResult(methodType, data) {
                      return data;
                    }
                  }, {
                    key: "decodePush",
                    value: function decodePush(data) {
                      return data;
                    }
                  }, {
                    key: "decodePushData",
                    value: function decodePushData(pushType, data) {
                      return data;
                    }
                  }]);
                  return JsonDecoder2;
                }();
                exports3.JsonDecoder = JsonDecoder;
              }
            ),
            /***/
            471: (
              /***/
              function(module3, exports3, __webpack_require__2) {
                function _typeof(obj2) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj3) {
                      return typeof obj3;
                    };
                  } else {
                    _typeof = function _typeof2(obj3) {
                      return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
                    };
                  }
                  return _typeof(obj2);
                }
                Object.defineProperty(exports3, "__esModule", {
                  value: true
                });
                exports3["default"] = void 0;
                var _events = _interopRequireDefault(__webpack_require__2(187));
                var _utils = __webpack_require__2(853);
                function _interopRequireDefault(obj2) {
                  return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _createSuper(Derived) {
                  var hasNativeReflectConstruct = _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super = _getPrototypeOf(Derived), result;
                    if (hasNativeReflectConstruct) {
                      var NewTarget = _getPrototypeOf(this).constructor;
                      result = Reflect.construct(Super, arguments, NewTarget);
                    } else {
                      result = Super.apply(this, arguments);
                    }
                    return _possibleConstructorReturn(this, result);
                  };
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                  } else if (call !== void 0) {
                    throw new TypeError("Derived constructors may only return object or undefined");
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                var _STATE_NEW = 0;
                var _STATE_SUBSCRIBING = 1;
                var _STATE_SUCCESS = 2;
                var _STATE_ERROR = 3;
                var _STATE_UNSUBSCRIBED = 4;
                var Subscription = function(_EventEmitter) {
                  _inherits(Subscription2, _EventEmitter);
                  var _super = _createSuper(Subscription2);
                  function Subscription2(centrifuge, channel, events) {
                    var _this;
                    _classCallCheck(this, Subscription2);
                    _this = _super.call(this);
                    _this.channel = channel;
                    _this._centrifuge = centrifuge;
                    _this._status = _STATE_NEW;
                    _this._error = null;
                    _this._isResubscribe = false;
                    _this._ready = false;
                    _this._subscriptionPromise = null;
                    _this._noResubscribe = false;
                    _this._recoverable = false;
                    _this._recover = false;
                    _this._setEvents(events);
                    _this._initializePromise();
                    _this._promises = {};
                    _this._promiseId = 0;
                    _this._subscribeData = null;
                    _this.on("error", function(errContext) {
                      this._centrifuge._debug("subscription error", errContext);
                    });
                    return _this;
                  }
                  _createClass(Subscription2, [{
                    key: "_nextPromiseId",
                    value: function _nextPromiseId() {
                      return ++this._promiseId;
                    }
                  }, {
                    key: "_initializePromise",
                    value: function _initializePromise() {
                      var _this2 = this;
                      this._ready = false;
                      this._subscriptionPromise = new Promise(function(resolve, reject) {
                        _this2._resolve = function(value) {
                          _this2._ready = true;
                          resolve(value);
                        };
                        _this2._reject = function(err) {
                          _this2._ready = true;
                          reject(err);
                        };
                      }).then(function() {
                      }, function() {
                      });
                    }
                  }, {
                    key: "_setNeedRecover",
                    value: function _setNeedRecover(enabled) {
                      this._recoverable = enabled;
                      this._recover = enabled;
                    }
                  }, {
                    key: "_needRecover",
                    value: function _needRecover() {
                      return this._recoverable === true && this._recover === true;
                    }
                  }, {
                    key: "_setEvents",
                    value: function _setEvents(events) {
                      if (!events) {
                        return;
                      }
                      if ((0, _utils.isFunction)(events)) {
                        this.on("publish", events);
                      } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {
                        var knownEvents = ["publish", "join", "leave", "unsubscribe", "subscribe", "error"];
                        for (var i = 0, l = knownEvents.length; i < l; i++) {
                          var ev = knownEvents[i];
                          if (ev in events) {
                            this.on(ev, events[ev]);
                          }
                        }
                      }
                    }
                  }, {
                    key: "_isNew",
                    value: function _isNew() {
                      return this._status === _STATE_NEW;
                    }
                  }, {
                    key: "_isUnsubscribed",
                    value: function _isUnsubscribed() {
                      return this._status === _STATE_UNSUBSCRIBED;
                    }
                  }, {
                    key: "_isSubscribing",
                    value: function _isSubscribing() {
                      return this._status === _STATE_SUBSCRIBING;
                    }
                  }, {
                    key: "_isReady",
                    value: function _isReady() {
                      return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;
                    }
                  }, {
                    key: "_isSuccess",
                    value: function _isSuccess() {
                      return this._status === _STATE_SUCCESS;
                    }
                  }, {
                    key: "_isError",
                    value: function _isError() {
                      return this._status === _STATE_ERROR;
                    }
                  }, {
                    key: "_setNew",
                    value: function _setNew() {
                      this._status = _STATE_NEW;
                    }
                  }, {
                    key: "_setSubscribing",
                    value: function _setSubscribing(isResubscribe) {
                      this._isResubscribe = isResubscribe || false;
                      if (this._ready === true) {
                        this._initializePromise();
                      }
                      this._status = _STATE_SUBSCRIBING;
                    }
                  }, {
                    key: "_setSubscribeSuccess",
                    value: function _setSubscribeSuccess(subscribeResult) {
                      if (this._status === _STATE_SUCCESS) {
                        return;
                      }
                      this._status = _STATE_SUCCESS;
                      var successContext = this._getSubscribeSuccessContext(subscribeResult);
                      this._recover = false;
                      this.emit("subscribe", successContext);
                      this._resolve(successContext);
                      for (var id in this._promises) {
                        clearTimeout(this._promises[id].timeout);
                        this._promises[id].resolve();
                        delete this._promises[id];
                      }
                    }
                  }, {
                    key: "_setSubscribeError",
                    value: function _setSubscribeError(err) {
                      if (this._status === _STATE_ERROR) {
                        return;
                      }
                      this._status = _STATE_ERROR;
                      this._error = err;
                      var errContext = this._getSubscribeErrorContext();
                      this.emit("error", errContext);
                      this._reject(errContext);
                      for (var id in this._promises) {
                        clearTimeout(this._promises[id].timeout);
                        this._promises[id].reject(err);
                        delete this._promises[id];
                      }
                    }
                  }, {
                    key: "_triggerUnsubscribe",
                    value: function _triggerUnsubscribe() {
                      this.emit("unsubscribe", {
                        channel: this.channel
                      });
                    }
                  }, {
                    key: "_setUnsubscribed",
                    value: function _setUnsubscribed(noResubscribe) {
                      this._centrifuge._clearSubRefreshTimeout(this.channel);
                      if (this._status === _STATE_UNSUBSCRIBED) {
                        return;
                      }
                      var needTrigger = this._status === _STATE_SUCCESS;
                      this._status = _STATE_UNSUBSCRIBED;
                      if (noResubscribe === true) {
                        this._recover = false;
                        this._noResubscribe = true;
                        delete this._centrifuge._lastSeq[this.channel];
                        delete this._centrifuge._lastGen[this.channel];
                        delete this._centrifuge._lastEpoch[this.channel];
                      }
                      if (needTrigger) {
                        this._triggerUnsubscribe();
                      }
                    }
                  }, {
                    key: "_shouldResubscribe",
                    value: function _shouldResubscribe() {
                      return !this._noResubscribe;
                    }
                  }, {
                    key: "_getSubscribeSuccessContext",
                    value: function _getSubscribeSuccessContext(subscribeResult) {
                      var ctx = {
                        channel: this.channel,
                        isResubscribe: this._isResubscribe
                      };
                      if (subscribeResult) {
                        ctx = this._centrifuge._expandSubscribeContext(ctx, subscribeResult);
                      }
                      return ctx;
                    }
                  }, {
                    key: "_getSubscribeErrorContext",
                    value: function _getSubscribeErrorContext() {
                      var subscribeErrorContext = this._error;
                      subscribeErrorContext.channel = this.channel;
                      subscribeErrorContext.isResubscribe = this._isResubscribe;
                      return subscribeErrorContext;
                    }
                  }, {
                    key: "_setSubscribeData",
                    value: function _setSubscribeData(data) {
                      this._subscribeData = data;
                    }
                  }, {
                    key: "ready",
                    value: function ready(callback, errback) {
                      if (this._ready) {
                        if (this._isSuccess()) {
                          callback(this._getSubscribeSuccessContext());
                        } else {
                          errback(this._getSubscribeErrorContext());
                        }
                      }
                    }
                  }, {
                    key: "subscribe",
                    value: function subscribe(opts) {
                      if (this._status === _STATE_SUCCESS) {
                        return;
                      }
                      if (opts && opts.since) {
                        this._centrifuge._setSubscribeSince(this, opts.since);
                      }
                      if (opts && opts.data) {
                        this._setSubscribeData(opts.data);
                      }
                      this._noResubscribe = false;
                      this._centrifuge._subscribe(this);
                    }
                  }, {
                    key: "unsubscribe",
                    value: function unsubscribe() {
                      this._setUnsubscribed(true);
                      this._centrifuge._unsubscribe(this);
                    }
                  }, {
                    key: "_methodCall",
                    value: function _methodCall() {
                      var _this3 = this;
                      if (this._isSuccess()) {
                        return Promise.resolve();
                      } else if (this._isError()) {
                        return Promise.reject(this._error);
                      }
                      var subPromise = new Promise(function(res, rej) {
                        var timeout = setTimeout(function() {
                          rej({
                            "code": 0,
                            "message": "timeout"
                          });
                        }, _this3._centrifuge._config.timeout);
                        _this3._promises[_this3._nextPromiseId()] = {
                          timeout,
                          resolve: res,
                          reject: rej
                        };
                      });
                      return subPromise;
                    }
                  }, {
                    key: "publish",
                    value: function publish(data) {
                      var self2 = this;
                      return this._methodCall().then(function() {
                        return self2._centrifuge.publish(self2.channel, data);
                      });
                    }
                  }, {
                    key: "presence",
                    value: function presence() {
                      var self2 = this;
                      return this._methodCall().then(function() {
                        return self2._centrifuge.presence(self2.channel);
                      });
                    }
                  }, {
                    key: "presenceStats",
                    value: function presenceStats() {
                      var self2 = this;
                      return this._methodCall().then(function() {
                        return self2._centrifuge.presenceStats(self2.channel);
                      });
                    }
                  }, {
                    key: "history",
                    value: function history(options) {
                      var self2 = this;
                      return this._methodCall().then(function() {
                        return self2._centrifuge.history(self2.channel, options);
                      });
                    }
                  }]);
                  return Subscription2;
                }(_events["default"]);
                exports3["default"] = Subscription;
                module3.exports = exports3["default"];
              }
            ),
            /***/
            853: (
              /***/
              function(__unused_webpack_module, exports3, __webpack_require__2) {
                Object.defineProperty(exports3, "__esModule", {
                  value: true
                });
                exports3.backoff = backoff;
                exports3.errorExists = errorExists;
                exports3.extend = extend;
                exports3.isFunction = isFunction;
                exports3.log = log;
                exports3.startsWith = startsWith;
                function startsWith(value, prefix) {
                  return value.lastIndexOf(prefix, 0) === 0;
                }
                ;
                function isFunction(value) {
                  if (value === void 0 || value === null) {
                    return false;
                  }
                  return typeof value === "function";
                }
                ;
                function log(level, args) {
                  if (__webpack_require__2.g.console) {
                    var logger = __webpack_require__2.g.console[level];
                    if (isFunction(logger)) {
                      logger.apply(__webpack_require__2.g.console, args);
                    }
                  }
                }
                ;
                function backoff(step, min, max) {
                  var jitter = 0.5 * Math.random();
                  var interval = Math.min(max, min * Math.pow(2, step + 1));
                  return Math.floor((1 - jitter) * interval);
                }
                ;
                function errorExists(data) {
                  return "error" in data && data.error !== null;
                }
                ;
                function extend(a, b) {
                  for (var key in b) {
                    if (b.hasOwnProperty(key)) {
                      a[key] = b[key];
                    }
                  }
                  return a;
                }
                ;
              }
            ),
            /***/
            187: (
              /***/
              function(module3) {
                var R = typeof Reflect === "object" ? Reflect : null;
                var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver2, args) {
                  return Function.prototype.apply.call(target, receiver2, args);
                };
                var ReflectOwnKeys;
                if (R && typeof R.ownKeys === "function") {
                  ReflectOwnKeys = R.ownKeys;
                } else if (Object.getOwnPropertySymbols) {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                  };
                } else {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target);
                  };
                }
                function ProcessEmitWarning(warning) {
                  if (console && console.warn)
                    console.warn(warning);
                }
                var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                  return value !== value;
                };
                function EventEmitter() {
                  EventEmitter.init.call(this);
                }
                module3.exports = EventEmitter;
                module3.exports.once = once;
                EventEmitter.EventEmitter = EventEmitter;
                EventEmitter.prototype._events = void 0;
                EventEmitter.prototype._eventsCount = 0;
                EventEmitter.prototype._maxListeners = void 0;
                var defaultMaxListeners = 10;
                function checkListener(listener) {
                  if (typeof listener !== "function") {
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                  }
                }
                Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                  enumerable: true,
                  get: function() {
                    return defaultMaxListeners;
                  },
                  set: function(arg) {
                    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                    }
                    defaultMaxListeners = arg;
                  }
                });
                EventEmitter.init = function() {
                  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                  }
                  this._maxListeners = this._maxListeners || void 0;
                };
                EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                  }
                  this._maxListeners = n;
                  return this;
                };
                function _getMaxListeners(that) {
                  if (that._maxListeners === void 0)
                    return EventEmitter.defaultMaxListeners;
                  return that._maxListeners;
                }
                EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                  return _getMaxListeners(this);
                };
                EventEmitter.prototype.emit = function emit(type) {
                  var args = [];
                  for (var i = 1; i < arguments.length; i++)
                    args.push(arguments[i]);
                  var doError = type === "error";
                  var events = this._events;
                  if (events !== void 0)
                    doError = doError && events.error === void 0;
                  else if (!doError)
                    return false;
                  if (doError) {
                    var er;
                    if (args.length > 0)
                      er = args[0];
                    if (er instanceof Error) {
                      throw er;
                    }
                    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                    err.context = er;
                    throw err;
                  }
                  var handler = events[type];
                  if (handler === void 0)
                    return false;
                  if (typeof handler === "function") {
                    ReflectApply(handler, this, args);
                  } else {
                    var len = handler.length;
                    var listeners = arrayClone(handler, len);
                    for (var i = 0; i < len; ++i)
                      ReflectApply(listeners[i], this, args);
                  }
                  return true;
                };
                function _addListener(target, type, listener, prepend) {
                  var m;
                  var events;
                  var existing;
                  checkListener(listener);
                  events = target._events;
                  if (events === void 0) {
                    events = target._events = /* @__PURE__ */ Object.create(null);
                    target._eventsCount = 0;
                  } else {
                    if (events.newListener !== void 0) {
                      target.emit(
                        "newListener",
                        type,
                        listener.listener ? listener.listener : listener
                      );
                      events = target._events;
                    }
                    existing = events[type];
                  }
                  if (existing === void 0) {
                    existing = events[type] = listener;
                    ++target._eventsCount;
                  } else {
                    if (typeof existing === "function") {
                      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                    } else if (prepend) {
                      existing.unshift(listener);
                    } else {
                      existing.push(listener);
                    }
                    m = _getMaxListeners(target);
                    if (m > 0 && existing.length > m && !existing.warned) {
                      existing.warned = true;
                      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                      w.name = "MaxListenersExceededWarning";
                      w.emitter = target;
                      w.type = type;
                      w.count = existing.length;
                      ProcessEmitWarning(w);
                    }
                  }
                  return target;
                }
                EventEmitter.prototype.addListener = function addListener(type, listener) {
                  return _addListener(this, type, listener, false);
                };
                EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                EventEmitter.prototype.prependListener = function prependListener(type, listener) {
                  return _addListener(this, type, listener, true);
                };
                function onceWrapper() {
                  if (!this.fired) {
                    this.target.removeListener(this.type, this.wrapFn);
                    this.fired = true;
                    if (arguments.length === 0)
                      return this.listener.call(this.target);
                    return this.listener.apply(this.target, arguments);
                  }
                }
                function _onceWrap(target, type, listener) {
                  var state = { fired: false, wrapFn: void 0, target, type, listener };
                  var wrapped = onceWrapper.bind(state);
                  wrapped.listener = listener;
                  state.wrapFn = wrapped;
                  return wrapped;
                }
                EventEmitter.prototype.once = function once2(type, listener) {
                  checkListener(listener);
                  this.on(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                  checkListener(listener);
                  this.prependListener(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter.prototype.removeListener = function removeListener(type, listener) {
                  var list, events, position, i, originalListener;
                  checkListener(listener);
                  events = this._events;
                  if (events === void 0)
                    return this;
                  list = events[type];
                  if (list === void 0)
                    return this;
                  if (list === listener || list.listener === listener) {
                    if (--this._eventsCount === 0)
                      this._events = /* @__PURE__ */ Object.create(null);
                    else {
                      delete events[type];
                      if (events.removeListener)
                        this.emit("removeListener", type, list.listener || listener);
                    }
                  } else if (typeof list !== "function") {
                    position = -1;
                    for (i = list.length - 1; i >= 0; i--) {
                      if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                      }
                    }
                    if (position < 0)
                      return this;
                    if (position === 0)
                      list.shift();
                    else {
                      spliceOne(list, position);
                    }
                    if (list.length === 1)
                      events[type] = list[0];
                    if (events.removeListener !== void 0)
                      this.emit("removeListener", type, originalListener || listener);
                  }
                  return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
                  var listeners, events, i;
                  events = this._events;
                  if (events === void 0)
                    return this;
                  if (events.removeListener === void 0) {
                    if (arguments.length === 0) {
                      this._events = /* @__PURE__ */ Object.create(null);
                      this._eventsCount = 0;
                    } else if (events[type] !== void 0) {
                      if (--this._eventsCount === 0)
                        this._events = /* @__PURE__ */ Object.create(null);
                      else
                        delete events[type];
                    }
                    return this;
                  }
                  if (arguments.length === 0) {
                    var keys = Object.keys(events);
                    var key;
                    for (i = 0; i < keys.length; ++i) {
                      key = keys[i];
                      if (key === "removeListener")
                        continue;
                      this.removeAllListeners(key);
                    }
                    this.removeAllListeners("removeListener");
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                    return this;
                  }
                  listeners = events[type];
                  if (typeof listeners === "function") {
                    this.removeListener(type, listeners);
                  } else if (listeners !== void 0) {
                    for (i = listeners.length - 1; i >= 0; i--) {
                      this.removeListener(type, listeners[i]);
                    }
                  }
                  return this;
                };
                function _listeners(target, type, unwrap) {
                  var events = target._events;
                  if (events === void 0)
                    return [];
                  var evlistener = events[type];
                  if (evlistener === void 0)
                    return [];
                  if (typeof evlistener === "function")
                    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
                }
                EventEmitter.prototype.listeners = function listeners(type) {
                  return _listeners(this, type, true);
                };
                EventEmitter.prototype.rawListeners = function rawListeners(type) {
                  return _listeners(this, type, false);
                };
                EventEmitter.listenerCount = function(emitter, type) {
                  if (typeof emitter.listenerCount === "function") {
                    return emitter.listenerCount(type);
                  } else {
                    return listenerCount.call(emitter, type);
                  }
                };
                EventEmitter.prototype.listenerCount = listenerCount;
                function listenerCount(type) {
                  var events = this._events;
                  if (events !== void 0) {
                    var evlistener = events[type];
                    if (typeof evlistener === "function") {
                      return 1;
                    } else if (evlistener !== void 0) {
                      return evlistener.length;
                    }
                  }
                  return 0;
                }
                EventEmitter.prototype.eventNames = function eventNames() {
                  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                };
                function arrayClone(arr, n) {
                  var copy = new Array(n);
                  for (var i = 0; i < n; ++i)
                    copy[i] = arr[i];
                  return copy;
                }
                function spliceOne(list, index) {
                  for (; index + 1 < list.length; index++)
                    list[index] = list[index + 1];
                  list.pop();
                }
                function unwrapListeners(arr) {
                  var ret2 = new Array(arr.length);
                  for (var i = 0; i < ret2.length; ++i) {
                    ret2[i] = arr[i].listener || arr[i];
                  }
                  return ret2;
                }
                function once(emitter, name) {
                  return new Promise(function(resolve, reject) {
                    function errorListener(err) {
                      emitter.removeListener(name, resolver);
                      reject(err);
                    }
                    function resolver() {
                      if (typeof emitter.removeListener === "function") {
                        emitter.removeListener("error", errorListener);
                      }
                      resolve([].slice.call(arguments));
                    }
                    ;
                    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                    if (name !== "error") {
                      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                    }
                  });
                }
                function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                  if (typeof emitter.on === "function") {
                    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                  }
                }
                function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                  if (typeof emitter.on === "function") {
                    if (flags.once) {
                      emitter.once(name, listener);
                    } else {
                      emitter.on(name, listener);
                    }
                  } else if (typeof emitter.addEventListener === "function") {
                    emitter.addEventListener(name, function wrapListener(arg) {
                      if (flags.once) {
                        emitter.removeEventListener(name, wrapListener);
                      }
                      listener(arg);
                    });
                  } else {
                    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                  }
                }
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module3 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module3, module3.exports, __webpack_require__);
            return module3.exports;
          }
          !function() {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object")
                return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object")
                  return window;
              }
            }();
          }();
          var __webpack_exports__ = __webpack_require__(579);
          return __webpack_exports__;
        }()
      );
    });
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/node_modules/ws/browser.js
var require_browser4 = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/node_modules/ws/browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/ClientMessenger/TransactionNotifier.js
var require_TransactionNotifier = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/ClientMessenger/TransactionNotifier.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TransactionNotifier = class {
      constructor(transactionId, socketClient, options) {
        this.socketClient = socketClient;
        this.transactionId = transactionId;
        this.onMined = options.onMinedHandler;
        this.onHashGenerated = options.onHashGeneratedHandler;
        this.onHashChanged = options.onHashChanged;
        this.onError = options.onErrorHandler;
        this.socketClient.subscribe(`transaction:${transactionId}`, this.transactionNotifierMessageHandler.bind(this));
      }
      transactionNotifierMessageHandler(messageCtx) {
        const { transactionId, event } = messageCtx.data;
        try {
          if (!transactionId || transactionId !== this.transactionId) {
            throw new Error(`Invalid message received, expected the transactionId to be ${this.transactionId}
: ${JSON.stringify(messageCtx, void 0, 4)}`);
          }
          if (event === "transactionHashGenerated" && this.onHashGenerated) {
            this.transactionHash = messageCtx.data.transactionHash;
            this.onHashGenerated(this);
            delete this.onHashGenerated;
          } else if (event === "transactionMined" && this.onMined) {
            this.transactionHash = messageCtx.data.transactionHash;
            this.receipt = messageCtx.data.receipt;
            this.onMined(this);
            delete this.onMined;
          } else if (event === "error" && this.onError) {
            this.error = messageCtx.data.error;
            this.onError(this);
            delete this.onError;
          } else if (event === "transactionHashChanged" && this.onHashChanged) {
            this.transactionHash = messageCtx.data.transactionHash;
            this.onHashChanged(this);
          }
        } catch (e) {
          console.error(e);
        }
      }
    };
    exports2.default = TransactionNotifier;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/ClientMessenger/index.js
var require_ClientMessenger = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/ClientMessenger/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var centrifuge_1 = __importDefault(require_centrifuge());
    var ws_1 = require_browser4();
    var TransactionNotifier_1 = __importDefault(require_TransactionNotifier());
    var ClientMessenger = class {
      constructor(socketClientEndpoint, websocket) {
        this.socketClient = new centrifuge_1.default(socketClientEndpoint, {
          debug: process.env.BICONOMY_SDK_DEBUG === "true" || process.env.REACT_APP_BICONOMY_SDK_DEBUG === "true",
          websocket: websocket || ws_1.WebSocket
        });
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          yield new Promise((resolve) => {
            this.socketClient.on("connect", () => {
              resolve();
            });
            this.socketClient.on("error", (error) => {
              console.error("Error while connecting to socket server in client messenger", error);
            });
            this.socketClient.connect();
          });
        });
      }
      createTransactionNotifier(transactionId, options = {}) {
        return new TransactionNotifier_1.default(transactionId, this.socketClient, {
          onMinedHandler: options.onMined,
          onHashGeneratedHandler: options.onHashGenerated,
          onErrorHandler: options.onError,
          onHashChanged: options.onHashChanged
        });
      }
      unsubscribe(transactionId) {
        const subscription = this.socketClient.getSub(`transaction:${transactionId}`);
        subscription.unsubscribe();
      }
    };
    exports2.default = ClientMessenger;
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj2, fn) {
      if (obj2 === null || typeof obj2 === "undefined") {
        return;
      }
      if (typeof obj2 !== "object") {
        obj2 = [obj2];
      }
      if (isArray(obj2)) {
        for (var i = 0, l = obj2.length; i < l; i++) {
          fn.call(null, obj2[i], i, obj2);
        }
      } else {
        for (var key in obj2) {
          if (Object.prototype.hasOwnProperty.call(obj2, key)) {
            fn.call(null, obj2[key], key, obj2);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject: isObject2,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/cent.js/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/cent.js/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/env/data.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = {
      "version": "0.26.0"
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/cent.js/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/cent.js/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/cent.js/node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var utils = require_utils2();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// node_modules/cent.js/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/cent.js/node_modules/axios/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = require_axios();
  }
});

// node_modules/cent.js/dist/cent.exception.js
var require_cent_exception = __commonJS({
  "node_modules/cent.js/dist/cent.exception.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CentException = void 0;
    var CentException = class extends Error {
    };
    exports2.CentException = CentException;
  }
});

// node_modules/cent.js/dist/cent-methods.enum.js
var require_cent_methods_enum = __commonJS({
  "node_modules/cent.js/dist/cent-methods.enum.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CentMethods = void 0;
    var CentMethods;
    (function(CentMethods2) {
      CentMethods2["Publish"] = "publish";
      CentMethods2["Broadcast"] = "broadcast";
      CentMethods2["Subscribe"] = "subscribe";
      CentMethods2["Unsubscribe"] = "unsubscribe";
      CentMethods2["Disconnect"] = "disconnect";
      CentMethods2["Refresh"] = "refresh";
      CentMethods2["Presence"] = "presence";
      CentMethods2["PresenceStats"] = "presence_stats";
      CentMethods2["History"] = "history";
      CentMethods2["HistoryRemove"] = "history_remove";
      CentMethods2["Channels"] = "channels";
      CentMethods2["Info"] = "info";
    })(CentMethods = exports2.CentMethods || (exports2.CentMethods = {}));
  }
});

// node_modules/cent.js/dist/cent.client.js
var require_cent_client = __commonJS({
  "node_modules/cent.js/dist/cent.client.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CentClient = void 0;
    var axios_1 = require_axios2();
    var cent_exception_1 = require_cent_exception();
    var cent_methods_enum_1 = require_cent_methods_enum();
    var CentClient = class {
      constructor(options) {
        this.publish = this.methodFactory(cent_methods_enum_1.CentMethods.Publish);
        this.broadcast = this.methodFactory(cent_methods_enum_1.CentMethods.Broadcast);
        this.subscribe = this.methodFactory(cent_methods_enum_1.CentMethods.Subscribe);
        this.unsubscribe = this.methodFactory(cent_methods_enum_1.CentMethods.Unsubscribe);
        this.disconnect = this.methodFactory(cent_methods_enum_1.CentMethods.Disconnect);
        this.refresh = this.methodFactory(cent_methods_enum_1.CentMethods.Refresh);
        this.getPresence = this.methodFactory(cent_methods_enum_1.CentMethods.Presence);
        this.getPresenceStats = this.methodFactory(cent_methods_enum_1.CentMethods.PresenceStats);
        this.getHistory = this.methodFactory(cent_methods_enum_1.CentMethods.History);
        this.removeHistory = this.methodFactory(cent_methods_enum_1.CentMethods.HistoryRemove);
        this.getChannels = this.methodFactory(cent_methods_enum_1.CentMethods.Channels);
        this.getInfo = this.methodFactory(cent_methods_enum_1.CentMethods.Info);
        this.options = options;
      }
      methodFactory(method) {
        return (params) => (0, axios_1.default)({
          method: "POST",
          url: this.options.url,
          timeout: this.options.timeout,
          headers: {
            "Content-Type": "application/json",
            Authorization: `apikey ${this.options.token}`
          },
          data: { method, params }
        }).then(({ data }) => data === null || data === void 0 ? void 0 : data.result).catch((err) => {
          throw new cent_exception_1.CentException(err);
        });
      }
    };
    exports2.CentClient = CentClient;
  }
});

// node_modules/cent.js/dist/cent-options.interface.js
var require_cent_options_interface = __commonJS({
  "node_modules/cent.js/dist/cent-options.interface.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/cent.js/dist/index.js
var require_dist = __commonJS({
  "node_modules/cent.js/dist/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cent_client(), exports2);
    __exportStar(require_cent_exception(), exports2);
    __exportStar(require_cent_options_interface(), exports2);
  }
});

// node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "node_modules/stream-browserify/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Stream;
    var EE = require_events().EventEmitter;
    var inherits2 = require_inherits_browser();
    inherits2(Stream, EE);
    Stream.Readable = require_stream_readable();
    Stream.Writable = require_stream_writable();
    Stream.Duplex = require_stream_duplex();
    Stream.Transform = require_stream_transform();
    Stream.PassThrough = require_stream_passthrough();
    Stream.finished = require_end_of_stream();
    Stream.pipeline = require_pipeline();
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require_stream_browserify();
    var util = require_util2();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_buffer().Buffer;
    var SlowBuffer = require_buffer().SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = require_crypto();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util2();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj2) {
      return Buffer2.isBuffer(obj2) || typeof obj2 === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Buffer2 = require_buffer().Buffer;
    module2.exports = function toString(obj2) {
      if (typeof obj2 === "string")
        return obj2;
      if (typeof obj2 === "number" || Buffer2.isBuffer(obj2))
        return obj2.toString();
      return JSON.stringify(obj2);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream_browserify();
    var toString = require_tostring();
    var util = require_util2();
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream_browserify();
    var toString = require_tostring();
    var util = require_util2();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject2(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject2(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj2 = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj2);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    init_process();
    init_buffer();
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    init_process();
    init_buffer();
    var jws = require_jws();
    module2.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj2 = JSON.parse(payload);
          if (obj2 !== null && typeof obj2 === "object") {
            payload = obj2;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    init_process();
    init_buffer();
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    init_process();
    init_buffer();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    init_process();
    init_buffer();
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    init_process();
    init_buffer();
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/jsonwebtoken/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/jsonwebtoken/node_modules/semver/semver.js"(exports2, module2) {
    init_process();
    init_buffer();
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret2;
        if (isX(M)) {
          ret2 = "";
        } else if (isX(m)) {
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret2);
        return ret2;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret2;
        if (isX(M)) {
          ret2 = "";
        } else if (isX(m)) {
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret2 = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret2 = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret2);
        return ret2;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret2, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret2, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret2 = "<0.0.0";
          } else {
            ret2 = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret2 = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret2);
        return ret2;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    init_process();
    init_buffer();
    var semver = require_semver();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    init_process();
    init_buffer();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      var done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      var parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      var decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      var header = decodedToken.header;
      var getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        var hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          options.algorithms = ["none"];
        }
        if (!options.algorithms) {
          options.algorithms = ~secretOrPublicKey2.toString().indexOf("BEGIN CERTIFICATE") || ~secretOrPublicKey2.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~secretOrPublicKey2.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS;
        }
        if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        var valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        var payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          var match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          var invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          var signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash8 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    init_process();
    init_buffer();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var includes = require_lodash2();
    var isBoolean = require_lodash3();
    var isInteger = require_lodash4();
    var isNumber = require_lodash5();
    var isPlainObject = require_lodash6();
    var isString = require_lodash7();
    var once = require_lodash8();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        var validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      var isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      var header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        var invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      var timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        var claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      var encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          callback(null, signature);
        });
      } else {
        return jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var has = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key = decode(part[1]), value = decode(part[2]);
        if (key === null || value === null || key in result)
          continue;
        result[key] = value;
      }
      return result;
    }
    function querystringify(obj2, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix)
        prefix = "?";
      for (key in obj2) {
        if (has.call(obj2, key)) {
          value = obj2[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode(key);
          value = encode(value);
          if (key === null || value === null)
            continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof globalThis !== "undefined")
        globalVar = globalThis;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore)
          delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore)
            continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base) {
      if (relative === "")
        return base;
      var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
      while (i--) {
        if (path[i] === ".") {
          path.splice(i, 1);
        } else if (path[i] === "..") {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0)
            unshift = true;
          path.splice(i, 1);
          up--;
        }
      }
      if (unshift)
        path.unshift("");
      if (last === "." || last === "..")
        path.push("");
      return path.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
      if ("object" !== type && "string" !== type) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser)
        parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key = instruction[1];
        if (parse !== parse) {
          url[key] = address;
        } else if ("string" === typeof parse) {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4])
          url[key] = url[key].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString(stringify) {
      if (!stringify || "function" !== typeof stringify)
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query)
        result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/buffer-more-ints/buffer-more-ints.js
var require_buffer_more_ints = __commonJS({
  "node_modules/buffer-more-ints/buffer-more-ints.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var MAX_INT = 9007199254740991;
    function isContiguousInt(val) {
      return val <= MAX_INT && val >= -MAX_INT;
    }
    function assertContiguousInt(val) {
      if (!isContiguousInt(val)) {
        throw new TypeError("number cannot be represented as a contiguous integer");
      }
    }
    module2.exports.isContiguousInt = isContiguousInt;
    module2.exports.assertContiguousInt = assertContiguousInt;
    ["UInt", "Int"].forEach(function(sign) {
      var suffix = sign + "8";
      module2.exports["read" + suffix] = Buffer.prototype["read" + suffix].call;
      module2.exports["write" + suffix] = Buffer.prototype["write" + suffix].call;
      ["16", "32"].forEach(function(size) {
        ["LE", "BE"].forEach(function(endian) {
          var suffix2 = sign + size + endian;
          var read = Buffer.prototype["read" + suffix2];
          module2.exports["read" + suffix2] = function(buf, offset) {
            return read.call(buf, offset);
          };
          var write = Buffer.prototype["write" + suffix2];
          module2.exports["write" + suffix2] = function(buf, val, offset) {
            return write.call(buf, val, offset);
          };
        });
      });
    });
    function check_value(val, min, max) {
      val = +val;
      if (typeof val != "number" || val < min || val > max || Math.floor(val) !== val) {
        throw new TypeError('"value" argument is out of bounds');
      }
      return val;
    }
    function check_bounds(buf, offset, len) {
      if (offset < 0 || offset + len > buf.length) {
        throw new RangeError("Index out of range");
      }
    }
    function readUInt24BE(buf, offset) {
      return buf.readUInt8(offset) << 16 | buf.readUInt16BE(offset + 1);
    }
    module2.exports.readUInt24BE = readUInt24BE;
    function writeUInt24BE(buf, val, offset) {
      val = check_value(val, 0, 16777215);
      check_bounds(buf, offset, 3);
      buf.writeUInt8(val >>> 16, offset);
      buf.writeUInt16BE(val & 65535, offset + 1);
    }
    module2.exports.writeUInt24BE = writeUInt24BE;
    function readUInt40BE(buf, offset) {
      return (buf.readUInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
    }
    module2.exports.readUInt40BE = readUInt40BE;
    function writeUInt40BE(buf, val, offset) {
      val = check_value(val, 0, 1099511627775);
      check_bounds(buf, offset, 5);
      buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
      buf.writeInt32BE(val & -1, offset + 1);
    }
    module2.exports.writeUInt40BE = writeUInt40BE;
    function readUInt48BE(buf, offset) {
      return buf.readUInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
    }
    module2.exports.readUInt48BE = readUInt48BE;
    function writeUInt48BE(buf, val, offset) {
      val = check_value(val, 0, 281474976710655);
      check_bounds(buf, offset, 6);
      buf.writeUInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
      buf.writeInt32BE(val & -1, offset + 2);
    }
    module2.exports.writeUInt48BE = writeUInt48BE;
    function readUInt56BE(buf, offset) {
      return ((buf.readUInt8(offset) || 0) << 16 | buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
    }
    module2.exports.readUInt56BE = readUInt56BE;
    function writeUInt56BE(buf, val, offset) {
      val = check_value(val, 0, 72057594037927940);
      check_bounds(buf, offset, 7);
      if (val < 72057594037927940) {
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt8(hi >>> 16, offset);
        buf.writeUInt16BE(hi & 65535, offset + 1);
        buf.writeInt32BE(val & -1, offset + 3);
      } else {
        buf[offset] = 255;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 255;
      }
    }
    module2.exports.writeUInt56BE = writeUInt56BE;
    function readUInt64BE(buf, offset) {
      return buf.readUInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
    }
    module2.exports.readUInt64BE = readUInt64BE;
    function writeUInt64BE(buf, val, offset) {
      val = check_value(val, 0, 18446744073709552e3);
      check_bounds(buf, offset, 8);
      if (val < 18446744073709552e3) {
        buf.writeUInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
        buf.writeInt32BE(val & -1, offset + 4);
      } else {
        buf[offset] = 255;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 255;
        buf[offset + 7] = 255;
      }
    }
    module2.exports.writeUInt64BE = writeUInt64BE;
    function readUInt24LE(buf, offset) {
      return buf.readUInt8(offset + 2) << 16 | buf.readUInt16LE(offset);
    }
    module2.exports.readUInt24LE = readUInt24LE;
    function writeUInt24LE(buf, val, offset) {
      val = check_value(val, 0, 16777215);
      check_bounds(buf, offset, 3);
      buf.writeUInt16LE(val & 65535, offset);
      buf.writeUInt8(val >>> 16, offset + 2);
    }
    module2.exports.writeUInt24LE = writeUInt24LE;
    function readUInt40LE(buf, offset) {
      return (buf.readUInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readUInt40LE = readUInt40LE;
    function writeUInt40LE(buf, val, offset) {
      val = check_value(val, 0, 1099511627775);
      check_bounds(buf, offset, 5);
      buf.writeInt32LE(val & -1, offset);
      buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    }
    module2.exports.writeUInt40LE = writeUInt40LE;
    function readUInt48LE(buf, offset) {
      return buf.readUInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readUInt48LE = readUInt48LE;
    function writeUInt48LE(buf, val, offset) {
      val = check_value(val, 0, 281474976710655);
      check_bounds(buf, offset, 6);
      buf.writeInt32LE(val & -1, offset);
      buf.writeUInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    }
    module2.exports.writeUInt48LE = writeUInt48LE;
    function readUInt56LE(buf, offset) {
      return ((buf.readUInt8(offset + 6) || 0) << 16 | buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readUInt56LE = readUInt56LE;
    function writeUInt56LE(buf, val, offset) {
      val = check_value(val, 0, 72057594037927940);
      check_bounds(buf, offset, 7);
      if (val < 72057594037927940) {
        buf.writeInt32LE(val & -1, offset);
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt16LE(hi & 65535, offset + 4);
        buf.writeUInt8(hi >>> 16, offset + 6);
      } else {
        buf[offset] = 255;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 255;
      }
    }
    module2.exports.writeUInt56LE = writeUInt56LE;
    function readUInt64LE(buf, offset) {
      return buf.readUInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buf, val, offset) {
      val = check_value(val, 0, 18446744073709552e3);
      check_bounds(buf, offset, 8);
      if (val < 18446744073709552e3) {
        buf.writeInt32LE(val & -1, offset);
        buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
      } else {
        buf[offset] = 255;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 255;
        buf[offset + 7] = 255;
      }
    }
    module2.exports.writeUInt64LE = writeUInt64LE;
    function readInt24BE(buf, offset) {
      return (buf.readInt8(offset) << 16) + buf.readUInt16BE(offset + 1);
    }
    module2.exports.readInt24BE = readInt24BE;
    function writeInt24BE(buf, val, offset) {
      val = check_value(val, -8388608, 8388607);
      check_bounds(buf, offset, 3);
      buf.writeInt8(val >> 16, offset);
      buf.writeUInt16BE(val & 65535, offset + 1);
    }
    module2.exports.writeInt24BE = writeInt24BE;
    function readInt40BE(buf, offset) {
      return (buf.readInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
    }
    module2.exports.readInt40BE = readInt40BE;
    function writeInt40BE(buf, val, offset) {
      val = check_value(val, -549755813888, 549755813887);
      check_bounds(buf, offset, 5);
      buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
      buf.writeInt32BE(val & -1, offset + 1);
    }
    module2.exports.writeInt40BE = writeInt40BE;
    function readInt48BE(buf, offset) {
      return buf.readInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
    }
    module2.exports.readInt48BE = readInt48BE;
    function writeInt48BE(buf, val, offset) {
      val = check_value(val, -140737488355328, 140737488355327);
      check_bounds(buf, offset, 6);
      buf.writeInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
      buf.writeInt32BE(val & -1, offset + 2);
    }
    module2.exports.writeInt48BE = writeInt48BE;
    function readInt56BE(buf, offset) {
      return (((buf.readInt8(offset) || 0) << 16) + buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
    }
    module2.exports.readInt56BE = readInt56BE;
    function writeInt56BE(buf, val, offset) {
      val = check_value(val, -576460752303423500, 36028797018963970);
      check_bounds(buf, offset, 7);
      if (val < 36028797018963970) {
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeInt8(hi >> 16, offset);
        buf.writeUInt16BE(hi & 65535, offset + 1);
        buf.writeInt32BE(val & -1, offset + 3);
      } else {
        buf[offset] = 127;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 255;
      }
    }
    module2.exports.writeInt56BE = writeInt56BE;
    function readInt64BE(buf, offset) {
      return buf.readInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
    }
    module2.exports.readInt64BE = readInt64BE;
    function writeInt64BE(buf, val, offset) {
      val = check_value(val, -23611832414348226e5, 9223372036854776e3);
      check_bounds(buf, offset, 8);
      if (val < 9223372036854776e3) {
        buf.writeInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
        buf.writeInt32BE(val & -1, offset + 4);
      } else {
        buf[offset] = 127;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 255;
        buf[offset + 7] = 255;
      }
    }
    module2.exports.writeInt64BE = writeInt64BE;
    function readInt24LE(buf, offset) {
      return (buf.readInt8(offset + 2) << 16) + buf.readUInt16LE(offset);
    }
    module2.exports.readInt24LE = readInt24LE;
    function writeInt24LE(buf, val, offset) {
      val = check_value(val, -8388608, 8388607);
      check_bounds(buf, offset, 3);
      buf.writeUInt16LE(val & 65535, offset);
      buf.writeInt8(val >> 16, offset + 2);
    }
    module2.exports.writeInt24LE = writeInt24LE;
    function readInt40LE(buf, offset) {
      return (buf.readInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readInt40LE = readInt40LE;
    function writeInt40LE(buf, val, offset) {
      val = check_value(val, -549755813888, 549755813887);
      check_bounds(buf, offset, 5);
      buf.writeInt32LE(val & -1, offset);
      buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    }
    module2.exports.writeInt40LE = writeInt40LE;
    function readInt48LE(buf, offset) {
      return buf.readInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readInt48LE = readInt48LE;
    function writeInt48LE(buf, val, offset) {
      val = check_value(val, -140737488355328, 140737488355327);
      check_bounds(buf, offset, 6);
      buf.writeInt32LE(val & -1, offset);
      buf.writeInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    }
    module2.exports.writeInt48LE = writeInt48LE;
    function readInt56LE(buf, offset) {
      return (((buf.readInt8(offset + 6) || 0) << 16) + buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readInt56LE = readInt56LE;
    function writeInt56LE(buf, val, offset) {
      val = check_value(val, -36028797018963970, 36028797018963970);
      check_bounds(buf, offset, 7);
      if (val < 36028797018963970) {
        buf.writeInt32LE(val & -1, offset);
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt16LE(hi & 65535, offset + 4);
        buf.writeInt8(hi >> 16, offset + 6);
      } else {
        buf[offset] = 255;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 127;
      }
    }
    module2.exports.writeInt56LE = writeInt56LE;
    function readInt64LE(buf, offset) {
      return buf.readInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
    }
    module2.exports.readInt64LE = readInt64LE;
    function writeInt64LE(buf, val, offset) {
      val = check_value(val, -9223372036854776e3, 9223372036854776e3);
      check_bounds(buf, offset, 8);
      if (val < 9223372036854776e3) {
        buf.writeInt32LE(val & -1, offset);
        buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
      } else {
        buf[offset] = 255;
        buf[offset + 1] = 255;
        buf[offset + 2] = 255;
        buf[offset + 3] = 255;
        buf[offset + 4] = 255;
        buf[offset + 5] = 255;
        buf[offset + 6] = 255;
        buf[offset + 7] = 127;
      }
    }
    module2.exports.writeInt64LE = writeInt64LE;
  }
});

// node_modules/amqplib/lib/codec.js
var require_codec = __commonJS({
  "node_modules/amqplib/lib/codec.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var ints = require_buffer_more_ints();
    function isFloatingPoint(n) {
      return n >= 9223372036854776e3 || Math.abs(n) < 1125899906842624 && Math.floor(n) !== n;
    }
    function encodeTable(buffer, val, offset) {
      var start = offset;
      offset += 4;
      for (var key in val) {
        if (val[key] !== void 0) {
          var len = Buffer.byteLength(key);
          buffer.writeUInt8(len, offset);
          offset++;
          buffer.write(key, offset, "utf8");
          offset += len;
          offset += encodeFieldValue(buffer, val[key], offset);
        }
      }
      var size = offset - start;
      buffer.writeUInt32BE(size - 4, start);
      return size;
    }
    function encodeArray(buffer, val, offset) {
      var start = offset;
      offset += 4;
      for (var i = 0, num = val.length; i < num; i++) {
        offset += encodeFieldValue(buffer, val[i], offset);
      }
      var size = offset - start;
      buffer.writeUInt32BE(size - 4, start);
      return size;
    }
    function encodeFieldValue(buffer, value, offset) {
      var start = offset;
      var type = typeof value, val = value;
      if (value && type === "object" && value.hasOwnProperty("!")) {
        val = value.value;
        type = value["!"];
      }
      if (type == "number") {
        if (isFloatingPoint(val)) {
          type = "double";
        } else {
          if (val < 128 && val >= -128) {
            type = "byte";
          } else if (val >= -32768 && val < 32768) {
            type = "short";
          } else if (val >= -2147483648 && val < 2147483648) {
            type = "int";
          } else {
            type = "long";
          }
        }
      }
      function tag(t) {
        buffer.write(t, offset);
        offset++;
      }
      switch (type) {
        case "string":
          var len = Buffer.byteLength(val, "utf8");
          tag("S");
          buffer.writeUInt32BE(len, offset);
          offset += 4;
          buffer.write(val, offset, "utf8");
          offset += len;
          break;
        case "object":
          if (val === null) {
            tag("V");
          } else if (Array.isArray(val)) {
            tag("A");
            offset += encodeArray(buffer, val, offset);
          } else if (Buffer.isBuffer(val)) {
            tag("x");
            buffer.writeUInt32BE(val.length, offset);
            offset += 4;
            val.copy(buffer, offset);
            offset += val.length;
          } else {
            tag("F");
            offset += encodeTable(buffer, val, offset);
          }
          break;
        case "boolean":
          tag("t");
          buffer.writeUInt8(val ? 1 : 0, offset);
          offset++;
          break;
        case "double":
        case "float64":
          tag("d");
          buffer.writeDoubleBE(val, offset);
          offset += 8;
          break;
        case "byte":
        case "int8":
          tag("b");
          buffer.writeInt8(val, offset);
          offset++;
          break;
        case "short":
        case "int16":
          tag("s");
          buffer.writeInt16BE(val, offset);
          offset += 2;
          break;
        case "int":
        case "int32":
          tag("I");
          buffer.writeInt32BE(val, offset);
          offset += 4;
          break;
        case "long":
        case "int64":
          tag("l");
          ints.writeInt64BE(buffer, val, offset);
          offset += 8;
          break;
        case "timestamp":
          tag("T");
          ints.writeUInt64BE(buffer, val, offset);
          offset += 8;
          break;
        case "float":
          tag("f");
          buffer.writeFloatBE(val, offset);
          offset += 4;
          break;
        case "decimal":
          tag("D");
          if (val.hasOwnProperty("places") && val.hasOwnProperty("digits") && val.places >= 0 && val.places < 256) {
            buffer[offset] = val.places;
            offset++;
            buffer.writeUInt32BE(val.digits, offset);
            offset += 4;
          } else
            throw new TypeError(
              "Decimal value must be {'places': 0..255, 'digits': uint32}, got " + JSON.stringify(val)
            );
          break;
        default:
          throw new TypeError("Unknown type to encode: " + type);
      }
      return offset - start;
    }
    function decodeFields(slice) {
      var fields = {}, offset = 0, size = slice.length;
      var len, key, val;
      function decodeFieldValue() {
        var tag = String.fromCharCode(slice[offset]);
        offset++;
        switch (tag) {
          case "b":
            val = slice.readInt8(offset);
            offset++;
            break;
          case "S":
            len = slice.readUInt32BE(offset);
            offset += 4;
            val = slice.toString("utf8", offset, offset + len);
            offset += len;
            break;
          case "I":
            val = slice.readInt32BE(offset);
            offset += 4;
            break;
          case "D":
            var places = slice[offset];
            offset++;
            var digits = slice.readUInt32BE(offset);
            offset += 4;
            val = { "!": "decimal", value: { places, digits } };
            break;
          case "T":
            val = ints.readUInt64BE(slice, offset);
            offset += 8;
            val = { "!": "timestamp", value: val };
            break;
          case "F":
            len = slice.readUInt32BE(offset);
            offset += 4;
            val = decodeFields(slice.slice(offset, offset + len));
            offset += len;
            break;
          case "A":
            len = slice.readUInt32BE(offset);
            offset += 4;
            decodeArray(offset + len);
            break;
          case "d":
            val = slice.readDoubleBE(offset);
            offset += 8;
            break;
          case "f":
            val = slice.readFloatBE(offset);
            offset += 4;
            break;
          case "l":
            val = ints.readInt64BE(slice, offset);
            offset += 8;
            break;
          case "s":
            val = slice.readInt16BE(offset);
            offset += 2;
            break;
          case "t":
            val = slice[offset] != 0;
            offset++;
            break;
          case "V":
            val = null;
            break;
          case "x":
            len = slice.readUInt32BE(offset);
            offset += 4;
            val = slice.slice(offset, offset + len);
            offset += len;
            break;
          default:
            throw new TypeError('Unexpected type tag "' + tag + '"');
        }
      }
      function decodeArray(until) {
        var vals = [];
        while (offset < until) {
          decodeFieldValue();
          vals.push(val);
        }
        val = vals;
      }
      while (offset < size) {
        len = slice.readUInt8(offset);
        offset++;
        key = slice.toString("utf8", offset, offset + len);
        offset += len;
        decodeFieldValue();
        fields[key] = val;
      }
      return fields;
    }
    module2.exports.encodeTable = encodeTable;
    module2.exports.decodeFields = decodeFields;
  }
});

// node_modules/amqplib/lib/defs.js
var require_defs = __commonJS({
  "node_modules/amqplib/lib/defs.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function decodeConnectionStart(buffer) {
      var val, len, offset = 0, fields = {
        versionMajor: void 0,
        versionMinor: void 0,
        serverProperties: void 0,
        mechanisms: void 0,
        locales: void 0
      };
      val = buffer[offset];
      offset++;
      fields.versionMajor = val;
      val = buffer[offset];
      offset++;
      fields.versionMinor = val;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.serverProperties = val;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = buffer.slice(offset, offset + len);
      offset += len;
      fields.mechanisms = val;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = buffer.slice(offset, offset + len);
      offset += len;
      fields.locales = val;
      return fields;
    }
    function encodeConnectionStart(channel, fields) {
      var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
      val = fields.serverProperties;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'serverProperties'");
      if ("object" != typeof val)
        throw new TypeError("Field 'serverProperties' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var serverProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += serverProperties_encoded.length;
      val = fields.mechanisms;
      if (void 0 === val)
        val = Buffer.from("PLAIN");
      else if (!Buffer.isBuffer(val))
        throw new TypeError("Field 'mechanisms' is the wrong type; must be a Buffer");
      varyingSize += val.length;
      val = fields.locales;
      if (void 0 === val)
        val = Buffer.from("en_US");
      else if (!Buffer.isBuffer(val))
        throw new TypeError("Field 'locales' is the wrong type; must be a Buffer");
      varyingSize += val.length;
      var buffer = Buffer.alloc(22 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655370, 7);
      offset = 11;
      val = fields.versionMajor;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'versionMajor' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt8(val, offset);
      offset++;
      val = fields.versionMinor;
      if (void 0 === val)
        val = 9;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'versionMinor' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt8(val, offset);
      offset++;
      offset += serverProperties_encoded.copy(buffer, offset);
      val = fields.mechanisms;
      void 0 === val && (val = Buffer.from("PLAIN"));
      len = val.length;
      buffer.writeUInt32BE(len, offset);
      offset += 4;
      val.copy(buffer, offset);
      offset += len;
      val = fields.locales;
      void 0 === val && (val = Buffer.from("en_US"));
      len = val.length;
      buffer.writeUInt32BE(len, offset);
      offset += 4;
      val.copy(buffer, offset);
      offset += len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionStartOk(buffer) {
      var val, len, offset = 0, fields = {
        clientProperties: void 0,
        mechanism: void 0,
        response: void 0,
        locale: void 0
      };
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.clientProperties = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.mechanism = val;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = buffer.slice(offset, offset + len);
      offset += len;
      fields.response = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.locale = val;
      return fields;
    }
    function encodeConnectionStartOk(channel, fields) {
      var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
      val = fields.clientProperties;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'clientProperties'");
      if ("object" != typeof val)
        throw new TypeError("Field 'clientProperties' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var clientProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += clientProperties_encoded.length;
      val = fields.mechanism;
      if (void 0 === val)
        val = "PLAIN";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'mechanism' is the wrong type; must be a string (up to 255 chars)");
      var mechanism_len = Buffer.byteLength(val, "utf8");
      varyingSize += mechanism_len;
      val = fields.response;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'response'");
      if (!Buffer.isBuffer(val))
        throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
      varyingSize += val.length;
      val = fields.locale;
      if (void 0 === val)
        val = "en_US";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'locale' is the wrong type; must be a string (up to 255 chars)");
      var locale_len = Buffer.byteLength(val, "utf8");
      varyingSize += locale_len;
      var buffer = Buffer.alloc(18 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655371, 7);
      offset = 11;
      offset += clientProperties_encoded.copy(buffer, offset);
      val = fields.mechanism;
      void 0 === val && (val = "PLAIN");
      buffer[offset] = mechanism_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += mechanism_len;
      val = fields.response;
      void 0 === val && (val = Buffer.from(void 0));
      len = val.length;
      buffer.writeUInt32BE(len, offset);
      offset += 4;
      val.copy(buffer, offset);
      offset += len;
      val = fields.locale;
      void 0 === val && (val = "en_US");
      buffer[offset] = locale_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += locale_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionSecure(buffer) {
      var val, len, offset = 0, fields = {
        challenge: void 0
      };
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = buffer.slice(offset, offset + len);
      offset += len;
      fields.challenge = val;
      return fields;
    }
    function encodeConnectionSecure(channel, fields) {
      var len, offset = 0, val = null, varyingSize = 0;
      val = fields.challenge;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'challenge'");
      if (!Buffer.isBuffer(val))
        throw new TypeError("Field 'challenge' is the wrong type; must be a Buffer");
      varyingSize += val.length;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655380, 7);
      offset = 11;
      val = fields.challenge;
      void 0 === val && (val = Buffer.from(void 0));
      len = val.length;
      buffer.writeUInt32BE(len, offset);
      offset += 4;
      val.copy(buffer, offset);
      offset += len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionSecureOk(buffer) {
      var val, len, offset = 0, fields = {
        response: void 0
      };
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = buffer.slice(offset, offset + len);
      offset += len;
      fields.response = val;
      return fields;
    }
    function encodeConnectionSecureOk(channel, fields) {
      var len, offset = 0, val = null, varyingSize = 0;
      val = fields.response;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'response'");
      if (!Buffer.isBuffer(val))
        throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
      varyingSize += val.length;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655381, 7);
      offset = 11;
      val = fields.response;
      void 0 === val && (val = Buffer.from(void 0));
      len = val.length;
      buffer.writeUInt32BE(len, offset);
      offset += 4;
      val.copy(buffer, offset);
      offset += len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionTune(buffer) {
      var val, offset = 0, fields = {
        channelMax: void 0,
        frameMax: void 0,
        heartbeat: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.channelMax = val;
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.frameMax = val;
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.heartbeat = val;
      return fields;
    }
    function encodeConnectionTune(channel, fields) {
      var offset = 0, val = null, buffer = Buffer.alloc(20);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655390, 7);
      offset = 11;
      val = fields.channelMax;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.frameMax;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      val = fields.heartbeat;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionTuneOk(buffer) {
      var val, offset = 0, fields = {
        channelMax: void 0,
        frameMax: void 0,
        heartbeat: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.channelMax = val;
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.frameMax = val;
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.heartbeat = val;
      return fields;
    }
    function encodeConnectionTuneOk(channel, fields) {
      var offset = 0, val = null, buffer = Buffer.alloc(20);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655391, 7);
      offset = 11;
      val = fields.channelMax;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.frameMax;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      val = fields.heartbeat;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionOpen(buffer) {
      var val, len, offset = 0, fields = {
        virtualHost: void 0,
        capabilities: void 0,
        insist: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.virtualHost = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.capabilities = val;
      val = !!(1 & buffer[offset]);
      fields.insist = val;
      return fields;
    }
    function encodeConnectionOpen(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.virtualHost;
      if (void 0 === val)
        val = "/";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'virtualHost' is the wrong type; must be a string (up to 255 chars)");
      var virtualHost_len = Buffer.byteLength(val, "utf8");
      varyingSize += virtualHost_len;
      val = fields.capabilities;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'capabilities' is the wrong type; must be a string (up to 255 chars)");
      var capabilities_len = Buffer.byteLength(val, "utf8");
      varyingSize += capabilities_len;
      var buffer = Buffer.alloc(15 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655400, 7);
      offset = 11;
      val = fields.virtualHost;
      void 0 === val && (val = "/");
      buffer[offset] = virtualHost_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += virtualHost_len;
      val = fields.capabilities;
      void 0 === val && (val = "");
      buffer[offset] = capabilities_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += capabilities_len;
      val = fields.insist;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionOpenOk(buffer) {
      var val, len, offset = 0, fields = {
        knownHosts: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.knownHosts = val;
      return fields;
    }
    function encodeConnectionOpenOk(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.knownHosts;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'knownHosts' is the wrong type; must be a string (up to 255 chars)");
      var knownHosts_len = Buffer.byteLength(val, "utf8");
      varyingSize += knownHosts_len;
      var buffer = Buffer.alloc(13 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655401, 7);
      offset = 11;
      val = fields.knownHosts;
      void 0 === val && (val = "");
      buffer[offset] = knownHosts_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += knownHosts_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionClose(buffer) {
      var val, len, offset = 0, fields = {
        replyCode: void 0,
        replyText: void 0,
        classId: void 0,
        methodId: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.replyCode = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.replyText = val;
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.classId = val;
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.methodId = val;
      return fields;
    }
    function encodeConnectionClose(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.replyText;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
      var replyText_len = Buffer.byteLength(val, "utf8");
      varyingSize += replyText_len;
      var buffer = Buffer.alloc(19 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655410, 7);
      offset = 11;
      val = fields.replyCode;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'replyCode'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.replyText;
      void 0 === val && (val = "");
      buffer[offset] = replyText_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += replyText_len;
      val = fields.classId;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'classId'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.methodId;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'methodId'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionCloseOk(buffer) {
      return {};
    }
    function encodeConnectionCloseOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655411, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionBlocked(buffer) {
      var val, len, offset = 0, fields = {
        reason: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.reason = val;
      return fields;
    }
    function encodeConnectionBlocked(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.reason;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'reason' is the wrong type; must be a string (up to 255 chars)");
      var reason_len = Buffer.byteLength(val, "utf8");
      varyingSize += reason_len;
      var buffer = Buffer.alloc(13 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655420, 7);
      offset = 11;
      val = fields.reason;
      void 0 === val && (val = "");
      buffer[offset] = reason_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += reason_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConnectionUnblocked(buffer) {
      return {};
    }
    function encodeConnectionUnblocked(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(655421, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeChannelOpen(buffer) {
      var val, len, offset = 0, fields = {
        outOfBand: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.outOfBand = val;
      return fields;
    }
    function encodeChannelOpen(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.outOfBand;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'outOfBand' is the wrong type; must be a string (up to 255 chars)");
      var outOfBand_len = Buffer.byteLength(val, "utf8");
      varyingSize += outOfBand_len;
      var buffer = Buffer.alloc(13 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1310730, 7);
      offset = 11;
      val = fields.outOfBand;
      void 0 === val && (val = "");
      buffer[offset] = outOfBand_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += outOfBand_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeChannelOpenOk(buffer) {
      var val, len, offset = 0, fields = {
        channelId: void 0
      };
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = buffer.slice(offset, offset + len);
      offset += len;
      fields.channelId = val;
      return fields;
    }
    function encodeChannelOpenOk(channel, fields) {
      var len, offset = 0, val = null, varyingSize = 0;
      val = fields.channelId;
      if (void 0 === val)
        val = Buffer.from("");
      else if (!Buffer.isBuffer(val))
        throw new TypeError("Field 'channelId' is the wrong type; must be a Buffer");
      varyingSize += val.length;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1310731, 7);
      offset = 11;
      val = fields.channelId;
      void 0 === val && (val = Buffer.from(""));
      len = val.length;
      buffer.writeUInt32BE(len, offset);
      offset += 4;
      val.copy(buffer, offset);
      offset += len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeChannelFlow(buffer) {
      var val, fields = {
        active: void 0
      };
      val = !!(1 & buffer[0]);
      fields.active = val;
      return fields;
    }
    function encodeChannelFlow(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1310740, 7);
      offset = 11;
      val = fields.active;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'active'");
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeChannelFlowOk(buffer) {
      var val, fields = {
        active: void 0
      };
      val = !!(1 & buffer[0]);
      fields.active = val;
      return fields;
    }
    function encodeChannelFlowOk(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1310741, 7);
      offset = 11;
      val = fields.active;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'active'");
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeChannelClose(buffer) {
      var val, len, offset = 0, fields = {
        replyCode: void 0,
        replyText: void 0,
        classId: void 0,
        methodId: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.replyCode = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.replyText = val;
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.classId = val;
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.methodId = val;
      return fields;
    }
    function encodeChannelClose(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.replyText;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
      var replyText_len = Buffer.byteLength(val, "utf8");
      varyingSize += replyText_len;
      var buffer = Buffer.alloc(19 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1310760, 7);
      offset = 11;
      val = fields.replyCode;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'replyCode'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.replyText;
      void 0 === val && (val = "");
      buffer[offset] = replyText_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += replyText_len;
      val = fields.classId;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'classId'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.methodId;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'methodId'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeChannelCloseOk(buffer) {
      return {};
    }
    function encodeChannelCloseOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1310761, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeAccessRequest(buffer) {
      var val, len, offset = 0, fields = {
        realm: void 0,
        exclusive: void 0,
        passive: void 0,
        active: void 0,
        write: void 0,
        read: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.realm = val;
      val = !!(1 & buffer[offset]);
      fields.exclusive = val;
      val = !!(2 & buffer[offset]);
      fields.passive = val;
      val = !!(4 & buffer[offset]);
      fields.active = val;
      val = !!(8 & buffer[offset]);
      fields.write = val;
      val = !!(16 & buffer[offset]);
      fields.read = val;
      return fields;
    }
    function encodeAccessRequest(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.realm;
      if (void 0 === val)
        val = "/data";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'realm' is the wrong type; must be a string (up to 255 chars)");
      var realm_len = Buffer.byteLength(val, "utf8");
      varyingSize += realm_len;
      var buffer = Buffer.alloc(14 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1966090, 7);
      offset = 11;
      val = fields.realm;
      void 0 === val && (val = "/data");
      buffer[offset] = realm_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += realm_len;
      val = fields.exclusive;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.passive;
      void 0 === val && (val = true);
      val && (bits += 2);
      val = fields.active;
      void 0 === val && (val = true);
      val && (bits += 4);
      val = fields.write;
      void 0 === val && (val = true);
      val && (bits += 8);
      val = fields.read;
      void 0 === val && (val = true);
      val && (bits += 16);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeAccessRequestOk(buffer) {
      var val, offset = 0, fields = {
        ticket: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      return fields;
    }
    function encodeAccessRequestOk(channel, fields) {
      var offset = 0, val = null, buffer = Buffer.alloc(14);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(1966091, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 1;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeDeclare(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        exchange: void 0,
        type: void 0,
        passive: void 0,
        durable: void 0,
        autoDelete: void 0,
        internal: void 0,
        nowait: void 0,
        arguments: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.type = val;
      val = !!(1 & buffer[offset]);
      fields.passive = val;
      val = !!(2 & buffer[offset]);
      fields.durable = val;
      val = !!(4 & buffer[offset]);
      fields.autoDelete = val;
      val = !!(8 & buffer[offset]);
      fields.internal = val;
      val = !!(16 & buffer[offset]);
      fields.nowait = val;
      offset++;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.arguments = val;
      return fields;
    }
    function encodeExchangeDeclare(channel, fields) {
      var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
      val = fields.exchange;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'exchange'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      val = fields.type;
      if (void 0 === val)
        val = "direct";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
      var type_len = Buffer.byteLength(val, "utf8");
      varyingSize += type_len;
      val = fields.arguments;
      if (void 0 === val)
        val = {};
      else if ("object" != typeof val)
        throw new TypeError("Field 'arguments' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += arguments_encoded.length;
      var buffer = Buffer.alloc(17 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621450, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.exchange;
      void 0 === val && (val = void 0);
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.type;
      void 0 === val && (val = "direct");
      buffer[offset] = type_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += type_len;
      val = fields.passive;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.durable;
      void 0 === val && (val = false);
      val && (bits += 2);
      val = fields.autoDelete;
      void 0 === val && (val = false);
      val && (bits += 4);
      val = fields.internal;
      void 0 === val && (val = false);
      val && (bits += 8);
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 16);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      offset += arguments_encoded.copy(buffer, offset);
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeDeclareOk(buffer) {
      return {};
    }
    function encodeExchangeDeclareOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621451, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeDelete(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        exchange: void 0,
        ifUnused: void 0,
        nowait: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      val = !!(1 & buffer[offset]);
      fields.ifUnused = val;
      val = !!(2 & buffer[offset]);
      fields.nowait = val;
      return fields;
    }
    function encodeExchangeDelete(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.exchange;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'exchange'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621460, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.exchange;
      void 0 === val && (val = void 0);
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.ifUnused;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 2);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeDeleteOk(buffer) {
      return {};
    }
    function encodeExchangeDeleteOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621461, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeBind(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        destination: void 0,
        source: void 0,
        routingKey: void 0,
        nowait: void 0,
        arguments: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.destination = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.source = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      val = !!(1 & buffer[offset]);
      fields.nowait = val;
      offset++;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.arguments = val;
      return fields;
    }
    function encodeExchangeBind(channel, fields) {
      var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
      val = fields.destination;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'destination'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
      var destination_len = Buffer.byteLength(val, "utf8");
      varyingSize += destination_len;
      val = fields.source;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'source'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
      var source_len = Buffer.byteLength(val, "utf8");
      varyingSize += source_len;
      val = fields.routingKey;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      val = fields.arguments;
      if (void 0 === val)
        val = {};
      else if ("object" != typeof val)
        throw new TypeError("Field 'arguments' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += arguments_encoded.length;
      var buffer = Buffer.alloc(18 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621470, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.destination;
      void 0 === val && (val = void 0);
      buffer[offset] = destination_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += destination_len;
      val = fields.source;
      void 0 === val && (val = void 0);
      buffer[offset] = source_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += source_len;
      val = fields.routingKey;
      void 0 === val && (val = "");
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      offset += arguments_encoded.copy(buffer, offset);
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeBindOk(buffer) {
      return {};
    }
    function encodeExchangeBindOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621471, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeUnbind(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        destination: void 0,
        source: void 0,
        routingKey: void 0,
        nowait: void 0,
        arguments: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.destination = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.source = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      val = !!(1 & buffer[offset]);
      fields.nowait = val;
      offset++;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.arguments = val;
      return fields;
    }
    function encodeExchangeUnbind(channel, fields) {
      var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
      val = fields.destination;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'destination'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
      var destination_len = Buffer.byteLength(val, "utf8");
      varyingSize += destination_len;
      val = fields.source;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'source'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
      var source_len = Buffer.byteLength(val, "utf8");
      varyingSize += source_len;
      val = fields.routingKey;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      val = fields.arguments;
      if (void 0 === val)
        val = {};
      else if ("object" != typeof val)
        throw new TypeError("Field 'arguments' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += arguments_encoded.length;
      var buffer = Buffer.alloc(18 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621480, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.destination;
      void 0 === val && (val = void 0);
      buffer[offset] = destination_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += destination_len;
      val = fields.source;
      void 0 === val && (val = void 0);
      buffer[offset] = source_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += source_len;
      val = fields.routingKey;
      void 0 === val && (val = "");
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      offset += arguments_encoded.copy(buffer, offset);
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeExchangeUnbindOk(buffer) {
      return {};
    }
    function encodeExchangeUnbindOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(2621491, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueDeclare(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        queue: void 0,
        passive: void 0,
        durable: void 0,
        exclusive: void 0,
        autoDelete: void 0,
        nowait: void 0,
        arguments: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      val = !!(1 & buffer[offset]);
      fields.passive = val;
      val = !!(2 & buffer[offset]);
      fields.durable = val;
      val = !!(4 & buffer[offset]);
      fields.exclusive = val;
      val = !!(8 & buffer[offset]);
      fields.autoDelete = val;
      val = !!(16 & buffer[offset]);
      fields.nowait = val;
      offset++;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.arguments = val;
      return fields;
    }
    function encodeQueueDeclare(channel, fields) {
      var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
      val = fields.queue;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      val = fields.arguments;
      if (void 0 === val)
        val = {};
      else if ("object" != typeof val)
        throw new TypeError("Field 'arguments' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += arguments_encoded.length;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276810, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.queue;
      void 0 === val && (val = "");
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.passive;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.durable;
      void 0 === val && (val = false);
      val && (bits += 2);
      val = fields.exclusive;
      void 0 === val && (val = false);
      val && (bits += 4);
      val = fields.autoDelete;
      void 0 === val && (val = false);
      val && (bits += 8);
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 16);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      offset += arguments_encoded.copy(buffer, offset);
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueDeclareOk(buffer) {
      var val, len, offset = 0, fields = {
        queue: void 0,
        messageCount: void 0,
        consumerCount: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.messageCount = val;
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.consumerCount = val;
      return fields;
    }
    function encodeQueueDeclareOk(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.queue;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'queue'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      var buffer = Buffer.alloc(21 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276811, 7);
      offset = 11;
      val = fields.queue;
      void 0 === val && (val = void 0);
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.messageCount;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'messageCount'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      val = fields.consumerCount;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'consumerCount'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'consumerCount' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueBind(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        queue: void 0,
        exchange: void 0,
        routingKey: void 0,
        nowait: void 0,
        arguments: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      val = !!(1 & buffer[offset]);
      fields.nowait = val;
      offset++;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.arguments = val;
      return fields;
    }
    function encodeQueueBind(channel, fields) {
      var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
      val = fields.queue;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      val = fields.exchange;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'exchange'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      val = fields.routingKey;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      val = fields.arguments;
      if (void 0 === val)
        val = {};
      else if ("object" != typeof val)
        throw new TypeError("Field 'arguments' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += arguments_encoded.length;
      var buffer = Buffer.alloc(18 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276820, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.queue;
      void 0 === val && (val = "");
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.exchange;
      void 0 === val && (val = void 0);
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.routingKey;
      void 0 === val && (val = "");
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      offset += arguments_encoded.copy(buffer, offset);
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueBindOk(buffer) {
      return {};
    }
    function encodeQueueBindOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276821, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueuePurge(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        queue: void 0,
        nowait: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      val = !!(1 & buffer[offset]);
      fields.nowait = val;
      return fields;
    }
    function encodeQueuePurge(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.queue;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276830, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.queue;
      void 0 === val && (val = "");
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueuePurgeOk(buffer) {
      var val, offset = 0, fields = {
        messageCount: void 0
      };
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.messageCount = val;
      return fields;
    }
    function encodeQueuePurgeOk(channel, fields) {
      var offset = 0, val = null, buffer = Buffer.alloc(16);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276831, 7);
      offset = 11;
      val = fields.messageCount;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'messageCount'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueDelete(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        queue: void 0,
        ifUnused: void 0,
        ifEmpty: void 0,
        nowait: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      val = !!(1 & buffer[offset]);
      fields.ifUnused = val;
      val = !!(2 & buffer[offset]);
      fields.ifEmpty = val;
      val = !!(4 & buffer[offset]);
      fields.nowait = val;
      return fields;
    }
    function encodeQueueDelete(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.queue;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276840, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.queue;
      void 0 === val && (val = "");
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.ifUnused;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.ifEmpty;
      void 0 === val && (val = false);
      val && (bits += 2);
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 4);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueDeleteOk(buffer) {
      var val, offset = 0, fields = {
        messageCount: void 0
      };
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.messageCount = val;
      return fields;
    }
    function encodeQueueDeleteOk(channel, fields) {
      var offset = 0, val = null, buffer = Buffer.alloc(16);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276841, 7);
      offset = 11;
      val = fields.messageCount;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'messageCount'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueUnbind(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        queue: void 0,
        exchange: void 0,
        routingKey: void 0,
        arguments: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.arguments = val;
      return fields;
    }
    function encodeQueueUnbind(channel, fields) {
      var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
      val = fields.queue;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      val = fields.exchange;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'exchange'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      val = fields.routingKey;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      val = fields.arguments;
      if (void 0 === val)
        val = {};
      else if ("object" != typeof val)
        throw new TypeError("Field 'arguments' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += arguments_encoded.length;
      var buffer = Buffer.alloc(17 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276850, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.queue;
      void 0 === val && (val = "");
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.exchange;
      void 0 === val && (val = void 0);
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.routingKey;
      void 0 === val && (val = "");
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      offset += arguments_encoded.copy(buffer, offset);
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeQueueUnbindOk(buffer) {
      return {};
    }
    function encodeQueueUnbindOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3276851, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicQos(buffer) {
      var val, offset = 0, fields = {
        prefetchSize: void 0,
        prefetchCount: void 0,
        global: void 0
      };
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.prefetchSize = val;
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.prefetchCount = val;
      val = !!(1 & buffer[offset]);
      fields.global = val;
      return fields;
    }
    function encodeBasicQos(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(19);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932170, 7);
      offset = 11;
      val = fields.prefetchSize;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'prefetchSize' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      val = fields.prefetchCount;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'prefetchCount' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.global;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicQosOk(buffer) {
      return {};
    }
    function encodeBasicQosOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932171, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicConsume(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        queue: void 0,
        consumerTag: void 0,
        noLocal: void 0,
        noAck: void 0,
        exclusive: void 0,
        nowait: void 0,
        arguments: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.consumerTag = val;
      val = !!(1 & buffer[offset]);
      fields.noLocal = val;
      val = !!(2 & buffer[offset]);
      fields.noAck = val;
      val = !!(4 & buffer[offset]);
      fields.exclusive = val;
      val = !!(8 & buffer[offset]);
      fields.nowait = val;
      offset++;
      len = buffer.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer.slice(offset, offset + len));
      offset += len;
      fields.arguments = val;
      return fields;
    }
    function encodeBasicConsume(channel, fields) {
      var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
      val = fields.queue;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      val = fields.consumerTag;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
      var consumerTag_len = Buffer.byteLength(val, "utf8");
      varyingSize += consumerTag_len;
      val = fields.arguments;
      if (void 0 === val)
        val = {};
      else if ("object" != typeof val)
        throw new TypeError("Field 'arguments' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += arguments_encoded.length;
      var buffer = Buffer.alloc(17 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932180, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.queue;
      void 0 === val && (val = "");
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.consumerTag;
      void 0 === val && (val = "");
      buffer[offset] = consumerTag_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += consumerTag_len;
      val = fields.noLocal;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.noAck;
      void 0 === val && (val = false);
      val && (bits += 2);
      val = fields.exclusive;
      void 0 === val && (val = false);
      val && (bits += 4);
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 8);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      offset += arguments_encoded.copy(buffer, offset);
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicConsumeOk(buffer) {
      var val, len, offset = 0, fields = {
        consumerTag: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.consumerTag = val;
      return fields;
    }
    function encodeBasicConsumeOk(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.consumerTag;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'consumerTag'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
      var consumerTag_len = Buffer.byteLength(val, "utf8");
      varyingSize += consumerTag_len;
      var buffer = Buffer.alloc(13 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932181, 7);
      offset = 11;
      val = fields.consumerTag;
      void 0 === val && (val = void 0);
      buffer[offset] = consumerTag_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += consumerTag_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicCancel(buffer) {
      var val, len, offset = 0, fields = {
        consumerTag: void 0,
        nowait: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.consumerTag = val;
      val = !!(1 & buffer[offset]);
      fields.nowait = val;
      return fields;
    }
    function encodeBasicCancel(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.consumerTag;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'consumerTag'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
      var consumerTag_len = Buffer.byteLength(val, "utf8");
      varyingSize += consumerTag_len;
      var buffer = Buffer.alloc(14 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932190, 7);
      offset = 11;
      val = fields.consumerTag;
      void 0 === val && (val = void 0);
      buffer[offset] = consumerTag_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += consumerTag_len;
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicCancelOk(buffer) {
      var val, len, offset = 0, fields = {
        consumerTag: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.consumerTag = val;
      return fields;
    }
    function encodeBasicCancelOk(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.consumerTag;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'consumerTag'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
      var consumerTag_len = Buffer.byteLength(val, "utf8");
      varyingSize += consumerTag_len;
      var buffer = Buffer.alloc(13 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932191, 7);
      offset = 11;
      val = fields.consumerTag;
      void 0 === val && (val = void 0);
      buffer[offset] = consumerTag_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += consumerTag_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicPublish(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        exchange: void 0,
        routingKey: void 0,
        mandatory: void 0,
        immediate: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      val = !!(1 & buffer[offset]);
      fields.mandatory = val;
      val = !!(2 & buffer[offset]);
      fields.immediate = val;
      return fields;
    }
    function encodeBasicPublish(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.exchange;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      val = fields.routingKey;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      var buffer = Buffer.alloc(17 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932200, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.exchange;
      void 0 === val && (val = "");
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.routingKey;
      void 0 === val && (val = "");
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      val = fields.mandatory;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.immediate;
      void 0 === val && (val = false);
      val && (bits += 2);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicReturn(buffer) {
      var val, len, offset = 0, fields = {
        replyCode: void 0,
        replyText: void 0,
        exchange: void 0,
        routingKey: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.replyCode = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.replyText = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      return fields;
    }
    function encodeBasicReturn(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.replyText;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
      var replyText_len = Buffer.byteLength(val, "utf8");
      varyingSize += replyText_len;
      val = fields.exchange;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'exchange'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      val = fields.routingKey;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'routingKey'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      var buffer = Buffer.alloc(17 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932210, 7);
      offset = 11;
      val = fields.replyCode;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'replyCode'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.replyText;
      void 0 === val && (val = "");
      buffer[offset] = replyText_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += replyText_len;
      val = fields.exchange;
      void 0 === val && (val = void 0);
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.routingKey;
      void 0 === val && (val = void 0);
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicDeliver(buffer) {
      var val, len, offset = 0, fields = {
        consumerTag: void 0,
        deliveryTag: void 0,
        redelivered: void 0,
        exchange: void 0,
        routingKey: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.consumerTag = val;
      val = ints.readUInt64BE(buffer, offset);
      offset += 8;
      fields.deliveryTag = val;
      val = !!(1 & buffer[offset]);
      fields.redelivered = val;
      offset++;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      return fields;
    }
    function encodeBasicDeliver(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.consumerTag;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'consumerTag'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
      var consumerTag_len = Buffer.byteLength(val, "utf8");
      varyingSize += consumerTag_len;
      val = fields.exchange;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'exchange'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      val = fields.routingKey;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'routingKey'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      var buffer = Buffer.alloc(24 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932220, 7);
      offset = 11;
      val = fields.consumerTag;
      void 0 === val && (val = void 0);
      buffer[offset] = consumerTag_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += consumerTag_len;
      val = fields.deliveryTag;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'deliveryTag'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
      ints.writeUInt64BE(buffer, val, offset);
      offset += 8;
      val = fields.redelivered;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      val = fields.exchange;
      void 0 === val && (val = void 0);
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.routingKey;
      void 0 === val && (val = void 0);
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicGet(buffer) {
      var val, len, offset = 0, fields = {
        ticket: void 0,
        queue: void 0,
        noAck: void 0
      };
      val = buffer.readUInt16BE(offset);
      offset += 2;
      fields.ticket = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.queue = val;
      val = !!(1 & buffer[offset]);
      fields.noAck = val;
      return fields;
    }
    function encodeBasicGet(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.queue;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
      var queue_len = Buffer.byteLength(val, "utf8");
      varyingSize += queue_len;
      var buffer = Buffer.alloc(16 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932230, 7);
      offset = 11;
      val = fields.ticket;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt16BE(val, offset);
      offset += 2;
      val = fields.queue;
      void 0 === val && (val = "");
      buffer[offset] = queue_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += queue_len;
      val = fields.noAck;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicGetOk(buffer) {
      var val, len, offset = 0, fields = {
        deliveryTag: void 0,
        redelivered: void 0,
        exchange: void 0,
        routingKey: void 0,
        messageCount: void 0
      };
      val = ints.readUInt64BE(buffer, offset);
      offset += 8;
      fields.deliveryTag = val;
      val = !!(1 & buffer[offset]);
      fields.redelivered = val;
      offset++;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.exchange = val;
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.routingKey = val;
      val = buffer.readUInt32BE(offset);
      offset += 4;
      fields.messageCount = val;
      return fields;
    }
    function encodeBasicGetOk(channel, fields) {
      var offset = 0, val = null, bits = 0, varyingSize = 0;
      val = fields.exchange;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'exchange'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
      var exchange_len = Buffer.byteLength(val, "utf8");
      varyingSize += exchange_len;
      val = fields.routingKey;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'routingKey'");
      if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
      var routingKey_len = Buffer.byteLength(val, "utf8");
      varyingSize += routingKey_len;
      var buffer = Buffer.alloc(27 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932231, 7);
      offset = 11;
      val = fields.deliveryTag;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'deliveryTag'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
      ints.writeUInt64BE(buffer, val, offset);
      offset += 8;
      val = fields.redelivered;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      bits = 0;
      val = fields.exchange;
      void 0 === val && (val = void 0);
      buffer[offset] = exchange_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += exchange_len;
      val = fields.routingKey;
      void 0 === val && (val = void 0);
      buffer[offset] = routingKey_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += routingKey_len;
      val = fields.messageCount;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'messageCount'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
      buffer.writeUInt32BE(val, offset);
      offset += 4;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicGetEmpty(buffer) {
      var val, len, offset = 0, fields = {
        clusterId: void 0
      };
      len = buffer.readUInt8(offset);
      offset++;
      val = buffer.toString("utf8", offset, offset + len);
      offset += len;
      fields.clusterId = val;
      return fields;
    }
    function encodeBasicGetEmpty(channel, fields) {
      var offset = 0, val = null, varyingSize = 0;
      val = fields.clusterId;
      if (void 0 === val)
        val = "";
      else if (!("string" == typeof val && Buffer.byteLength(val) < 256))
        throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
      var clusterId_len = Buffer.byteLength(val, "utf8");
      varyingSize += clusterId_len;
      var buffer = Buffer.alloc(13 + varyingSize);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932232, 7);
      offset = 11;
      val = fields.clusterId;
      void 0 === val && (val = "");
      buffer[offset] = clusterId_len;
      offset++;
      buffer.write(val, offset, "utf8");
      offset += clusterId_len;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicAck(buffer) {
      var val, offset = 0, fields = {
        deliveryTag: void 0,
        multiple: void 0
      };
      val = ints.readUInt64BE(buffer, offset);
      offset += 8;
      fields.deliveryTag = val;
      val = !!(1 & buffer[offset]);
      fields.multiple = val;
      return fields;
    }
    function encodeBasicAck(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932240, 7);
      offset = 11;
      val = fields.deliveryTag;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
      ints.writeUInt64BE(buffer, val, offset);
      offset += 8;
      val = fields.multiple;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicReject(buffer) {
      var val, offset = 0, fields = {
        deliveryTag: void 0,
        requeue: void 0
      };
      val = ints.readUInt64BE(buffer, offset);
      offset += 8;
      fields.deliveryTag = val;
      val = !!(1 & buffer[offset]);
      fields.requeue = val;
      return fields;
    }
    function encodeBasicReject(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932250, 7);
      offset = 11;
      val = fields.deliveryTag;
      if (void 0 === val)
        throw new Error("Missing value for mandatory field 'deliveryTag'");
      if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
      ints.writeUInt64BE(buffer, val, offset);
      offset += 8;
      val = fields.requeue;
      void 0 === val && (val = true);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicRecoverAsync(buffer) {
      var val, fields = {
        requeue: void 0
      };
      val = !!(1 & buffer[0]);
      fields.requeue = val;
      return fields;
    }
    function encodeBasicRecoverAsync(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932260, 7);
      offset = 11;
      val = fields.requeue;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicRecover(buffer) {
      var val, fields = {
        requeue: void 0
      };
      val = !!(1 & buffer[0]);
      fields.requeue = val;
      return fields;
    }
    function encodeBasicRecover(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932270, 7);
      offset = 11;
      val = fields.requeue;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicRecoverOk(buffer) {
      return {};
    }
    function encodeBasicRecoverOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932271, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeBasicNack(buffer) {
      var val, offset = 0, fields = {
        deliveryTag: void 0,
        multiple: void 0,
        requeue: void 0
      };
      val = ints.readUInt64BE(buffer, offset);
      offset += 8;
      fields.deliveryTag = val;
      val = !!(1 & buffer[offset]);
      fields.multiple = val;
      val = !!(2 & buffer[offset]);
      fields.requeue = val;
      return fields;
    }
    function encodeBasicNack(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932280, 7);
      offset = 11;
      val = fields.deliveryTag;
      if (void 0 === val)
        val = 0;
      else if ("number" != typeof val || isNaN(val))
        throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
      ints.writeUInt64BE(buffer, val, offset);
      offset += 8;
      val = fields.multiple;
      void 0 === val && (val = false);
      val && (bits += 1);
      val = fields.requeue;
      void 0 === val && (val = true);
      val && (bits += 2);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeTxSelect(buffer) {
      return {};
    }
    function encodeTxSelect(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5898250, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeTxSelectOk(buffer) {
      return {};
    }
    function encodeTxSelectOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5898251, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeTxCommit(buffer) {
      return {};
    }
    function encodeTxCommit(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5898260, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeTxCommitOk(buffer) {
      return {};
    }
    function encodeTxCommitOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5898261, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeTxRollback(buffer) {
      return {};
    }
    function encodeTxRollback(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5898270, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeTxRollbackOk(buffer) {
      return {};
    }
    function encodeTxRollbackOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5898271, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConfirmSelect(buffer) {
      var val, fields = {
        nowait: void 0
      };
      val = !!(1 & buffer[0]);
      fields.nowait = val;
      return fields;
    }
    function encodeConfirmSelect(channel, fields) {
      var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5570570, 7);
      offset = 11;
      val = fields.nowait;
      void 0 === val && (val = false);
      val && (bits += 1);
      buffer[offset] = bits;
      offset++;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function decodeConfirmSelectOk(buffer) {
      return {};
    }
    function encodeConfirmSelectOk(channel, fields) {
      var offset = 0, buffer = Buffer.alloc(12);
      buffer[0] = 1;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(5570571, 7);
      offset = 11;
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      return buffer;
    }
    function encodeBasicProperties(channel, size, fields) {
      var val, len, offset = 0, flags = 0, scratchOffset = 0, varyingSize = 0;
      val = fields.contentType;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'contentType' is the wrong type; must be a string (up to 255 chars)");
        var contentType_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += contentType_len;
      }
      val = fields.contentEncoding;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'contentEncoding' is the wrong type; must be a string (up to 255 chars)");
        var contentEncoding_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += contentEncoding_len;
      }
      val = fields.headers;
      if (void 0 != val) {
        if ("object" != typeof val)
          throw new TypeError("Field 'headers' is the wrong type; must be an object");
        len = encodeTable(SCRATCH, val, scratchOffset);
        var headers_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
        scratchOffset += len;
        varyingSize += headers_encoded.length;
      }
      val = fields.deliveryMode;
      if (void 0 != val) {
        if ("number" != typeof val || isNaN(val))
          throw new TypeError("Field 'deliveryMode' is the wrong type; must be a number (but not NaN)");
        varyingSize += 1;
      }
      val = fields.priority;
      if (void 0 != val) {
        if ("number" != typeof val || isNaN(val))
          throw new TypeError("Field 'priority' is the wrong type; must be a number (but not NaN)");
        varyingSize += 1;
      }
      val = fields.correlationId;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'correlationId' is the wrong type; must be a string (up to 255 chars)");
        var correlationId_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += correlationId_len;
      }
      val = fields.replyTo;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'replyTo' is the wrong type; must be a string (up to 255 chars)");
        var replyTo_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += replyTo_len;
      }
      val = fields.expiration;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'expiration' is the wrong type; must be a string (up to 255 chars)");
        var expiration_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += expiration_len;
      }
      val = fields.messageId;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'messageId' is the wrong type; must be a string (up to 255 chars)");
        var messageId_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += messageId_len;
      }
      val = fields.timestamp;
      if (void 0 != val) {
        if ("number" != typeof val || isNaN(val))
          throw new TypeError("Field 'timestamp' is the wrong type; must be a number (but not NaN)");
        varyingSize += 8;
      }
      val = fields.type;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
        var type_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += type_len;
      }
      val = fields.userId;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'userId' is the wrong type; must be a string (up to 255 chars)");
        var userId_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += userId_len;
      }
      val = fields.appId;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'appId' is the wrong type; must be a string (up to 255 chars)");
        var appId_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += appId_len;
      }
      val = fields.clusterId;
      if (void 0 != val) {
        if (!("string" == typeof val && Buffer.byteLength(val) < 256))
          throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
        var clusterId_len = Buffer.byteLength(val, "utf8");
        varyingSize += 1;
        varyingSize += clusterId_len;
      }
      var buffer = Buffer.alloc(22 + varyingSize);
      buffer[0] = 2;
      buffer.writeUInt16BE(channel, 1);
      buffer.writeUInt32BE(3932160, 7);
      ints.writeUInt64BE(buffer, size, 11);
      flags = 0;
      offset = 21;
      val = fields.contentType;
      if (void 0 != val) {
        flags += 32768;
        buffer[offset] = contentType_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += contentType_len;
      }
      val = fields.contentEncoding;
      if (void 0 != val) {
        flags += 16384;
        buffer[offset] = contentEncoding_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += contentEncoding_len;
      }
      val = fields.headers;
      if (void 0 != val) {
        flags += 8192;
        offset += headers_encoded.copy(buffer, offset);
      }
      val = fields.deliveryMode;
      if (void 0 != val) {
        flags += 4096;
        buffer.writeUInt8(val, offset);
        offset++;
      }
      val = fields.priority;
      if (void 0 != val) {
        flags += 2048;
        buffer.writeUInt8(val, offset);
        offset++;
      }
      val = fields.correlationId;
      if (void 0 != val) {
        flags += 1024;
        buffer[offset] = correlationId_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += correlationId_len;
      }
      val = fields.replyTo;
      if (void 0 != val) {
        flags += 512;
        buffer[offset] = replyTo_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += replyTo_len;
      }
      val = fields.expiration;
      if (void 0 != val) {
        flags += 256;
        buffer[offset] = expiration_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += expiration_len;
      }
      val = fields.messageId;
      if (void 0 != val) {
        flags += 128;
        buffer[offset] = messageId_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += messageId_len;
      }
      val = fields.timestamp;
      if (void 0 != val) {
        flags += 64;
        ints.writeUInt64BE(buffer, val, offset);
        offset += 8;
      }
      val = fields.type;
      if (void 0 != val) {
        flags += 32;
        buffer[offset] = type_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += type_len;
      }
      val = fields.userId;
      if (void 0 != val) {
        flags += 16;
        buffer[offset] = userId_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += userId_len;
      }
      val = fields.appId;
      if (void 0 != val) {
        flags += 8;
        buffer[offset] = appId_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += appId_len;
      }
      val = fields.clusterId;
      if (void 0 != val) {
        flags += 4;
        buffer[offset] = clusterId_len;
        offset++;
        buffer.write(val, offset, "utf8");
        offset += clusterId_len;
      }
      buffer[offset] = 206;
      buffer.writeUInt32BE(offset - 7, 3);
      buffer.writeUInt16BE(flags, 19);
      return buffer.slice(0, offset + 1);
    }
    function decodeBasicProperties(buffer) {
      var flags, val, len, offset = 2;
      flags = buffer.readUInt16BE(0);
      if (0 === flags)
        return {};
      var fields = {
        contentType: void 0,
        contentEncoding: void 0,
        headers: void 0,
        deliveryMode: void 0,
        priority: void 0,
        correlationId: void 0,
        replyTo: void 0,
        expiration: void 0,
        messageId: void 0,
        timestamp: void 0,
        type: void 0,
        userId: void 0,
        appId: void 0,
        clusterId: void 0
      };
      if (32768 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.contentType = val;
      }
      if (16384 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.contentEncoding = val;
      }
      if (8192 & flags) {
        len = buffer.readUInt32BE(offset);
        offset += 4;
        val = decodeFields(buffer.slice(offset, offset + len));
        offset += len;
        fields.headers = val;
      }
      if (4096 & flags) {
        val = buffer[offset];
        offset++;
        fields.deliveryMode = val;
      }
      if (2048 & flags) {
        val = buffer[offset];
        offset++;
        fields.priority = val;
      }
      if (1024 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.correlationId = val;
      }
      if (512 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.replyTo = val;
      }
      if (256 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.expiration = val;
      }
      if (128 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.messageId = val;
      }
      if (64 & flags) {
        val = ints.readUInt64BE(buffer, offset);
        offset += 8;
        fields.timestamp = val;
      }
      if (32 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.type = val;
      }
      if (16 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.userId = val;
      }
      if (8 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.appId = val;
      }
      if (4 & flags) {
        len = buffer.readUInt8(offset);
        offset++;
        val = buffer.toString("utf8", offset, offset + len);
        offset += len;
        fields.clusterId = val;
      }
      return fields;
    }
    var codec = require_codec();
    var ints = require_buffer_more_ints();
    var encodeTable = codec.encodeTable;
    var decodeFields = codec.decodeFields;
    var SCRATCH = Buffer.alloc(65536);
    var EMPTY_OBJECT = Object.freeze({});
    module2.exports.constants = {
      FRAME_METHOD: 1,
      FRAME_HEADER: 2,
      FRAME_BODY: 3,
      FRAME_HEARTBEAT: 8,
      FRAME_MIN_SIZE: 4096,
      FRAME_END: 206,
      REPLY_SUCCESS: 200,
      CONTENT_TOO_LARGE: 311,
      NO_ROUTE: 312,
      NO_CONSUMERS: 313,
      ACCESS_REFUSED: 403,
      NOT_FOUND: 404,
      RESOURCE_LOCKED: 405,
      PRECONDITION_FAILED: 406,
      CONNECTION_FORCED: 320,
      INVALID_PATH: 402,
      FRAME_ERROR: 501,
      SYNTAX_ERROR: 502,
      COMMAND_INVALID: 503,
      CHANNEL_ERROR: 504,
      UNEXPECTED_FRAME: 505,
      RESOURCE_ERROR: 506,
      NOT_ALLOWED: 530,
      NOT_IMPLEMENTED: 540,
      INTERNAL_ERROR: 541
    };
    module2.exports.constant_strs = {
      "1": "FRAME-METHOD",
      "2": "FRAME-HEADER",
      "3": "FRAME-BODY",
      "8": "FRAME-HEARTBEAT",
      "200": "REPLY-SUCCESS",
      "206": "FRAME-END",
      "311": "CONTENT-TOO-LARGE",
      "312": "NO-ROUTE",
      "313": "NO-CONSUMERS",
      "320": "CONNECTION-FORCED",
      "402": "INVALID-PATH",
      "403": "ACCESS-REFUSED",
      "404": "NOT-FOUND",
      "405": "RESOURCE-LOCKED",
      "406": "PRECONDITION-FAILED",
      "501": "FRAME-ERROR",
      "502": "SYNTAX-ERROR",
      "503": "COMMAND-INVALID",
      "504": "CHANNEL-ERROR",
      "505": "UNEXPECTED-FRAME",
      "506": "RESOURCE-ERROR",
      "530": "NOT-ALLOWED",
      "540": "NOT-IMPLEMENTED",
      "541": "INTERNAL-ERROR",
      "4096": "FRAME-MIN-SIZE"
    };
    module2.exports.FRAME_OVERHEAD = 8;
    module2.exports.decode = function(id, buf) {
      switch (id) {
        case 655370:
          return decodeConnectionStart(buf);
        case 655371:
          return decodeConnectionStartOk(buf);
        case 655380:
          return decodeConnectionSecure(buf);
        case 655381:
          return decodeConnectionSecureOk(buf);
        case 655390:
          return decodeConnectionTune(buf);
        case 655391:
          return decodeConnectionTuneOk(buf);
        case 655400:
          return decodeConnectionOpen(buf);
        case 655401:
          return decodeConnectionOpenOk(buf);
        case 655410:
          return decodeConnectionClose(buf);
        case 655411:
          return decodeConnectionCloseOk(buf);
        case 655420:
          return decodeConnectionBlocked(buf);
        case 655421:
          return decodeConnectionUnblocked(buf);
        case 1310730:
          return decodeChannelOpen(buf);
        case 1310731:
          return decodeChannelOpenOk(buf);
        case 1310740:
          return decodeChannelFlow(buf);
        case 1310741:
          return decodeChannelFlowOk(buf);
        case 1310760:
          return decodeChannelClose(buf);
        case 1310761:
          return decodeChannelCloseOk(buf);
        case 1966090:
          return decodeAccessRequest(buf);
        case 1966091:
          return decodeAccessRequestOk(buf);
        case 2621450:
          return decodeExchangeDeclare(buf);
        case 2621451:
          return decodeExchangeDeclareOk(buf);
        case 2621460:
          return decodeExchangeDelete(buf);
        case 2621461:
          return decodeExchangeDeleteOk(buf);
        case 2621470:
          return decodeExchangeBind(buf);
        case 2621471:
          return decodeExchangeBindOk(buf);
        case 2621480:
          return decodeExchangeUnbind(buf);
        case 2621491:
          return decodeExchangeUnbindOk(buf);
        case 3276810:
          return decodeQueueDeclare(buf);
        case 3276811:
          return decodeQueueDeclareOk(buf);
        case 3276820:
          return decodeQueueBind(buf);
        case 3276821:
          return decodeQueueBindOk(buf);
        case 3276830:
          return decodeQueuePurge(buf);
        case 3276831:
          return decodeQueuePurgeOk(buf);
        case 3276840:
          return decodeQueueDelete(buf);
        case 3276841:
          return decodeQueueDeleteOk(buf);
        case 3276850:
          return decodeQueueUnbind(buf);
        case 3276851:
          return decodeQueueUnbindOk(buf);
        case 3932170:
          return decodeBasicQos(buf);
        case 3932171:
          return decodeBasicQosOk(buf);
        case 3932180:
          return decodeBasicConsume(buf);
        case 3932181:
          return decodeBasicConsumeOk(buf);
        case 3932190:
          return decodeBasicCancel(buf);
        case 3932191:
          return decodeBasicCancelOk(buf);
        case 3932200:
          return decodeBasicPublish(buf);
        case 3932210:
          return decodeBasicReturn(buf);
        case 3932220:
          return decodeBasicDeliver(buf);
        case 3932230:
          return decodeBasicGet(buf);
        case 3932231:
          return decodeBasicGetOk(buf);
        case 3932232:
          return decodeBasicGetEmpty(buf);
        case 3932240:
          return decodeBasicAck(buf);
        case 3932250:
          return decodeBasicReject(buf);
        case 3932260:
          return decodeBasicRecoverAsync(buf);
        case 3932270:
          return decodeBasicRecover(buf);
        case 3932271:
          return decodeBasicRecoverOk(buf);
        case 3932280:
          return decodeBasicNack(buf);
        case 5898250:
          return decodeTxSelect(buf);
        case 5898251:
          return decodeTxSelectOk(buf);
        case 5898260:
          return decodeTxCommit(buf);
        case 5898261:
          return decodeTxCommitOk(buf);
        case 5898270:
          return decodeTxRollback(buf);
        case 5898271:
          return decodeTxRollbackOk(buf);
        case 5570570:
          return decodeConfirmSelect(buf);
        case 5570571:
          return decodeConfirmSelectOk(buf);
        case 60:
          return decodeBasicProperties(buf);
        default:
          throw new Error("Unknown class/method ID");
      }
    };
    module2.exports.encodeMethod = function(id, channel, fields) {
      switch (id) {
        case 655370:
          return encodeConnectionStart(channel, fields);
        case 655371:
          return encodeConnectionStartOk(channel, fields);
        case 655380:
          return encodeConnectionSecure(channel, fields);
        case 655381:
          return encodeConnectionSecureOk(channel, fields);
        case 655390:
          return encodeConnectionTune(channel, fields);
        case 655391:
          return encodeConnectionTuneOk(channel, fields);
        case 655400:
          return encodeConnectionOpen(channel, fields);
        case 655401:
          return encodeConnectionOpenOk(channel, fields);
        case 655410:
          return encodeConnectionClose(channel, fields);
        case 655411:
          return encodeConnectionCloseOk(channel, fields);
        case 655420:
          return encodeConnectionBlocked(channel, fields);
        case 655421:
          return encodeConnectionUnblocked(channel, fields);
        case 1310730:
          return encodeChannelOpen(channel, fields);
        case 1310731:
          return encodeChannelOpenOk(channel, fields);
        case 1310740:
          return encodeChannelFlow(channel, fields);
        case 1310741:
          return encodeChannelFlowOk(channel, fields);
        case 1310760:
          return encodeChannelClose(channel, fields);
        case 1310761:
          return encodeChannelCloseOk(channel, fields);
        case 1966090:
          return encodeAccessRequest(channel, fields);
        case 1966091:
          return encodeAccessRequestOk(channel, fields);
        case 2621450:
          return encodeExchangeDeclare(channel, fields);
        case 2621451:
          return encodeExchangeDeclareOk(channel, fields);
        case 2621460:
          return encodeExchangeDelete(channel, fields);
        case 2621461:
          return encodeExchangeDeleteOk(channel, fields);
        case 2621470:
          return encodeExchangeBind(channel, fields);
        case 2621471:
          return encodeExchangeBindOk(channel, fields);
        case 2621480:
          return encodeExchangeUnbind(channel, fields);
        case 2621491:
          return encodeExchangeUnbindOk(channel, fields);
        case 3276810:
          return encodeQueueDeclare(channel, fields);
        case 3276811:
          return encodeQueueDeclareOk(channel, fields);
        case 3276820:
          return encodeQueueBind(channel, fields);
        case 3276821:
          return encodeQueueBindOk(channel, fields);
        case 3276830:
          return encodeQueuePurge(channel, fields);
        case 3276831:
          return encodeQueuePurgeOk(channel, fields);
        case 3276840:
          return encodeQueueDelete(channel, fields);
        case 3276841:
          return encodeQueueDeleteOk(channel, fields);
        case 3276850:
          return encodeQueueUnbind(channel, fields);
        case 3276851:
          return encodeQueueUnbindOk(channel, fields);
        case 3932170:
          return encodeBasicQos(channel, fields);
        case 3932171:
          return encodeBasicQosOk(channel, fields);
        case 3932180:
          return encodeBasicConsume(channel, fields);
        case 3932181:
          return encodeBasicConsumeOk(channel, fields);
        case 3932190:
          return encodeBasicCancel(channel, fields);
        case 3932191:
          return encodeBasicCancelOk(channel, fields);
        case 3932200:
          return encodeBasicPublish(channel, fields);
        case 3932210:
          return encodeBasicReturn(channel, fields);
        case 3932220:
          return encodeBasicDeliver(channel, fields);
        case 3932230:
          return encodeBasicGet(channel, fields);
        case 3932231:
          return encodeBasicGetOk(channel, fields);
        case 3932232:
          return encodeBasicGetEmpty(channel, fields);
        case 3932240:
          return encodeBasicAck(channel, fields);
        case 3932250:
          return encodeBasicReject(channel, fields);
        case 3932260:
          return encodeBasicRecoverAsync(channel, fields);
        case 3932270:
          return encodeBasicRecover(channel, fields);
        case 3932271:
          return encodeBasicRecoverOk(channel, fields);
        case 3932280:
          return encodeBasicNack(channel, fields);
        case 5898250:
          return encodeTxSelect(channel, fields);
        case 5898251:
          return encodeTxSelectOk(channel, fields);
        case 5898260:
          return encodeTxCommit(channel, fields);
        case 5898261:
          return encodeTxCommitOk(channel, fields);
        case 5898270:
          return encodeTxRollback(channel, fields);
        case 5898271:
          return encodeTxRollbackOk(channel, fields);
        case 5570570:
          return encodeConfirmSelect(channel, fields);
        case 5570571:
          return encodeConfirmSelectOk(channel, fields);
        default:
          throw new Error("Unknown class/method ID");
      }
    };
    module2.exports.encodeProperties = function(id, channel, size, fields) {
      switch (id) {
        case 60:
          return encodeBasicProperties(channel, size, fields);
        default:
          throw new Error("Unknown class/properties ID");
      }
    };
    module2.exports.info = function(id) {
      switch (id) {
        case 655370:
          return methodInfoConnectionStart;
        case 655371:
          return methodInfoConnectionStartOk;
        case 655380:
          return methodInfoConnectionSecure;
        case 655381:
          return methodInfoConnectionSecureOk;
        case 655390:
          return methodInfoConnectionTune;
        case 655391:
          return methodInfoConnectionTuneOk;
        case 655400:
          return methodInfoConnectionOpen;
        case 655401:
          return methodInfoConnectionOpenOk;
        case 655410:
          return methodInfoConnectionClose;
        case 655411:
          return methodInfoConnectionCloseOk;
        case 655420:
          return methodInfoConnectionBlocked;
        case 655421:
          return methodInfoConnectionUnblocked;
        case 1310730:
          return methodInfoChannelOpen;
        case 1310731:
          return methodInfoChannelOpenOk;
        case 1310740:
          return methodInfoChannelFlow;
        case 1310741:
          return methodInfoChannelFlowOk;
        case 1310760:
          return methodInfoChannelClose;
        case 1310761:
          return methodInfoChannelCloseOk;
        case 1966090:
          return methodInfoAccessRequest;
        case 1966091:
          return methodInfoAccessRequestOk;
        case 2621450:
          return methodInfoExchangeDeclare;
        case 2621451:
          return methodInfoExchangeDeclareOk;
        case 2621460:
          return methodInfoExchangeDelete;
        case 2621461:
          return methodInfoExchangeDeleteOk;
        case 2621470:
          return methodInfoExchangeBind;
        case 2621471:
          return methodInfoExchangeBindOk;
        case 2621480:
          return methodInfoExchangeUnbind;
        case 2621491:
          return methodInfoExchangeUnbindOk;
        case 3276810:
          return methodInfoQueueDeclare;
        case 3276811:
          return methodInfoQueueDeclareOk;
        case 3276820:
          return methodInfoQueueBind;
        case 3276821:
          return methodInfoQueueBindOk;
        case 3276830:
          return methodInfoQueuePurge;
        case 3276831:
          return methodInfoQueuePurgeOk;
        case 3276840:
          return methodInfoQueueDelete;
        case 3276841:
          return methodInfoQueueDeleteOk;
        case 3276850:
          return methodInfoQueueUnbind;
        case 3276851:
          return methodInfoQueueUnbindOk;
        case 3932170:
          return methodInfoBasicQos;
        case 3932171:
          return methodInfoBasicQosOk;
        case 3932180:
          return methodInfoBasicConsume;
        case 3932181:
          return methodInfoBasicConsumeOk;
        case 3932190:
          return methodInfoBasicCancel;
        case 3932191:
          return methodInfoBasicCancelOk;
        case 3932200:
          return methodInfoBasicPublish;
        case 3932210:
          return methodInfoBasicReturn;
        case 3932220:
          return methodInfoBasicDeliver;
        case 3932230:
          return methodInfoBasicGet;
        case 3932231:
          return methodInfoBasicGetOk;
        case 3932232:
          return methodInfoBasicGetEmpty;
        case 3932240:
          return methodInfoBasicAck;
        case 3932250:
          return methodInfoBasicReject;
        case 3932260:
          return methodInfoBasicRecoverAsync;
        case 3932270:
          return methodInfoBasicRecover;
        case 3932271:
          return methodInfoBasicRecoverOk;
        case 3932280:
          return methodInfoBasicNack;
        case 5898250:
          return methodInfoTxSelect;
        case 5898251:
          return methodInfoTxSelectOk;
        case 5898260:
          return methodInfoTxCommit;
        case 5898261:
          return methodInfoTxCommitOk;
        case 5898270:
          return methodInfoTxRollback;
        case 5898271:
          return methodInfoTxRollbackOk;
        case 5570570:
          return methodInfoConfirmSelect;
        case 5570571:
          return methodInfoConfirmSelectOk;
        case 60:
          return propertiesInfoBasicProperties;
        default:
          throw new Error("Unknown class/method ID");
      }
    };
    module2.exports.ConnectionStart = 655370;
    var methodInfoConnectionStart = module2.exports.methodInfoConnectionStart = {
      id: 655370,
      classId: 10,
      methodId: 10,
      name: "ConnectionStart",
      args: [{
        type: "octet",
        name: "versionMajor",
        default: 0
      }, {
        type: "octet",
        name: "versionMinor",
        default: 9
      }, {
        type: "table",
        name: "serverProperties"
      }, {
        type: "longstr",
        name: "mechanisms",
        default: "PLAIN"
      }, {
        type: "longstr",
        name: "locales",
        default: "en_US"
      }]
    };
    module2.exports.ConnectionStartOk = 655371;
    var methodInfoConnectionStartOk = module2.exports.methodInfoConnectionStartOk = {
      id: 655371,
      classId: 10,
      methodId: 11,
      name: "ConnectionStartOk",
      args: [{
        type: "table",
        name: "clientProperties"
      }, {
        type: "shortstr",
        name: "mechanism",
        default: "PLAIN"
      }, {
        type: "longstr",
        name: "response"
      }, {
        type: "shortstr",
        name: "locale",
        default: "en_US"
      }]
    };
    module2.exports.ConnectionSecure = 655380;
    var methodInfoConnectionSecure = module2.exports.methodInfoConnectionSecure = {
      id: 655380,
      classId: 10,
      methodId: 20,
      name: "ConnectionSecure",
      args: [{
        type: "longstr",
        name: "challenge"
      }]
    };
    module2.exports.ConnectionSecureOk = 655381;
    var methodInfoConnectionSecureOk = module2.exports.methodInfoConnectionSecureOk = {
      id: 655381,
      classId: 10,
      methodId: 21,
      name: "ConnectionSecureOk",
      args: [{
        type: "longstr",
        name: "response"
      }]
    };
    module2.exports.ConnectionTune = 655390;
    var methodInfoConnectionTune = module2.exports.methodInfoConnectionTune = {
      id: 655390,
      classId: 10,
      methodId: 30,
      name: "ConnectionTune",
      args: [{
        type: "short",
        name: "channelMax",
        default: 0
      }, {
        type: "long",
        name: "frameMax",
        default: 0
      }, {
        type: "short",
        name: "heartbeat",
        default: 0
      }]
    };
    module2.exports.ConnectionTuneOk = 655391;
    var methodInfoConnectionTuneOk = module2.exports.methodInfoConnectionTuneOk = {
      id: 655391,
      classId: 10,
      methodId: 31,
      name: "ConnectionTuneOk",
      args: [{
        type: "short",
        name: "channelMax",
        default: 0
      }, {
        type: "long",
        name: "frameMax",
        default: 0
      }, {
        type: "short",
        name: "heartbeat",
        default: 0
      }]
    };
    module2.exports.ConnectionOpen = 655400;
    var methodInfoConnectionOpen = module2.exports.methodInfoConnectionOpen = {
      id: 655400,
      classId: 10,
      methodId: 40,
      name: "ConnectionOpen",
      args: [{
        type: "shortstr",
        name: "virtualHost",
        default: "/"
      }, {
        type: "shortstr",
        name: "capabilities",
        default: ""
      }, {
        type: "bit",
        name: "insist",
        default: false
      }]
    };
    module2.exports.ConnectionOpenOk = 655401;
    var methodInfoConnectionOpenOk = module2.exports.methodInfoConnectionOpenOk = {
      id: 655401,
      classId: 10,
      methodId: 41,
      name: "ConnectionOpenOk",
      args: [{
        type: "shortstr",
        name: "knownHosts",
        default: ""
      }]
    };
    module2.exports.ConnectionClose = 655410;
    var methodInfoConnectionClose = module2.exports.methodInfoConnectionClose = {
      id: 655410,
      classId: 10,
      methodId: 50,
      name: "ConnectionClose",
      args: [{
        type: "short",
        name: "replyCode"
      }, {
        type: "shortstr",
        name: "replyText",
        default: ""
      }, {
        type: "short",
        name: "classId"
      }, {
        type: "short",
        name: "methodId"
      }]
    };
    module2.exports.ConnectionCloseOk = 655411;
    var methodInfoConnectionCloseOk = module2.exports.methodInfoConnectionCloseOk = {
      id: 655411,
      classId: 10,
      methodId: 51,
      name: "ConnectionCloseOk",
      args: []
    };
    module2.exports.ConnectionBlocked = 655420;
    var methodInfoConnectionBlocked = module2.exports.methodInfoConnectionBlocked = {
      id: 655420,
      classId: 10,
      methodId: 60,
      name: "ConnectionBlocked",
      args: [{
        type: "shortstr",
        name: "reason",
        default: ""
      }]
    };
    module2.exports.ConnectionUnblocked = 655421;
    var methodInfoConnectionUnblocked = module2.exports.methodInfoConnectionUnblocked = {
      id: 655421,
      classId: 10,
      methodId: 61,
      name: "ConnectionUnblocked",
      args: []
    };
    module2.exports.ChannelOpen = 1310730;
    var methodInfoChannelOpen = module2.exports.methodInfoChannelOpen = {
      id: 1310730,
      classId: 20,
      methodId: 10,
      name: "ChannelOpen",
      args: [{
        type: "shortstr",
        name: "outOfBand",
        default: ""
      }]
    };
    module2.exports.ChannelOpenOk = 1310731;
    var methodInfoChannelOpenOk = module2.exports.methodInfoChannelOpenOk = {
      id: 1310731,
      classId: 20,
      methodId: 11,
      name: "ChannelOpenOk",
      args: [{
        type: "longstr",
        name: "channelId",
        default: ""
      }]
    };
    module2.exports.ChannelFlow = 1310740;
    var methodInfoChannelFlow = module2.exports.methodInfoChannelFlow = {
      id: 1310740,
      classId: 20,
      methodId: 20,
      name: "ChannelFlow",
      args: [{
        type: "bit",
        name: "active"
      }]
    };
    module2.exports.ChannelFlowOk = 1310741;
    var methodInfoChannelFlowOk = module2.exports.methodInfoChannelFlowOk = {
      id: 1310741,
      classId: 20,
      methodId: 21,
      name: "ChannelFlowOk",
      args: [{
        type: "bit",
        name: "active"
      }]
    };
    module2.exports.ChannelClose = 1310760;
    var methodInfoChannelClose = module2.exports.methodInfoChannelClose = {
      id: 1310760,
      classId: 20,
      methodId: 40,
      name: "ChannelClose",
      args: [{
        type: "short",
        name: "replyCode"
      }, {
        type: "shortstr",
        name: "replyText",
        default: ""
      }, {
        type: "short",
        name: "classId"
      }, {
        type: "short",
        name: "methodId"
      }]
    };
    module2.exports.ChannelCloseOk = 1310761;
    var methodInfoChannelCloseOk = module2.exports.methodInfoChannelCloseOk = {
      id: 1310761,
      classId: 20,
      methodId: 41,
      name: "ChannelCloseOk",
      args: []
    };
    module2.exports.AccessRequest = 1966090;
    var methodInfoAccessRequest = module2.exports.methodInfoAccessRequest = {
      id: 1966090,
      classId: 30,
      methodId: 10,
      name: "AccessRequest",
      args: [{
        type: "shortstr",
        name: "realm",
        default: "/data"
      }, {
        type: "bit",
        name: "exclusive",
        default: false
      }, {
        type: "bit",
        name: "passive",
        default: true
      }, {
        type: "bit",
        name: "active",
        default: true
      }, {
        type: "bit",
        name: "write",
        default: true
      }, {
        type: "bit",
        name: "read",
        default: true
      }]
    };
    module2.exports.AccessRequestOk = 1966091;
    var methodInfoAccessRequestOk = module2.exports.methodInfoAccessRequestOk = {
      id: 1966091,
      classId: 30,
      methodId: 11,
      name: "AccessRequestOk",
      args: [{
        type: "short",
        name: "ticket",
        default: 1
      }]
    };
    module2.exports.ExchangeDeclare = 2621450;
    var methodInfoExchangeDeclare = module2.exports.methodInfoExchangeDeclare = {
      id: 2621450,
      classId: 40,
      methodId: 10,
      name: "ExchangeDeclare",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "exchange"
      }, {
        type: "shortstr",
        name: "type",
        default: "direct"
      }, {
        type: "bit",
        name: "passive",
        default: false
      }, {
        type: "bit",
        name: "durable",
        default: false
      }, {
        type: "bit",
        name: "autoDelete",
        default: false
      }, {
        type: "bit",
        name: "internal",
        default: false
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }, {
        type: "table",
        name: "arguments",
        default: {}
      }]
    };
    module2.exports.ExchangeDeclareOk = 2621451;
    var methodInfoExchangeDeclareOk = module2.exports.methodInfoExchangeDeclareOk = {
      id: 2621451,
      classId: 40,
      methodId: 11,
      name: "ExchangeDeclareOk",
      args: []
    };
    module2.exports.ExchangeDelete = 2621460;
    var methodInfoExchangeDelete = module2.exports.methodInfoExchangeDelete = {
      id: 2621460,
      classId: 40,
      methodId: 20,
      name: "ExchangeDelete",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "exchange"
      }, {
        type: "bit",
        name: "ifUnused",
        default: false
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }]
    };
    module2.exports.ExchangeDeleteOk = 2621461;
    var methodInfoExchangeDeleteOk = module2.exports.methodInfoExchangeDeleteOk = {
      id: 2621461,
      classId: 40,
      methodId: 21,
      name: "ExchangeDeleteOk",
      args: []
    };
    module2.exports.ExchangeBind = 2621470;
    var methodInfoExchangeBind = module2.exports.methodInfoExchangeBind = {
      id: 2621470,
      classId: 40,
      methodId: 30,
      name: "ExchangeBind",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "destination"
      }, {
        type: "shortstr",
        name: "source"
      }, {
        type: "shortstr",
        name: "routingKey",
        default: ""
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }, {
        type: "table",
        name: "arguments",
        default: {}
      }]
    };
    module2.exports.ExchangeBindOk = 2621471;
    var methodInfoExchangeBindOk = module2.exports.methodInfoExchangeBindOk = {
      id: 2621471,
      classId: 40,
      methodId: 31,
      name: "ExchangeBindOk",
      args: []
    };
    module2.exports.ExchangeUnbind = 2621480;
    var methodInfoExchangeUnbind = module2.exports.methodInfoExchangeUnbind = {
      id: 2621480,
      classId: 40,
      methodId: 40,
      name: "ExchangeUnbind",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "destination"
      }, {
        type: "shortstr",
        name: "source"
      }, {
        type: "shortstr",
        name: "routingKey",
        default: ""
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }, {
        type: "table",
        name: "arguments",
        default: {}
      }]
    };
    module2.exports.ExchangeUnbindOk = 2621491;
    var methodInfoExchangeUnbindOk = module2.exports.methodInfoExchangeUnbindOk = {
      id: 2621491,
      classId: 40,
      methodId: 51,
      name: "ExchangeUnbindOk",
      args: []
    };
    module2.exports.QueueDeclare = 3276810;
    var methodInfoQueueDeclare = module2.exports.methodInfoQueueDeclare = {
      id: 3276810,
      classId: 50,
      methodId: 10,
      name: "QueueDeclare",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "queue",
        default: ""
      }, {
        type: "bit",
        name: "passive",
        default: false
      }, {
        type: "bit",
        name: "durable",
        default: false
      }, {
        type: "bit",
        name: "exclusive",
        default: false
      }, {
        type: "bit",
        name: "autoDelete",
        default: false
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }, {
        type: "table",
        name: "arguments",
        default: {}
      }]
    };
    module2.exports.QueueDeclareOk = 3276811;
    var methodInfoQueueDeclareOk = module2.exports.methodInfoQueueDeclareOk = {
      id: 3276811,
      classId: 50,
      methodId: 11,
      name: "QueueDeclareOk",
      args: [{
        type: "shortstr",
        name: "queue"
      }, {
        type: "long",
        name: "messageCount"
      }, {
        type: "long",
        name: "consumerCount"
      }]
    };
    module2.exports.QueueBind = 3276820;
    var methodInfoQueueBind = module2.exports.methodInfoQueueBind = {
      id: 3276820,
      classId: 50,
      methodId: 20,
      name: "QueueBind",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "queue",
        default: ""
      }, {
        type: "shortstr",
        name: "exchange"
      }, {
        type: "shortstr",
        name: "routingKey",
        default: ""
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }, {
        type: "table",
        name: "arguments",
        default: {}
      }]
    };
    module2.exports.QueueBindOk = 3276821;
    var methodInfoQueueBindOk = module2.exports.methodInfoQueueBindOk = {
      id: 3276821,
      classId: 50,
      methodId: 21,
      name: "QueueBindOk",
      args: []
    };
    module2.exports.QueuePurge = 3276830;
    var methodInfoQueuePurge = module2.exports.methodInfoQueuePurge = {
      id: 3276830,
      classId: 50,
      methodId: 30,
      name: "QueuePurge",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "queue",
        default: ""
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }]
    };
    module2.exports.QueuePurgeOk = 3276831;
    var methodInfoQueuePurgeOk = module2.exports.methodInfoQueuePurgeOk = {
      id: 3276831,
      classId: 50,
      methodId: 31,
      name: "QueuePurgeOk",
      args: [{
        type: "long",
        name: "messageCount"
      }]
    };
    module2.exports.QueueDelete = 3276840;
    var methodInfoQueueDelete = module2.exports.methodInfoQueueDelete = {
      id: 3276840,
      classId: 50,
      methodId: 40,
      name: "QueueDelete",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "queue",
        default: ""
      }, {
        type: "bit",
        name: "ifUnused",
        default: false
      }, {
        type: "bit",
        name: "ifEmpty",
        default: false
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }]
    };
    module2.exports.QueueDeleteOk = 3276841;
    var methodInfoQueueDeleteOk = module2.exports.methodInfoQueueDeleteOk = {
      id: 3276841,
      classId: 50,
      methodId: 41,
      name: "QueueDeleteOk",
      args: [{
        type: "long",
        name: "messageCount"
      }]
    };
    module2.exports.QueueUnbind = 3276850;
    var methodInfoQueueUnbind = module2.exports.methodInfoQueueUnbind = {
      id: 3276850,
      classId: 50,
      methodId: 50,
      name: "QueueUnbind",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "queue",
        default: ""
      }, {
        type: "shortstr",
        name: "exchange"
      }, {
        type: "shortstr",
        name: "routingKey",
        default: ""
      }, {
        type: "table",
        name: "arguments",
        default: {}
      }]
    };
    module2.exports.QueueUnbindOk = 3276851;
    var methodInfoQueueUnbindOk = module2.exports.methodInfoQueueUnbindOk = {
      id: 3276851,
      classId: 50,
      methodId: 51,
      name: "QueueUnbindOk",
      args: []
    };
    module2.exports.BasicQos = 3932170;
    var methodInfoBasicQos = module2.exports.methodInfoBasicQos = {
      id: 3932170,
      classId: 60,
      methodId: 10,
      name: "BasicQos",
      args: [{
        type: "long",
        name: "prefetchSize",
        default: 0
      }, {
        type: "short",
        name: "prefetchCount",
        default: 0
      }, {
        type: "bit",
        name: "global",
        default: false
      }]
    };
    module2.exports.BasicQosOk = 3932171;
    var methodInfoBasicQosOk = module2.exports.methodInfoBasicQosOk = {
      id: 3932171,
      classId: 60,
      methodId: 11,
      name: "BasicQosOk",
      args: []
    };
    module2.exports.BasicConsume = 3932180;
    var methodInfoBasicConsume = module2.exports.methodInfoBasicConsume = {
      id: 3932180,
      classId: 60,
      methodId: 20,
      name: "BasicConsume",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "queue",
        default: ""
      }, {
        type: "shortstr",
        name: "consumerTag",
        default: ""
      }, {
        type: "bit",
        name: "noLocal",
        default: false
      }, {
        type: "bit",
        name: "noAck",
        default: false
      }, {
        type: "bit",
        name: "exclusive",
        default: false
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }, {
        type: "table",
        name: "arguments",
        default: {}
      }]
    };
    module2.exports.BasicConsumeOk = 3932181;
    var methodInfoBasicConsumeOk = module2.exports.methodInfoBasicConsumeOk = {
      id: 3932181,
      classId: 60,
      methodId: 21,
      name: "BasicConsumeOk",
      args: [{
        type: "shortstr",
        name: "consumerTag"
      }]
    };
    module2.exports.BasicCancel = 3932190;
    var methodInfoBasicCancel = module2.exports.methodInfoBasicCancel = {
      id: 3932190,
      classId: 60,
      methodId: 30,
      name: "BasicCancel",
      args: [{
        type: "shortstr",
        name: "consumerTag"
      }, {
        type: "bit",
        name: "nowait",
        default: false
      }]
    };
    module2.exports.BasicCancelOk = 3932191;
    var methodInfoBasicCancelOk = module2.exports.methodInfoBasicCancelOk = {
      id: 3932191,
      classId: 60,
      methodId: 31,
      name: "BasicCancelOk",
      args: [{
        type: "shortstr",
        name: "consumerTag"
      }]
    };
    module2.exports.BasicPublish = 3932200;
    var methodInfoBasicPublish = module2.exports.methodInfoBasicPublish = {
      id: 3932200,
      classId: 60,
      methodId: 40,
      name: "BasicPublish",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "exchange",
        default: ""
      }, {
        type: "shortstr",
        name: "routingKey",
        default: ""
      }, {
        type: "bit",
        name: "mandatory",
        default: false
      }, {
        type: "bit",
        name: "immediate",
        default: false
      }]
    };
    module2.exports.BasicReturn = 3932210;
    var methodInfoBasicReturn = module2.exports.methodInfoBasicReturn = {
      id: 3932210,
      classId: 60,
      methodId: 50,
      name: "BasicReturn",
      args: [{
        type: "short",
        name: "replyCode"
      }, {
        type: "shortstr",
        name: "replyText",
        default: ""
      }, {
        type: "shortstr",
        name: "exchange"
      }, {
        type: "shortstr",
        name: "routingKey"
      }]
    };
    module2.exports.BasicDeliver = 3932220;
    var methodInfoBasicDeliver = module2.exports.methodInfoBasicDeliver = {
      id: 3932220,
      classId: 60,
      methodId: 60,
      name: "BasicDeliver",
      args: [{
        type: "shortstr",
        name: "consumerTag"
      }, {
        type: "longlong",
        name: "deliveryTag"
      }, {
        type: "bit",
        name: "redelivered",
        default: false
      }, {
        type: "shortstr",
        name: "exchange"
      }, {
        type: "shortstr",
        name: "routingKey"
      }]
    };
    module2.exports.BasicGet = 3932230;
    var methodInfoBasicGet = module2.exports.methodInfoBasicGet = {
      id: 3932230,
      classId: 60,
      methodId: 70,
      name: "BasicGet",
      args: [{
        type: "short",
        name: "ticket",
        default: 0
      }, {
        type: "shortstr",
        name: "queue",
        default: ""
      }, {
        type: "bit",
        name: "noAck",
        default: false
      }]
    };
    module2.exports.BasicGetOk = 3932231;
    var methodInfoBasicGetOk = module2.exports.methodInfoBasicGetOk = {
      id: 3932231,
      classId: 60,
      methodId: 71,
      name: "BasicGetOk",
      args: [{
        type: "longlong",
        name: "deliveryTag"
      }, {
        type: "bit",
        name: "redelivered",
        default: false
      }, {
        type: "shortstr",
        name: "exchange"
      }, {
        type: "shortstr",
        name: "routingKey"
      }, {
        type: "long",
        name: "messageCount"
      }]
    };
    module2.exports.BasicGetEmpty = 3932232;
    var methodInfoBasicGetEmpty = module2.exports.methodInfoBasicGetEmpty = {
      id: 3932232,
      classId: 60,
      methodId: 72,
      name: "BasicGetEmpty",
      args: [{
        type: "shortstr",
        name: "clusterId",
        default: ""
      }]
    };
    module2.exports.BasicAck = 3932240;
    var methodInfoBasicAck = module2.exports.methodInfoBasicAck = {
      id: 3932240,
      classId: 60,
      methodId: 80,
      name: "BasicAck",
      args: [{
        type: "longlong",
        name: "deliveryTag",
        default: 0
      }, {
        type: "bit",
        name: "multiple",
        default: false
      }]
    };
    module2.exports.BasicReject = 3932250;
    var methodInfoBasicReject = module2.exports.methodInfoBasicReject = {
      id: 3932250,
      classId: 60,
      methodId: 90,
      name: "BasicReject",
      args: [{
        type: "longlong",
        name: "deliveryTag"
      }, {
        type: "bit",
        name: "requeue",
        default: true
      }]
    };
    module2.exports.BasicRecoverAsync = 3932260;
    var methodInfoBasicRecoverAsync = module2.exports.methodInfoBasicRecoverAsync = {
      id: 3932260,
      classId: 60,
      methodId: 100,
      name: "BasicRecoverAsync",
      args: [{
        type: "bit",
        name: "requeue",
        default: false
      }]
    };
    module2.exports.BasicRecover = 3932270;
    var methodInfoBasicRecover = module2.exports.methodInfoBasicRecover = {
      id: 3932270,
      classId: 60,
      methodId: 110,
      name: "BasicRecover",
      args: [{
        type: "bit",
        name: "requeue",
        default: false
      }]
    };
    module2.exports.BasicRecoverOk = 3932271;
    var methodInfoBasicRecoverOk = module2.exports.methodInfoBasicRecoverOk = {
      id: 3932271,
      classId: 60,
      methodId: 111,
      name: "BasicRecoverOk",
      args: []
    };
    module2.exports.BasicNack = 3932280;
    var methodInfoBasicNack = module2.exports.methodInfoBasicNack = {
      id: 3932280,
      classId: 60,
      methodId: 120,
      name: "BasicNack",
      args: [{
        type: "longlong",
        name: "deliveryTag",
        default: 0
      }, {
        type: "bit",
        name: "multiple",
        default: false
      }, {
        type: "bit",
        name: "requeue",
        default: true
      }]
    };
    module2.exports.TxSelect = 5898250;
    var methodInfoTxSelect = module2.exports.methodInfoTxSelect = {
      id: 5898250,
      classId: 90,
      methodId: 10,
      name: "TxSelect",
      args: []
    };
    module2.exports.TxSelectOk = 5898251;
    var methodInfoTxSelectOk = module2.exports.methodInfoTxSelectOk = {
      id: 5898251,
      classId: 90,
      methodId: 11,
      name: "TxSelectOk",
      args: []
    };
    module2.exports.TxCommit = 5898260;
    var methodInfoTxCommit = module2.exports.methodInfoTxCommit = {
      id: 5898260,
      classId: 90,
      methodId: 20,
      name: "TxCommit",
      args: []
    };
    module2.exports.TxCommitOk = 5898261;
    var methodInfoTxCommitOk = module2.exports.methodInfoTxCommitOk = {
      id: 5898261,
      classId: 90,
      methodId: 21,
      name: "TxCommitOk",
      args: []
    };
    module2.exports.TxRollback = 5898270;
    var methodInfoTxRollback = module2.exports.methodInfoTxRollback = {
      id: 5898270,
      classId: 90,
      methodId: 30,
      name: "TxRollback",
      args: []
    };
    module2.exports.TxRollbackOk = 5898271;
    var methodInfoTxRollbackOk = module2.exports.methodInfoTxRollbackOk = {
      id: 5898271,
      classId: 90,
      methodId: 31,
      name: "TxRollbackOk",
      args: []
    };
    module2.exports.ConfirmSelect = 5570570;
    var methodInfoConfirmSelect = module2.exports.methodInfoConfirmSelect = {
      id: 5570570,
      classId: 85,
      methodId: 10,
      name: "ConfirmSelect",
      args: [{
        type: "bit",
        name: "nowait",
        default: false
      }]
    };
    module2.exports.ConfirmSelectOk = 5570571;
    var methodInfoConfirmSelectOk = module2.exports.methodInfoConfirmSelectOk = {
      id: 5570571,
      classId: 85,
      methodId: 11,
      name: "ConfirmSelectOk",
      args: []
    };
    module2.exports.BasicProperties = 60;
    var propertiesInfoBasicProperties = module2.exports.propertiesInfoBasicProperties = {
      id: 60,
      name: "BasicProperties",
      args: [{
        type: "shortstr",
        name: "contentType"
      }, {
        type: "shortstr",
        name: "contentEncoding"
      }, {
        type: "table",
        name: "headers"
      }, {
        type: "octet",
        name: "deliveryMode"
      }, {
        type: "octet",
        name: "priority"
      }, {
        type: "shortstr",
        name: "correlationId"
      }, {
        type: "shortstr",
        name: "replyTo"
      }, {
        type: "shortstr",
        name: "expiration"
      }, {
        type: "shortstr",
        name: "messageId"
      }, {
        type: "timestamp",
        name: "timestamp"
      }, {
        type: "shortstr",
        name: "type"
      }, {
        type: "shortstr",
        name: "userId"
      }, {
        type: "shortstr",
        name: "appId"
      }, {
        type: "shortstr",
        name: "clusterId"
      }]
    };
  }
});

// node_modules/bitsyntax/lib/pattern.js
var require_pattern = __commonJS({
  "node_modules/bitsyntax/lib/pattern.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function set(values) {
      var s = {};
      for (var i in values) {
        s[values[i]] = 1;
      }
      return s;
    }
    function variable(name, size, specifiers0) {
      var specifiers = set(specifiers0);
      var segment = { name };
      segment.type = type_in(specifiers);
      specs(segment, segment.type, specifiers);
      segment.size = size_of(segment, segment.type, size, segment.unit);
      return segment;
    }
    module2.exports.variable = variable;
    module2.exports.rest = function() {
      return variable("_", true, ["binary"]);
    };
    function value(val, size, specifiers0) {
      var specifiers = set(specifiers0);
      var segment = { value: val };
      segment.type = type_in(specifiers);
      specs(segment, segment.type, specifiers);
      segment.size = size_of(segment, segment.type, size, segment.unit);
      return segment;
    }
    module2.exports.value = value;
    function string(val) {
      return { value: val, type: "string" };
    }
    module2.exports.string = string;
    var TYPES = { "integer": 1, "binary": 1, "float": 1 };
    function type_in(specifiers) {
      for (var t in specifiers) {
        if (TYPES[t]) {
          return t;
        }
      }
      return "integer";
    }
    function specs(segment, type, specifiers) {
      switch (type) {
        case "integer":
          segment.signed = signed_in(specifiers);
        case "float":
          segment.bigendian = endian_in(specifiers);
        default:
          segment.unit = unit_in(specifiers, segment.type);
      }
      return segment;
    }
    function endian_in(specifiers) {
      return !specifiers["little"];
    }
    function signed_in(specifiers) {
      return specifiers["signed"];
    }
    function unit_in(specifiers, type) {
      for (var s in specifiers) {
        if (s.substr(0, 5) == "unit:") {
          var unit = parseInt(s.substr(5));
          return unit;
        }
      }
      switch (type) {
        case "binary":
          return 8;
        case "integer":
        case "float":
          return 1;
      }
    }
    function size_of(segment, type, size, unit) {
      if (size !== void 0 && size !== "") {
        return size;
      } else {
        switch (type) {
          case "integer":
            return 8;
          case "float":
            return 64;
          case "binary":
            return true;
        }
      }
    }
  }
});

// node_modules/bitsyntax/lib/parser.js
var require_parser = __commonJS({
  "node_modules/bitsyntax/lib/parser.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = function() {
      function quote(s) {
        return '"' + s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
      }
      var result = {
        /*
         * Parses the input with a generated parser. If the parsing is successfull,
         * returns a value explicitly or implicitly specified by the grammar from
         * which the parser was generated (see |PEG.buildParser|). If the parsing is
         * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
         */
        parse: function(input, startRule) {
          var parseFunctions = {
            "start": parse_start,
            "segmentTail": parse_segmentTail,
            "segment": parse_segment,
            "string": parse_string,
            "chars": parse_chars,
            "char": parse_char,
            "hexDigit": parse_hexDigit,
            "identifier": parse_identifier,
            "number": parse_number,
            "size": parse_size,
            "specifierList": parse_specifierList,
            "specifierTail": parse_specifierTail,
            "specifier": parse_specifier,
            "unit": parse_unit,
            "ws": parse_ws
          };
          if (startRule !== void 0) {
            if (parseFunctions[startRule] === void 0) {
              throw new Error("Invalid rule name: " + quote(startRule) + ".");
            }
          } else {
            startRule = "start";
          }
          var pos = 0;
          var reportFailures = 0;
          var rightmostFailuresPos = 0;
          var rightmostFailuresExpected = [];
          function padLeft(input2, padding, length) {
            var result3 = input2;
            var padLength = length - input2.length;
            for (var i = 0; i < padLength; i++) {
              result3 = padding + result3;
            }
            return result3;
          }
          function escape2(ch) {
            var charCode = ch.charCodeAt(0);
            var escapeChar;
            var length;
            if (charCode <= 255) {
              escapeChar = "x";
              length = 2;
            } else {
              escapeChar = "u";
              length = 4;
            }
            return "\\" + escapeChar + padLeft(charCode.toString(16).toUpperCase(), "0", length);
          }
          function matchFailed(failure) {
            if (pos < rightmostFailuresPos) {
              return;
            }
            if (pos > rightmostFailuresPos) {
              rightmostFailuresPos = pos;
              rightmostFailuresExpected = [];
            }
            rightmostFailuresExpected.push(failure);
          }
          function parse_start() {
            var result0, result1, result22, result3;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            result0 = parse_ws();
            if (result0 !== null) {
              result1 = parse_segment();
              if (result1 !== null) {
                result22 = [];
                result3 = parse_segmentTail();
                while (result3 !== null) {
                  result22.push(result3);
                  result3 = parse_segmentTail();
                }
                if (result22 !== null) {
                  result0 = [result0, result1, result22];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, head, tail) {
                tail.unshift(head);
                return tail;
              }(pos0, result0[1], result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          function parse_segmentTail() {
            var result0, result1, result22, result3;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            result0 = parse_ws();
            if (result0 !== null) {
              if (input.charCodeAt(pos) === 44) {
                result1 = ",";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed('","');
                }
              }
              if (result1 !== null) {
                result22 = parse_ws();
                if (result22 !== null) {
                  result3 = parse_segment();
                  if (result3 !== null) {
                    result0 = [result0, result1, result22, result3];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, seg) {
                return seg;
              }(pos0, result0[3]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          function parse_segment() {
            var result0, result1, result22;
            var pos0, pos1;
            pos0 = pos;
            result0 = parse_string();
            if (result0 !== null) {
              result0 = function(offset2, str) {
                return { string: str };
              }(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse_identifier();
              if (result0 !== null) {
                result1 = parse_size();
                result1 = result1 !== null ? result1 : "";
                if (result1 !== null) {
                  result22 = parse_specifierList();
                  result22 = result22 !== null ? result22 : "";
                  if (result22 !== null) {
                    result0 = [result0, result1, result22];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = function(offset2, v, size, specs) {
                  return { name: v, size, specifiers: specs };
                }(pos0, result0[0], result0[1], result0[2]);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                result0 = parse_number();
                if (result0 !== null) {
                  result1 = parse_size();
                  result1 = result1 !== null ? result1 : "";
                  if (result1 !== null) {
                    result22 = parse_specifierList();
                    result22 = result22 !== null ? result22 : "";
                    if (result22 !== null) {
                      result0 = [result0, result1, result22];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = function(offset2, v, size, specs) {
                    return { value: v, size, specifiers: specs };
                  }(pos0, result0[0], result0[1], result0[2]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
            return result0;
          }
          function parse_string() {
            var result0, result1, result22;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 34) {
              result0 = '"';
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('"\\""');
              }
            }
            if (result0 !== null) {
              if (input.charCodeAt(pos) === 34) {
                result1 = '"';
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\""');
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2) {
                return "";
              }(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 34) {
                result0 = '"';
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\""');
                }
              }
              if (result0 !== null) {
                result1 = parse_chars();
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 34) {
                    result22 = '"';
                    pos++;
                  } else {
                    result22 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\""');
                    }
                  }
                  if (result22 !== null) {
                    result0 = [result0, result1, result22];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = function(offset2, chars) {
                  return chars;
                }(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
            return result0;
          }
          function parse_chars() {
            var result0, result1;
            var pos0;
            pos0 = pos;
            result1 = parse_char();
            if (result1 !== null) {
              result0 = [];
              while (result1 !== null) {
                result0.push(result1);
                result1 = parse_char();
              }
            } else {
              result0 = null;
            }
            if (result0 !== null) {
              result0 = function(offset2, chars) {
                return chars.join("");
              }(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          function parse_char() {
            var result0, result1, result22, result3, result4;
            var pos0, pos1;
            if (/^[^"\\\0-\x1F]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('[^"\\\\\\0-\\x1F]');
              }
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 2) === '\\"') {
                result0 = '\\"';
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\\\\\""');
                }
              }
              if (result0 !== null) {
                result0 = function(offset2) {
                  return '"';
                }(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 2) === "\\\\") {
                  result0 = "\\\\";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\\\\\\\"');
                  }
                }
                if (result0 !== null) {
                  result0 = function(offset2) {
                    return "\\";
                  }(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  if (input.substr(pos, 2) === "\\/") {
                    result0 = "\\/";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\\\/"');
                    }
                  }
                  if (result0 !== null) {
                    result0 = function(offset2) {
                      return "/";
                    }(pos0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                  if (result0 === null) {
                    pos0 = pos;
                    if (input.substr(pos, 2) === "\\b") {
                      result0 = "\\b";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\\\b"');
                      }
                    }
                    if (result0 !== null) {
                      result0 = function(offset2) {
                        return "\b";
                      }(pos0);
                    }
                    if (result0 === null) {
                      pos = pos0;
                    }
                    if (result0 === null) {
                      pos0 = pos;
                      if (input.substr(pos, 2) === "\\f") {
                        result0 = "\\f";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\\\f"');
                        }
                      }
                      if (result0 !== null) {
                        result0 = function(offset2) {
                          return "\f";
                        }(pos0);
                      }
                      if (result0 === null) {
                        pos = pos0;
                      }
                      if (result0 === null) {
                        pos0 = pos;
                        if (input.substr(pos, 2) === "\\n") {
                          result0 = "\\n";
                          pos += 2;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\\\n"');
                          }
                        }
                        if (result0 !== null) {
                          result0 = function(offset2) {
                            return "\n";
                          }(pos0);
                        }
                        if (result0 === null) {
                          pos = pos0;
                        }
                        if (result0 === null) {
                          pos0 = pos;
                          if (input.substr(pos, 2) === "\\r") {
                            result0 = "\\r";
                            pos += 2;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\\\r"');
                            }
                          }
                          if (result0 !== null) {
                            result0 = function(offset2) {
                              return "\r";
                            }(pos0);
                          }
                          if (result0 === null) {
                            pos = pos0;
                          }
                          if (result0 === null) {
                            pos0 = pos;
                            if (input.substr(pos, 2) === "\\t") {
                              result0 = "\\t";
                              pos += 2;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\\\t"');
                              }
                            }
                            if (result0 !== null) {
                              result0 = function(offset2) {
                                return "	";
                              }(pos0);
                            }
                            if (result0 === null) {
                              pos = pos0;
                            }
                            if (result0 === null) {
                              pos0 = pos;
                              pos1 = pos;
                              if (input.substr(pos, 2) === "\\u") {
                                result0 = "\\u";
                                pos += 2;
                              } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\\\\u"');
                                }
                              }
                              if (result0 !== null) {
                                result1 = parse_hexDigit();
                                if (result1 !== null) {
                                  result22 = parse_hexDigit();
                                  if (result22 !== null) {
                                    result3 = parse_hexDigit();
                                    if (result3 !== null) {
                                      result4 = parse_hexDigit();
                                      if (result4 !== null) {
                                        result0 = [result0, result1, result22, result3, result4];
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                              if (result0 !== null) {
                                result0 = function(offset2, h1, h2, h3, h4) {
                                  return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                                }(pos0, result0[1], result0[2], result0[3], result0[4]);
                              }
                              if (result0 === null) {
                                pos = pos0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return result0;
          }
          function parse_hexDigit() {
            var result0;
            if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9a-fA-F]");
              }
            }
            return result0;
          }
          function parse_identifier() {
            var result0, result1, result22;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            if (/^[_a-zA-Z]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[_a-zA-Z]");
              }
            }
            if (result0 !== null) {
              result1 = [];
              if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
                result22 = input.charAt(pos);
                pos++;
              } else {
                result22 = null;
                if (reportFailures === 0) {
                  matchFailed("[_a-zA-Z0-9]");
                }
              }
              while (result22 !== null) {
                result1.push(result22);
                if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
                  result22 = input.charAt(pos);
                  pos++;
                } else {
                  result22 = null;
                  if (reportFailures === 0) {
                    matchFailed("[_a-zA-Z0-9]");
                  }
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, head, tail) {
                return head + tail.join("");
              }(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          function parse_number() {
            var result0, result1, result22;
            var pos0, pos1;
            pos0 = pos;
            if (input.charCodeAt(pos) === 48) {
              result0 = "0";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('"0"');
              }
            }
            if (result0 !== null) {
              result0 = function(offset2) {
                return 0;
              }(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (/^[1-9]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result0 !== null) {
                result1 = [];
                if (/^[0-9]/.test(input.charAt(pos))) {
                  result22 = input.charAt(pos);
                  pos++;
                } else {
                  result22 = null;
                  if (reportFailures === 0) {
                    matchFailed("[0-9]");
                  }
                }
                while (result22 !== null) {
                  result1.push(result22);
                  if (/^[0-9]/.test(input.charAt(pos))) {
                    result22 = input.charAt(pos);
                    pos++;
                  } else {
                    result22 = null;
                    if (reportFailures === 0) {
                      matchFailed("[0-9]");
                    }
                  }
                }
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = function(offset2, head, tail) {
                  return parseInt(head + tail.join(""));
                }(pos0, result0[0], result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
            return result0;
          }
          function parse_size() {
            var result0, result1;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 58) {
              result0 = ":";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('":"');
              }
            }
            if (result0 !== null) {
              result1 = parse_number();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, num) {
                return num;
              }(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed('":"');
                }
              }
              if (result0 !== null) {
                result1 = parse_identifier();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = function(offset2, id) {
                  return id;
                }(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
            return result0;
          }
          function parse_specifierList() {
            var result0, result1, result22, result3;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('"/"');
              }
            }
            if (result0 !== null) {
              result1 = parse_specifier();
              if (result1 !== null) {
                result22 = [];
                result3 = parse_specifierTail();
                while (result3 !== null) {
                  result22.push(result3);
                  result3 = parse_specifierTail();
                }
                if (result22 !== null) {
                  result0 = [result0, result1, result22];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, head, tail) {
                tail.unshift(head);
                return tail;
              }(pos0, result0[1], result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          function parse_specifierTail() {
            var result0, result1;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 45) {
              result0 = "-";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('"-"');
              }
            }
            if (result0 !== null) {
              result1 = parse_specifier();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, spec) {
                return spec;
              }(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          function parse_specifier() {
            var result0;
            if (input.substr(pos, 6) === "little") {
              result0 = "little";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('"little"');
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 3) === "big") {
                result0 = "big";
                pos += 3;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed('"big"');
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6) === "signed") {
                  result0 = "signed";
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"signed"');
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 8) === "unsigned") {
                    result0 = "unsigned";
                    pos += 8;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"unsigned"');
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 7) === "integer") {
                      result0 = "integer";
                      pos += 7;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"integer"');
                      }
                    }
                    if (result0 === null) {
                      if (input.substr(pos, 6) === "binary") {
                        result0 = "binary";
                        pos += 6;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"binary"');
                        }
                      }
                      if (result0 === null) {
                        if (input.substr(pos, 5) === "float") {
                          result0 = "float";
                          pos += 5;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"float"');
                          }
                        }
                        if (result0 === null) {
                          result0 = parse_unit();
                        }
                      }
                    }
                  }
                }
              }
            }
            return result0;
          }
          function parse_unit() {
            var result0, result1;
            var pos0, pos1;
            pos0 = pos;
            pos1 = pos;
            if (input.substr(pos, 5) === "unit:") {
              result0 = "unit:";
              pos += 5;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed('"unit:"');
              }
            }
            if (result0 !== null) {
              result1 = parse_number();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, num) {
                return "unit:" + num;
              }(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          function parse_ws() {
            var result0, result1;
            result0 = [];
            if (/^[ \t\n]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[ \\t\\n]");
              }
            }
            while (result1 !== null) {
              result0.push(result1);
              if (/^[ \t\n]/.test(input.charAt(pos))) {
                result1 = input.charAt(pos);
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("[ \\t\\n]");
                }
              }
            }
            return result0;
          }
          function cleanupExpected(expected) {
            expected.sort();
            var lastExpected = null;
            var cleanExpected = [];
            for (var i = 0; i < expected.length; i++) {
              if (expected[i] !== lastExpected) {
                cleanExpected.push(expected[i]);
                lastExpected = expected[i];
              }
            }
            return cleanExpected;
          }
          function computeErrorPosition() {
            var line = 1;
            var column = 1;
            var seenCR = false;
            for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
              var ch = input.charAt(i);
              if (ch === "\n") {
                if (!seenCR) {
                  line++;
                }
                column = 1;
                seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                line++;
                column = 1;
                seenCR = true;
              } else {
                column++;
                seenCR = false;
              }
            }
            return { line, column };
          }
          var result2 = parseFunctions[startRule]();
          if (result2 === null || pos !== input.length) {
            var offset = Math.max(pos, rightmostFailuresPos);
            var found = offset < input.length ? input.charAt(offset) : null;
            var errorPosition = computeErrorPosition();
            throw new this.SyntaxError(
              cleanupExpected(rightmostFailuresExpected),
              found,
              offset,
              errorPosition.line,
              errorPosition.column
            );
          }
          return result2;
        },
        /* Returns the parser source code. */
        toSource: function() {
          return this._source;
        }
      };
      result.SyntaxError = function(expected, found, offset, line, column) {
        function buildMessage(expected2, found2) {
          var expectedHumanized, foundHumanized;
          switch (expected2.length) {
            case 0:
              expectedHumanized = "end of input";
              break;
            case 1:
              expectedHumanized = expected2[0];
              break;
            default:
              expectedHumanized = expected2.slice(0, expected2.length - 1).join(", ") + " or " + expected2[expected2.length - 1];
          }
          foundHumanized = found2 ? quote(found2) : "end of input";
          return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
        }
        this.name = "SyntaxError";
        this.expected = expected;
        this.found = found;
        this.message = buildMessage(expected, found);
        this.offset = offset;
        this.line = line;
        this.column = column;
      };
      result.SyntaxError.prototype = Error.prototype;
      return result;
    }();
  }
});

// node_modules/bitsyntax/lib/parse.js
var require_parse = __commonJS({
  "node_modules/bitsyntax/lib/parse.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var ast = require_pattern();
    var parser = require_parser();
    function parse_pattern(string) {
      var segments = parser.parse(string);
      for (var i = 0, len = segments.length; i < len; i++) {
        var s = segments[i];
        if (s.string != void 0) {
          segments[i] = ast.string(s.string);
        } else if (s.value != void 0) {
          segments[i] = ast.value(s.value, s.size, s.specifiers);
        } else if (s.name != void 0) {
          segments[i] = ast.variable(s.name, s.size, s.specifiers);
        } else {
          throw "Unknown segment " + s;
        }
      }
      return segments;
    }
    module2.exports.parse = function() {
      var str = [].join.call(arguments, ",");
      return parse_pattern(str);
    };
  }
});

// node_modules/bitsyntax/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/bitsyntax/node_modules/ms/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/bitsyntax/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/bitsyntax/node_modules/debug/src/debug.js"(exports2, module2) {
    init_process();
    init_buffer();
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/bitsyntax/node_modules/debug/src/browser.js
var require_browser5 = __commonJS({
  "node_modules/bitsyntax/node_modules/debug/src/browser.js"(exports2, module2) {
    init_process();
    init_buffer();
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/bitsyntax/lib/interp.js
var require_interp = __commonJS({
  "node_modules/bitsyntax/lib/interp.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var ints = require_buffer_more_ints();
    var debug = require_browser5()("bitsyntax-Interpreter");
    function parse_int(bin, off, sizeInBytes, bigendian, signed) {
      switch (sizeInBytes) {
        case 1:
          return signed ? bin.readInt8(off) : bin.readUInt8(off);
        case 2:
          return bigendian ? signed ? bin.readInt16BE(off) : bin.readUInt16BE(off) : signed ? bin.readInt16LE(off) : bin.readUInt16LE(off);
        case 4:
          return bigendian ? signed ? bin.readInt32BE(off) : bin.readUInt32BE(off) : signed ? bin.readInt32LE(off) : bin.readUInt32LE(off);
        case 8:
          return bigendian ? (signed ? ints.readInt64BE : ints.readUInt64BE)(bin, off) : (signed ? ints.readInt64LE : ints.readUInt64LE)(bin, off);
        default:
          throw "Integers must be 8-, 16-, 32- or 64-bit";
      }
    }
    function parse_float(bin, off, sizeInBytes, bigendian) {
      switch (sizeInBytes) {
        case 4:
          return bigendian ? bin.readFloatBE(off) : bin.readFloatLE(off);
        case 8:
          return bigendian ? bin.readDoubleBE(off) : bin.readDoubleLE(off);
        default:
          throw "Floats must be 32- or 64-bit";
      }
    }
    function size_of(segment, bound) {
      var size = segment.size;
      if (typeof size === "string") {
        return bound[size];
      } else {
        return size;
      }
    }
    function new_scope(env2) {
      function scope() {
      }
      ;
      scope.prototype = env2;
      return new scope();
    }
    function bindings(scope) {
      var s = {};
      for (var k in scope) {
        if (scope.hasOwnProperty(k)) {
          s[k] = scope[k];
        }
      }
      return s;
    }
    function match(pattern, binary, boundvars) {
      var offset = 0, vars = new_scope(boundvars);
      var binsize = binary.length * 8;
      function skip_bits(segment2) {
        debug("skip bits");
        debug(segment2);
        var size = size_of(segment2, vars);
        if (size === true) {
          if (offset % 8 === 0) {
            offset = binsize;
            return true;
          } else {
            return false;
          }
        }
        var bits = segment2.unit * size;
        if (offset + bits > binsize) {
          return false;
        } else {
          offset += bits;
        }
      }
      function get_integer(segment2) {
        debug("get_integer");
        debug(segment2);
        var unit = segment2.unit, size = size_of(segment2, vars);
        var bitsize = size * unit;
        var byteoffset = offset / 8;
        offset += bitsize;
        if (bitsize % 8 > 0 || offset > binsize) {
          return false;
        } else {
          return parse_int(
            binary,
            byteoffset,
            bitsize / 8,
            segment2.bigendian,
            segment2.signed
          );
        }
      }
      function get_float(segment2) {
        debug("get_float");
        debug(segment2);
        var unit = segment2.unit;
        var size = size_of(segment2, vars);
        var bitsize = size * unit;
        var byteoffset = offset / 8;
        offset += bitsize;
        if (offset > binsize) {
          return false;
        } else {
          return parse_float(
            binary,
            byteoffset,
            bitsize / 8,
            segment2.bigendian
          );
        }
      }
      function get_binary(segment2) {
        debug("get_binary");
        debug(segment2);
        var unit = segment2.unit, size = size_of(segment2, vars);
        var byteoffset = offset / 8;
        if (size === true) {
          offset = binsize;
          return binary.slice(byteoffset);
        } else {
          var bitsize = size * unit;
          if (bitsize % 8 > 0 || offset + bitsize > binsize) {
            return false;
          } else {
            offset += bitsize;
            return binary.slice(byteoffset, byteoffset + bitsize / 8);
          }
        }
      }
      function get_string(segment2) {
        debug("get_string");
        debug(segment2);
        var len = segment2.value.length;
        var byteoffset = offset / 8;
        offset += len * 8;
        if (offset > binsize) {
          return false;
        }
        return binary.slice(byteoffset, byteoffset + len).toString("utf8");
      }
      var patternlen = pattern.length;
      for (var i = 0; i < patternlen; i++) {
        var segment = pattern[i];
        var result = false;
        if (segment.name === "_") {
          result = skip_bits(segment);
        } else {
          switch (segment.type) {
            case "string":
              result = get_string(segment);
              break;
            case "integer":
              result = get_integer(segment);
              break;
            case "float":
              result = get_float(segment);
              break;
            case "binary":
              result = get_binary(segment);
              break;
          }
          if (result === false) {
            return false;
          } else if (segment.name) {
            vars[segment.name] = result;
          } else if (segment.value != result) {
            return false;
          }
        }
      }
      if (offset == binsize) {
        return bindings(vars);
      } else {
        return false;
      }
    }
    module2.exports.match = match;
    module2.exports.parse_int = parse_int;
    module2.exports.parse_float = parse_float;
  }
});

// node_modules/bitsyntax/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/bitsyntax/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/bitsyntax/lib/constructor.js
var require_constructor = __commonJS({
  "node_modules/bitsyntax/lib/constructor.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var ints = require_buffer_more_ints();
    var Buffer2 = require_safe_buffer2().Buffer;
    function write(buf, offset, pattern, bindings) {
      for (var i = 0, len = pattern.length; i < len; i++) {
        var segment = pattern[i];
        switch (segment.type) {
          case "string":
            offset += buf.write(segment.value, offset, "utf8");
            break;
          case "binary":
            offset += writeBinary(segment, buf, offset, bindings);
            break;
          case "integer":
            offset += writeInteger(segment, buf, offset, bindings);
            break;
          case "float":
            offset += writeFloat(segment, buf, offset, bindings);
            break;
        }
      }
      return offset;
    }
    function build(pattern, bindings) {
      var bufsize = size_of(pattern, bindings);
      var buf = Buffer2.alloc(bufsize);
      write(buf, 0, pattern, bindings);
      return buf;
    }
    function size_of_segment(segment, bindings) {
      if (typeof segment.size === "string") {
        return bindings[segment.size] * segment.unit / 8;
      }
      if (segment.type === "string") {
        return Buffer2.byteLength(segment.value, "utf8");
      }
      if (segment.type === "binary" && segment.size === true) {
        var val = bindings[segment.name];
        return val.length;
      }
      return segment.size * segment.unit / 8;
    }
    function size_of(segments, bindings) {
      var size = 0;
      for (var i = 0, len = segments.length; i < len; i++) {
        size += size_of_segment(segments[i], bindings);
      }
      return size;
    }
    function writeBinary(segment, buf, offset, bindings) {
      var bin = bindings[segment.name];
      var size = size_of_segment(segment, bindings);
      bin.copy(buf, offset, 0, size);
      return size;
    }
    function writeInteger(segment, buf, offset, bindings) {
      var value = segment.name ? bindings[segment.name] : segment.value;
      var size = size_of_segment(segment, bindings);
      return write_int(buf, value, offset, size, segment.bigendian);
    }
    function write_int(buf, value, offset, size, bigendian) {
      switch (size) {
        case 1:
          buf.writeUInt8(value, offset);
          break;
        case 2:
          bigendian ? buf.writeUInt16BE(value, offset) : buf.writeUInt16LE(value, offset);
          break;
        case 4:
          bigendian ? buf.writeUInt32BE(value, offset) : buf.writeUInt32LE(value, offset);
          break;
        case 8:
          bigendian ? ints.writeUInt64BE(buf, value, offset) : ints.writeUInt64LE(buf, value, offset);
          break;
        default:
          throw new Error("integer size * unit must be 8, 16, 32 or 64");
      }
      return size;
    }
    function writeFloat(segment, buf, offset, bindings) {
      var value = segment.name ? bindings[segment.name] : segment.value;
      var size = size_of_segment(segment, bindings);
      return write_float(buf, value, offset, size, segment.bigendian);
    }
    function write_float(buf, value, offset, size, bigendian) {
      if (size === 4) {
        bigendian ? buf.writeFloatBE(value, offset) : buf.writeFloatLE(value, offset);
      } else if (size === 8) {
        bigendian ? buf.writeDoubleBE(value, offset) : buf.writeDoubleLE(value, offset);
      } else {
        throw new Error("float size * unit must be 32 or 64");
      }
      return size;
    }
    var parse = require_parse().parse;
    module2.exports.write = write;
    module2.exports.build = build;
    module2.exports.write_int = write_int;
    module2.exports.write_float = write_float;
    module2.exports.builder = function(pstr) {
      pstr = arguments.length > 1 ? [].join.call(arguments, ",") : pstr;
      var pattern = parse(pstr);
      return function(vars) {
        return build(pattern, vars);
      };
    };
  }
});

// node_modules/bitsyntax/lib/compile.js
var require_compile = __commonJS({
  "node_modules/bitsyntax/lib/compile.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    require_buffer_more_ints();
    var $ = require_util2().format;
    var parse = require_parse().parse;
    var interp = require_interp();
    var parse_int = interp.parse_int;
    var parse_float = interp.parse_float;
    var construct = require_constructor();
    var write_int = construct.write_int;
    var write_float = construct.write_float;
    var Buffer2 = require_safe_buffer2().Buffer;
    var lines = [];
    function $start() {
      lines = [];
    }
    function $line() {
      lines.push($.apply(null, arguments));
    }
    function $result() {
      return lines.join("\n");
    }
    function bits_expr(segment) {
      if (typeof segment.size === "string") {
        return $("%s * %d", var_name(segment.size), segment.unit);
      } else {
        return (segment.size * segment.unit).toString();
      }
    }
    function get_number(segment) {
      $line("bits = %s;\n", bits_expr(segment));
      var parser = segment.type === "integer" ? "parse_int" : "parse_float";
      var be = segment.bigendian, sg = segment.signed;
      $line("byteoffset = offset / 8; offset += bits");
      $line("if (offset > binsize) { return false; }");
      $line(
        "else { result = %s(bin, byteoffset, bits / 8, %s, %s); }",
        parser,
        be,
        sg
      );
    }
    function get_binary(segment) {
      $line("byteoffset = offset / 8;");
      if (segment.size === true) {
        $line("offset = binsize;");
        $line("result = bin.slice(byteoffset);");
      } else {
        $line("bits = %s;", bits_expr(segment));
        $line("offset += bits;");
        $line("if (offset > binsize) { return false; }");
        $line(
          "else { result = bin.slice(byteoffset,",
          "byteoffset + bits / 8); }"
        );
      }
    }
    function get_string(segment) {
      $line("byteoffset = offset / 8;");
      var strlen = segment.value.length;
      var strlenbits = strlen * 8;
      $line("offset += %d;", strlenbits);
      $line("if (offset > binsize) { return false; }");
      $line(
        "else { result = bin.toString(byteoffset,",
        $("byteoffset + %d); }", strlen)
      );
    }
    function skip_bits(segment) {
      if (typeof segment.size === "string") {
        $line(
          "var skipbits = %s * %d;",
          var_name(segment.size),
          segment.unit
        );
        $line("if (offset + skipbits > binsize) { return false; }");
        $line("else { offset += skipbits; }");
      } else if (segment.size === true) {
        $line("if (offset % 8 === 0) { offset = binsize; }");
        $line("else { return false; }");
      } else {
        var bits = segment.unit * segment.size;
        $line("if (offset + %d > binsize) { return false; }", bits);
        $line("else { offset += %d; }", bits);
      }
    }
    function match_seg(segment) {
      if (segment.name === "_") {
        skip_bits(segment);
      } else {
        var assign_result;
        switch (segment.type) {
          case "integer":
          case "float":
            get_number(segment);
            break;
          case "binary":
            get_binary(segment);
            break;
          case "string":
            get_string(segment);
            break;
        }
        $line("if (result === false) return false;");
        if (segment.name) {
          $line("else if (%s !== undefined) {", var_name(segment.name));
          $line(
            "if (%s != result) return false;",
            var_name(segment.name)
          );
          $line("}");
          $line("else %s = result;", var_name(segment.name));
        } else {
          var repr = JSON.stringify(segment.value);
          $line("else if (result != %s) return false;", repr);
        }
      }
    }
    function var_name(name) {
      return "var_" + name;
    }
    function variables(segments) {
      var names = {};
      for (var i = 0; i < segments.length; i++) {
        var name = segments[i].name;
        if (name && name !== "_") {
          names[name] = true;
        }
        name = segments[i].size;
        if (typeof name === "string") {
          names[name] = true;
        }
      }
      return Object.keys(names);
    }
    function compile_pattern(segments) {
      $start();
      $line("return function(binary, env) {");
      $line("'use strict';");
      $line("var bin = binary, env = env || {};");
      $line("var offset = 0, binsize = bin.length * 8;");
      $line("var bits, result, byteoffset;");
      var varnames = variables(segments);
      for (var v = 0; v < varnames.length; v++) {
        var name = varnames[v];
        $line("var %s = env['%s'];", var_name(name), name);
      }
      var len = segments.length;
      for (var i = 0; i < len; i++) {
        var segment = segments[i];
        $line("// " + JSON.stringify(segment));
        match_seg(segment);
      }
      $line("if (offset == binsize) {");
      $line("return {");
      for (var v = 0; v < varnames.length; v++) {
        var name = varnames[v];
        $line("%s: %s,", name, var_name(name));
      }
      $line("};");
      $line("}");
      $line("else return false;");
      $line("}");
      var fn = new Function("parse_int", "parse_float", $result());
      return fn(parse_int, parse_float);
    }
    function write_seg(segment) {
      switch (segment.type) {
        case "string":
          $line(
            "offset += buf.write(%s, offset, 'utf8');",
            JSON.stringify(segment.value)
          );
          break;
        case "binary":
          $line("val = bindings['%s'];", segment.name);
          if (segment.size === true) {
            $line("size = val.length;");
          } else if (typeof segment.size === "string") {
            $line(
              "size = (bindings['%s'] * %d) / 8;",
              segment.size,
              segment.unit
            );
          } else {
            $line("size = %d;", segment.size * segment.unit / 8);
          }
          $line("val.copy(buf, offset, 0, size);");
          $line("offset += size;");
          break;
        case "integer":
        case "float":
          write_number(segment);
          break;
      }
    }
    function write_number(segment) {
      if (segment.name) {
        $line("val = bindings['%s'];", segment.name);
      } else {
        $line("val = %d", segment.value);
      }
      var writer = segment.type === "integer" ? "write_int" : "write_float";
      if (typeof segment.size === "string") {
        $line(
          "size = (bindings['%s'] * %d) / 8;",
          segment.size,
          segment.unit
        );
      } else {
        $line("size = %d;", segment.size * segment.unit / 8);
      }
      $line(
        "%s(buf, val, offset, size, %s);",
        writer,
        segment.bigendian
      );
      $line("offset += size;");
    }
    function size_of(segments) {
      var variable = [];
      var fixed = 0;
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (typeof segment.size === "string" || segment.size === true) {
          variable.push(segment);
        } else if (segment.type === "string") {
          fixed += Buffer2.byteLength(segment.value);
        } else {
          fixed += segment.size * segment.unit / 8;
        }
      }
      $line("var buffersize = %d;", fixed);
      if (variable.length > 0) {
        for (var j = 0; j < variable.length; j++) {
          var segment = variable[j];
          if (segment.size === true) {
            $line("buffersize += bindings['%s'].length;", segment.name);
          } else {
            $line(
              "buffersize += (bindings['%s'] * %d) / 8;",
              segment.size,
              segment.unit
            );
          }
        }
      }
    }
    function emit_write(segments) {
      $line("var val, size;");
      var len = segments.length;
      for (var i = 0; i < len; i++) {
        var segment = segments[i];
        $line("// %s", JSON.stringify(segment));
        write_seg(segment);
      }
    }
    function compile_ctor(segments) {
      $start();
      $line("return function(bindings) {");
      $line("'use strict';");
      size_of(segments);
      $line("var buf = Buffer.alloc(buffersize);");
      $line("var offset = 0;");
      emit_write(segments);
      $line("return buf;");
      $line("}");
      return new Function(
        "write_int",
        "write_float",
        "Buffer",
        $result()
      )(write_int, write_float, Buffer2);
    }
    module2.exports.compile_pattern = compile_pattern;
    module2.exports.compile = function() {
      var str = [].join.call(arguments, ",");
      var p = parse(str);
      return compile_pattern(p);
    };
    module2.exports.compile_builder = function() {
      var str = [].join.call(arguments, ",");
      var p = parse(str);
      return compile_ctor(p);
    };
  }
});

// node_modules/bitsyntax/index.js
var require_bitsyntax = __commonJS({
  "node_modules/bitsyntax/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports.parse = require_parse().parse;
    module2.exports.match = require_interp().match;
    module2.exports.build = require_constructor().build;
    module2.exports.write = require_constructor().write;
    module2.exports.matcher = module2.exports.compile = require_compile().compile;
    module2.exports.builder = require_compile().compile_builder;
  }
});

// node_modules/amqplib/lib/frame.js
var require_frame = __commonJS({
  "node_modules/amqplib/lib/frame.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var defs = require_defs();
    var constants = defs.constants;
    var decode = defs.decode;
    var Bits = require_bitsyntax();
    module2.exports.PROTOCOL_HEADER = "AMQP" + String.fromCharCode(0, 0, 9, 1);
    var FRAME_METHOD = constants.FRAME_METHOD;
    var FRAME_HEARTBEAT = constants.FRAME_HEARTBEAT;
    var FRAME_HEADER = constants.FRAME_HEADER;
    var FRAME_BODY = constants.FRAME_BODY;
    var FRAME_END = constants.FRAME_END;
    var bodyCons = Bits.builder(
      FRAME_BODY,
      "channel:16, size:32, payload:size/binary",
      FRAME_END
    );
    module2.exports.makeBodyFrame = function(channel, payload) {
      return bodyCons({ channel, size: payload.length, payload });
    };
    var frameHeaderPattern = Bits.matcher(
      "type:8",
      "channel:16",
      "size:32",
      "rest/binary"
    );
    function parseFrame(bin, max) {
      var fh = frameHeaderPattern(bin);
      if (fh) {
        var size = fh.size, rest = fh.rest;
        if (size > max) {
          throw new Error("Frame size exceeds frame max");
        } else if (rest.length > size) {
          if (rest[size] !== FRAME_END)
            throw new Error("Invalid frame");
          return {
            type: fh.type,
            channel: fh.channel,
            size,
            payload: rest.slice(0, size),
            rest: rest.slice(size + 1)
          };
        }
      }
      return false;
    }
    module2.exports.parseFrame = parseFrame;
    var headerPattern = Bits.matcher(
      "class:16",
      "_weight:16",
      "size:64",
      "flagsAndfields/binary"
    );
    var methodPattern = Bits.matcher("id:32, args/binary");
    var HEARTBEAT = { channel: 0 };
    module2.exports.decodeFrame = function(frame) {
      var payload = frame.payload;
      switch (frame.type) {
        case FRAME_METHOD:
          var idAndArgs = methodPattern(payload);
          var id = idAndArgs.id;
          var fields = decode(id, idAndArgs.args);
          return { id, channel: frame.channel, fields };
        case FRAME_HEADER:
          var parts = headerPattern(payload);
          var id = parts["class"];
          var fields = decode(id, parts.flagsAndfields);
          return {
            id,
            channel: frame.channel,
            size: parts.size,
            fields
          };
        case FRAME_BODY:
          return { channel: frame.channel, content: frame.payload };
        case FRAME_HEARTBEAT:
          return HEARTBEAT;
        default:
          throw new Error("Unknown frame type " + frame.type);
      }
    };
    module2.exports.HEARTBEAT_BUF = Buffer.from([
      constants.FRAME_HEARTBEAT,
      0,
      0,
      0,
      0,
      // size = 0
      0,
      0,
      // channel = 0
      constants.FRAME_END
    ]);
    module2.exports.HEARTBEAT = HEARTBEAT;
  }
});

// node_modules/amqplib/lib/mux.js
var require_mux = __commonJS({
  "node_modules/amqplib/lib/mux.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var assert = require_assert();
    var schedule = typeof setImmediate === "function" ? setImmediate : process.nextTick;
    function Mux(downstream) {
      this.newStreams = [];
      this.oldStreams = [];
      this.blocked = false;
      this.scheduledRead = false;
      this.out = downstream;
      var self2 = this;
      downstream.on("drain", function() {
        self2.blocked = false;
        self2._readIncoming();
      });
    }
    Mux.prototype._readIncoming = function() {
      if (this.blocked)
        return;
      var accepting = true;
      var out = this.out;
      function roundrobin(streams) {
        var s;
        while (accepting && (s = streams.shift())) {
          var chunk = s.read();
          if (chunk !== null) {
            accepting = out.write(chunk);
            streams.push(s);
          }
        }
      }
      roundrobin(this.newStreams);
      if (accepting) {
        assert.equal(0, this.newStreams.length);
        roundrobin(this.oldStreams);
      } else {
        assert(this.newStreams.length > 0, "Expect some new streams to remain");
        Array.prototype.push.apply(this.oldStreams, this.newStreams);
        this.newStreams = [];
      }
      this.blocked = !accepting;
    };
    Mux.prototype._scheduleRead = function() {
      var self2 = this;
      if (!self2.scheduledRead) {
        schedule(function() {
          self2.scheduledRead = false;
          self2._readIncoming();
        });
        self2.scheduledRead = true;
      }
    };
    Mux.prototype.pipeFrom = function(readable) {
      var self2 = this;
      function enqueue() {
        self2.newStreams.push(readable);
        self2._scheduleRead();
      }
      function cleanup() {
        readable.removeListener("readable", enqueue);
        readable.removeListener("error", cleanup);
        readable.removeListener("end", cleanup);
        readable.removeListener("unpipeFrom", cleanupIfMe);
      }
      function cleanupIfMe(dest) {
        if (dest === self2)
          cleanup();
      }
      readable.on("unpipeFrom", cleanupIfMe);
      readable.on("end", cleanup);
      readable.on("error", cleanup);
      readable.on("readable", enqueue);
    };
    Mux.prototype.unpipeFrom = function(readable) {
      readable.emit("unpipeFrom", this);
    };
    module2.exports.Mux = Mux;
  }
});

// node_modules/core-util-is/lib/util.js
var require_util3 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    init_process();
    init_buffer();
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError2(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError2;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/amqplib/node_modules/string_decoder/index.js
var require_string_decoder2 = __commonJS({
  "node_modules/amqplib/node_modules/string_decoder/index.js"(exports2) {
    init_process();
    init_buffer();
    var Buffer2 = require_buffer().Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports2.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/amqplib/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/amqplib/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Buffer2 = require_buffer().Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require_stream_browserify();
    var util = require_util3();
    util.inherits = require_inherits_browser();
    var StringDecoder;
    var debug = require_util();
    if (debug && debug.debuglog) {
      debug = debug.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = require_stream_duplex2();
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          if (!addToFront)
            state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      }
      if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (util.isNull(ret2)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (!util.isNull(ret2))
        this.emit("data", ret2);
      return ret2;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          process.nextTick(function() {
            emitReadable_(stream);
          });
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        if (false === ret2) {
          debug(
            "false write response, pause",
            src._readableState.awaitDrain
          );
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data" && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self2 = this;
            process.nextTick(function() {
              debug("readable nexttick read 0");
              self2.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        if (!state.reading) {
          debug("resume read 0");
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function() {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length)
          return;
        var ret2 = self2.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret2;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret2 = null;
      else if (objectMode)
        ret2 = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret2 = list.join("");
        else
          ret2 = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret2 = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret2 = list.shift();
        } else {
          if (stringMode)
            ret2 = "";
          else
            ret2 = new Buffer2(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret2 += buf.slice(0, cpy);
            else
              buf.copy(ret2, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/amqplib/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/amqplib/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Writable;
    var Buffer2 = require_buffer().Buffer;
    Writable.WritableState = WritableState;
    var util = require_util3();
    util.inherits = require_inherits_browser();
    var Stream = require_stream_browserify();
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = require_stream_duplex2();
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex2();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (!util.isFunction(cb))
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          state.pendingcb--;
          cb(er);
        });
      else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++)
          cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, "", function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length)
          state.buffer = state.buffer.slice(c);
        else
          state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk))
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit("finish");
        } else
          prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// node_modules/amqplib/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/amqplib/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Duplex;
    var objectKeys = Object.keys || function(obj2) {
      var keys = [];
      for (var key in obj2)
        keys.push(key);
      return keys;
    };
    var util = require_util3();
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }
});

// node_modules/amqplib/node_modules/readable-stream/duplex.js
var require_duplex = __commonJS({
  "node_modules/amqplib/node_modules/readable-stream/duplex.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = require_stream_duplex2();
  }
});

// node_modules/amqplib/lib/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/amqplib/lib/heartbeat.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var inherits2 = require_util2().inherits;
    var EventEmitter = require_events().EventEmitter;
    module2.exports.UNITS_TO_MS = 1e3;
    function Heart(interval, checkSend, checkRecv) {
      EventEmitter.call(this);
      this.interval = interval;
      var intervalMs = interval * module2.exports.UNITS_TO_MS;
      var beat = this.emit.bind(this, "beat");
      var timeout = this.emit.bind(this, "timeout");
      this.sendTimer = setInterval(
        this.runHeartbeat.bind(this, checkSend, beat),
        intervalMs / 2
      );
      var recvMissed = 0;
      function missedTwo() {
        if (!checkRecv())
          return ++recvMissed < 2;
        else {
          recvMissed = 0;
          return true;
        }
      }
      this.recvTimer = setInterval(
        this.runHeartbeat.bind(this, missedTwo, timeout),
        intervalMs
      );
    }
    inherits2(Heart, EventEmitter);
    module2.exports.Heart = Heart;
    Heart.prototype.clear = function() {
      clearInterval(this.sendTimer);
      clearInterval(this.recvTimer);
    };
    Heart.prototype.runHeartbeat = function(check, fail) {
      if (!check())
        fail();
    };
  }
});

// node_modules/amqplib/lib/format.js
var require_format = __commonJS({
  "node_modules/amqplib/lib/format.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var defs = require_defs();
    var format = require_util2().format;
    var inherits2 = require_util2().inherits;
    var HEARTBEAT = require_frame().HEARTBEAT;
    module2.exports.closeMessage = function(close) {
      var code = close.fields.replyCode;
      return format(
        '%d (%s) with message "%s"',
        code,
        defs.constant_strs[code],
        close.fields.replyText
      );
    };
    module2.exports.methodName = function(id) {
      return defs.info(id).name;
    };
    module2.exports.inspect = function(frame, showFields) {
      if (frame === HEARTBEAT) {
        return "<Heartbeat>";
      } else if (!frame.id) {
        return format(
          "<Content channel:%d size:%d>",
          frame.channel,
          frame.size
        );
      } else {
        var info = defs.info(frame.id);
        return format(
          "<%s channel:%d%s>",
          info.name,
          frame.channel,
          showFields ? " " + JSON.stringify(frame.fields, void 0, 2) : ""
        );
      }
    };
  }
});

// node_modules/amqplib/lib/bitset.js
var require_bitset = __commonJS({
  "node_modules/amqplib/lib/bitset.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var BitSet = class {
      /**
       * @param {number} [size]
       */
      constructor(size) {
        if (size) {
          const numWords = Math.ceil(size / 32);
          this.words = new Array(numWords);
        } else {
          this.words = [];
        }
        this.wordsInUse = 0;
      }
      /**
       * @param {number} numWords
       */
      ensureSize(numWords) {
        const wordsPresent = this.words.length;
        if (wordsPresent < numWords) {
          this.words = this.words.concat(new Array(numWords - wordsPresent));
        }
      }
      /**
       * @param {number} bitIndex
       */
      set(bitIndex) {
        const w = wordIndex(bitIndex);
        if (w >= this.wordsInUse) {
          this.ensureSize(w + 1);
          this.wordsInUse = w + 1;
        }
        const bit = 1 << bitIndex;
        this.words[w] |= bit;
      }
      /**
       * @param {number} bitIndex
       */
      clear(bitIndex) {
        const w = wordIndex(bitIndex);
        if (w >= this.wordsInUse)
          return;
        const mask = ~(1 << bitIndex);
        this.words[w] &= mask;
      }
      /**
       * @param {number} bitIndex
       */
      get(bitIndex) {
        const w = wordIndex(bitIndex);
        if (w >= this.wordsInUse)
          return false;
        const bit = 1 << bitIndex;
        return !!(this.words[w] & bit);
      }
      /**
       * Give the next bit that is set on or after fromIndex, or -1 if no such bit
       *
       * @param {number} fromIndex
       */
      nextSetBit(fromIndex) {
        let w = wordIndex(fromIndex);
        if (w >= this.wordsInUse)
          return -1;
        let word = this.words[w] & 4294967295 << fromIndex;
        while (true) {
          if (word)
            return w * 32 + trailingZeros(word);
          w++;
          if (w === this.wordsInUse)
            return -1;
          word = this.words[w];
        }
      }
      /**
       * @param {number} fromIndex
       */
      nextClearBit(fromIndex) {
        let w = wordIndex(fromIndex);
        if (w >= this.wordsInUse)
          return fromIndex;
        let word = ~this.words[w] & 4294967295 << fromIndex;
        while (true) {
          if (word)
            return w * 32 + trailingZeros(word);
          w++;
          if (w == this.wordsInUse)
            return w * 32;
          word = ~this.words[w];
        }
      }
    };
    function wordIndex(bitIndex) {
      return Math.floor(bitIndex / 32);
    }
    function trailingZeros(i) {
      if (i === 0)
        return 32;
      let y, n = 31;
      y = i << 16;
      if (y != 0) {
        n = n - 16;
        i = y;
      }
      y = i << 8;
      if (y != 0) {
        n = n - 8;
        i = y;
      }
      y = i << 4;
      if (y != 0) {
        n = n - 4;
        i = y;
      }
      y = i << 2;
      if (y != 0) {
        n = n - 2;
        i = y;
      }
      return n - (i << 1 >>> 31);
    }
    module2.exports.BitSet = BitSet;
  }
});

// node_modules/amqplib/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/amqplib/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Transform;
    var Duplex = require_stream_duplex2();
    var util = require_util3();
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data))
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("prefinish", function() {
        if (util.isFunction(this._flush))
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws2 = stream._writableState;
      var ts = stream._transformState;
      if (ws2.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/amqplib/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/amqplib/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    var util = require_util3();
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/amqplib/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/amqplib/node_modules/readable-stream/passthrough.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = require_stream_passthrough2();
  }
});

// node_modules/amqplib/lib/error.js
var require_error = __commonJS({
  "node_modules/amqplib/lib/error.js"(exports2, module2) {
    init_process();
    init_buffer();
    var inherits2 = require_util2().inherits;
    function trimStack(stack, num) {
      return stack && stack.split("\n").slice(num).join("\n");
    }
    function IllegalOperationError(msg, stack) {
      var tmp = new Error();
      this.message = msg;
      this.stack = this.toString() + "\n" + trimStack(tmp.stack, 2);
      this.stackAtStateChange = stack;
    }
    inherits2(IllegalOperationError, Error);
    IllegalOperationError.prototype.name = "IllegalOperationError";
    function stackCapture(reason) {
      var e = new Error();
      return "Stack capture: " + reason + "\n" + trimStack(e.stack, 2);
    }
    module2.exports.IllegalOperationError = IllegalOperationError;
    module2.exports.stackCapture = stackCapture;
  }
});

// node_modules/amqplib/lib/connection.js
var require_connection = __commonJS({
  "node_modules/amqplib/lib/connection.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var defs = require_defs();
    var constants = defs.constants;
    var frame = require_frame();
    var HEARTBEAT = frame.HEARTBEAT;
    var Mux = require_mux().Mux;
    var Duplex = require_stream_browserify().Duplex || require_duplex();
    var EventEmitter = require_events().EventEmitter;
    var Heart = require_heartbeat().Heart;
    var methodName = require_format().methodName;
    var closeMsg = require_format().closeMessage;
    var inspect = require_format().inspect;
    var BitSet = require_bitset().BitSet;
    var inherits2 = require_util2().inherits;
    var fmt = require_util2().format;
    var PassThrough = require_stream_browserify().PassThrough || require_passthrough();
    var IllegalOperationError = require_error().IllegalOperationError;
    var stackCapture = require_error().stackCapture;
    var DEFAULT_WRITE_HWM = 1024;
    var SINGLE_CHUNK_THRESHOLD = 2048;
    function Connection(underlying) {
      EventEmitter.call(this);
      var stream = this.stream = wrapStream(underlying);
      this.muxer = new Mux(stream);
      this.rest = Buffer.alloc(0);
      this.frameMax = constants.FRAME_MIN_SIZE;
      this.sentSinceLastCheck = false;
      this.recvSinceLastCheck = false;
      this.expectSocketClose = false;
      this.freeChannels = new BitSet();
      this.channels = [{
        channel: { accept: channel0(this) },
        buffer: underlying
      }];
    }
    inherits2(Connection, EventEmitter);
    var C = Connection.prototype;
    function mainAccept(frame2) {
      var rec = this.channels[frame2.channel];
      if (rec) {
        return rec.channel.accept(frame2);
      } else
        this.closeWithError(
          fmt("Frame on unknown channel %d", frame2.channel),
          constants.CHANNEL_ERROR,
          new Error(fmt(
            "Frame on unknown channel: %s",
            inspect(frame2, false)
          ))
        );
    }
    function channel0(connection) {
      return function(f) {
        if (f === HEARTBEAT)
          ;
        else if (f.id === defs.ConnectionClose) {
          connection.sendMethod(0, defs.ConnectionCloseOk, {});
          var emsg = fmt("Connection closed: %s", closeMsg(f));
          var s = stackCapture(emsg);
          var e = new Error(emsg);
          e.code = f.fields.replyCode;
          if (isFatalError(e)) {
            connection.emit("error", e);
          }
          connection.toClosed(s, e);
        } else if (f.id === defs.ConnectionBlocked) {
          connection.emit("blocked", f.fields.reason);
        } else if (f.id === defs.ConnectionUnblocked) {
          connection.emit("unblocked");
        } else {
          connection.closeWithError(
            fmt("Unexpected frame on channel 0"),
            constants.UNEXPECTED_FRAME,
            new Error(fmt(
              "Unexpected frame on channel 0: %s",
              inspect(f, false)
            ))
          );
        }
      };
    }
    C.sendProtocolHeader = function() {
      this.sendBytes(frame.PROTOCOL_HEADER);
    };
    C.open = function(allFields, openCallback0) {
      var self2 = this;
      var openCallback = openCallback0 || function() {
      };
      var tunedOptions = Object.create(allFields);
      function wait(k) {
        self2.step(function(err, frame2) {
          if (err !== null)
            bail(err);
          else if (frame2.channel !== 0) {
            bail(new Error(
              fmt(
                "Frame on channel != 0 during handshake: %s",
                inspect(frame2, false)
              )
            ));
          } else
            k(frame2);
        });
      }
      function expect(Method, k) {
        wait(function(frame2) {
          if (frame2.id === Method)
            k(frame2);
          else {
            bail(new Error(
              fmt(
                "Expected %s; got %s",
                methodName(Method),
                inspect(frame2, false)
              )
            ));
          }
        });
      }
      function bail(err) {
        openCallback(err);
      }
      function send(Method) {
        self2.sendMethod(0, Method, tunedOptions);
      }
      function negotiate(server, desired) {
        if (server === 0 || desired === 0) {
          return Math.max(server, desired);
        } else {
          return Math.min(server, desired);
        }
      }
      function onStart(start) {
        var mechanisms = start.fields.mechanisms.toString().split(" ");
        if (mechanisms.indexOf(allFields.mechanism) < 0) {
          bail(new Error(fmt(
            "SASL mechanism %s is not provided by the server",
            allFields.mechanism
          )));
          return;
        }
        self2.serverProperties = start.fields.serverProperties;
        try {
          send(defs.ConnectionStartOk);
        } catch (err) {
          bail(err);
          return;
        }
        wait(afterStartOk);
      }
      function afterStartOk(reply) {
        switch (reply.id) {
          case defs.ConnectionSecure:
            bail(new Error(
              "Wasn't expecting to have to go through secure"
            ));
            break;
          case defs.ConnectionClose:
            bail(new Error(fmt(
              "Handshake terminated by server: %s",
              closeMsg(reply)
            )));
            break;
          case defs.ConnectionTune:
            var fields = reply.fields;
            tunedOptions.frameMax = negotiate(fields.frameMax, allFields.frameMax);
            tunedOptions.channelMax = negotiate(fields.channelMax, allFields.channelMax);
            tunedOptions.heartbeat = negotiate(fields.heartbeat, allFields.heartbeat);
            try {
              send(defs.ConnectionTuneOk);
              send(defs.ConnectionOpen);
            } catch (err) {
              bail(err);
              return;
            }
            expect(defs.ConnectionOpenOk, onOpenOk);
            break;
          default:
            bail(new Error(
              fmt(
                "Expected connection.secure, connection.close, or connection.tune during handshake; got %s",
                inspect(reply, false)
              )
            ));
            break;
        }
      }
      function onOpenOk(openOk) {
        self2.channelMax = tunedOptions.channelMax || 65535;
        self2.frameMax = tunedOptions.frameMax || 4294967295;
        self2.heartbeat = tunedOptions.heartbeat;
        self2.heartbeater = self2.startHeartbeater();
        self2.accept = mainAccept;
        succeed(openOk);
      }
      function endWhileOpening(err) {
        bail(err || new Error("Socket closed abruptly during opening handshake"));
      }
      this.stream.on("end", endWhileOpening);
      this.stream.on("error", endWhileOpening);
      function succeed(ok) {
        self2.stream.removeListener("end", endWhileOpening);
        self2.stream.removeListener("error", endWhileOpening);
        self2.stream.on("error", self2.onSocketError.bind(self2));
        self2.stream.on("end", self2.onSocketError.bind(
          self2,
          new Error("Unexpected close")
        ));
        self2.on("frameError", self2.onSocketError.bind(self2));
        self2.acceptLoop();
        openCallback(null, ok);
      }
      this.sendProtocolHeader();
      expect(defs.ConnectionStart, onStart);
    };
    C.close = function(closeCallback) {
      var k = closeCallback && function() {
        closeCallback(null);
      };
      this.closeBecause("Cheers, thanks", constants.REPLY_SUCCESS, k);
    };
    C.closeBecause = function(reason, code, k) {
      this.sendMethod(0, defs.ConnectionClose, {
        replyText: reason,
        replyCode: code,
        methodId: 0,
        classId: 0
      });
      var s = stackCapture("closeBecause called: " + reason);
      this.toClosing(s, k);
    };
    C.closeWithError = function(reason, code, error) {
      this.emit("error", error);
      this.closeBecause(reason, code);
    };
    C.onSocketError = function(err) {
      if (!this.expectSocketClose) {
        this.expectSocketClose = true;
        this.emit("error", err);
        var s = stackCapture("Socket error");
        this.toClosed(s, err);
      }
    };
    function invalidOp(msg, stack) {
      return function() {
        throw new IllegalOperationError(msg, stack);
      };
    }
    function invalidateSend(conn, msg, stack) {
      conn.sendMethod = conn.sendContent = conn.sendMessage = invalidOp(msg, stack);
    }
    C.toClosing = function(capturedStack, k) {
      var send = this.sendMethod.bind(this);
      this.accept = function(f) {
        if (f.id === defs.ConnectionCloseOk) {
          if (k)
            k();
          var s = stackCapture("ConnectionCloseOk received");
          this.toClosed(s, void 0);
        } else if (f.id === defs.ConnectionClose) {
          send(0, defs.ConnectionCloseOk, {});
        }
      };
      invalidateSend(this, "Connection closing", capturedStack);
    };
    C._closeChannels = function(capturedStack) {
      for (var i = 1; i < this.channels.length; i++) {
        var ch = this.channels[i];
        if (ch !== null) {
          ch.channel.toClosed(capturedStack);
        }
      }
    };
    C.toClosed = function(capturedStack, maybeErr) {
      this._closeChannels(capturedStack);
      var info = fmt(
        "Connection closed (%s)",
        maybeErr ? maybeErr.toString() : "by client"
      );
      invalidateSend(this, info, capturedStack);
      this.accept = invalidOp(info, capturedStack);
      this.close = function(cb) {
        cb && cb(new IllegalOperationError(info, capturedStack));
      };
      if (this.heartbeater)
        this.heartbeater.clear();
      this.expectSocketClose = true;
      this.stream.end();
      this.emit("close", maybeErr);
    };
    C.startHeartbeater = function() {
      if (this.heartbeat === 0)
        return null;
      else {
        var self2 = this;
        var hb = new Heart(
          this.heartbeat,
          this.checkSend.bind(this),
          this.checkRecv.bind(this)
        );
        hb.on("timeout", function() {
          var hberr = new Error("Heartbeat timeout");
          self2.emit("error", hberr);
          var s = stackCapture("Heartbeat timeout");
          self2.toClosed(s, hberr);
        });
        hb.on("beat", function() {
          self2.sendHeartbeat();
        });
        return hb;
      }
    };
    C.freshChannel = function(channel, options) {
      var next = this.freeChannels.nextClearBit(1);
      if (next < 0 || next > this.channelMax)
        throw new Error("No channels left to allocate");
      this.freeChannels.set(next);
      var hwm = options && options.highWaterMark || DEFAULT_WRITE_HWM;
      var writeBuffer = new PassThrough({
        objectMode: true,
        highWaterMark: hwm
      });
      this.channels[next] = { channel, buffer: writeBuffer };
      writeBuffer.on("drain", function() {
        channel.onBufferDrain();
      });
      this.muxer.pipeFrom(writeBuffer);
      return next;
    };
    C.releaseChannel = function(channel) {
      this.freeChannels.clear(channel);
      var buffer = this.channels[channel].buffer;
      buffer.end();
      this.channels[channel] = null;
    };
    C.acceptLoop = function() {
      var self2 = this;
      function go() {
        try {
          var f;
          while (f = self2.recvFrame())
            self2.accept(f);
        } catch (e) {
          self2.emit("frameError", e);
        }
      }
      self2.stream.on("readable", go);
      go();
    };
    C.step = function(cb) {
      var self2 = this;
      function recv() {
        var f;
        try {
          f = self2.recvFrame();
        } catch (e) {
          cb(e, null);
          return;
        }
        if (f)
          cb(null, f);
        else
          self2.stream.once("readable", recv);
      }
      recv();
    };
    C.checkSend = function() {
      var check = this.sentSinceLastCheck;
      this.sentSinceLastCheck = false;
      return check;
    };
    C.checkRecv = function() {
      var check = this.recvSinceLastCheck;
      this.recvSinceLastCheck = false;
      return check;
    };
    C.sendBytes = function(bytes) {
      this.sentSinceLastCheck = true;
      this.stream.write(bytes);
    };
    C.sendHeartbeat = function() {
      return this.sendBytes(frame.HEARTBEAT_BUF);
    };
    var encodeMethod = defs.encodeMethod;
    var encodeProperties = defs.encodeProperties;
    C.sendMethod = function(channel, Method, fields) {
      var frame2 = encodeMethod(Method, channel, fields);
      this.sentSinceLastCheck = true;
      var buffer = this.channels[channel].buffer;
      return buffer.write(frame2);
    };
    C.sendMessage = function(channel, Method, fields, Properties, props, content) {
      if (!Buffer.isBuffer(content))
        throw new TypeError("content is not a buffer");
      var mframe = encodeMethod(Method, channel, fields);
      var pframe = encodeProperties(
        Properties,
        channel,
        content.length,
        props
      );
      var buffer = this.channels[channel].buffer;
      this.sentSinceLastCheck = true;
      var methodHeaderLen = mframe.length + pframe.length;
      var bodyLen = content.length > 0 ? content.length + FRAME_OVERHEAD : 0;
      var allLen = methodHeaderLen + bodyLen;
      if (allLen < SINGLE_CHUNK_THRESHOLD) {
        var all = Buffer.alloc(allLen);
        var offset = mframe.copy(all, 0);
        offset += pframe.copy(all, offset);
        if (bodyLen > 0)
          makeBodyFrame(channel, content).copy(all, offset);
        return buffer.write(all);
      } else {
        if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {
          var both = Buffer.alloc(methodHeaderLen);
          var offset = mframe.copy(both, 0);
          pframe.copy(both, offset);
          buffer.write(both);
        } else {
          buffer.write(mframe);
          buffer.write(pframe);
        }
        return this.sendContent(channel, content);
      }
    };
    var FRAME_OVERHEAD = defs.FRAME_OVERHEAD;
    var makeBodyFrame = frame.makeBodyFrame;
    C.sendContent = function(channel, body) {
      if (!Buffer.isBuffer(body)) {
        throw new TypeError(fmt("Expected buffer; got %s", body));
      }
      var writeResult = true;
      var buffer = this.channels[channel].buffer;
      var maxBody = this.frameMax - FRAME_OVERHEAD;
      for (var offset = 0; offset < body.length; offset += maxBody) {
        var end = offset + maxBody;
        var slice = end > body.length ? body.slice(offset) : body.slice(offset, end);
        var bodyFrame = makeBodyFrame(channel, slice);
        writeResult = buffer.write(bodyFrame);
      }
      this.sentSinceLastCheck = true;
      return writeResult;
    };
    var parseFrame = frame.parseFrame;
    var decodeFrame = frame.decodeFrame;
    C.recvFrame = function() {
      var frame2 = parseFrame(this.rest, this.frameMax);
      if (!frame2) {
        var incoming = this.stream.read();
        if (incoming === null) {
          return false;
        } else {
          this.recvSinceLastCheck = true;
          this.rest = Buffer.concat([this.rest, incoming]);
          return this.recvFrame();
        }
      } else {
        this.rest = frame2.rest;
        return decodeFrame(frame2);
      }
    };
    function wrapStream(s) {
      if (s instanceof Duplex)
        return s;
      else {
        var ws2 = new Duplex();
        ws2.wrap(s);
        ws2._write = function(chunk, encoding, callback) {
          return s.write(chunk, encoding, callback);
        };
        return ws2;
      }
    }
    function isFatalError(error) {
      switch (error && error.code) {
        case defs.constants.CONNECTION_FORCED:
        case defs.constants.REPLY_SUCCESS:
          return false;
        default:
          return true;
      }
    }
    module2.exports.Connection = Connection;
    module2.exports.isFatalError = isFatalError;
  }
});

// node_modules/amqplib/lib/credentials.js
var require_credentials = __commonJS({
  "node_modules/amqplib/lib/credentials.js"(exports2, module2) {
    init_process();
    init_buffer();
    var codec = require_codec();
    module2.exports.plain = function(user, passwd) {
      return {
        mechanism: "PLAIN",
        response: function() {
          return Buffer.from(["", user, passwd].join(String.fromCharCode(0)));
        },
        username: user,
        password: passwd
      };
    };
    module2.exports.amqplain = function(user, passwd) {
      return {
        mechanism: "AMQPLAIN",
        response: function() {
          const buffer = Buffer.alloc(16384);
          const size = codec.encodeTable(buffer, { LOGIN: user, PASSWORD: passwd }, 0);
          return buffer.slice(4, size);
        },
        username: user,
        password: passwd
      };
    };
    module2.exports.external = function() {
      return {
        mechanism: "EXTERNAL",
        response: function() {
          return Buffer.from("");
        }
      };
    };
  }
});

// node_modules/amqplib/package.json
var require_package2 = __commonJS({
  "node_modules/amqplib/package.json"(exports2, module2) {
    module2.exports = {
      name: "amqplib",
      homepage: "http://amqp-node.github.io/amqplib/",
      main: "./channel_api.js",
      version: "0.9.1",
      description: "An AMQP 0-9-1 (e.g., RabbitMQ) library and client.",
      repository: {
        type: "git",
        url: "https://github.com/amqp-node/amqplib.git"
      },
      engines: {
        node: ">=10"
      },
      dependencies: {
        bitsyntax: "~0.1.0",
        bluebird: "^3.7.2",
        "buffer-more-ints": "~1.0.0",
        "readable-stream": "1.x >=1.1.9",
        "url-parse": "~1.5.10"
      },
      devDependencies: {
        claire: "0.4.1",
        mocha: "^9.2.2",
        nyc: "^15.1.0",
        "uglify-js": "2.8.x"
      },
      scripts: {
        test: "make test",
        prepare: "make"
      },
      keywords: [
        "AMQP",
        "AMQP 0-9-1",
        "RabbitMQ"
      ],
      author: "Michael Bridgen <mikeb@squaremobius.net>",
      license: "MIT"
    };
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/amqplib/lib/connect.js
var require_connect = __commonJS({
  "node_modules/amqplib/lib/connect.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var URL = require_url_parse();
    var QS = require_querystring();
    var Connection = require_connection().Connection;
    var fmt = require_util2().format;
    var credentials = require_credentials();
    function copyInto(obj2, target) {
      var keys = Object.keys(obj2);
      var i = keys.length;
      while (i--) {
        var k = keys[i];
        target[k] = obj2[k];
      }
      return target;
    }
    function clone(obj2) {
      return copyInto(obj2, {});
    }
    var CLIENT_PROPERTIES = {
      "product": "amqplib",
      "version": require_package2().version,
      "platform": fmt("Node.JS %s", process.version),
      "information": "http://squaremo.github.io/amqp.node",
      "capabilities": {
        "publisher_confirms": true,
        "exchange_exchange_bindings": true,
        "basic.nack": true,
        "consumer_cancel_notify": true,
        "connection.blocked": true,
        "authentication_failure_close": true
      }
    };
    function openFrames(vhost, query, credentials2, extraClientProperties) {
      if (!vhost)
        vhost = "/";
      else
        vhost = QS.unescape(vhost);
      var query = query || {};
      function intOrDefault(val, def) {
        return val === void 0 ? def : parseInt(val);
      }
      var clientProperties = Object.create(CLIENT_PROPERTIES);
      return {
        // start-ok
        "clientProperties": copyInto(extraClientProperties, clientProperties),
        "mechanism": credentials2.mechanism,
        "response": credentials2.response(),
        "locale": query.locale || "en_US",
        // tune-ok
        "channelMax": intOrDefault(query.channelMax, 0),
        "frameMax": intOrDefault(query.frameMax, 4096),
        "heartbeat": intOrDefault(query.heartbeat, 0),
        // open
        "virtualHost": vhost,
        "capabilities": "",
        "insist": 0
      };
    }
    function credentialsFromUrl(parts) {
      var user = "guest", passwd = "guest";
      if (parts.username != "" || parts.password != "") {
        user = parts.username ? unescape(parts.username) : "";
        passwd = parts.password ? unescape(parts.password) : "";
      }
      return credentials.plain(user, passwd);
    }
    function connect(url, socketOptions, openCallback) {
      var sockopts = clone(socketOptions || {});
      url = url || "amqp://localhost";
      var noDelay = !!sockopts.noDelay;
      var timeout = sockopts.timeout;
      var keepAlive = !!sockopts.keepAlive;
      var keepAliveDelay = sockopts.keepAliveDelay || 0;
      var extraClientProperties = sockopts.clientProperties || {};
      var protocol, fields;
      if (typeof url === "object") {
        protocol = (url.protocol || "amqp") + ":";
        sockopts.host = url.hostname;
        sockopts.servername = url.hostname;
        sockopts.port = url.port || (protocol === "amqp:" ? 5672 : 5671);
        var user, pass;
        if (url.username == void 0 && url.password == void 0) {
          user = "guest";
          pass = "guest";
        } else {
          user = url.username || "";
          pass = url.password || "";
        }
        var config = {
          locale: url.locale,
          channelMax: url.channelMax,
          frameMax: url.frameMax,
          heartbeat: url.heartbeat
        };
        fields = openFrames(url.vhost, config, sockopts.credentials || credentials.plain(user, pass), extraClientProperties);
      } else {
        var parts = URL(url, true);
        protocol = parts.protocol;
        sockopts.host = parts.hostname;
        sockopts.servername = parts.hostname;
        sockopts.port = parseInt(parts.port) || (protocol === "amqp:" ? 5672 : 5671);
        var vhost = parts.pathname ? parts.pathname.substr(1) : null;
        fields = openFrames(vhost, parts.query, sockopts.credentials || credentialsFromUrl(parts), extraClientProperties);
      }
      var sockok = false;
      var sock;
      function onConnect() {
        sockok = true;
        sock.setNoDelay(noDelay);
        if (keepAlive)
          sock.setKeepAlive(keepAlive, keepAliveDelay);
        var c = new Connection(sock);
        c.open(fields, function(err, ok) {
          if (timeout)
            sock.setTimeout(0);
          if (err === null) {
            openCallback(null, c);
          } else {
            sock.end();
            sock.destroy();
            openCallback(err);
          }
        });
      }
      if (protocol === "amqp:") {
        sock = require_net().connect(sockopts, onConnect);
      } else if (protocol === "amqps:") {
        sock = require_tls().connect(sockopts, onConnect);
      } else {
        throw new Error("Expected amqp: or amqps: as the protocol; got " + protocol);
      }
      if (timeout) {
        sock.setTimeout(timeout, function() {
          sock.end();
          sock.destroy();
          openCallback(new Error("connect ETIMEDOUT"));
        });
      }
      sock.once("error", function(err) {
        if (!sockok)
          openCallback(err);
      });
    }
    module2.exports.connect = connect;
    module2.exports.credentialsFromUrl = credentialsFromUrl;
  }
});

// node_modules/bluebird/js/browser/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/bluebird/js/browser/bluebird.js"(exports, module) {
    init_process();
    init_buffer();
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof globalThis ? f = globalThis : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var SomePromiseArray = Promise2._SomePromiseArray;
          function any(promises) {
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(1);
            ret2.setUnwrap();
            ret2.init();
            return promise;
          }
          Promise2.any = function(promises) {
            return any(promises);
          };
          Promise2.prototype.any = function() {
            return any(this);
          };
        };
      }, {}], 2: [function(_dereq_2, module2, exports2) {
        "use strict";
        var firstLineError;
        try {
          throw new Error();
        } catch (e) {
          firstLineError = e;
        }
        var schedule = _dereq_2("./schedule");
        var Queue = _dereq_2("./queue");
        function Async() {
          this._customScheduler = false;
          this._isTickUsed = false;
          this._lateQueue = new Queue(16);
          this._normalQueue = new Queue(16);
          this._haveDrainedQueues = false;
          var self2 = this;
          this.drainQueues = function() {
            self2._drainQueues();
          };
          this._schedule = schedule;
        }
        Async.prototype.setScheduler = function(fn) {
          var prev = this._schedule;
          this._schedule = fn;
          this._customScheduler = true;
          return prev;
        };
        Async.prototype.hasCustomScheduler = function() {
          return this._customScheduler;
        };
        Async.prototype.haveItemsQueued = function() {
          return this._isTickUsed || this._haveDrainedQueues;
        };
        Async.prototype.fatalError = function(e, isNode2) {
          if (isNode2) {
            process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
            process.exit(2);
          } else {
            this.throwLater(e);
          }
        };
        Async.prototype.throwLater = function(fn, arg) {
          if (arguments.length === 1) {
            arg = fn;
            fn = function() {
              throw arg;
            };
          }
          if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
              fn(arg);
            }, 0);
          } else
            try {
              this._schedule(function() {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
            }
        };
        function AsyncInvokeLater(fn, receiver2, arg) {
          this._lateQueue.push(fn, receiver2, arg);
          this._queueTick();
        }
        function AsyncInvoke(fn, receiver2, arg) {
          this._normalQueue.push(fn, receiver2, arg);
          this._queueTick();
        }
        function AsyncSettlePromises(promise) {
          this._normalQueue._pushOne(promise);
          this._queueTick();
        }
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
        function _drainQueue(queue) {
          while (queue.length() > 0) {
            _drainQueueStep(queue);
          }
        }
        function _drainQueueStep(queue) {
          var fn = queue.shift();
          if (typeof fn !== "function") {
            fn._settlePromises();
          } else {
            var receiver2 = queue.shift();
            var arg = queue.shift();
            fn.call(receiver2, arg);
          }
        }
        Async.prototype._drainQueues = function() {
          _drainQueue(this._normalQueue);
          this._reset();
          this._haveDrainedQueues = true;
          _drainQueue(this._lateQueue);
        };
        Async.prototype._queueTick = function() {
          if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
          }
        };
        Async.prototype._reset = function() {
          this._isTickUsed = false;
        };
        module2.exports = Async;
        module2.exports.firstLineError = firstLineError;
      }, { "./queue": 26, "./schedule": 29 }], 3: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
          var calledBind = false;
          var rejectThis = function(_, e) {
            this._reject(e);
          };
          var targetRejected = function(e, context) {
            context.promiseRejectionQueued = true;
            context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
          };
          var bindingResolved = function(thisArg, context) {
            if ((this._bitField & 50397184) === 0) {
              this._resolveCallback(context.target);
            }
          };
          var bindingRejected = function(e, context) {
            if (!context.promiseRejectionQueued)
              this._reject(e);
          };
          Promise2.prototype.bind = function(thisArg) {
            if (!calledBind) {
              calledBind = true;
              Promise2.prototype._propagateFrom = debug.propagateFromFunction();
              Promise2.prototype._boundValue = debug.boundValueFunction();
            }
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._propagateFrom(this, 1);
            var target = this._target();
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              var context = {
                promiseRejectionQueued: false,
                promise: ret2,
                target,
                bindingPromise: maybePromise
              };
              target._then(INTERNAL, targetRejected, void 0, ret2, context);
              maybePromise._then(
                bindingResolved,
                bindingRejected,
                void 0,
                ret2,
                context
              );
              ret2._setOnCancel(maybePromise);
            } else {
              ret2._resolveCallback(target);
            }
            return ret2;
          };
          Promise2.prototype._setBoundTo = function(obj2) {
            if (obj2 !== void 0) {
              this._bitField = this._bitField | 2097152;
              this._boundTo = obj2;
            } else {
              this._bitField = this._bitField & ~2097152;
            }
          };
          Promise2.prototype._isBound = function() {
            return (this._bitField & 2097152) === 2097152;
          };
          Promise2.bind = function(thisArg, value) {
            return Promise2.resolve(value).bind(thisArg);
          };
        };
      }, {}], 4: [function(_dereq_2, module2, exports2) {
        "use strict";
        var old;
        if (typeof Promise !== "undefined")
          old = Promise;
        function noConflict() {
          try {
            if (Promise === bluebird)
              Promise = old;
          } catch (e) {
          }
          return bluebird;
        }
        var bluebird = _dereq_2("./promise")();
        bluebird.noConflict = noConflict;
        module2.exports = bluebird;
      }, { "./promise": 22 }], 5: [function(_dereq_2, module2, exports2) {
        "use strict";
        var cr = Object.create;
        if (cr) {
          var callerCache = cr(null);
          var getterCache = cr(null);
          callerCache[" size"] = getterCache[" size"] = 0;
        }
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util");
          var canEvaluate2 = util.canEvaluate;
          var isIdentifier2 = util.isIdentifier;
          var getMethodCaller;
          var getGetter;
          if (false) {
            var makeMethodCaller = function(methodName) {
              return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
            };
            var makeGetter = function(propertyName) {
              return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
            };
            var getCompiled = function(name, compiler, cache) {
              var ret2 = cache[name];
              if (typeof ret2 !== "function") {
                if (!isIdentifier2(name)) {
                  return null;
                }
                ret2 = compiler(name);
                cache[name] = ret2;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                  var keys = Object.keys(cache);
                  for (var i = 0; i < 256; ++i)
                    delete cache[keys[i]];
                  cache[" size"] = keys.length - 256;
                }
              }
              return ret2;
            };
            getMethodCaller = function(name) {
              return getCompiled(name, makeMethodCaller, callerCache);
            };
            getGetter = function(name) {
              return getCompiled(name, makeGetter, getterCache);
            };
          }
          function ensureMethod(obj2, methodName) {
            var fn;
            if (obj2 != null)
              fn = obj2[methodName];
            if (typeof fn !== "function") {
              var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
              throw new Promise2.TypeError(message);
            }
            return fn;
          }
          function caller(obj2) {
            var methodName = this.pop();
            var fn = ensureMethod(obj2, methodName);
            return fn.apply(obj2, this);
          }
          Promise2.prototype.call = function(methodName) {
            var args = [].slice.call(arguments, 1);
            ;
            if (false) {
              if (canEvaluate2) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                  return this._then(
                    maybeCaller,
                    void 0,
                    void 0,
                    args,
                    void 0
                  );
                }
              }
            }
            args.push(methodName);
            return this._then(caller, void 0, void 0, args, void 0);
          };
          function namedGetter(obj2) {
            return obj2[this];
          }
          function indexedGetter(obj2) {
            var index = +this;
            if (index < 0)
              index = Math.max(0, index + obj2.length);
            return obj2[index];
          }
          Promise2.prototype.get = function(propertyName) {
            var isIndex = typeof propertyName === "number";
            var getter;
            if (!isIndex) {
              if (canEvaluate2) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
              } else {
                getter = namedGetter;
              }
            } else {
              getter = indexedGetter;
            }
            return this._then(getter, void 0, void 0, propertyName, void 0);
          };
        };
      }, { "./util": 36 }], 6: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var async = Promise2._async;
          Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
            if (!debug.cancellation())
              return this._warn("cancellation is disabled");
            var promise = this;
            var child = promise;
            while (promise._isCancellable()) {
              if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                  child._followee().cancel();
                } else {
                  child._cancelBranched();
                }
                break;
              }
              var parent = promise._cancellationParent;
              if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                  promise._followee().cancel();
                } else {
                  promise._cancelBranched();
                }
                break;
              } else {
                if (promise._isFollowing())
                  promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
              }
            }
          };
          Promise2.prototype._branchHasCancelled = function() {
            this._branchesRemainingToCancel--;
          };
          Promise2.prototype._enoughBranchesHaveCancelled = function() {
            return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
          };
          Promise2.prototype._cancelBy = function(canceller) {
            if (canceller === this) {
              this._branchesRemainingToCancel = 0;
              this._invokeOnCancel();
              return true;
            } else {
              this._branchHasCancelled();
              if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
              }
            }
            return false;
          };
          Promise2.prototype._cancelBranched = function() {
            if (this._enoughBranchesHaveCancelled()) {
              this._cancel();
            }
          };
          Promise2.prototype._cancel = function() {
            if (!this._isCancellable())
              return;
            this._setCancelled();
            async.invoke(this._cancelPromises, this, void 0);
          };
          Promise2.prototype._cancelPromises = function() {
            if (this._length() > 0)
              this._settlePromises();
          };
          Promise2.prototype._unsetOnCancel = function() {
            this._onCancelField = void 0;
          };
          Promise2.prototype._isCancellable = function() {
            return this.isPending() && !this._isCancelled();
          };
          Promise2.prototype.isCancellable = function() {
            return this.isPending() && !this.isCancelled();
          };
          Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
            if (util.isArray(onCancelCallback)) {
              for (var i = 0; i < onCancelCallback.length; ++i) {
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
              }
            } else if (onCancelCallback !== void 0) {
              if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                  var e = tryCatch2(onCancelCallback).call(this._boundValue());
                  if (e === errorObj2) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                  }
                }
              } else {
                onCancelCallback._resultCancelled(this);
              }
            }
          };
          Promise2.prototype._invokeOnCancel = function() {
            var onCancelCallback = this._onCancel();
            this._unsetOnCancel();
            async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
          };
          Promise2.prototype._invokeInternalOnCancel = function() {
            if (this._isCancellable()) {
              this._doInvokeOnCancel(this._onCancel(), true);
              this._unsetOnCancel();
            }
          };
          Promise2.prototype._resultCancelled = function() {
            this.cancel();
          };
        };
      }, { "./util": 36 }], 7: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(NEXT_FILTER) {
          var util = _dereq_2("./util");
          var getKeys = _dereq_2("./es5").keys;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function catchFilter(instances, cb, promise) {
            return function(e) {
              var boundTo = promise._boundValue();
              predicateLoop:
                for (var i = 0; i < instances.length; ++i) {
                  var item = instances[i];
                  if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                      return tryCatch2(cb).call(boundTo, e);
                    }
                  } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch2(item).call(boundTo, e);
                    if (matchesPredicate === errorObj2) {
                      return matchesPredicate;
                    } else if (matchesPredicate) {
                      return tryCatch2(cb).call(boundTo, e);
                    }
                  } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for (var j = 0; j < keys.length; ++j) {
                      var key = keys[j];
                      if (item[key] != e[key]) {
                        continue predicateLoop;
                      }
                    }
                    return tryCatch2(cb).call(boundTo, e);
                  }
                }
              return NEXT_FILTER;
            };
          }
          return catchFilter;
        };
      }, { "./es5": 13, "./util": 36 }], 8: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var longStackTraces = false;
          var contextStack = [];
          Promise2.prototype._promiseCreated = function() {
          };
          Promise2.prototype._pushContext = function() {
          };
          Promise2.prototype._popContext = function() {
            return null;
          };
          Promise2._peekContext = Promise2.prototype._peekContext = function() {
          };
          function Context() {
            this._trace = new Context.CapturedTrace(peekContext());
          }
          Context.prototype._pushContext = function() {
            if (this._trace !== void 0) {
              this._trace._promiseCreated = null;
              contextStack.push(this._trace);
            }
          };
          Context.prototype._popContext = function() {
            if (this._trace !== void 0) {
              var trace = contextStack.pop();
              var ret2 = trace._promiseCreated;
              trace._promiseCreated = null;
              return ret2;
            }
            return null;
          };
          function createContext() {
            if (longStackTraces)
              return new Context();
          }
          function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) {
              return contextStack[lastIndex];
            }
            return void 0;
          }
          Context.CapturedTrace = null;
          Context.create = createContext;
          Context.deactivateLongStackTraces = function() {
          };
          Context.activateLongStackTraces = function() {
            var Promise_pushContext = Promise2.prototype._pushContext;
            var Promise_popContext = Promise2.prototype._popContext;
            var Promise_PeekContext = Promise2._peekContext;
            var Promise_peekContext = Promise2.prototype._peekContext;
            var Promise_promiseCreated = Promise2.prototype._promiseCreated;
            Context.deactivateLongStackTraces = function() {
              Promise2.prototype._pushContext = Promise_pushContext;
              Promise2.prototype._popContext = Promise_popContext;
              Promise2._peekContext = Promise_PeekContext;
              Promise2.prototype._peekContext = Promise_peekContext;
              Promise2.prototype._promiseCreated = Promise_promiseCreated;
              longStackTraces = false;
            };
            longStackTraces = true;
            Promise2.prototype._pushContext = Context.prototype._pushContext;
            Promise2.prototype._popContext = Context.prototype._popContext;
            Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
            Promise2.prototype._promiseCreated = function() {
              var ctx = this._peekContext();
              if (ctx && ctx._promiseCreated == null)
                ctx._promiseCreated = this;
            };
          };
          return Context;
        };
      }, {}], 9: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, Context, enableAsyncHooks, disableAsyncHooks) {
          var async = Promise2._async;
          var Warning = _dereq_2("./errors").Warning;
          var util = _dereq_2("./util");
          var es52 = _dereq_2("./es5");
          var canAttachTrace2 = util.canAttachTrace;
          var unhandledRejectionHandled;
          var possiblyUnhandledRejection;
          var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
          var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
          var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
          var stackFramePattern = null;
          var formatStack = null;
          var indentStackFrames = false;
          var printWarning;
          var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && true);
          var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
          var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
          var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
          var deferUnhandledRejectionCheck;
          (function() {
            var promises = [];
            function unhandledRejectionCheck() {
              for (var i = 0; i < promises.length; ++i) {
                promises[i]._notifyUnhandledRejection();
              }
              unhandledRejectionClear();
            }
            function unhandledRejectionClear() {
              promises.length = 0;
            }
            deferUnhandledRejectionCheck = function(promise) {
              promises.push(promise);
              setTimeout(unhandledRejectionCheck, 1);
            };
            es52.defineProperty(Promise2, "_unhandledRejectionCheck", {
              value: unhandledRejectionCheck
            });
            es52.defineProperty(Promise2, "_unhandledRejectionClear", {
              value: unhandledRejectionClear
            });
          })();
          Promise2.prototype.suppressUnhandledRejections = function() {
            var target = this._target();
            target._bitField = target._bitField & ~1048576 | 524288;
          };
          Promise2.prototype._ensurePossibleRejectionHandled = function() {
            if ((this._bitField & 524288) !== 0)
              return;
            this._setRejectionIsUnhandled();
            deferUnhandledRejectionCheck(this);
          };
          Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
            fireRejectionEvent(
              "rejectionHandled",
              unhandledRejectionHandled,
              void 0,
              this
            );
          };
          Promise2.prototype._setReturnedNonUndefined = function() {
            this._bitField = this._bitField | 268435456;
          };
          Promise2.prototype._returnedNonUndefined = function() {
            return (this._bitField & 268435456) !== 0;
          };
          Promise2.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var reason = this._settledValue();
              this._setUnhandledRejectionIsNotified();
              fireRejectionEvent(
                "unhandledRejection",
                possiblyUnhandledRejection,
                reason,
                this
              );
            }
          };
          Promise2.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 262144;
          };
          Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & ~262144;
          };
          Promise2.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 262144) > 0;
          };
          Promise2.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 1048576;
          };
          Promise2.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & ~1048576;
            if (this._isUnhandledRejectionNotified()) {
              this._unsetUnhandledRejectionIsNotified();
              this._notifyUnhandledRejectionIsHandled();
            }
          };
          Promise2.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 1048576) > 0;
          };
          Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
            return warn(message, shouldUseOwnTrace, promise || this);
          };
          Promise2.onPossiblyUnhandledRejection = function(fn) {
            var context = Promise2._getContext();
            possiblyUnhandledRejection = util.contextBind(context, fn);
          };
          Promise2.onUnhandledRejectionHandled = function(fn) {
            var context = Promise2._getContext();
            unhandledRejectionHandled = util.contextBind(context, fn);
          };
          var disableLongStackTraces = function() {
          };
          Promise2.longStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            if (!config.longStackTraces && longStackTracesIsSupported()) {
              var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
              var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
              var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
              config.longStackTraces = true;
              disableLongStackTraces = function() {
                if (async.haveItemsQueued() && !config.longStackTraces) {
                  throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                }
                Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
                Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
                Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
                Context.deactivateLongStackTraces();
                config.longStackTraces = false;
              };
              Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
              Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
              Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
              Context.activateLongStackTraces();
            }
          };
          Promise2.hasLongStackTraces = function() {
            return config.longStackTraces && longStackTracesIsSupported();
          };
          var legacyHandlers = {
            unhandledrejection: {
              before: function() {
                var ret2 = util.global.onunhandledrejection;
                util.global.onunhandledrejection = null;
                return ret2;
              },
              after: function(fn) {
                util.global.onunhandledrejection = fn;
              }
            },
            rejectionhandled: {
              before: function() {
                var ret2 = util.global.onrejectionhandled;
                util.global.onrejectionhandled = null;
                return ret2;
              },
              after: function(fn) {
                util.global.onrejectionhandled = fn;
              }
            }
          };
          var fireDomEvent = function() {
            var dispatch = function(legacy, e) {
              if (legacy) {
                var fn;
                try {
                  fn = legacy.before();
                  return !util.global.dispatchEvent(e);
                } finally {
                  legacy.after(fn);
                }
              } else {
                return !util.global.dispatchEvent(e);
              }
            };
            try {
              if (typeof CustomEvent === "function") {
                var event = new CustomEvent("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var eventData = {
                    detail: event2,
                    cancelable: true
                  };
                  var domEvent = new CustomEvent(name, eventData);
                  es52.defineProperty(
                    domEvent,
                    "promise",
                    { value: event2.promise }
                  );
                  es52.defineProperty(
                    domEvent,
                    "reason",
                    { value: event2.reason }
                  );
                  return dispatch(legacyHandlers[name], domEvent);
                };
              } else if (typeof Event === "function") {
                var event = new Event("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var domEvent = new Event(name, {
                    cancelable: true
                  });
                  domEvent.detail = event2;
                  es52.defineProperty(domEvent, "promise", { value: event2.promise });
                  es52.defineProperty(domEvent, "reason", { value: event2.reason });
                  return dispatch(legacyHandlers[name], domEvent);
                };
              } else {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var domEvent = document.createEvent("CustomEvent");
                  domEvent.initCustomEvent(
                    name,
                    false,
                    true,
                    event2
                  );
                  return dispatch(legacyHandlers[name], domEvent);
                };
              }
            } catch (e) {
            }
            return function() {
              return false;
            };
          }();
          var fireGlobalEvent = function() {
            if (util.isNode) {
              return function() {
                return process.emit.apply(process, arguments);
              };
            } else {
              if (!util.global) {
                return function() {
                  return false;
                };
              }
              return function(name) {
                var methodName = "on" + name.toLowerCase();
                var method = util.global[methodName];
                if (!method)
                  return false;
                method.apply(util.global, [].slice.call(arguments, 1));
                return true;
              };
            }
          }();
          function generatePromiseLifecycleEventObject(name, promise) {
            return { promise };
          }
          var eventToObjectGenerator = {
            promiseCreated: generatePromiseLifecycleEventObject,
            promiseFulfilled: generatePromiseLifecycleEventObject,
            promiseRejected: generatePromiseLifecycleEventObject,
            promiseResolved: generatePromiseLifecycleEventObject,
            promiseCancelled: generatePromiseLifecycleEventObject,
            promiseChained: function(name, promise, child) {
              return { promise, child };
            },
            warning: function(name, warning) {
              return { warning };
            },
            unhandledRejection: function(name, reason, promise) {
              return { reason, promise };
            },
            rejectionHandled: generatePromiseLifecycleEventObject
          };
          var activeFireEvent = function(name) {
            var globalEventFired = false;
            try {
              globalEventFired = fireGlobalEvent.apply(null, arguments);
            } catch (e) {
              async.throwLater(e);
              globalEventFired = true;
            }
            var domEventFired = false;
            try {
              domEventFired = fireDomEvent(
                name,
                eventToObjectGenerator[name].apply(null, arguments)
              );
            } catch (e) {
              async.throwLater(e);
              domEventFired = true;
            }
            return domEventFired || globalEventFired;
          };
          Promise2.config = function(opts) {
            opts = Object(opts);
            if ("longStackTraces" in opts) {
              if (opts.longStackTraces) {
                Promise2.longStackTraces();
              } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
                disableLongStackTraces();
              }
            }
            if ("warnings" in opts) {
              var warningsOption = opts.warnings;
              config.warnings = !!warningsOption;
              wForgottenReturn = config.warnings;
              if (util.isObject(warningsOption)) {
                if ("wForgottenReturn" in warningsOption) {
                  wForgottenReturn = !!warningsOption.wForgottenReturn;
                }
              }
            }
            if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
              if (async.haveItemsQueued()) {
                throw new Error(
                  "cannot enable cancellation after promises are in use"
                );
              }
              Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
              Promise2.prototype._propagateFrom = cancellationPropagateFrom;
              Promise2.prototype._onCancel = cancellationOnCancel;
              Promise2.prototype._setOnCancel = cancellationSetOnCancel;
              Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
              Promise2.prototype._execute = cancellationExecute;
              propagateFromFunction = cancellationPropagateFrom;
              config.cancellation = true;
            }
            if ("monitoring" in opts) {
              if (opts.monitoring && !config.monitoring) {
                config.monitoring = true;
                Promise2.prototype._fireEvent = activeFireEvent;
              } else if (!opts.monitoring && config.monitoring) {
                config.monitoring = false;
                Promise2.prototype._fireEvent = defaultFireEvent;
              }
            }
            if ("asyncHooks" in opts && util.nodeSupportsAsyncResource) {
              var prev = config.asyncHooks;
              var cur = !!opts.asyncHooks;
              if (prev !== cur) {
                config.asyncHooks = cur;
                if (cur) {
                  enableAsyncHooks();
                } else {
                  disableAsyncHooks();
                }
              }
            }
            return Promise2;
          };
          function defaultFireEvent() {
            return false;
          }
          Promise2.prototype._fireEvent = defaultFireEvent;
          Promise2.prototype._execute = function(executor, resolve, reject) {
            try {
              executor(resolve, reject);
            } catch (e) {
              return e;
            }
          };
          Promise2.prototype._onCancel = function() {
          };
          Promise2.prototype._setOnCancel = function(handler) {
            ;
          };
          Promise2.prototype._attachCancellationCallback = function(onCancel) {
            ;
          };
          Promise2.prototype._captureStackTrace = function() {
          };
          Promise2.prototype._attachExtraTrace = function() {
          };
          Promise2.prototype._dereferenceTrace = function() {
          };
          Promise2.prototype._clearCancellationData = function() {
          };
          Promise2.prototype._propagateFrom = function(parent, flags) {
            ;
            ;
          };
          function cancellationExecute(executor, resolve, reject) {
            var promise = this;
            try {
              executor(resolve, reject, function(onCancel) {
                if (typeof onCancel !== "function") {
                  throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                }
                promise._attachCancellationCallback(onCancel);
              });
            } catch (e) {
              return e;
            }
          }
          function cancellationAttachCancellationCallback(onCancel) {
            if (!this._isCancellable())
              return this;
            var previousOnCancel = this._onCancel();
            if (previousOnCancel !== void 0) {
              if (util.isArray(previousOnCancel)) {
                previousOnCancel.push(onCancel);
              } else {
                this._setOnCancel([previousOnCancel, onCancel]);
              }
            } else {
              this._setOnCancel(onCancel);
            }
          }
          function cancellationOnCancel() {
            return this._onCancelField;
          }
          function cancellationSetOnCancel(onCancel) {
            this._onCancelField = onCancel;
          }
          function cancellationClearCancellationData() {
            this._cancellationParent = void 0;
            this._onCancelField = void 0;
          }
          function cancellationPropagateFrom(parent, flags) {
            if ((flags & 1) !== 0) {
              this._cancellationParent = parent;
              var branchesRemainingToCancel = parent._branchesRemainingToCancel;
              if (branchesRemainingToCancel === void 0) {
                branchesRemainingToCancel = 0;
              }
              parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
            }
            if ((flags & 2) !== 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          }
          function bindingPropagateFrom(parent, flags) {
            if ((flags & 2) !== 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          }
          var propagateFromFunction = bindingPropagateFrom;
          function boundValueFunction() {
            var ret2 = this._boundTo;
            if (ret2 !== void 0) {
              if (ret2 instanceof Promise2) {
                if (ret2.isFulfilled()) {
                  return ret2.value();
                } else {
                  return void 0;
                }
              }
            }
            return ret2;
          }
          function longStackTracesCaptureStackTrace() {
            this._trace = new CapturedTrace(this._peekContext());
          }
          function longStackTracesAttachExtraTrace(error, ignoreSelf) {
            if (canAttachTrace2(error)) {
              var trace = this._trace;
              if (trace !== void 0) {
                if (ignoreSelf)
                  trace = trace._parent;
              }
              if (trace !== void 0) {
                trace.attachExtraTrace(error);
              } else if (!error.__stackCleaned__) {
                var parsed = parseStackAndMessage(error);
                util.notEnumerableProp(
                  error,
                  "stack",
                  parsed.message + "\n" + parsed.stack.join("\n")
                );
                util.notEnumerableProp(error, "__stackCleaned__", true);
              }
            }
          }
          function longStackTracesDereferenceTrace() {
            this._trace = void 0;
          }
          function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
            if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
              if (parent !== void 0 && parent._returnedNonUndefined())
                return;
              if ((promise._bitField & 65535) === 0)
                return;
              if (name)
                name = name + " ";
              var handlerLine = "";
              var creatorLine = "";
              if (promiseCreated._trace) {
                var traceLines = promiseCreated._trace.stack.split("\n");
                var stack = cleanStack(traceLines);
                for (var i = stack.length - 1; i >= 0; --i) {
                  var line = stack[i];
                  if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                      handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                  }
                }
                if (stack.length > 0) {
                  var firstUserLine = stack[0];
                  for (var i = 0; i < traceLines.length; ++i) {
                    if (traceLines[i] === firstUserLine) {
                      if (i > 0) {
                        creatorLine = "\n" + traceLines[i - 1];
                      }
                      break;
                    }
                  }
                }
              }
              var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
              promise._warn(msg, true, promiseCreated);
            }
          }
          function deprecated(name, replacement) {
            var message = name + " is deprecated and will be removed in a future version.";
            if (replacement)
              message += " Use " + replacement + " instead.";
            return warn(message);
          }
          function warn(message, shouldUseOwnTrace, promise) {
            if (!config.warnings)
              return;
            var warning = new Warning(message);
            var ctx;
            if (shouldUseOwnTrace) {
              promise._attachExtraTrace(warning);
            } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
              ctx.attachExtraTrace(warning);
            } else {
              var parsed = parseStackAndMessage(warning);
              warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
            }
            if (!activeFireEvent("warning", warning)) {
              formatAndLogError(warning, "", true);
            }
          }
          function reconstructStack(message, stacks) {
            for (var i = 0; i < stacks.length - 1; ++i) {
              stacks[i].push("From previous event:");
              stacks[i] = stacks[i].join("\n");
            }
            if (i < stacks.length) {
              stacks[i] = stacks[i].join("\n");
            }
            return message + "\n" + stacks.join("\n");
          }
          function removeDuplicateOrEmptyJumps(stacks) {
            for (var i = 0; i < stacks.length; ++i) {
              if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
              }
            }
          }
          function removeCommonRoots(stacks) {
            var current = stacks[0];
            for (var i = 1; i < stacks.length; ++i) {
              var prev = stacks[i];
              var currentLastIndex = current.length - 1;
              var currentLastLine = current[currentLastIndex];
              var commonRootMeetPoint = -1;
              for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                  commonRootMeetPoint = j;
                  break;
                }
              }
              for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                  current.pop();
                  currentLastIndex--;
                } else {
                  break;
                }
              }
              current = prev;
            }
          }
          function cleanStack(stack) {
            var ret2 = [];
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
              var isInternalFrame = isTraceLine && shouldIgnore(line);
              if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                  line = "    " + line;
                }
                ret2.push(line);
              }
            }
            return ret2;
          }
          function stackFramesAsArray(error) {
            var stack = error.stack.replace(/\s+$/g, "").split("\n");
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
              }
            }
            if (i > 0 && error.name != "SyntaxError") {
              stack = stack.slice(i);
            }
            return stack;
          }
          function parseStackAndMessage(error) {
            var stack = error.stack;
            var message = error.toString();
            stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
            return {
              message,
              stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
            };
          }
          function formatAndLogError(error, title, isSoft) {
            if (typeof console !== "undefined") {
              var message;
              if (util.isObject(error)) {
                var stack = error.stack;
                message = title + formatStack(stack, error);
              } else {
                message = title + String(error);
              }
              if (typeof printWarning === "function") {
                printWarning(message, isSoft);
              } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
              }
            }
          }
          function fireRejectionEvent(name, localHandler, reason, promise) {
            var localEventFired = false;
            try {
              if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                  localHandler(promise);
                } else {
                  localHandler(reason, promise);
                }
              }
            } catch (e) {
              async.throwLater(e);
            }
            if (name === "unhandledRejection") {
              if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                formatAndLogError(reason, "Unhandled rejection ");
              }
            } else {
              activeFireEvent(name, promise);
            }
          }
          function formatNonError(obj2) {
            var str;
            if (typeof obj2 === "function") {
              str = "[function " + (obj2.name || "anonymous") + "]";
            } else {
              str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
              var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
              if (ruselessToString.test(str)) {
                try {
                  var newStr = JSON.stringify(obj2);
                  str = newStr;
                } catch (e) {
                }
              }
              if (str.length === 0) {
                str = "(empty array)";
              }
            }
            return "(<" + snip(str) + ">, no stack trace)";
          }
          function snip(str) {
            var maxChars = 41;
            if (str.length < maxChars) {
              return str;
            }
            return str.substr(0, maxChars - 3) + "...";
          }
          function longStackTracesIsSupported() {
            return typeof captureStackTrace === "function";
          }
          var shouldIgnore = function() {
            return false;
          };
          var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) {
              return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
              };
            }
          }
          function setBounds(firstLineError, lastLineError) {
            if (!longStackTracesIsSupported())
              return;
            var firstStackLines = (firstLineError.stack || "").split("\n");
            var lastStackLines = (lastLineError.stack || "").split("\n");
            var firstIndex = -1;
            var lastIndex = -1;
            var firstFileName;
            var lastFileName;
            for (var i = 0; i < firstStackLines.length; ++i) {
              var result = parseLineInfo(firstStackLines[i]);
              if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
              }
            }
            for (var i = 0; i < lastStackLines.length; ++i) {
              var result = parseLineInfo(lastStackLines[i]);
              if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
              }
            }
            if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
              return;
            }
            shouldIgnore = function(line) {
              if (bluebirdFramePattern.test(line))
                return true;
              var info = parseLineInfo(line);
              if (info) {
                if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                  return true;
                }
              }
              return false;
            };
          }
          function CapturedTrace(parent) {
            this._parent = parent;
            this._promisesCreated = 0;
            var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace);
            if (length > 32)
              this.uncycle();
          }
          util.inherits(CapturedTrace, Error);
          Context.CapturedTrace = CapturedTrace;
          CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (length < 2)
              return;
            var nodes = [];
            var stackToIndex = {};
            for (var i = 0, node = this; node !== void 0; ++i) {
              nodes.push(node);
              node = node._parent;
            }
            length = this._length = i;
            for (var i = length - 1; i >= 0; --i) {
              var stack = nodes[i].stack;
              if (stackToIndex[stack] === void 0) {
                stackToIndex[stack] = i;
              }
            }
            for (var i = 0; i < length; ++i) {
              var currentStack = nodes[i].stack;
              var index = stackToIndex[currentStack];
              if (index !== void 0 && index !== i) {
                if (index > 0) {
                  nodes[index - 1]._parent = void 0;
                  nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = void 0;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                  cycleEdgeNode._parent = nodes[index + 1];
                  cycleEdgeNode._parent.uncycle();
                  cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                  cycleEdgeNode._parent = void 0;
                  cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                  nodes[j]._length = currentChildLength;
                  currentChildLength++;
                }
                return;
              }
            }
          };
          CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (error.__stackCleaned__)
              return;
            this.uncycle();
            var parsed = parseStackAndMessage(error);
            var message = parsed.message;
            var stacks = [parsed.stack];
            var trace = this;
            while (trace !== void 0) {
              stacks.push(cleanStack(trace.stack.split("\n")));
              trace = trace._parent;
            }
            removeCommonRoots(stacks);
            removeDuplicateOrEmptyJumps(stacks);
            util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          };
          var captureStackTrace = function stackDetection() {
            var v8stackFramePattern = /^\s*at\s*/;
            var v8stackFormatter = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if (error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
              Error.stackTraceLimit += 6;
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              var captureStackTrace2 = Error.captureStackTrace;
              shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
              };
              return function(receiver2, ignoreUntil) {
                Error.stackTraceLimit += 6;
                captureStackTrace2(receiver2, ignoreUntil);
                Error.stackTraceLimit -= 6;
              };
            }
            var err = new Error();
            if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
              stackFramePattern = /@/;
              formatStack = v8stackFormatter;
              indentStackFrames = true;
              return function captureStackTrace3(o) {
                o.stack = new Error().stack;
              };
            }
            var hasStackAfterThrow;
            try {
              throw new Error();
            } catch (e) {
              hasStackAfterThrow = "stack" in e;
            }
            if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              return function captureStackTrace3(o) {
                Error.stackTraceLimit += 6;
                try {
                  throw new Error();
                } catch (e) {
                  o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
              };
            }
            formatStack = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            return null;
          }([]);
          if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
            printWarning = function(message) {
              console.warn(message);
            };
            if (util.isNode && process.stderr.isTTY) {
              printWarning = function(message, isSoft) {
                var color = isSoft ? "\x1B[33m" : "\x1B[31m";
                console.warn(color + message + "\x1B[0m\n");
              };
            } else if (!util.isNode && typeof new Error().stack === "string") {
              printWarning = function(message, isSoft) {
                console.warn(
                  "%c" + message,
                  isSoft ? "color: darkorange" : "color: red"
                );
              };
            }
          }
          var config = {
            warnings,
            longStackTraces: false,
            cancellation: false,
            monitoring: false,
            asyncHooks: false
          };
          if (longStackTraces)
            Promise2.longStackTraces();
          return {
            asyncHooks: function() {
              return config.asyncHooks;
            },
            longStackTraces: function() {
              return config.longStackTraces;
            },
            warnings: function() {
              return config.warnings;
            },
            cancellation: function() {
              return config.cancellation;
            },
            monitoring: function() {
              return config.monitoring;
            },
            propagateFromFunction: function() {
              return propagateFromFunction;
            },
            boundValueFunction: function() {
              return boundValueFunction;
            },
            checkForgottenReturns,
            setBounds,
            warn,
            deprecated,
            CapturedTrace,
            fireDomEvent,
            fireGlobalEvent
          };
        };
      }, { "./errors": 12, "./es5": 13, "./util": 36 }], 10: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function returner() {
            return this.value;
          }
          function thrower2() {
            throw this.reason;
          }
          Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
            if (value instanceof Promise2)
              value.suppressUnhandledRejections();
            return this._then(
              returner,
              void 0,
              void 0,
              { value },
              void 0
            );
          };
          Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
            return this._then(
              thrower2,
              void 0,
              void 0,
              { reason },
              void 0
            );
          };
          Promise2.prototype.catchThrow = function(reason) {
            if (arguments.length <= 1) {
              return this._then(
                void 0,
                thrower2,
                void 0,
                { reason },
                void 0
              );
            } else {
              var _reason = arguments[1];
              var handler = function() {
                throw _reason;
              };
              return this.caught(reason, handler);
            }
          };
          Promise2.prototype.catchReturn = function(value) {
            if (arguments.length <= 1) {
              if (value instanceof Promise2)
                value.suppressUnhandledRejections();
              return this._then(
                void 0,
                returner,
                void 0,
                { value },
                void 0
              );
            } else {
              var _value = arguments[1];
              if (_value instanceof Promise2)
                _value.suppressUnhandledRejections();
              var handler = function() {
                return _value;
              };
              return this.caught(value, handler);
            }
          };
        };
      }, {}], 11: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseReduce = Promise2.reduce;
          var PromiseAll = Promise2.all;
          function promiseAllThis() {
            return PromiseAll(this);
          }
          function PromiseMapSeries(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
          }
          Promise2.prototype.each = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
          };
          Promise2.prototype.mapSeries = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, INTERNAL);
          };
          Promise2.each = function(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
          };
          Promise2.mapSeries = PromiseMapSeries;
        };
      }, {}], 12: [function(_dereq_2, module2, exports2) {
        "use strict";
        var es52 = _dereq_2("./es5");
        var Objectfreeze = es52.freeze;
        var util = _dereq_2("./util");
        var inherits2 = util.inherits;
        var notEnumerableProp2 = util.notEnumerableProp;
        function subError(nameProperty, defaultMessage) {
          function SubError(message) {
            if (!(this instanceof SubError))
              return new SubError(message);
            notEnumerableProp2(
              this,
              "message",
              typeof message === "string" ? message : defaultMessage
            );
            notEnumerableProp2(this, "name", nameProperty);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              Error.call(this);
            }
          }
          inherits2(SubError, Error);
          return SubError;
        }
        var _TypeError, _RangeError;
        var Warning = subError("Warning", "warning");
        var CancellationError = subError("CancellationError", "cancellation error");
        var TimeoutError = subError("TimeoutError", "timeout error");
        var AggregateError = subError("AggregateError", "aggregate error");
        try {
          _TypeError = TypeError;
          _RangeError = RangeError;
        } catch (e) {
          _TypeError = subError("TypeError", "type error");
          _RangeError = subError("RangeError", "range error");
        }
        var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
        for (var i = 0; i < methods.length; ++i) {
          if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
          }
        }
        es52.defineProperty(AggregateError.prototype, "length", {
          value: 0,
          configurable: false,
          writable: true,
          enumerable: true
        });
        AggregateError.prototype["isOperational"] = true;
        var level = 0;
        AggregateError.prototype.toString = function() {
          var indent = Array(level * 4 + 1).join(" ");
          var ret2 = "\n" + indent + "AggregateError of:\n";
          level++;
          indent = Array(level * 4 + 1).join(" ");
          for (var i2 = 0; i2 < this.length; ++i2) {
            var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
              lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret2 += str + "\n";
          }
          level--;
          return ret2;
        };
        function OperationalError(message) {
          if (!(this instanceof OperationalError))
            return new OperationalError(message);
          notEnumerableProp2(this, "name", "OperationalError");
          notEnumerableProp2(this, "message", message);
          this.cause = message;
          this["isOperational"] = true;
          if (message instanceof Error) {
            notEnumerableProp2(this, "message", message.message);
            notEnumerableProp2(this, "stack", message.stack);
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        inherits2(OperationalError, Error);
        var errorTypes = Error["__BluebirdErrorTypes__"];
        if (!errorTypes) {
          errorTypes = Objectfreeze({
            CancellationError,
            TimeoutError,
            OperationalError,
            RejectionError: OperationalError,
            AggregateError
          });
          es52.defineProperty(Error, "__BluebirdErrorTypes__", {
            value: errorTypes,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
        module2.exports = {
          Error,
          TypeError: _TypeError,
          RangeError: _RangeError,
          CancellationError: errorTypes.CancellationError,
          OperationalError: errorTypes.OperationalError,
          TimeoutError: errorTypes.TimeoutError,
          AggregateError: errorTypes.AggregateError,
          Warning
        };
      }, { "./es5": 13, "./util": 36 }], 13: [function(_dereq_2, module2, exports2) {
        var isES5 = function() {
          "use strict";
          return this === void 0;
        }();
        if (isES5) {
          module2.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5,
            propertyIsWritable: function(obj2, prop) {
              var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
              return !!(!descriptor || descriptor.writable || descriptor.set);
            }
          };
        } else {
          var has = {}.hasOwnProperty;
          var str = {}.toString;
          var proto = {}.constructor.prototype;
          var ObjectKeys = function(o) {
            var ret2 = [];
            for (var key in o) {
              if (has.call(o, key)) {
                ret2.push(key);
              }
            }
            return ret2;
          };
          var ObjectGetDescriptor = function(o, key) {
            return { value: o[key] };
          };
          var ObjectDefineProperty = function(o, key, desc) {
            o[key] = desc.value;
            return o;
          };
          var ObjectFreeze = function(obj2) {
            return obj2;
          };
          var ObjectGetPrototypeOf = function(obj2) {
            try {
              return Object(obj2).constructor.prototype;
            } catch (e) {
              return proto;
            }
          };
          var ArrayIsArray = function(obj2) {
            try {
              return str.call(obj2) === "[object Array]";
            } catch (e) {
              return false;
            }
          };
          module2.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5,
            propertyIsWritable: function() {
              return true;
            }
          };
        }
      }, {}], 14: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseMap = Promise2.map;
          Promise2.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
          };
          Promise2.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
          };
        };
      }, {}], 15: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
          var util = _dereq_2("./util");
          var CancellationError = Promise2.CancellationError;
          var errorObj2 = util.errorObj;
          var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
          function PassThroughHandlerContext(promise, type, handler) {
            this.promise = promise;
            this.type = type;
            this.handler = handler;
            this.called = false;
            this.cancelPromise = null;
          }
          PassThroughHandlerContext.prototype.isFinallyHandler = function() {
            return this.type === 0;
          };
          function FinallyHandlerCancelReaction(finallyHandler2) {
            this.finallyHandler = finallyHandler2;
          }
          FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
            checkCancel(this.finallyHandler);
          };
          function checkCancel(ctx, reason) {
            if (ctx.cancelPromise != null) {
              if (arguments.length > 1) {
                ctx.cancelPromise._reject(reason);
              } else {
                ctx.cancelPromise._cancel();
              }
              ctx.cancelPromise = null;
              return true;
            }
            return false;
          }
          function succeed() {
            return finallyHandler.call(this, this.promise._target()._settledValue());
          }
          function fail(reason) {
            if (checkCancel(this, reason))
              return;
            errorObj2.e = reason;
            return errorObj2;
          }
          function finallyHandler(reasonOrValue) {
            var promise = this.promise;
            var handler = this.handler;
            if (!this.called) {
              this.called = true;
              var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
              if (ret2 === NEXT_FILTER) {
                return ret2;
              } else if (ret2 !== void 0) {
                promise._setReturnedNonUndefined();
                var maybePromise = tryConvertToPromise(ret2, promise);
                if (maybePromise instanceof Promise2) {
                  if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                      var reason = new CancellationError("late cancellation observer");
                      promise._attachExtraTrace(reason);
                      errorObj2.e = reason;
                      return errorObj2;
                    } else if (maybePromise.isPending()) {
                      maybePromise._attachCancellationCallback(
                        new FinallyHandlerCancelReaction(this)
                      );
                    }
                  }
                  return maybePromise._then(
                    succeed,
                    fail,
                    void 0,
                    this,
                    void 0
                  );
                }
              }
            }
            if (promise.isRejected()) {
              checkCancel(this);
              errorObj2.e = reasonOrValue;
              return errorObj2;
            } else {
              checkCancel(this);
              return reasonOrValue;
            }
          }
          Promise2.prototype._passThrough = function(handler, type, success, fail2) {
            if (typeof handler !== "function")
              return this.then();
            return this._then(
              success,
              fail2,
              void 0,
              new PassThroughHandlerContext(this, type, handler),
              void 0
            );
          };
          Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
            return this._passThrough(
              handler,
              0,
              finallyHandler,
              finallyHandler
            );
          };
          Promise2.prototype.tap = function(handler) {
            return this._passThrough(handler, 1, finallyHandler);
          };
          Promise2.prototype.tapCatch = function(handlerOrPredicate) {
            var len = arguments.length;
            if (len === 1) {
              return this._passThrough(
                handlerOrPredicate,
                1,
                void 0,
                finallyHandler
              );
            } else {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                  catchInstances[j++] = item;
                } else {
                  return Promise2.reject(new TypeError(
                    "tapCatch statement predicate: expecting an object but got " + util.classString(item)
                  ));
                }
              }
              catchInstances.length = j;
              var handler = arguments[i];
              return this._passThrough(
                catchFilter(catchInstances, handler, this),
                1,
                void 0,
                finallyHandler
              );
            }
          };
          return PassThroughHandlerContext;
        };
      }, { "./catch_filter": 7, "./util": 36 }], 16: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
          var errors = _dereq_2("./errors");
          var TypeError2 = errors.TypeError;
          var util = _dereq_2("./util");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var yieldHandlers = [];
          function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
            for (var i = 0; i < yieldHandlers2.length; ++i) {
              traceParent._pushContext();
              var result = tryCatch2(yieldHandlers2[i])(value);
              traceParent._popContext();
              if (result === errorObj2) {
                traceParent._pushContext();
                var ret2 = Promise2.reject(errorObj2.e);
                traceParent._popContext();
                return ret2;
              }
              var maybePromise = tryConvertToPromise(result, traceParent);
              if (maybePromise instanceof Promise2)
                return maybePromise;
            }
            return null;
          }
          function PromiseSpawn(generatorFunction, receiver2, yieldHandler, stack) {
            if (debug.cancellation()) {
              var internal = new Promise2(INTERNAL);
              var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
              this._promise = internal.lastly(function() {
                return _finallyPromise;
              });
              internal._captureStackTrace();
              internal._setOnCancel(this);
            } else {
              var promise = this._promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
            }
            this._stack = stack;
            this._generatorFunction = generatorFunction;
            this._receiver = receiver2;
            this._generator = void 0;
            this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
            this._yieldedPromise = null;
            this._cancellationPhase = false;
          }
          util.inherits(PromiseSpawn, Proxyable);
          PromiseSpawn.prototype._isResolved = function() {
            return this._promise === null;
          };
          PromiseSpawn.prototype._cleanup = function() {
            this._promise = this._generator = null;
            if (debug.cancellation() && this._finallyPromise !== null) {
              this._finallyPromise._fulfill();
              this._finallyPromise = null;
            }
          };
          PromiseSpawn.prototype._promiseCancelled = function() {
            if (this._isResolved())
              return;
            var implementsReturn = typeof this._generator["return"] !== "undefined";
            var result;
            if (!implementsReturn) {
              var reason = new Promise2.CancellationError(
                "generator .return() sentinel"
              );
              Promise2.coroutine.returnSentinel = reason;
              this._promise._attachExtraTrace(reason);
              this._promise._pushContext();
              result = tryCatch2(this._generator["throw"]).call(
                this._generator,
                reason
              );
              this._promise._popContext();
            } else {
              this._promise._pushContext();
              result = tryCatch2(this._generator["return"]).call(
                this._generator,
                void 0
              );
              this._promise._popContext();
            }
            this._cancellationPhase = true;
            this._yieldedPromise = null;
            this._continue(result);
          };
          PromiseSpawn.prototype._promiseFulfilled = function(value) {
            this._yieldedPromise = null;
            this._promise._pushContext();
            var result = tryCatch2(this._generator.next).call(this._generator, value);
            this._promise._popContext();
            this._continue(result);
          };
          PromiseSpawn.prototype._promiseRejected = function(reason) {
            this._yieldedPromise = null;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
            this._continue(result);
          };
          PromiseSpawn.prototype._resultCancelled = function() {
            if (this._yieldedPromise instanceof Promise2) {
              var promise = this._yieldedPromise;
              this._yieldedPromise = null;
              promise.cancel();
            }
          };
          PromiseSpawn.prototype.promise = function() {
            return this._promise;
          };
          PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver);
            this._receiver = this._generatorFunction = void 0;
            this._promiseFulfilled(void 0);
          };
          PromiseSpawn.prototype._continue = function(result) {
            var promise = this._promise;
            if (result === errorObj2) {
              this._cleanup();
              if (this._cancellationPhase) {
                return promise.cancel();
              } else {
                return promise._rejectCallback(result.e, false);
              }
            }
            var value = result.value;
            if (result.done === true) {
              this._cleanup();
              if (this._cancellationPhase) {
                return promise.cancel();
              } else {
                return promise._resolveCallback(value);
              }
            } else {
              var maybePromise = tryConvertToPromise(value, this._promise);
              if (!(maybePromise instanceof Promise2)) {
                maybePromise = promiseFromYieldHandler(
                  maybePromise,
                  this._yieldHandlers,
                  this._promise
                );
                if (maybePromise === null) {
                  this._promiseRejected(
                    new TypeError2(
                      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                    )
                  );
                  return;
                }
              }
              maybePromise = maybePromise._target();
              var bitField = maybePromise._bitField;
              ;
              if ((bitField & 50397184) === 0) {
                this._yieldedPromise = maybePromise;
                maybePromise._proxy(this, null);
              } else if ((bitField & 33554432) !== 0) {
                Promise2._async.invoke(
                  this._promiseFulfilled,
                  this,
                  maybePromise._value()
                );
              } else if ((bitField & 16777216) !== 0) {
                Promise2._async.invoke(
                  this._promiseRejected,
                  this,
                  maybePromise._reason()
                );
              } else {
                this._promiseCancelled();
              }
            }
          };
          Promise2.coroutine = function(generatorFunction, options) {
            if (typeof generatorFunction !== "function") {
              throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            var yieldHandler = Object(options).yieldHandler;
            var PromiseSpawn$ = PromiseSpawn;
            var stack = new Error().stack;
            return function() {
              var generator = generatorFunction.apply(this, arguments);
              var spawn = new PromiseSpawn$(
                void 0,
                void 0,
                yieldHandler,
                stack
              );
              var ret2 = spawn.promise();
              spawn._generator = generator;
              spawn._promiseFulfilled(void 0);
              return ret2;
            };
          };
          Promise2.coroutine.addYieldHandler = function(fn) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            yieldHandlers.push(fn);
          };
          Promise2.spawn = function(generatorFunction) {
            debug.deprecated("Promise.spawn()", "Promise.coroutine()");
            if (typeof generatorFunction !== "function") {
              return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            var spawn = new PromiseSpawn(generatorFunction, this);
            var ret2 = spawn.promise();
            spawn._run(Promise2.spawn);
            return ret2;
          };
        };
      }, { "./errors": 12, "./util": 36 }], 17: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async) {
          var util = _dereq_2("./util");
          var canEvaluate2 = util.canEvaluate;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var reject;
          if (false) {
            if (canEvaluate2) {
              var thenCallback = function(i2) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
              };
              var promiseSetter = function(i2) {
                return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
              };
              var generateHolderClass = function(total) {
                var props = new Array(total);
                for (var i2 = 0; i2 < props.length; ++i2) {
                  props[i2] = "this.p" + (i2 + 1);
                }
                var assignment = props.join(" = ") + " = null;";
                var cancellationCode = "var promise;\n" + props.map(function(prop) {
                  return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
                }).join("\n");
                var passedArguments = props.join(", ");
                var name = "Holder$" + total;
                var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
                code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
                return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
              };
              var holderClasses = [];
              var thenCallbacks = [];
              var promiseSetters = [];
              for (var i = 0; i < 8; ++i) {
                holderClasses.push(generateHolderClass(i + 1));
                thenCallbacks.push(thenCallback(i + 1));
                promiseSetters.push(promiseSetter(i + 1));
              }
              reject = function(reason) {
                this._reject(reason);
              };
            }
          }
          Promise2.join = function() {
            var last = arguments.length - 1;
            var fn;
            if (last > 0 && typeof arguments[last] === "function") {
              fn = arguments[last];
              if (false) {
                if (last <= 8 && canEvaluate2) {
                  var ret2 = new Promise2(INTERNAL);
                  ret2._captureStackTrace();
                  var HolderClass = holderClasses[last - 1];
                  var holder = new HolderClass(fn);
                  var callbacks = thenCallbacks;
                  for (var i2 = 0; i2 < last; ++i2) {
                    var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                    if (maybePromise instanceof Promise2) {
                      maybePromise = maybePromise._target();
                      var bitField = maybePromise._bitField;
                      ;
                      if ((bitField & 50397184) === 0) {
                        maybePromise._then(
                          callbacks[i2],
                          reject,
                          void 0,
                          ret2,
                          holder
                        );
                        promiseSetters[i2](maybePromise, holder);
                        holder.asyncNeeded = false;
                      } else if ((bitField & 33554432) !== 0) {
                        callbacks[i2].call(
                          ret2,
                          maybePromise._value(),
                          holder
                        );
                      } else if ((bitField & 16777216) !== 0) {
                        ret2._reject(maybePromise._reason());
                      } else {
                        ret2._cancel();
                      }
                    } else {
                      callbacks[i2].call(ret2, maybePromise, holder);
                    }
                  }
                  if (!ret2._isFateSealed()) {
                    if (holder.asyncNeeded) {
                      var context = Promise2._getContext();
                      holder.fn = util.contextBind(context, holder.fn);
                    }
                    ret2._setAsyncGuaranteed();
                    ret2._setOnCancel(holder);
                  }
                  return ret2;
                }
              }
            }
            var args = [].slice.call(arguments);
            ;
            if (fn)
              args.pop();
            var ret2 = new PromiseArray(args).promise();
            return fn !== void 0 ? ret2.spread(fn) : ret2;
          };
        };
      }, { "./util": 36 }], 18: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var async = Promise2._async;
          function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            var context = Promise2._getContext();
            this._callback = util.contextBind(context, fn);
            this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
            this._limit = limit;
            this._inFlight = 0;
            this._queue = [];
            async.invoke(this._asyncInit, this, void 0);
            if (util.isArray(promises)) {
              for (var i = 0; i < promises.length; ++i) {
                var maybePromise = promises[i];
                if (maybePromise instanceof Promise2) {
                  maybePromise.suppressUnhandledRejections();
                }
              }
            }
          }
          util.inherits(MappingPromiseArray, PromiseArray);
          MappingPromiseArray.prototype._asyncInit = function() {
            this._init$(void 0, -2);
          };
          MappingPromiseArray.prototype._init = function() {
          };
          MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values = this._values;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var limit = this._limit;
            if (index < 0) {
              index = index * -1 - 1;
              values[index] = value;
              if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved())
                  return true;
              }
            } else {
              if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return false;
              }
              if (preservedValues !== null)
                preservedValues[index] = value;
              var promise = this._promise;
              var callback = this._callback;
              var receiver2 = promise._boundValue();
              promise._pushContext();
              var ret2 = tryCatch2(callback).call(receiver2, value, index, length);
              var promiseCreated = promise._popContext();
              debug.checkForgottenReturns(
                ret2,
                promiseCreated,
                preservedValues !== null ? "Promise.filter" : "Promise.map",
                promise
              );
              if (ret2 === errorObj2) {
                this._reject(ret2.e);
                return true;
              }
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                  if (limit >= 1)
                    this._inFlight++;
                  values[index] = maybePromise;
                  maybePromise._proxy(this, (index + 1) * -1);
                  return false;
                } else if ((bitField & 33554432) !== 0) {
                  ret2 = maybePromise._value();
                } else if ((bitField & 16777216) !== 0) {
                  this._reject(maybePromise._reason());
                  return true;
                } else {
                  this._cancel();
                  return true;
                }
              }
              values[index] = ret2;
            }
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= length) {
              if (preservedValues !== null) {
                this._filter(values, preservedValues);
              } else {
                this._resolve(values);
              }
              return true;
            }
            return false;
          };
          MappingPromiseArray.prototype._drainQueue = function() {
            var queue = this._queue;
            var limit = this._limit;
            var values = this._values;
            while (queue.length > 0 && this._inFlight < limit) {
              if (this._isResolved())
                return;
              var index = queue.pop();
              this._promiseFulfilled(values[index], index);
            }
          };
          MappingPromiseArray.prototype._filter = function(booleans, values) {
            var len = values.length;
            var ret2 = new Array(len);
            var j = 0;
            for (var i = 0; i < len; ++i) {
              if (booleans[i])
                ret2[j++] = values[i];
            }
            ret2.length = j;
            this._resolve(ret2);
          };
          MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
          };
          function map(promises, fn, options, _filter) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var limit = 0;
            if (options !== void 0) {
              if (typeof options === "object" && options !== null) {
                if (typeof options.concurrency !== "number") {
                  return Promise2.reject(
                    new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency))
                  );
                }
                limit = options.concurrency;
              } else {
                return Promise2.reject(new TypeError(
                  "options argument must be an object but it is " + util.classString(options)
                ));
              }
            }
            limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
            return new MappingPromiseArray(promises, fn, limit, _filter).promise();
          }
          Promise2.prototype.map = function(fn, options) {
            return map(this, fn, options, null);
          };
          Promise2.map = function(promises, fn, options, _filter) {
            return map(promises, fn, options, _filter);
          };
        };
      }, { "./util": 36 }], 19: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          Promise2.method = function(fn) {
            if (typeof fn !== "function") {
              throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
            }
            return function() {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._pushContext();
              var value = tryCatch2(fn).apply(this, arguments);
              var promiseCreated = ret2._popContext();
              debug.checkForgottenReturns(
                value,
                promiseCreated,
                "Promise.method",
                ret2
              );
              ret2._resolveFromSyncValue(value);
              return ret2;
            };
          };
          Promise2.attempt = Promise2["try"] = function(fn) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value;
            if (arguments.length > 1) {
              debug.deprecated("calling Promise.try with more than 1 argument");
              var arg = arguments[1];
              var ctx = arguments[2];
              value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
            } else {
              value = tryCatch2(fn)();
            }
            var promiseCreated = ret2._popContext();
            debug.checkForgottenReturns(
              value,
              promiseCreated,
              "Promise.try",
              ret2
            );
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
          Promise2.prototype._resolveFromSyncValue = function(value) {
            if (value === util.errorObj) {
              this._rejectCallback(value.e, false);
            } else {
              this._resolveCallback(value, true);
            }
          };
        };
      }, { "./util": 36 }], 20: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util");
        var maybeWrapAsError2 = util.maybeWrapAsError;
        var errors = _dereq_2("./errors");
        var OperationalError = errors.OperationalError;
        var es52 = _dereq_2("./es5");
        function isUntypedError(obj2) {
          return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
        }
        var rErrorKey = /^(?:name|message|stack|cause)$/;
        function wrapAsOperationalError(obj2) {
          var ret2;
          if (isUntypedError(obj2)) {
            ret2 = new OperationalError(obj2);
            ret2.name = obj2.name;
            ret2.message = obj2.message;
            ret2.stack = obj2.stack;
            var keys = es52.keys(obj2);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!rErrorKey.test(key)) {
                ret2[key] = obj2[key];
              }
            }
            return ret2;
          }
          util.markAsOriginatingFromRejection(obj2);
          return obj2;
        }
        function nodebackForPromise(promise, multiArgs) {
          return function(err, value) {
            if (promise === null)
              return;
            if (err) {
              var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
              promise._attachExtraTrace(wrapped);
              promise._reject(wrapped);
            } else if (!multiArgs) {
              promise._fulfill(value);
            } else {
              var args = [].slice.call(arguments, 1);
              ;
              promise._fulfill(args);
            }
            promise = null;
          };
        }
        module2.exports = nodebackForPromise;
      }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util");
          var async = Promise2._async;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function spreadAdapter(val, nodeback) {
            var promise = this;
            if (!util.isArray(val))
              return successAdapter.call(promise, val, nodeback);
            var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function successAdapter(val, nodeback) {
            var promise = this;
            var receiver2 = promise._boundValue();
            var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver2, null) : tryCatch2(nodeback).call(receiver2, null, val);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function errorAdapter(reason, nodeback) {
            var promise = this;
            if (!reason) {
              var newReason = new Error(reason + "");
              newReason.cause = reason;
              reason = newReason;
            }
            var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
            if (typeof nodeback == "function") {
              var adapter = successAdapter;
              if (options !== void 0 && Object(options).spread) {
                adapter = spreadAdapter;
              }
              this._then(
                adapter,
                errorAdapter,
                void 0,
                this,
                nodeback
              );
            }
            return this;
          };
        };
      }, { "./util": 36 }], 22: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var makeSelfResolutionError = function() {
            return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
          };
          var reflectHandler2 = function() {
            return new Promise2.PromiseInspection(this._target());
          };
          var apiRejection = function(msg) {
            return Promise2.reject(new TypeError2(msg));
          };
          function Proxyable() {
          }
          var UNDEFINED_BINDING = {};
          var util = _dereq_2("./util");
          util.setReflectHandler(reflectHandler2);
          var getDomain = function() {
            var domain = process.domain;
            if (domain === void 0) {
              return null;
            }
            return domain;
          };
          var getContextDefault = function() {
            return null;
          };
          var getContextDomain = function() {
            return {
              domain: getDomain(),
              async: null
            };
          };
          var AsyncResource = util.isNode && util.nodeSupportsAsyncResource ? _dereq_2("async_hooks").AsyncResource : null;
          var getContextAsyncHooks = function() {
            return {
              domain: getDomain(),
              async: new AsyncResource("Bluebird::Promise")
            };
          };
          var getContext = util.isNode ? getContextDomain : getContextDefault;
          util.notEnumerableProp(Promise2, "_getContext", getContext);
          var enableAsyncHooks = function() {
            getContext = getContextAsyncHooks;
            util.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
          };
          var disableAsyncHooks = function() {
            getContext = getContextDomain;
            util.notEnumerableProp(Promise2, "_getContext", getContextDomain);
          };
          var es52 = _dereq_2("./es5");
          var Async = _dereq_2("./async");
          var async = new Async();
          es52.defineProperty(Promise2, "_async", { value: async });
          var errors = _dereq_2("./errors");
          var TypeError2 = Promise2.TypeError = errors.TypeError;
          Promise2.RangeError = errors.RangeError;
          var CancellationError = Promise2.CancellationError = errors.CancellationError;
          Promise2.TimeoutError = errors.TimeoutError;
          Promise2.OperationalError = errors.OperationalError;
          Promise2.RejectionError = errors.OperationalError;
          Promise2.AggregateError = errors.AggregateError;
          var INTERNAL = function() {
          };
          var APPLY = {};
          var NEXT_FILTER = {};
          var tryConvertToPromise = _dereq_2("./thenables")(Promise2, INTERNAL);
          var PromiseArray = _dereq_2("./promise_array")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection,
            Proxyable
          );
          var Context = _dereq_2("./context")(Promise2);
          var createContext = Context.create;
          var debug = _dereq_2("./debuggability")(
            Promise2,
            Context,
            enableAsyncHooks,
            disableAsyncHooks
          );
          var CapturedTrace = debug.CapturedTrace;
          var PassThroughHandlerContext = _dereq_2("./finally")(Promise2, tryConvertToPromise, NEXT_FILTER);
          var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
          var nodebackForPromise = _dereq_2("./nodeback");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          function check(self2, executor) {
            if (self2 == null || self2.constructor !== Promise2) {
              throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
            }
            if (typeof executor !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(executor));
            }
          }
          function Promise2(executor) {
            if (executor !== INTERNAL) {
              check(this, executor);
            }
            this._bitField = 0;
            this._fulfillmentHandler0 = void 0;
            this._rejectionHandler0 = void 0;
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._resolveFromExecutor(executor);
            this._promiseCreated();
            this._fireEvent("promiseCreated", this);
          }
          Promise2.prototype.toString = function() {
            return "[object Promise]";
          };
          Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
            var len = arguments.length;
            if (len > 1) {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                  catchInstances[j++] = item;
                } else {
                  return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
                }
              }
              catchInstances.length = j;
              fn = arguments[i];
              if (typeof fn !== "function") {
                throw new TypeError2("The last argument to .catch() must be a function, got " + util.toString(fn));
              }
              return this.then(void 0, catchFilter(catchInstances, fn, this));
            }
            return this.then(void 0, fn);
          };
          Promise2.prototype.reflect = function() {
            return this._then(
              reflectHandler2,
              reflectHandler2,
              void 0,
              this,
              void 0
            );
          };
          Promise2.prototype.then = function(didFulfill, didReject) {
            if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
              var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
              if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
              }
              this._warn(msg);
            }
            return this._then(didFulfill, didReject, void 0, void 0, void 0);
          };
          Promise2.prototype.done = function(didFulfill, didReject) {
            var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
            promise._setIsFinal();
          };
          Promise2.prototype.spread = function(fn) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            return this.all()._then(fn, void 0, void 0, APPLY, void 0);
          };
          Promise2.prototype.toJSON = function() {
            var ret2 = {
              isFulfilled: false,
              isRejected: false,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            if (this.isFulfilled()) {
              ret2.fulfillmentValue = this.value();
              ret2.isFulfilled = true;
            } else if (this.isRejected()) {
              ret2.rejectionReason = this.reason();
              ret2.isRejected = true;
            }
            return ret2;
          };
          Promise2.prototype.all = function() {
            if (arguments.length > 0) {
              this._warn(".all() was passed arguments but it does not take any");
            }
            return new PromiseArray(this).promise();
          };
          Promise2.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
          };
          Promise2.getNewLibraryCopy = module2.exports;
          Promise2.is = function(val) {
            return val instanceof Promise2;
          };
          Promise2.fromNode = Promise2.fromCallback = function(fn) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
            var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
            if (result === errorObj2) {
              ret2._rejectCallback(result.e, true);
            }
            if (!ret2._isFateSealed())
              ret2._setAsyncGuaranteed();
            return ret2;
          };
          Promise2.all = function(promises) {
            return new PromiseArray(promises).promise();
          };
          Promise2.cast = function(obj2) {
            var ret2 = tryConvertToPromise(obj2);
            if (!(ret2 instanceof Promise2)) {
              ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._setFulfilled();
              ret2._rejectionHandler0 = obj2;
            }
            return ret2;
          };
          Promise2.resolve = Promise2.fulfilled = Promise2.cast;
          Promise2.reject = Promise2.rejected = function(reason) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._rejectCallback(reason, true);
            return ret2;
          };
          Promise2.setScheduler = function(fn) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            return async.setScheduler(fn);
          };
          Promise2.prototype._then = function(didFulfill, didReject, _, receiver2, internalData) {
            var haveInternalData = internalData !== void 0;
            var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
            var target = this._target();
            var bitField = target._bitField;
            if (!haveInternalData) {
              promise._propagateFrom(this, 3);
              promise._captureStackTrace();
              if (receiver2 === void 0 && (this._bitField & 2097152) !== 0) {
                if (!((bitField & 50397184) === 0)) {
                  receiver2 = this._boundValue();
                } else {
                  receiver2 = target === this ? void 0 : this._boundTo;
                }
              }
              this._fireEvent("promiseChained", this, promise);
            }
            var context = getContext();
            if (!((bitField & 50397184) === 0)) {
              var handler, value, settler = target._settlePromiseCtx;
              if ((bitField & 33554432) !== 0) {
                value = target._rejectionHandler0;
                handler = didFulfill;
              } else if ((bitField & 16777216) !== 0) {
                value = target._fulfillmentHandler0;
                handler = didReject;
                target._unsetRejectionIsUnhandled();
              } else {
                settler = target._settlePromiseLateCancellationObserver;
                value = new CancellationError("late cancellation observer");
                target._attachExtraTrace(value);
                handler = didReject;
              }
              async.invoke(settler, target, {
                handler: util.contextBind(context, handler),
                promise,
                receiver: receiver2,
                value
              });
            } else {
              target._addCallbacks(
                didFulfill,
                didReject,
                promise,
                receiver2,
                context
              );
            }
            return promise;
          };
          Promise2.prototype._length = function() {
            return this._bitField & 65535;
          };
          Promise2.prototype._isFateSealed = function() {
            return (this._bitField & 117506048) !== 0;
          };
          Promise2.prototype._isFollowing = function() {
            return (this._bitField & 67108864) === 67108864;
          };
          Promise2.prototype._setLength = function(len) {
            this._bitField = this._bitField & -65536 | len & 65535;
          };
          Promise2.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 33554432;
            this._fireEvent("promiseFulfilled", this);
          };
          Promise2.prototype._setRejected = function() {
            this._bitField = this._bitField | 16777216;
            this._fireEvent("promiseRejected", this);
          };
          Promise2.prototype._setFollowing = function() {
            this._bitField = this._bitField | 67108864;
            this._fireEvent("promiseResolved", this);
          };
          Promise2.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 4194304;
          };
          Promise2.prototype._isFinal = function() {
            return (this._bitField & 4194304) > 0;
          };
          Promise2.prototype._unsetCancelled = function() {
            this._bitField = this._bitField & ~65536;
          };
          Promise2.prototype._setCancelled = function() {
            this._bitField = this._bitField | 65536;
            this._fireEvent("promiseCancelled", this);
          };
          Promise2.prototype._setWillBeCancelled = function() {
            this._bitField = this._bitField | 8388608;
          };
          Promise2.prototype._setAsyncGuaranteed = function() {
            if (async.hasCustomScheduler())
              return;
            var bitField = this._bitField;
            this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
          };
          Promise2.prototype._setNoAsyncGuarantee = function() {
            this._bitField = (this._bitField | 536870912) & ~134217728;
          };
          Promise2.prototype._receiverAt = function(index) {
            var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
            if (ret2 === UNDEFINED_BINDING) {
              return void 0;
            } else if (ret2 === void 0 && this._isBound()) {
              return this._boundValue();
            }
            return ret2;
          };
          Promise2.prototype._promiseAt = function(index) {
            return this[index * 4 - 4 + 2];
          };
          Promise2.prototype._fulfillmentHandlerAt = function(index) {
            return this[index * 4 - 4 + 0];
          };
          Promise2.prototype._rejectionHandlerAt = function(index) {
            return this[index * 4 - 4 + 1];
          };
          Promise2.prototype._boundValue = function() {
          };
          Promise2.prototype._migrateCallback0 = function(follower) {
            var bitField = follower._bitField;
            var fulfill = follower._fulfillmentHandler0;
            var reject = follower._rejectionHandler0;
            var promise = follower._promise0;
            var receiver2 = follower._receiverAt(0);
            if (receiver2 === void 0)
              receiver2 = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject, promise, receiver2, null);
          };
          Promise2.prototype._migrateCallbackAt = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index);
            var reject = follower._rejectionHandlerAt(index);
            var promise = follower._promiseAt(index);
            var receiver2 = follower._receiverAt(index);
            if (receiver2 === void 0)
              receiver2 = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject, promise, receiver2, null);
          };
          Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver2, context) {
            var index = this._length();
            if (index >= 65535 - 4) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promise;
              this._receiver0 = receiver2;
              if (typeof fulfill === "function") {
                this._fulfillmentHandler0 = util.contextBind(context, fulfill);
              }
              if (typeof reject === "function") {
                this._rejectionHandler0 = util.contextBind(context, reject);
              }
            } else {
              var base = index * 4 - 4;
              this[base + 2] = promise;
              this[base + 3] = receiver2;
              if (typeof fulfill === "function") {
                this[base + 0] = util.contextBind(context, fulfill);
              }
              if (typeof reject === "function") {
                this[base + 1] = util.contextBind(context, reject);
              }
            }
            this._setLength(index + 1);
            return index;
          };
          Promise2.prototype._proxy = function(proxyable, arg) {
            this._addCallbacks(void 0, void 0, arg, proxyable, null);
          };
          Promise2.prototype._resolveCallback = function(value, shouldBind) {
            if ((this._bitField & 117506048) !== 0)
              return;
            if (value === this)
              return this._rejectCallback(makeSelfResolutionError(), false);
            var maybePromise = tryConvertToPromise(value, this);
            if (!(maybePromise instanceof Promise2))
              return this._fulfill(value);
            if (shouldBind)
              this._propagateFrom(maybePromise, 2);
            var promise = maybePromise._target();
            if (promise === this) {
              this._reject(makeSelfResolutionError());
              return;
            }
            var bitField = promise._bitField;
            if ((bitField & 50397184) === 0) {
              var len = this._length();
              if (len > 0)
                promise._migrateCallback0(this);
              for (var i = 1; i < len; ++i) {
                promise._migrateCallbackAt(this, i);
              }
              this._setFollowing();
              this._setLength(0);
              this._setFollowee(maybePromise);
            } else if ((bitField & 33554432) !== 0) {
              this._fulfill(promise._value());
            } else if ((bitField & 16777216) !== 0) {
              this._reject(promise._reason());
            } else {
              var reason = new CancellationError("late cancellation observer");
              promise._attachExtraTrace(reason);
              this._reject(reason);
            }
          };
          Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
            var trace = util.ensureErrorObject(reason);
            var hasStack = trace === reason;
            if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
              var message = "a promise was rejected with a non-error: " + util.classString(reason);
              this._warn(message, true);
            }
            this._attachExtraTrace(trace, synchronous ? hasStack : false);
            this._reject(reason);
          };
          Promise2.prototype._resolveFromExecutor = function(executor) {
            if (executor === INTERNAL)
              return;
            var promise = this;
            this._captureStackTrace();
            this._pushContext();
            var synchronous = true;
            var r = this._execute(executor, function(value) {
              promise._resolveCallback(value);
            }, function(reason) {
              promise._rejectCallback(reason, synchronous);
            });
            synchronous = false;
            this._popContext();
            if (r !== void 0) {
              promise._rejectCallback(r, true);
            }
          };
          Promise2.prototype._settlePromiseFromHandler = function(handler, receiver2, value, promise) {
            var bitField = promise._bitField;
            if ((bitField & 65536) !== 0)
              return;
            promise._pushContext();
            var x;
            if (receiver2 === APPLY) {
              if (!value || typeof value.length !== "number") {
                x = errorObj2;
                x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
              } else {
                x = tryCatch2(handler).apply(this._boundValue(), value);
              }
            } else {
              x = tryCatch2(handler).call(receiver2, value);
            }
            var promiseCreated = promise._popContext();
            bitField = promise._bitField;
            if ((bitField & 65536) !== 0)
              return;
            if (x === NEXT_FILTER) {
              promise._reject(value);
            } else if (x === errorObj2) {
              promise._rejectCallback(x.e, false);
            } else {
              debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
              promise._resolveCallback(x);
            }
          };
          Promise2.prototype._target = function() {
            var ret2 = this;
            while (ret2._isFollowing())
              ret2 = ret2._followee();
            return ret2;
          };
          Promise2.prototype._followee = function() {
            return this._rejectionHandler0;
          };
          Promise2.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
          };
          Promise2.prototype._settlePromise = function(promise, handler, receiver2, value) {
            var isPromise = promise instanceof Promise2;
            var bitField = this._bitField;
            var asyncGuaranteed = (bitField & 134217728) !== 0;
            if ((bitField & 65536) !== 0) {
              if (isPromise)
                promise._invokeInternalOnCancel();
              if (receiver2 instanceof PassThroughHandlerContext && receiver2.isFinallyHandler()) {
                receiver2.cancelPromise = promise;
                if (tryCatch2(handler).call(receiver2, value) === errorObj2) {
                  promise._reject(errorObj2.e);
                }
              } else if (handler === reflectHandler2) {
                promise._fulfill(reflectHandler2.call(receiver2));
              } else if (receiver2 instanceof Proxyable) {
                receiver2._promiseCancelled(promise);
              } else if (isPromise || promise instanceof PromiseArray) {
                promise._cancel();
              } else {
                receiver2.cancel();
              }
            } else if (typeof handler === "function") {
              if (!isPromise) {
                handler.call(receiver2, value, promise);
              } else {
                if (asyncGuaranteed)
                  promise._setAsyncGuaranteed();
                this._settlePromiseFromHandler(handler, receiver2, value, promise);
              }
            } else if (receiver2 instanceof Proxyable) {
              if (!receiver2._isResolved()) {
                if ((bitField & 33554432) !== 0) {
                  receiver2._promiseFulfilled(value, promise);
                } else {
                  receiver2._promiseRejected(value, promise);
                }
              }
            } else if (isPromise) {
              if (asyncGuaranteed)
                promise._setAsyncGuaranteed();
              if ((bitField & 33554432) !== 0) {
                promise._fulfill(value);
              } else {
                promise._reject(value);
              }
            }
          };
          Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
            var handler = ctx.handler;
            var promise = ctx.promise;
            var receiver2 = ctx.receiver;
            var value = ctx.value;
            if (typeof handler === "function") {
              if (!(promise instanceof Promise2)) {
                handler.call(receiver2, value, promise);
              } else {
                this._settlePromiseFromHandler(handler, receiver2, value, promise);
              }
            } else if (promise instanceof Promise2) {
              promise._reject(value);
            }
          };
          Promise2.prototype._settlePromiseCtx = function(ctx) {
            this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
          };
          Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
            var promise = this._promise0;
            var receiver2 = this._receiverAt(0);
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._settlePromise(promise, handler, receiver2, value);
          };
          Promise2.prototype._clearCallbackDataAtIndex = function(index) {
            var base = index * 4 - 4;
            this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
          };
          Promise2.prototype._fulfill = function(value) {
            var bitField = this._bitField;
            if ((bitField & 117506048) >>> 16)
              return;
            if (value === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._reject(err);
            }
            this._setFulfilled();
            this._rejectionHandler0 = value;
            if ((bitField & 65535) > 0) {
              if ((bitField & 134217728) !== 0) {
                this._settlePromises();
              } else {
                async.settlePromises(this);
              }
              this._dereferenceTrace();
            }
          };
          Promise2.prototype._reject = function(reason) {
            var bitField = this._bitField;
            if ((bitField & 117506048) >>> 16)
              return;
            this._setRejected();
            this._fulfillmentHandler0 = reason;
            if (this._isFinal()) {
              return async.fatalError(reason, util.isNode);
            }
            if ((bitField & 65535) > 0) {
              async.settlePromises(this);
            } else {
              this._ensurePossibleRejectionHandled();
            }
          };
          Promise2.prototype._fulfillPromises = function(len, value) {
            for (var i = 1; i < len; i++) {
              var handler = this._fulfillmentHandlerAt(i);
              var promise = this._promiseAt(i);
              var receiver2 = this._receiverAt(i);
              this._clearCallbackDataAtIndex(i);
              this._settlePromise(promise, handler, receiver2, value);
            }
          };
          Promise2.prototype._rejectPromises = function(len, reason) {
            for (var i = 1; i < len; i++) {
              var handler = this._rejectionHandlerAt(i);
              var promise = this._promiseAt(i);
              var receiver2 = this._receiverAt(i);
              this._clearCallbackDataAtIndex(i);
              this._settlePromise(promise, handler, receiver2, reason);
            }
          };
          Promise2.prototype._settlePromises = function() {
            var bitField = this._bitField;
            var len = bitField & 65535;
            if (len > 0) {
              if ((bitField & 16842752) !== 0) {
                var reason = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, reason, bitField);
                this._rejectPromises(len, reason);
              } else {
                var value = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                this._fulfillPromises(len, value);
              }
              this._setLength(0);
            }
            this._clearCancellationData();
          };
          Promise2.prototype._settledValue = function() {
            var bitField = this._bitField;
            if ((bitField & 33554432) !== 0) {
              return this._rejectionHandler0;
            } else if ((bitField & 16777216) !== 0) {
              return this._fulfillmentHandler0;
            }
          };
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            es52.defineProperty(Promise2.prototype, Symbol.toStringTag, {
              get: function() {
                return "Object";
              }
            });
          }
          function deferResolve(v) {
            this.promise._resolveCallback(v);
          }
          function deferReject(v) {
            this.promise._rejectCallback(v, false);
          }
          Promise2.defer = Promise2.pending = function() {
            debug.deprecated("Promise.defer", "new Promise");
            var promise = new Promise2(INTERNAL);
            return {
              promise,
              resolve: deferResolve,
              reject: deferReject
            };
          };
          util.notEnumerableProp(
            Promise2,
            "_makeSelfResolutionError",
            makeSelfResolutionError
          );
          _dereq_2("./method")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection,
            debug
          );
          _dereq_2("./bind")(Promise2, INTERNAL, tryConvertToPromise, debug);
          _dereq_2("./cancel")(Promise2, PromiseArray, apiRejection, debug);
          _dereq_2("./direct_resolve")(Promise2);
          _dereq_2("./synchronous_inspection")(Promise2);
          _dereq_2("./join")(
            Promise2,
            PromiseArray,
            tryConvertToPromise,
            INTERNAL,
            async
          );
          Promise2.Promise = Promise2;
          Promise2.version = "3.7.2";
          _dereq_2("./call_get.js")(Promise2);
          _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
          _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
          _dereq_2("./nodeify.js")(Promise2);
          _dereq_2("./promisify.js")(Promise2, INTERNAL);
          _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
          _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
          _dereq_2("./settle.js")(Promise2, PromiseArray, debug);
          _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
          _dereq_2("./timers.js")(Promise2, INTERNAL, debug);
          _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
          _dereq_2("./any.js")(Promise2);
          _dereq_2("./each.js")(Promise2, INTERNAL);
          _dereq_2("./filter.js")(Promise2, INTERNAL);
          util.toFastProperties(Promise2);
          util.toFastProperties(Promise2.prototype);
          function fillTypes(value) {
            var p = new Promise2(INTERNAL);
            p._fulfillmentHandler0 = value;
            p._rejectionHandler0 = value;
            p._promise0 = value;
            p._receiver0 = value;
          }
          fillTypes({ a: 1 });
          fillTypes({ b: 2 });
          fillTypes({ c: 3 });
          fillTypes(1);
          fillTypes(function() {
          });
          fillTypes(void 0);
          fillTypes(false);
          fillTypes(new Promise2(INTERNAL));
          debug.setBounds(Async.firstLineError, util.lastLineError);
          return Promise2;
        };
      }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36, "async_hooks": void 0 }], 23: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
          var util = _dereq_2("./util");
          var isArray = util.isArray;
          function toResolutionValue(val) {
            switch (val) {
              case -2:
                return [];
              case -3:
                return {};
              case -6:
                return /* @__PURE__ */ new Map();
            }
          }
          function PromiseArray(values) {
            var promise = this._promise = new Promise2(INTERNAL);
            if (values instanceof Promise2) {
              promise._propagateFrom(values, 3);
              values.suppressUnhandledRejections();
            }
            promise._setOnCancel(this);
            this._values = values;
            this._length = 0;
            this._totalResolved = 0;
            this._init(void 0, -2);
          }
          util.inherits(PromiseArray, Proxyable);
          PromiseArray.prototype.length = function() {
            return this._length;
          };
          PromiseArray.prototype.promise = function() {
            return this._promise;
          };
          PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
            var values = tryConvertToPromise(this._values, this._promise);
            if (values instanceof Promise2) {
              values = values._target();
              var bitField = values._bitField;
              ;
              this._values = values;
              if ((bitField & 50397184) === 0) {
                this._promise._setAsyncGuaranteed();
                return values._then(
                  init,
                  this._reject,
                  void 0,
                  this,
                  resolveValueIfEmpty
                );
              } else if ((bitField & 33554432) !== 0) {
                values = values._value();
              } else if ((bitField & 16777216) !== 0) {
                return this._reject(values._reason());
              } else {
                return this._cancel();
              }
            }
            values = util.asArray(values);
            if (values === null) {
              var err = apiRejection(
                "expecting an array or an iterable object but got " + util.classString(values)
              ).reason();
              this._promise._rejectCallback(err, false);
              return;
            }
            if (values.length === 0) {
              if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
              } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
              }
              return;
            }
            this._iterate(values);
          };
          PromiseArray.prototype._iterate = function(values) {
            var len = this.getActualLength(values.length);
            this._length = len;
            this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            var result = this._promise;
            var isResolved = false;
            var bitField = null;
            for (var i = 0; i < len; ++i) {
              var maybePromise = tryConvertToPromise(values[i], result);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                bitField = maybePromise._bitField;
              } else {
                bitField = null;
              }
              if (isResolved) {
                if (bitField !== null) {
                  maybePromise.suppressUnhandledRejections();
                }
              } else if (bitField !== null) {
                if ((bitField & 50397184) === 0) {
                  maybePromise._proxy(this, i);
                  this._values[i] = maybePromise;
                } else if ((bitField & 33554432) !== 0) {
                  isResolved = this._promiseFulfilled(maybePromise._value(), i);
                } else if ((bitField & 16777216) !== 0) {
                  isResolved = this._promiseRejected(maybePromise._reason(), i);
                } else {
                  isResolved = this._promiseCancelled(i);
                }
              } else {
                isResolved = this._promiseFulfilled(maybePromise, i);
              }
            }
            if (!isResolved)
              result._setAsyncGuaranteed();
          };
          PromiseArray.prototype._isResolved = function() {
            return this._values === null;
          };
          PromiseArray.prototype._resolve = function(value) {
            this._values = null;
            this._promise._fulfill(value);
          };
          PromiseArray.prototype._cancel = function() {
            if (this._isResolved() || !this._promise._isCancellable())
              return;
            this._values = null;
            this._promise._cancel();
          };
          PromiseArray.prototype._reject = function(reason) {
            this._values = null;
            this._promise._rejectCallback(reason, false);
          };
          PromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
              return true;
            }
            return false;
          };
          PromiseArray.prototype._promiseCancelled = function() {
            this._cancel();
            return true;
          };
          PromiseArray.prototype._promiseRejected = function(reason) {
            this._totalResolved++;
            this._reject(reason);
            return true;
          };
          PromiseArray.prototype._resultCancelled = function() {
            if (this._isResolved())
              return;
            var values = this._values;
            this._cancel();
            if (values instanceof Promise2) {
              values.cancel();
            } else {
              for (var i = 0; i < values.length; ++i) {
                if (values[i] instanceof Promise2) {
                  values[i].cancel();
                }
              }
            }
          };
          PromiseArray.prototype.shouldCopyValues = function() {
            return true;
          };
          PromiseArray.prototype.getActualLength = function(len) {
            return len;
          };
          return PromiseArray;
        };
      }, { "./util": 36 }], 24: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var THIS = {};
          var util = _dereq_2("./util");
          var nodebackForPromise = _dereq_2("./nodeback");
          var withAppended2 = util.withAppended;
          var maybeWrapAsError2 = util.maybeWrapAsError;
          var canEvaluate2 = util.canEvaluate;
          var TypeError2 = _dereq_2("./errors").TypeError;
          var defaultSuffix = "Async";
          var defaultPromisified = { __isPromisified__: true };
          var noCopyProps = [
            "arity",
            "length",
            "name",
            "arguments",
            "caller",
            "callee",
            "prototype",
            "__isPromisified__"
          ];
          var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
          var defaultFilter = function(name) {
            return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
          };
          function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
          }
          function isPromisified(fn) {
            try {
              return fn.__isPromisified__ === true;
            } catch (e) {
              return false;
            }
          }
          function hasPromisified(obj2, key, suffix) {
            var val = util.getDataPropertyOrDefault(
              obj2,
              key + suffix,
              defaultPromisified
            );
            return val ? isPromisified(val) : false;
          }
          function checkValid(ret2, suffix, suffixRegexp) {
            for (var i = 0; i < ret2.length; i += 2) {
              var key = ret2[i];
              if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret2.length; j += 2) {
                  if (ret2[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                  }
                }
              }
            }
          }
          function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
            var keys = util.inheritedDataKeys(obj2);
            var ret2 = [];
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              var value = obj2[key];
              var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
              if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
                ret2.push(key, value);
              }
            }
            checkValid(ret2, suffix, suffixRegexp);
            return ret2;
          }
          var escapeIdentRegex = function(str) {
            return str.replace(/([$])/, "\\$");
          };
          var makeNodePromisifiedEval;
          if (false) {
            var switchCaseArgumentOrder = function(likelyArgumentCount) {
              var ret2 = [likelyArgumentCount];
              var min = Math.max(0, likelyArgumentCount - 1 - 3);
              for (var i = likelyArgumentCount - 1; i >= min; --i) {
                ret2.push(i);
              }
              for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret2.push(i);
              }
              return ret2;
            };
            var argumentSequence = function(argumentCount) {
              return util.filledRange(argumentCount, "_arg", "");
            };
            var parameterDeclaration = function(parameterCount2) {
              return util.filledRange(
                Math.max(parameterCount2, 3),
                "_arg",
                ""
              );
            };
            var parameterCount = function(fn) {
              if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
              }
              return 0;
            };
            makeNodePromisifiedEval = function(callback, receiver2, originalName, fn, _, multiArgs) {
              var newParameterCount = Math.max(0, parameterCount(fn) - 1);
              var argumentOrder = switchCaseArgumentOrder(newParameterCount);
              var shouldProxyThis = typeof callback === "string" || receiver2 === THIS;
              function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret2;
                if (shouldProxyThis) {
                  ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                  ret2 = receiver2 === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret2.replace("{{args}}", args).replace(", ", comma);
              }
              function generateArgumentSwitchCase() {
                var ret2 = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                  ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret2;
              }
              var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
              var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
              body = body.replace("Parameters", parameterDeclaration(newParameterCount));
              return new Function(
                "Promise",
                "fn",
                "receiver",
                "withAppended",
                "maybeWrapAsError",
                "nodebackForPromise",
                "tryCatch",
                "errorObj",
                "notEnumerableProp",
                "INTERNAL",
                body
              )(
                Promise2,
                fn,
                receiver2,
                withAppended2,
                maybeWrapAsError2,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
              );
            };
          }
          function makeNodePromisifiedClosure(callback, receiver2, _, fn, __, multiArgs) {
            var defaultThis = function() {
              return this;
            }();
            var method = callback;
            if (typeof method === "string") {
              callback = fn;
            }
            function promisified() {
              var _receiver = receiver2;
              if (receiver2 === THIS)
                _receiver = this;
              var promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
              var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
              var fn2 = nodebackForPromise(promise, multiArgs);
              try {
                cb.apply(_receiver, withAppended2(arguments, fn2));
              } catch (e) {
                promise._rejectCallback(maybeWrapAsError2(e), true, true);
              }
              if (!promise._isFateSealed())
                promise._setAsyncGuaranteed();
              return promise;
            }
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            return promisified;
          }
          var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
          function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
            var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
            var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
            for (var i = 0, len = methods.length; i < len; i += 2) {
              var key = methods[i];
              var fn = methods[i + 1];
              var promisifiedKey = key + suffix;
              if (promisifier === makeNodePromisified) {
                obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
              } else {
                var promisified = promisifier(fn, function() {
                  return makeNodePromisified(
                    key,
                    THIS,
                    key,
                    fn,
                    suffix,
                    multiArgs
                  );
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj2[promisifiedKey] = promisified;
              }
            }
            util.toFastProperties(obj2);
            return obj2;
          }
          function promisify(callback, receiver2, multiArgs) {
            return makeNodePromisified(
              callback,
              receiver2,
              void 0,
              callback,
              null,
              multiArgs
            );
          }
          Promise2.promisify = function(fn, options) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            if (isPromisified(fn)) {
              return fn;
            }
            options = Object(options);
            var receiver2 = options.context === void 0 ? THIS : options.context;
            var multiArgs = !!options.multiArgs;
            var ret2 = promisify(fn, receiver2, multiArgs);
            util.copyDescriptors(fn, ret2, propsFilter);
            return ret2;
          };
          Promise2.promisifyAll = function(target, options) {
            if (typeof target !== "function" && typeof target !== "object") {
              throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            options = Object(options);
            var multiArgs = !!options.multiArgs;
            var suffix = options.suffix;
            if (typeof suffix !== "string")
              suffix = defaultSuffix;
            var filter = options.filter;
            if (typeof filter !== "function")
              filter = defaultFilter;
            var promisifier = options.promisifier;
            if (typeof promisifier !== "function")
              promisifier = makeNodePromisified;
            if (!util.isIdentifier(suffix)) {
              throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
            }
            var keys = util.inheritedDataKeys(target);
            for (var i = 0; i < keys.length; ++i) {
              var value = target[keys[i]];
              if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(
                  value.prototype,
                  suffix,
                  filter,
                  promisifier,
                  multiArgs
                );
                promisifyAll(value, suffix, filter, promisifier, multiArgs);
              }
            }
            return promisifyAll(target, suffix, filter, promisifier, multiArgs);
          };
        };
      }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util");
          var isObject2 = util.isObject;
          var es52 = _dereq_2("./es5");
          var Es6Map;
          if (typeof Map === "function")
            Es6Map = Map;
          var mapToEntries = function() {
            var index = 0;
            var size = 0;
            function extractEntry(value, key) {
              this[index] = value;
              this[index + size] = key;
              index++;
            }
            return function mapToEntries2(map) {
              size = map.size;
              index = 0;
              var ret2 = new Array(map.size * 2);
              map.forEach(extractEntry, ret2);
              return ret2;
            };
          }();
          var entriesToMap = function(entries) {
            var ret2 = new Es6Map();
            var length = entries.length / 2 | 0;
            for (var i = 0; i < length; ++i) {
              var key = entries[length + i];
              var value = entries[i];
              ret2.set(key, value);
            }
            return ret2;
          };
          function PropertiesPromiseArray(obj2) {
            var isMap = false;
            var entries;
            if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
              entries = mapToEntries(obj2);
              isMap = true;
            } else {
              var keys = es52.keys(obj2);
              var len = keys.length;
              entries = new Array(len * 2);
              for (var i = 0; i < len; ++i) {
                var key = keys[i];
                entries[i] = obj2[key];
                entries[i + len] = key;
              }
            }
            this.constructor$(entries);
            this._isMap = isMap;
            this._init$(void 0, isMap ? -6 : -3);
          }
          util.inherits(PropertiesPromiseArray, PromiseArray);
          PropertiesPromiseArray.prototype._init = function() {
          };
          PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              var val;
              if (this._isMap) {
                val = entriesToMap(this._values);
              } else {
                val = {};
                var keyOffset = this.length();
                for (var i = 0, len = this.length(); i < len; ++i) {
                  val[this._values[i + keyOffset]] = this._values[i];
                }
              }
              this._resolve(val);
              return true;
            }
            return false;
          };
          PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
          };
          function props(promises) {
            var ret2;
            var castValue = tryConvertToPromise(promises);
            if (!isObject2(castValue)) {
              return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
            } else if (castValue instanceof Promise2) {
              ret2 = castValue._then(
                Promise2.props,
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else {
              ret2 = new PropertiesPromiseArray(castValue).promise();
            }
            if (castValue instanceof Promise2) {
              ret2._propagateFrom(castValue, 2);
            }
            return ret2;
          }
          Promise2.prototype.props = function() {
            return props(this);
          };
          Promise2.props = function(promises) {
            return props(promises);
          };
        };
      }, { "./es5": 13, "./util": 36 }], 26: [function(_dereq_2, module2, exports2) {
        "use strict";
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function Queue(capacity) {
          this._capacity = capacity;
          this._length = 0;
          this._front = 0;
        }
        Queue.prototype._willBeOverCapacity = function(size) {
          return this._capacity < size;
        };
        Queue.prototype._pushOne = function(arg) {
          var length = this.length();
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = arg;
          this._length = length + 1;
        };
        Queue.prototype.push = function(fn, receiver2, arg) {
          var length = this.length() + 3;
          if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver2);
            this._pushOne(arg);
            return;
          }
          var j = this._front + length - 3;
          this._checkCapacity(length);
          var wrapMask = this._capacity - 1;
          this[j + 0 & wrapMask] = fn;
          this[j + 1 & wrapMask] = receiver2;
          this[j + 2 & wrapMask] = arg;
          this._length = length;
        };
        Queue.prototype.shift = function() {
          var front = this._front, ret2 = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length--;
          return ret2;
        };
        Queue.prototype.length = function() {
          return this._length;
        };
        Queue.prototype._checkCapacity = function(size) {
          if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
          }
        };
        Queue.prototype._resizeTo = function(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          var moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        };
        module2.exports = Queue;
      }, {}], 27: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util");
          var raceLater = function(promise) {
            return promise.then(function(array) {
              return race(array, promise);
            });
          };
          function race(promises, parent) {
            var maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise2) {
              return raceLater(maybePromise);
            } else {
              promises = util.asArray(promises);
              if (promises === null)
                return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
            }
            var ret2 = new Promise2(INTERNAL);
            if (parent !== void 0) {
              ret2._propagateFrom(parent, 3);
            }
            var fulfill = ret2._fulfill;
            var reject = ret2._reject;
            for (var i = 0, len = promises.length; i < len; ++i) {
              var val = promises[i];
              if (val === void 0 && !(i in promises)) {
                continue;
              }
              Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
            }
            return ret2;
          }
          Promise2.race = function(promises) {
            return race(promises, void 0);
          };
          Promise2.prototype.race = function() {
            return race(this, void 0);
          };
        };
      }, { "./util": 36 }], 28: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          function ReductionPromiseArray(promises, fn, initialValue, _each) {
            this.constructor$(promises);
            var context = Promise2._getContext();
            this._fn = util.contextBind(context, fn);
            if (initialValue !== void 0) {
              initialValue = Promise2.resolve(initialValue);
              initialValue._attachCancellationCallback(this);
            }
            this._initialValue = initialValue;
            this._currentCancellable = null;
            if (_each === INTERNAL) {
              this._eachValues = Array(this._length);
            } else if (_each === 0) {
              this._eachValues = null;
            } else {
              this._eachValues = void 0;
            }
            this._promise._captureStackTrace();
            this._init$(void 0, -5);
          }
          util.inherits(ReductionPromiseArray, PromiseArray);
          ReductionPromiseArray.prototype._gotAccum = function(accum) {
            if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
              this._eachValues.push(accum);
            }
          };
          ReductionPromiseArray.prototype._eachComplete = function(value) {
            if (this._eachValues !== null) {
              this._eachValues.push(value);
            }
            return this._eachValues;
          };
          ReductionPromiseArray.prototype._init = function() {
          };
          ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
          };
          ReductionPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          ReductionPromiseArray.prototype._resolve = function(value) {
            this._promise._resolveCallback(value);
            this._values = null;
          };
          ReductionPromiseArray.prototype._resultCancelled = function(sender) {
            if (sender === this._initialValue)
              return this._cancel();
            if (this._isResolved())
              return;
            this._resultCancelled$();
            if (this._currentCancellable instanceof Promise2) {
              this._currentCancellable.cancel();
            }
            if (this._initialValue instanceof Promise2) {
              this._initialValue.cancel();
            }
          };
          ReductionPromiseArray.prototype._iterate = function(values) {
            this._values = values;
            var value;
            var i;
            var length = values.length;
            if (this._initialValue !== void 0) {
              value = this._initialValue;
              i = 0;
            } else {
              value = Promise2.resolve(values[0]);
              i = 1;
            }
            this._currentCancellable = value;
            for (var j = i; j < length; ++j) {
              var maybePromise = values[j];
              if (maybePromise instanceof Promise2) {
                maybePromise.suppressUnhandledRejections();
              }
            }
            if (!value.isRejected()) {
              for (; i < length; ++i) {
                var ctx = {
                  accum: null,
                  value: values[i],
                  index: i,
                  length,
                  array: this
                };
                value = value._then(gotAccum, void 0, void 0, ctx, void 0);
                if ((i & 127) === 0) {
                  value._setNoAsyncGuarantee();
                }
              }
            }
            if (this._eachValues !== void 0) {
              value = value._then(this._eachComplete, void 0, void 0, this, void 0);
            }
            value._then(completed, completed, void 0, value, this);
          };
          Promise2.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
          };
          Promise2.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
          };
          function completed(valueOrReason, array) {
            if (this.isFulfilled()) {
              array._resolve(valueOrReason);
            } else {
              array._reject(valueOrReason);
            }
          }
          function reduce(promises, fn, initialValue, _each) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
            return array.promise();
          }
          function gotAccum(accum) {
            this.accum = accum;
            this.array._gotAccum(accum);
            var value = tryConvertToPromise(this.value, this.array._promise);
            if (value instanceof Promise2) {
              this.array._currentCancellable = value;
              return value._then(gotValue, void 0, void 0, this, void 0);
            } else {
              return gotValue.call(this, value);
            }
          }
          function gotValue(value) {
            var array = this.array;
            var promise = array._promise;
            var fn = tryCatch2(array._fn);
            promise._pushContext();
            var ret2;
            if (array._eachValues !== void 0) {
              ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
            } else {
              ret2 = fn.call(
                promise._boundValue(),
                this.accum,
                value,
                this.index,
                this.length
              );
            }
            if (ret2 instanceof Promise2) {
              array._currentCancellable = ret2;
            }
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(
              ret2,
              promiseCreated,
              array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
              promise
            );
            return ret2;
          }
        };
      }, { "./util": 36 }], 29: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util");
        var schedule;
        var noAsyncScheduler = function() {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        };
        var NativePromise = util.getNativePromise();
        if (util.isNode && typeof MutationObserver === "undefined") {
          var GlobalSetImmediate = globalThis.setImmediate;
          var ProcessNextTick = process.nextTick;
          schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(globalThis, fn);
          } : function(fn) {
            ProcessNextTick.call(process, fn);
          };
        } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
          var nativePromise = NativePromise.resolve();
          schedule = function(fn) {
            nativePromise.then(fn);
          };
        } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement) {
          schedule = function() {
            var div = document.createElement("div");
            var opts = { attributes: true };
            var toggleScheduled = false;
            var div2 = document.createElement("div");
            var o2 = new MutationObserver(function() {
              div.classList.toggle("foo");
              toggleScheduled = false;
            });
            o2.observe(div2, opts);
            var scheduleToggle = function() {
              if (toggleScheduled)
                return;
              toggleScheduled = true;
              div2.classList.toggle("foo");
            };
            return function schedule2(fn) {
              var o = new MutationObserver(function() {
                o.disconnect();
                fn();
              });
              o.observe(div, opts);
              scheduleToggle();
            };
          }();
        } else if (typeof setImmediate !== "undefined") {
          schedule = function(fn) {
            setImmediate(fn);
          };
        } else if (typeof setTimeout !== "undefined") {
          schedule = function(fn) {
            setTimeout(fn, 0);
          };
        } else {
          schedule = noAsyncScheduler;
        }
        module2.exports = schedule;
      }, { "./util": 36 }], 30: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, debug) {
          var PromiseInspection = Promise2.PromiseInspection;
          var util = _dereq_2("./util");
          function SettledPromiseArray(values) {
            this.constructor$(values);
          }
          util.inherits(SettledPromiseArray, PromiseArray);
          SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            this._values[index] = inspection;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
              return true;
            }
            return false;
          };
          SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 33554432;
            ret2._settledValueField = value;
            return this._promiseResolved(index, ret2);
          };
          SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 16777216;
            ret2._settledValueField = reason;
            return this._promiseResolved(index, ret2);
          };
          Promise2.settle = function(promises) {
            debug.deprecated(".settle()", ".reflect()");
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.allSettled = function(promises) {
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.prototype.settle = function() {
            return Promise2.settle(this);
          };
        };
      }, { "./util": 36 }], 31: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection) {
          var util = _dereq_2("./util");
          var RangeError2 = _dereq_2("./errors").RangeError;
          var AggregateError = _dereq_2("./errors").AggregateError;
          var isArray = util.isArray;
          var CANCELLATION = {};
          function SomePromiseArray(values) {
            this.constructor$(values);
            this._howMany = 0;
            this._unwrap = false;
            this._initialized = false;
          }
          util.inherits(SomePromiseArray, PromiseArray);
          SomePromiseArray.prototype._init = function() {
            if (!this._initialized) {
              return;
            }
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var isArrayResolved = isArray(this._values);
            if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
              this._reject(this._getRangeError(this.length()));
            }
          };
          SomePromiseArray.prototype.init = function() {
            this._initialized = true;
            this._init();
          };
          SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = true;
          };
          SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
          };
          SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
          };
          SomePromiseArray.prototype._promiseFulfilled = function(value) {
            this._addFulfilled(value);
            if (this._fulfilled() === this.howMany()) {
              this._values.length = this.howMany();
              if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
              } else {
                this._resolve(this._values);
              }
              return true;
            }
            return false;
          };
          SomePromiseArray.prototype._promiseRejected = function(reason) {
            this._addRejected(reason);
            return this._checkOutcome();
          };
          SomePromiseArray.prototype._promiseCancelled = function() {
            if (this._values instanceof Promise2 || this._values == null) {
              return this._cancel();
            }
            this._addRejected(CANCELLATION);
            return this._checkOutcome();
          };
          SomePromiseArray.prototype._checkOutcome = function() {
            if (this.howMany() > this._canPossiblyFulfill()) {
              var e = new AggregateError();
              for (var i = this.length(); i < this._values.length; ++i) {
                if (this._values[i] !== CANCELLATION) {
                  e.push(this._values[i]);
                }
              }
              if (e.length > 0) {
                this._reject(e);
              } else {
                this._cancel();
              }
              return true;
            }
            return false;
          };
          SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
          };
          SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
          };
          SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
          };
          SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
          };
          SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
          };
          SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError2(message);
          };
          SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
          };
          function some(promises, howMany) {
            if ((howMany | 0) !== howMany || howMany < 0) {
              return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
            }
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(howMany);
            ret2.init();
            return promise;
          }
          Promise2.some = function(promises, howMany) {
            return some(promises, howMany);
          };
          Promise2.prototype.some = function(howMany) {
            return some(this, howMany);
          };
          Promise2._SomePromiseArray = SomePromiseArray;
        };
      }, { "./errors": 12, "./util": 36 }], 32: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function PromiseInspection(promise) {
            if (promise !== void 0) {
              promise = promise._target();
              this._bitField = promise._bitField;
              this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
            } else {
              this._bitField = 0;
              this._settledValueField = void 0;
            }
          }
          PromiseInspection.prototype._settledValue = function() {
            return this._settledValueField;
          };
          var value = PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
            }
            return this._settledValue();
          };
          var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
            }
            return this._settledValue();
          };
          var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
            return (this._bitField & 33554432) !== 0;
          };
          var isRejected = PromiseInspection.prototype.isRejected = function() {
            return (this._bitField & 16777216) !== 0;
          };
          var isPending = PromiseInspection.prototype.isPending = function() {
            return (this._bitField & 50397184) === 0;
          };
          var isResolved = PromiseInspection.prototype.isResolved = function() {
            return (this._bitField & 50331648) !== 0;
          };
          PromiseInspection.prototype.isCancelled = function() {
            return (this._bitField & 8454144) !== 0;
          };
          Promise2.prototype.__isCancelled = function() {
            return (this._bitField & 65536) === 65536;
          };
          Promise2.prototype._isCancelled = function() {
            return this._target().__isCancelled();
          };
          Promise2.prototype.isCancelled = function() {
            return (this._target()._bitField & 8454144) !== 0;
          };
          Promise2.prototype.isPending = function() {
            return isPending.call(this._target());
          };
          Promise2.prototype.isRejected = function() {
            return isRejected.call(this._target());
          };
          Promise2.prototype.isFulfilled = function() {
            return isFulfilled.call(this._target());
          };
          Promise2.prototype.isResolved = function() {
            return isResolved.call(this._target());
          };
          Promise2.prototype.value = function() {
            return value.call(this._target());
          };
          Promise2.prototype.reason = function() {
            var target = this._target();
            target._unsetRejectionIsUnhandled();
            return reason.call(target);
          };
          Promise2.prototype._value = function() {
            return this._settledValue();
          };
          Promise2.prototype._reason = function() {
            this._unsetRejectionIsUnhandled();
            return this._settledValue();
          };
          Promise2.PromiseInspection = PromiseInspection;
        };
      }, {}], 33: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util");
          var errorObj2 = util.errorObj;
          var isObject2 = util.isObject;
          function tryConvertToPromise(obj2, context) {
            if (isObject2(obj2)) {
              if (obj2 instanceof Promise2)
                return obj2;
              var then = getThen(obj2);
              if (then === errorObj2) {
                if (context)
                  context._pushContext();
                var ret2 = Promise2.reject(then.e);
                if (context)
                  context._popContext();
                return ret2;
              } else if (typeof then === "function") {
                if (isAnyBluebirdPromise(obj2)) {
                  var ret2 = new Promise2(INTERNAL);
                  obj2._then(
                    ret2._fulfill,
                    ret2._reject,
                    void 0,
                    ret2,
                    null
                  );
                  return ret2;
                }
                return doThenable(obj2, then, context);
              }
            }
            return obj2;
          }
          function doGetThen(obj2) {
            return obj2.then;
          }
          function getThen(obj2) {
            try {
              return doGetThen(obj2);
            } catch (e) {
              errorObj2.e = e;
              return errorObj2;
            }
          }
          var hasProp = {}.hasOwnProperty;
          function isAnyBluebirdPromise(obj2) {
            try {
              return hasProp.call(obj2, "_promise0");
            } catch (e) {
              return false;
            }
          }
          function doThenable(x, then, context) {
            var promise = new Promise2(INTERNAL);
            var ret2 = promise;
            if (context)
              context._pushContext();
            promise._captureStackTrace();
            if (context)
              context._popContext();
            var synchronous = true;
            var result = util.tryCatch(then).call(x, resolve, reject);
            synchronous = false;
            if (promise && result === errorObj2) {
              promise._rejectCallback(result.e, true, true);
              promise = null;
            }
            function resolve(value) {
              if (!promise)
                return;
              promise._resolveCallback(value);
              promise = null;
            }
            function reject(reason) {
              if (!promise)
                return;
              promise._rejectCallback(reason, synchronous, true);
              promise = null;
            }
            return ret2;
          }
          return tryConvertToPromise;
        };
      }, { "./util": 36 }], 34: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var TimeoutError = Promise2.TimeoutError;
          function HandleWrapper(handle) {
            this.handle = handle;
          }
          HandleWrapper.prototype._resultCancelled = function() {
            clearTimeout(this.handle);
          };
          var afterValue = function(value) {
            return delay(+this).thenReturn(value);
          };
          var delay = Promise2.delay = function(ms, value) {
            var ret2;
            var handle;
            if (value !== void 0) {
              ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
              if (debug.cancellation() && value instanceof Promise2) {
                ret2._setOnCancel(value);
              }
            } else {
              ret2 = new Promise2(INTERNAL);
              handle = setTimeout(function() {
                ret2._fulfill();
              }, +ms);
              if (debug.cancellation()) {
                ret2._setOnCancel(new HandleWrapper(handle));
              }
              ret2._captureStackTrace();
            }
            ret2._setAsyncGuaranteed();
            return ret2;
          };
          Promise2.prototype.delay = function(ms) {
            return delay(ms, this);
          };
          var afterTimeout = function(promise, message, parent) {
            var err;
            if (typeof message !== "string") {
              if (message instanceof Error) {
                err = message;
              } else {
                err = new TimeoutError("operation timed out");
              }
            } else {
              err = new TimeoutError(message);
            }
            util.markAsOriginatingFromRejection(err);
            promise._attachExtraTrace(err);
            promise._reject(err);
            if (parent != null) {
              parent.cancel();
            }
          };
          function successClear(value) {
            clearTimeout(this.handle);
            return value;
          }
          function failureClear(reason) {
            clearTimeout(this.handle);
            throw reason;
          }
          Promise2.prototype.timeout = function(ms, message) {
            ms = +ms;
            var ret2, parent;
            var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
              if (ret2.isPending()) {
                afterTimeout(ret2, message, parent);
              }
            }, ms));
            if (debug.cancellation()) {
              parent = this.then();
              ret2 = parent._then(
                successClear,
                failureClear,
                void 0,
                handleWrapper,
                void 0
              );
              ret2._setOnCancel(handleWrapper);
            } else {
              ret2 = this._then(
                successClear,
                failureClear,
                void 0,
                handleWrapper,
                void 0
              );
            }
            return ret2;
          };
        };
      }, { "./util": 36 }], 35: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var TypeError2 = _dereq_2("./errors").TypeError;
          var inherits2 = _dereq_2("./util").inherits;
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var NULL = {};
          function thrower2(e) {
            setTimeout(function() {
              throw e;
            }, 0);
          }
          function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
              maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
          }
          function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret2 = new Promise2(INTERNAL);
            function iterator() {
              if (i >= len)
                return ret2._fulfill();
              var maybePromise = castPreservingDisposable(resources[i++]);
              if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
                try {
                  maybePromise = tryConvertToPromise(
                    maybePromise._getDisposer().tryDispose(inspection),
                    resources.promise
                  );
                } catch (e) {
                  return thrower2(e);
                }
                if (maybePromise instanceof Promise2) {
                  return maybePromise._then(
                    iterator,
                    thrower2,
                    null,
                    null,
                    null
                  );
                }
              }
              iterator();
            }
            iterator();
            return ret2;
          }
          function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
          }
          Disposer.prototype.data = function() {
            return this._data;
          };
          Disposer.prototype.promise = function() {
            return this._promise;
          };
          Disposer.prototype.resource = function() {
            if (this.promise().isFulfilled()) {
              return this.promise().value();
            }
            return NULL;
          };
          Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== void 0)
              context._pushContext();
            var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
            if (context !== void 0)
              context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret2;
          };
          Disposer.isDisposer = function(d) {
            return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
          };
          function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
          }
          inherits2(FunctionDisposer, Disposer);
          FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
          };
          function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
              this.resources[this.index]._setDisposable(value);
              return value.promise();
            }
            return value;
          }
          function ResourceList(length) {
            this.length = length;
            this.promise = null;
            this[length - 1] = null;
          }
          ResourceList.prototype._resultCancelled = function() {
            var len = this.length;
            for (var i = 0; i < len; ++i) {
              var item = this[i];
              if (item instanceof Promise2) {
                item.cancel();
              }
            }
          };
          Promise2.using = function() {
            var len = arguments.length;
            if (len < 2)
              return apiRejection(
                "you must pass at least 2 arguments to Promise.using"
              );
            var fn = arguments[len - 1];
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var input;
            var spreadArgs = true;
            if (len === 2 && Array.isArray(arguments[0])) {
              input = arguments[0];
              len = input.length;
              spreadArgs = false;
            } else {
              input = arguments;
              len--;
            }
            var resources = new ResourceList(len);
            for (var i = 0; i < len; ++i) {
              var resource = input[i];
              if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
              } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise2) {
                  resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                    resources,
                    index: i
                  }, void 0);
                }
              }
              resources[i] = resource;
            }
            var reflectedResources = new Array(resources.length);
            for (var i = 0; i < reflectedResources.length; ++i) {
              reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
            }
            var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
              for (var i2 = 0; i2 < inspections.length; ++i2) {
                var inspection = inspections[i2];
                if (inspection.isRejected()) {
                  errorObj2.e = inspection.error();
                  return errorObj2;
                } else if (!inspection.isFulfilled()) {
                  resultPromise.cancel();
                  return;
                }
                inspections[i2] = inspection.value();
              }
              promise._pushContext();
              fn = tryCatch2(fn);
              var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
              var promiseCreated = promise._popContext();
              debug.checkForgottenReturns(
                ret2,
                promiseCreated,
                "Promise.using",
                promise
              );
              return ret2;
            });
            var promise = resultPromise.lastly(function() {
              var inspection = new Promise2.PromiseInspection(resultPromise);
              return dispose(resources, inspection);
            });
            resources.promise = promise;
            promise._setOnCancel(resources);
            return promise;
          };
          Promise2.prototype._setDisposable = function(disposer) {
            this._bitField = this._bitField | 131072;
            this._disposer = disposer;
          };
          Promise2.prototype._isDisposable = function() {
            return (this._bitField & 131072) > 0;
          };
          Promise2.prototype._getDisposer = function() {
            return this._disposer;
          };
          Promise2.prototype._unsetDisposable = function() {
            this._bitField = this._bitField & ~131072;
            this._disposer = void 0;
          };
          Promise2.prototype.disposer = function(fn) {
            if (typeof fn === "function") {
              return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError2();
          };
        };
      }, { "./errors": 12, "./util": 36 }], 36: [function(_dereq_, module, exports) {
        "use strict";
        var es5 = _dereq_("./es5");
        var canEvaluate = typeof navigator == "undefined";
        var errorObj = { e: {} };
        var tryCatchTarget;
        var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : this !== void 0 ? this : null;
        function tryCatcher() {
          try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        var inherits = function(Child, Parent) {
          var hasProp = {}.hasOwnProperty;
          function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
              if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
              }
            }
          }
          T.prototype = Parent.prototype;
          Child.prototype = new T();
          return Child.prototype;
        };
        function isPrimitive(val) {
          return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
        }
        function isObject(value) {
          return typeof value === "function" || typeof value === "object" && value !== null;
        }
        function maybeWrapAsError(maybeError) {
          if (!isPrimitive(maybeError))
            return maybeError;
          return new Error(safeToString(maybeError));
        }
        function withAppended(target, appendee) {
          var len = target.length;
          var ret2 = new Array(len + 1);
          var i;
          for (i = 0; i < len; ++i) {
            ret2[i] = target[i];
          }
          ret2[i] = appendee;
          return ret2;
        }
        function getDataPropertyOrDefault(obj2, key, defaultValue) {
          if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null) {
              return desc.get == null && desc.set == null ? desc.value : defaultValue;
            }
          } else {
            return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
          }
        }
        function notEnumerableProp(obj2, name, value) {
          if (isPrimitive(obj2))
            return obj2;
          var descriptor = {
            value,
            configurable: true,
            enumerable: false,
            writable: true
          };
          es5.defineProperty(obj2, name, descriptor);
          return obj2;
        }
        function thrower(r) {
          throw r;
        }
        var inheritedDataKeys = function() {
          var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ];
          var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (excludedPrototypes[i] === val) {
                return true;
              }
            }
            return false;
          };
          if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj2) {
              var ret2 = [];
              var visitedKeys = /* @__PURE__ */ Object.create(null);
              while (obj2 != null && !isExcludedProto(obj2)) {
                var keys;
                try {
                  keys = getKeys(obj2);
                } catch (e) {
                  return ret2;
                }
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  if (visitedKeys[key])
                    continue;
                  visitedKeys[key] = true;
                  var desc = Object.getOwnPropertyDescriptor(obj2, key);
                  if (desc != null && desc.get == null && desc.set == null) {
                    ret2.push(key);
                  }
                }
                obj2 = es5.getPrototypeOf(obj2);
              }
              return ret2;
            };
          } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj2) {
              if (isExcludedProto(obj2))
                return [];
              var ret2 = [];
              enumeration:
                for (var key in obj2) {
                  if (hasProp.call(obj2, key)) {
                    ret2.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret2.push(key);
                  }
                }
              return ret2;
            };
          }
        }();
        var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
        function isClass(fn) {
          try {
            if (typeof fn === "function") {
              var keys = es5.names(fn.prototype);
              var hasMethods = es5.isES5 && keys.length > 1;
              var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
              var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
              if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
              }
            }
            return false;
          } catch (e) {
            return false;
          }
        }
        function toFastProperties(obj) {
          function FakeConstructor() {
          }
          FakeConstructor.prototype = obj;
          var receiver = new FakeConstructor();
          function ic() {
            return typeof receiver.foo;
          }
          ic();
          ic();
          return obj;
          eval(obj);
        }
        var rident = /^[a-z$_][a-z$_0-9]*$/i;
        function isIdentifier(str) {
          return rident.test(str);
        }
        function filledRange(count, prefix, suffix) {
          var ret2 = new Array(count);
          for (var i = 0; i < count; ++i) {
            ret2[i] = prefix + i + suffix;
          }
          return ret2;
        }
        function safeToString(obj2) {
          try {
            return obj2 + "";
          } catch (e) {
            return "[no string representation]";
          }
        }
        function isError(obj2) {
          return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
        }
        function markAsOriginatingFromRejection(e) {
          try {
            notEnumerableProp(e, "isOperational", true);
          } catch (ignore) {
          }
        }
        function originatesFromRejection(e) {
          if (e == null)
            return false;
          return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
        }
        function canAttachTrace(obj2) {
          return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
        }
        var ensureErrorObject = function() {
          if (!("stack" in new Error())) {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              try {
                throw new Error(safeToString(value));
              } catch (err) {
                return err;
              }
            };
          } else {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              return new Error(safeToString(value));
            };
          }
        }();
        function classString(obj2) {
          return {}.toString.call(obj2);
        }
        function copyDescriptors(from, to, filter) {
          var keys = es5.names(from);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
              try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
              } catch (ignore) {
              }
            }
          }
        }
        var asArray = function(v) {
          if (es5.isArray(v)) {
            return v;
          }
          return null;
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          var ArrayFrom = typeof Array.from === "function" ? function(v) {
            return Array.from(v);
          } : function(v) {
            var ret2 = [];
            var it = v[Symbol.iterator]();
            var itResult;
            while (!(itResult = it.next()).done) {
              ret2.push(itResult.value);
            }
            return ret2;
          };
          asArray = function(v) {
            if (es5.isArray(v)) {
              return v;
            } else if (v != null && typeof v[Symbol.iterator] === "function") {
              return ArrayFrom(v);
            }
            return null;
          };
        }
        var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
        var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
        function env(key) {
          return hasEnvVariables ? process.env[key] : void 0;
        }
        function getNativePromise() {
          if (typeof Promise === "function") {
            try {
              var promise = new Promise(function() {
              });
              if (classString(promise) === "[object Promise]") {
                return Promise;
              }
            } catch (e) {
            }
          }
        }
        var reflectHandler;
        function contextBind(ctx, cb) {
          if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
            return cb;
          }
          if (ctx.domain !== null) {
            cb = ctx.domain.bind(cb);
          }
          var async = ctx.async;
          if (async !== null) {
            var old = cb;
            cb = function() {
              var args = new Array(2).concat([].slice.call(arguments));
              ;
              args[0] = old;
              args[1] = this;
              return async.runInAsyncScope.apply(async, args);
            };
          }
          return cb;
        }
        var ret = {
          setReflectHandler: function(fn) {
            reflectHandler = fn;
          },
          isClass,
          isIdentifier,
          inheritedDataKeys,
          getDataPropertyOrDefault,
          thrower,
          isArray: es5.isArray,
          asArray,
          notEnumerableProp,
          isPrimitive,
          isObject,
          isError,
          canEvaluate,
          errorObj,
          tryCatch,
          inherits,
          withAppended,
          maybeWrapAsError,
          toFastProperties,
          filledRange,
          toString: safeToString,
          canAttachTrace,
          ensureErrorObject,
          originatesFromRejection,
          markAsOriginatingFromRejection,
          classString,
          copyDescriptors,
          isNode,
          hasEnvVariables,
          env,
          global: globalObject,
          getNativePromise,
          contextBind
        };
        ret.isRecentNode = ret.isNode && function() {
          var version;
          if (process.versions && process.versions.node) {
            version = process.versions.node.split(".").map(Number);
          } else if (process.version) {
            version = process.version.split(".").map(Number);
          }
          return version[0] === 0 && version[1] > 10 || version[0] > 0;
        }();
        ret.nodeSupportsAsyncResource = ret.isNode && function() {
          var supportsAsync = false;
          try {
            var res = _dereq_("async_hooks").AsyncResource;
            supportsAsync = typeof res.prototype.runInAsyncScope === "function";
          } catch (e) {
            supportsAsync = false;
          }
          return supportsAsync;
        }();
        if (ret.isNode)
          ret.toFastProperties(process);
        try {
          throw new Error();
        } catch (e) {
          ret.lastLineError = e;
        }
        module.exports = ret;
      }, { "./es5": 13, "async_hooks": void 0 }] }, {}, [4])(4);
    });
    if (typeof window !== "undefined" && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== "undefined" && self !== null) {
      self.P = self.Promise;
    }
  }
});

// node_modules/amqplib/lib/channel.js
var require_channel = __commonJS({
  "node_modules/amqplib/lib/channel.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var defs = require_defs();
    var closeMsg = require_format().closeMessage;
    var inspect = require_format().inspect;
    var methodName = require_format().methodName;
    var assert = require_assert();
    var inherits2 = require_util2().inherits;
    var EventEmitter = require_events().EventEmitter;
    var fmt = require_util2().format;
    var IllegalOperationError = require_error().IllegalOperationError;
    var stackCapture = require_error().stackCapture;
    function Channel(connection) {
      EventEmitter.call(this);
      this.connection = connection;
      this.reply = null;
      this.pending = [];
      this.lwm = 1;
      this.unconfirmed = [];
      this.on("ack", this.handleConfirm.bind(this, function(cb) {
        if (cb)
          cb(null);
      }));
      this.on("nack", this.handleConfirm.bind(this, function(cb) {
        if (cb)
          cb(new Error("message nacked"));
      }));
      this.on("close", function() {
        var cb;
        while (cb = this.unconfirmed.shift()) {
          if (cb)
            cb(new Error("channel closed"));
        }
      });
      this.handleMessage = acceptDeliveryOrReturn;
    }
    inherits2(Channel, EventEmitter);
    module2.exports.Channel = Channel;
    module2.exports.acceptMessage = acceptMessage;
    var C = Channel.prototype;
    C.allocate = function() {
      this.ch = this.connection.freshChannel(this);
      return this;
    };
    C.sendImmediately = function(method, fields) {
      return this.connection.sendMethod(this.ch, method, fields);
    };
    C.sendOrEnqueue = function(method, fields, reply) {
      if (!this.reply) {
        assert(this.pending.length === 0);
        this.reply = reply;
        this.sendImmediately(method, fields);
      } else {
        this.pending.push({
          method,
          fields,
          reply
        });
      }
    };
    C.sendMessage = function(fields, properties, content) {
      return this.connection.sendMessage(
        this.ch,
        defs.BasicPublish,
        fields,
        defs.BasicProperties,
        properties,
        content
      );
    };
    C._rpc = function(method, fields, expect, cb) {
      var self2 = this;
      function reply(err, f) {
        if (err === null) {
          if (f.id === expect) {
            return cb(null, f);
          } else {
            var expectedName = methodName(expect);
            var e = new Error(fmt(
              "Expected %s; got %s",
              expectedName,
              inspect(f, false)
            ));
            self2.closeWithError(
              f.id,
              fmt(
                "Expected %s; got %s",
                expectedName,
                methodName(f.id)
              ),
              defs.constants.UNEXPECTED_FRAME,
              e
            );
            return cb(e);
          }
        } else if (err instanceof Error)
          return cb(err);
        else {
          var closeReason = (err.fields.classId << 16) + err.fields.methodId;
          var e = method === closeReason ? fmt(
            "Operation failed: %s; %s",
            methodName(method),
            closeMsg(err)
          ) : fmt("Channel closed by server: %s", closeMsg(err));
          var closeFrameError = new Error(e);
          closeFrameError.code = err.fields.replyCode;
          closeFrameError.classId = err.fields.classId;
          closeFrameError.methodId = err.fields.methodId;
          return cb(closeFrameError);
        }
      }
      this.sendOrEnqueue(method, fields, reply);
    };
    function invalidOp(msg, stack) {
      return function() {
        throw new IllegalOperationError(msg, stack);
      };
    }
    function invalidateSend(ch, msg, stack) {
      ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage = invalidOp(msg, stack);
    }
    C.toClosed = function(capturedStack) {
      this._rejectPending();
      invalidateSend(this, "Channel closed", capturedStack);
      this.accept = invalidOp("Channel closed", capturedStack);
      this.connection.releaseChannel(this.ch);
      this.emit("close");
    };
    C.toClosing = function(capturedStack, k) {
      var send = this.sendImmediately.bind(this);
      invalidateSend(this, "Channel closing", capturedStack);
      this.accept = function(f) {
        if (f.id === defs.ChannelCloseOk) {
          if (k)
            k();
          var s = stackCapture("ChannelCloseOk frame received");
          this.toClosed(s);
        } else if (f.id === defs.ChannelClose) {
          send(defs.ChannelCloseOk, {});
        }
      };
    };
    C._rejectPending = function() {
      function rej(r) {
        r(new Error("Channel ended, no reply will be forthcoming"));
      }
      if (this.reply !== null)
        rej(this.reply);
      this.reply = null;
      var discard;
      while (discard = this.pending.shift())
        rej(discard.reply);
      this.pending = null;
    };
    C.closeBecause = function(reason, code, k) {
      this.sendImmediately(defs.ChannelClose, {
        replyText: reason,
        replyCode: code,
        methodId: 0,
        classId: 0
      });
      var s = stackCapture("closeBecause called: " + reason);
      this.toClosing(s, k);
    };
    C.closeWithError = function(id, reason, code, error) {
      var self2 = this;
      this.closeBecause(reason, code, function() {
        error.code = code;
        if (id) {
          error.classId = defs.info(id).classId;
          error.methodId = defs.info(id).methodId;
        }
        self2.emit("error", error);
      });
    };
    C.acceptMessageFrame = function(f) {
      try {
        this.handleMessage = this.handleMessage(f);
      } catch (msg) {
        if (typeof msg === "string") {
          this.closeWithError(
            f.id,
            msg,
            defs.constants.UNEXPECTED_FRAME,
            new Error(msg)
          );
        } else if (msg instanceof Error) {
          this.closeWithError(
            f.id,
            "Error while processing message",
            defs.constants.INTERNAL_ERROR,
            msg
          );
        } else {
          this.closeWithError(
            f.id,
            "Internal error while processing message",
            defs.constants.INTERNAL_ERROR,
            new Error(msg.toString())
          );
        }
      }
    };
    function acceptDeliveryOrReturn(f) {
      var event;
      if (f.id === defs.BasicDeliver)
        event = "delivery";
      else if (f.id === defs.BasicReturn)
        event = "return";
      else
        throw fmt(
          "Expected BasicDeliver or BasicReturn; got %s",
          inspect(f)
        );
      var self2 = this;
      var fields = f.fields;
      return acceptMessage(function(message) {
        message.fields = fields;
        self2.emit(event, message);
      });
    }
    function acceptMessage(continuation) {
      var totalSize = 0, remaining = 0;
      var buffers = null;
      var message = {
        fields: null,
        properties: null,
        content: null
      };
      return headers;
      function headers(f) {
        if (f.id === defs.BasicProperties) {
          message.properties = f.fields;
          totalSize = remaining = f.size;
          if (totalSize === 0) {
            message.content = Buffer.alloc(0);
            continuation(message);
            return acceptDeliveryOrReturn;
          } else {
            return content;
          }
        } else {
          throw "Expected headers frame after delivery";
        }
      }
      function content(f) {
        if (f.content) {
          var size = f.content.length;
          remaining -= size;
          if (remaining === 0) {
            if (buffers !== null) {
              buffers.push(f.content);
              message.content = Buffer.concat(buffers);
            } else {
              message.content = f.content;
            }
            continuation(message);
            return acceptDeliveryOrReturn;
          } else if (remaining < 0) {
            throw fmt(
              "Too much content sent! Expected %d bytes",
              totalSize
            );
          } else {
            if (buffers !== null)
              buffers.push(f.content);
            else
              buffers = [f.content];
            return content;
          }
        } else
          throw "Expected content frame after headers";
      }
    }
    C.handleConfirm = function(handle, f) {
      var tag = f.deliveryTag;
      var multi = f.multiple;
      if (multi) {
        var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);
        this.lwm = tag + 1;
        confirmed.forEach(handle);
      } else {
        var c;
        if (tag === this.lwm) {
          c = this.unconfirmed.shift();
          this.lwm++;
          while (this.unconfirmed[0] === null) {
            this.unconfirmed.shift();
            this.lwm++;
          }
        } else {
          c = this.unconfirmed[tag - this.lwm];
          this.unconfirmed[tag - this.lwm] = null;
        }
        handle(c);
      }
    };
    C.pushConfirmCallback = function(cb) {
      this.unconfirmed.push(cb || false);
    };
    C.accept = function(f) {
      switch (f.id) {
        case void 0:
        case defs.BasicDeliver:
        case defs.BasicReturn:
        case defs.BasicProperties:
          return this.acceptMessageFrame(f);
        case defs.BasicAck:
          return this.emit("ack", f.fields);
        case defs.BasicNack:
          return this.emit("nack", f.fields);
        case defs.BasicCancel:
          return this.emit("cancel", f.fields);
        case defs.ChannelClose:
          if (this.reply) {
            var reply = this.reply;
            this.reply = null;
            reply(f);
          }
          var emsg = "Channel closed by server: " + closeMsg(f);
          this.sendImmediately(defs.ChannelCloseOk, {});
          var error = new Error(emsg);
          error.code = f.fields.replyCode;
          error.classId = f.fields.classId;
          error.methodId = f.fields.methodId;
          this.emit("error", error);
          var s = stackCapture(emsg);
          this.toClosed(s);
          return;
        case defs.BasicFlow:
          return this.closeWithError(
            f.id,
            "Flow not implemented",
            defs.constants.NOT_IMPLEMENTED,
            new Error("Flow not implemented")
          );
        default:
          var reply = this.reply;
          this.reply = null;
          if (this.pending.length > 0) {
            var send = this.pending.shift();
            this.reply = send.reply;
            this.sendImmediately(send.method, send.fields);
          }
          return reply(null, f);
      }
    };
    C.onBufferDrain = function() {
      this.emit("drain");
    };
    function BaseChannel(connection) {
      Channel.call(this, connection);
      this.consumers = /* @__PURE__ */ new Map();
    }
    inherits2(BaseChannel, Channel);
    module2.exports.BaseChannel = BaseChannel;
    BaseChannel.prototype.registerConsumer = function(tag, callback) {
      this.consumers.set(tag, callback);
    };
    BaseChannel.prototype.unregisterConsumer = function(tag) {
      this.consumers.delete(tag);
    };
    BaseChannel.prototype.dispatchMessage = function(fields, message) {
      var consumerTag = fields.consumerTag;
      var consumer = this.consumers.get(consumerTag);
      if (consumer) {
        return consumer(message);
      } else {
        throw new Error("Unknown consumer: " + consumerTag);
      }
    };
    BaseChannel.prototype.handleDelivery = function(message) {
      return this.dispatchMessage(message.fields, message);
    };
    BaseChannel.prototype.handleCancel = function(fields) {
      var result = this.dispatchMessage(fields, null);
      this.unregisterConsumer(fields.consumerTag);
      return result;
    };
  }
});

// node_modules/amqplib/lib/api_args.js
var require_api_args = __commonJS({
  "node_modules/amqplib/lib/api_args.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function setIfDefined(obj2, prop, value) {
      if (value != void 0)
        obj2[prop] = value;
    }
    var EMPTY_OPTIONS = Object.freeze({});
    var Args = {};
    Args.assertQueue = function(queue, options) {
      queue = queue || "";
      options = options || EMPTY_OPTIONS;
      var argt = Object.create(options.arguments || null);
      setIfDefined(argt, "x-expires", options.expires);
      setIfDefined(argt, "x-message-ttl", options.messageTtl);
      setIfDefined(
        argt,
        "x-dead-letter-exchange",
        options.deadLetterExchange
      );
      setIfDefined(
        argt,
        "x-dead-letter-routing-key",
        options.deadLetterRoutingKey
      );
      setIfDefined(argt, "x-max-length", options.maxLength);
      setIfDefined(argt, "x-max-priority", options.maxPriority);
      setIfDefined(argt, "x-overflow", options.overflow);
      setIfDefined(argt, "x-queue-mode", options.queueMode);
      return {
        queue,
        exclusive: !!options.exclusive,
        durable: options.durable === void 0 ? true : options.durable,
        autoDelete: !!options.autoDelete,
        arguments: argt,
        passive: false,
        // deprecated but we have to include it
        ticket: 0,
        nowait: false
      };
    };
    Args.checkQueue = function(queue) {
      return {
        queue,
        passive: true,
        // switch to "completely different" mode
        nowait: false,
        durable: true,
        autoDelete: false,
        exclusive: false,
        // ignored
        ticket: 0
      };
    };
    Args.deleteQueue = function(queue, options) {
      options = options || EMPTY_OPTIONS;
      return {
        queue,
        ifUnused: !!options.ifUnused,
        ifEmpty: !!options.ifEmpty,
        ticket: 0,
        nowait: false
      };
    };
    Args.purgeQueue = function(queue) {
      return {
        queue,
        ticket: 0,
        nowait: false
      };
    };
    Args.bindQueue = function(queue, source, pattern, argt) {
      return {
        queue,
        exchange: source,
        routingKey: pattern,
        arguments: argt,
        ticket: 0,
        nowait: false
      };
    };
    Args.unbindQueue = function(queue, source, pattern, argt) {
      return {
        queue,
        exchange: source,
        routingKey: pattern,
        arguments: argt,
        ticket: 0,
        nowait: false
      };
    };
    Args.assertExchange = function(exchange, type, options) {
      options = options || EMPTY_OPTIONS;
      var argt = Object.create(options.arguments || null);
      setIfDefined(argt, "alternate-exchange", options.alternateExchange);
      return {
        exchange,
        ticket: 0,
        type,
        passive: false,
        durable: options.durable === void 0 ? true : options.durable,
        autoDelete: !!options.autoDelete,
        internal: !!options.internal,
        nowait: false,
        arguments: argt
      };
    };
    Args.checkExchange = function(exchange) {
      return {
        exchange,
        passive: true,
        // switch to 'may as well be another method' mode
        nowait: false,
        // ff are ignored
        durable: true,
        internal: false,
        type: "",
        autoDelete: false,
        ticket: 0
      };
    };
    Args.deleteExchange = function(exchange, options) {
      options = options || EMPTY_OPTIONS;
      return {
        exchange,
        ifUnused: !!options.ifUnused,
        ticket: 0,
        nowait: false
      };
    };
    Args.bindExchange = function(dest, source, pattern, argt) {
      return {
        source,
        destination: dest,
        routingKey: pattern,
        arguments: argt,
        ticket: 0,
        nowait: false
      };
    };
    Args.unbindExchange = function(dest, source, pattern, argt) {
      return {
        source,
        destination: dest,
        routingKey: pattern,
        arguments: argt,
        ticket: 0,
        nowait: false
      };
    };
    Args.publish = function(exchange, routingKey, options) {
      options = options || EMPTY_OPTIONS;
      function convertCC(cc) {
        if (cc === void 0) {
          return void 0;
        } else if (Array.isArray(cc)) {
          return cc.map(String);
        } else
          return [String(cc)];
      }
      var headers = Object.create(options.headers || null);
      setIfDefined(headers, "CC", convertCC(options.CC));
      setIfDefined(headers, "BCC", convertCC(options.BCC));
      var deliveryMode;
      if (options.persistent !== void 0)
        deliveryMode = options.persistent ? 2 : 1;
      else if (typeof options.deliveryMode === "number")
        deliveryMode = options.deliveryMode;
      else if (options.deliveryMode)
        deliveryMode = 2;
      var expiration = options.expiration;
      if (expiration !== void 0)
        expiration = expiration.toString();
      return {
        // method fields
        exchange,
        routingKey,
        mandatory: !!options.mandatory,
        immediate: false,
        // RabbitMQ doesn't implement this any more
        ticket: void 0,
        // properties
        contentType: options.contentType,
        contentEncoding: options.contentEncoding,
        headers,
        deliveryMode,
        priority: options.priority,
        correlationId: options.correlationId,
        replyTo: options.replyTo,
        expiration,
        messageId: options.messageId,
        timestamp: options.timestamp,
        type: options.type,
        userId: options.userId,
        appId: options.appId,
        clusterId: void 0
      };
    };
    Args.consume = function(queue, options) {
      options = options || EMPTY_OPTIONS;
      var argt = Object.create(options.arguments || null);
      setIfDefined(argt, "x-priority", options.priority);
      return {
        ticket: 0,
        queue,
        consumerTag: options.consumerTag || "",
        noLocal: !!options.noLocal,
        noAck: !!options.noAck,
        exclusive: !!options.exclusive,
        nowait: false,
        arguments: argt
      };
    };
    Args.cancel = function(consumerTag) {
      return {
        consumerTag,
        nowait: false
      };
    };
    Args.get = function(queue, options) {
      options = options || EMPTY_OPTIONS;
      return {
        ticket: 0,
        queue,
        noAck: !!options.noAck
      };
    };
    Args.ack = function(tag, allUpTo) {
      return {
        deliveryTag: tag,
        multiple: !!allUpTo
      };
    };
    Args.nack = function(tag, allUpTo, requeue) {
      return {
        deliveryTag: tag,
        multiple: !!allUpTo,
        requeue: requeue === void 0 ? true : requeue
      };
    };
    Args.reject = function(tag, requeue) {
      return {
        deliveryTag: tag,
        requeue: requeue === void 0 ? true : requeue
      };
    };
    Args.prefetch = function(count, global2) {
      return {
        prefetchCount: count || 0,
        prefetchSize: 0,
        global: !!global2
      };
    };
    Args.recover = function() {
      return { requeue: true };
    };
    module2.exports = Object.freeze(Args);
  }
});

// node_modules/amqplib/lib/channel_model.js
var require_channel_model = __commonJS({
  "node_modules/amqplib/lib/channel_model.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var EventEmitter = require_events();
    var Promise2 = require_bluebird();
    var defs = require_defs();
    var { BaseChannel } = require_channel();
    var { acceptMessage } = require_channel();
    var Args = require_api_args();
    var { inspect } = require_format();
    var ChannelModel = class extends EventEmitter {
      constructor(connection) {
        super();
        this.connection = connection;
        ["error", "close", "blocked", "unblocked"].forEach((ev) => {
          connection.on(ev, this.emit.bind(this, ev));
        });
      }
      close() {
        return Promise2.fromCallback(this.connection.close.bind(this.connection));
      }
      async createChannel() {
        const channel = new Channel(this.connection);
        await channel.open();
        return channel;
      }
      async createConfirmChannel() {
        const channel = new ConfirmChannel(this.connection);
        await channel.open();
        await channel.rpc(defs.ConfirmSelect, { nowait: false }, defs.ConfirmSelectOk);
        return channel;
      }
    };
    var Channel = class extends BaseChannel {
      constructor(connection) {
        super(connection);
        this.on("delivery", this.handleDelivery.bind(this));
        this.on("cancel", this.handleCancel.bind(this));
      }
      // An RPC that returns a 'proper' promise, which resolves to just the
      // response's fields; this is intended to be suitable for implementing
      // API procedures.
      async rpc(method, fields, expect) {
        const f = await Promise2.fromCallback((cb) => {
          return this._rpc(method, fields, expect, cb);
        });
        return f.fields;
      }
      // Do the remarkably simple channel open handshake
      open() {
        return Promise2.try(this.allocate.bind(this)).then(
          (ch) => {
            return ch.rpc(
              defs.ChannelOpen,
              { outOfBand: "" },
              defs.ChannelOpenOk
            );
          }
        );
      }
      close() {
        return Promise2.fromCallback((cb) => {
          return this.closeBecause(
            "Goodbye",
            defs.constants.REPLY_SUCCESS,
            cb
          );
        });
      }
      // === Public API, declaring queues and stuff ===
      assertQueue(queue, options) {
        return this.rpc(
          defs.QueueDeclare,
          Args.assertQueue(queue, options),
          defs.QueueDeclareOk
        );
      }
      checkQueue(queue) {
        return this.rpc(
          defs.QueueDeclare,
          Args.checkQueue(queue),
          defs.QueueDeclareOk
        );
      }
      deleteQueue(queue, options) {
        return this.rpc(
          defs.QueueDelete,
          Args.deleteQueue(queue, options),
          defs.QueueDeleteOk
        );
      }
      purgeQueue(queue) {
        return this.rpc(
          defs.QueuePurge,
          Args.purgeQueue(queue),
          defs.QueuePurgeOk
        );
      }
      bindQueue(queue, source, pattern, argt) {
        return this.rpc(
          defs.QueueBind,
          Args.bindQueue(queue, source, pattern, argt),
          defs.QueueBindOk
        );
      }
      unbindQueue(queue, source, pattern, argt) {
        return this.rpc(
          defs.QueueUnbind,
          Args.unbindQueue(queue, source, pattern, argt),
          defs.QueueUnbindOk
        );
      }
      assertExchange(exchange, type, options) {
        return this.rpc(
          defs.ExchangeDeclare,
          Args.assertExchange(exchange, type, options),
          defs.ExchangeDeclareOk
        ).then((_ok) => {
          return { exchange };
        });
      }
      checkExchange(exchange) {
        return this.rpc(
          defs.ExchangeDeclare,
          Args.checkExchange(exchange),
          defs.ExchangeDeclareOk
        );
      }
      deleteExchange(name, options) {
        return this.rpc(
          defs.ExchangeDelete,
          Args.deleteExchange(name, options),
          defs.ExchangeDeleteOk
        );
      }
      bindExchange(dest, source, pattern, argt) {
        return this.rpc(
          defs.ExchangeBind,
          Args.bindExchange(dest, source, pattern, argt),
          defs.ExchangeBindOk
        );
      }
      unbindExchange(dest, source, pattern, argt) {
        return this.rpc(
          defs.ExchangeUnbind,
          Args.unbindExchange(dest, source, pattern, argt),
          defs.ExchangeUnbindOk
        );
      }
      // Working with messages
      publish(exchange, routingKey, content, options) {
        const fieldsAndProps = Args.publish(exchange, routingKey, options);
        return this.sendMessage(fieldsAndProps, fieldsAndProps, content);
      }
      sendToQueue(queue, content, options) {
        return this.publish("", queue, content, options);
      }
      consume(queue, callback, options) {
        const fields = Args.consume(queue, options);
        return Promise2.fromCallback((cb) => {
          this._rpc(defs.BasicConsume, fields, defs.BasicConsumeOk, cb);
        }).then((ok) => {
          this.registerConsumer(ok.fields.consumerTag, callback);
          return ok.fields;
        });
      }
      async cancel(consumerTag) {
        const ok = await Promise2.fromCallback((cb) => {
          this._rpc(
            defs.BasicCancel,
            Args.cancel(consumerTag),
            defs.BasicCancelOk,
            cb
          );
        }).then((ok2) => {
          this.unregisterConsumer(consumerTag);
          return ok2.fields;
        });
      }
      get(queue, options) {
        const fields = Args.get(queue, options);
        return Promise2.fromCallback((cb) => {
          return this.sendOrEnqueue(defs.BasicGet, fields, cb);
        }).then((f) => {
          if (f.id === defs.BasicGetEmpty) {
            return false;
          } else if (f.id === defs.BasicGetOk) {
            const fields2 = f.fields;
            return new Promise2((resolve) => {
              this.handleMessage = acceptMessage((m) => {
                m.fields = fields2;
                resolve(m);
              });
            });
          } else {
            throw new Error(`Unexpected response to BasicGet: ${inspect(f)}`);
          }
        });
      }
      ack(message, allUpTo) {
        this.sendImmediately(
          defs.BasicAck,
          Args.ack(message.fields.deliveryTag, allUpTo)
        );
      }
      ackAll() {
        this.sendImmediately(defs.BasicAck, Args.ack(0, true));
      }
      nack(message, allUpTo, requeue) {
        this.sendImmediately(
          defs.BasicNack,
          Args.nack(message.fields.deliveryTag, allUpTo, requeue)
        );
      }
      nackAll(requeue) {
        this.sendImmediately(
          defs.BasicNack,
          Args.nack(0, true, requeue)
        );
      }
      // `Basic.Nack` is not available in older RabbitMQ versions (or in the
      // AMQP specification), so you have to use the one-at-a-time
      // `Basic.Reject`. This is otherwise synonymous with
      // `#nack(message, false, requeue)`.
      reject(message, requeue) {
        this.sendImmediately(
          defs.BasicReject,
          Args.reject(message.fields.deliveryTag, requeue)
        );
      }
      recover() {
        return this.rpc(
          defs.BasicRecover,
          Args.recover(),
          defs.BasicRecoverOk
        );
      }
      qos(count, global2) {
        return this.rpc(
          defs.BasicQos,
          Args.prefetch(count, global2),
          defs.BasicQosOk
        );
      }
    };
    Channel.prototype.prefetch = Channel.prototype.qos;
    var ConfirmChannel = class extends Channel {
      publish(exchange, routingKey, content, options, cb) {
        this.pushConfirmCallback(cb);
        return Channel.prototype.publish.call(this, exchange, routingKey, content, options);
      }
      sendToQueue(queue, content, options, cb) {
        return this.publish("", queue, content, options, cb);
      }
      waitForConfirms() {
        const awaiting = [];
        const unconfirmed = this.unconfirmed;
        unconfirmed.forEach((val, index) => {
          if (val !== null) {
            const confirmed = new Promise2((resolve, reject) => {
              unconfirmed[index] = (err) => {
                if (val)
                  val(err);
                if (err === null)
                  resolve();
                else
                  reject(err);
              };
            });
            awaiting.push(confirmed);
          }
        });
        return Promise2.all(awaiting);
      }
    };
    module2.exports.ConfirmChannel = ConfirmChannel;
    module2.exports.Channel = Channel;
    module2.exports.ChannelModel = ChannelModel;
  }
});

// node_modules/amqplib/channel_api.js
var require_channel_api = __commonJS({
  "node_modules/amqplib/channel_api.js"(exports2, module2) {
    init_process();
    init_buffer();
    var raw_connect = require_connect().connect;
    var ChannelModel = require_channel_model().ChannelModel;
    var Promise2 = require_bluebird();
    function connect(url, connOptions) {
      return Promise2.fromCallback(function(cb) {
        return raw_connect(url, connOptions, cb);
      }).then(function(conn) {
        return new ChannelModel(conn);
      });
    }
    module2.exports.connect = connect;
    module2.exports.credentials = require_credentials();
    module2.exports.IllegalOperationError = require_error().IllegalOperationError;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/RelayerManagerMessenger/TransactionNotifier.js
var require_TransactionNotifier2 = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/RelayerManagerMessenger/TransactionNotifier.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TransactionNotifier = class {
      constructor(transactionId, transactionHash, networkId, relayerAddress, socketClient, options = {}) {
        this.active = true;
        this.socketClient = socketClient;
        this.transactionId = transactionId;
        this.transactionHash = transactionHash;
        this.networkId = networkId;
        this.relayerAddress = relayerAddress;
        this.onMined = options.onMined;
        this.onDropped = options.onDropped;
        this.socketClient.subscribe(`relayer:${relayerAddress}`, this.transactionNotifierMessageHandler.bind(this));
      }
      transactionNotifierMessageHandler(messageCtx) {
        const { transactionId, event, transactionHash } = messageCtx.data;
        try {
          if (!transactionId || transactionId !== this.transactionId || transactionHash !== this.transactionHash) {
            return;
          }
          if (this.active) {
            if (event === "transactionDropped" && this.onDropped) {
              this.onDropped(this);
              this.active = false;
            } else if (event === "transactionMined" && this.onMined) {
              this.receipt = messageCtx.data.receipt;
              this.onMined(this);
              delete this.onMined;
              this.active = false;
            }
          }
        } catch (e) {
          console.error(e);
        }
      }
    };
    exports2.default = TransactionNotifier;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/RelayerManagerMessenger/RelayerMessenger.js
var require_RelayerMessenger = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/RelayerManagerMessenger/RelayerMessenger.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TransactionNotifier_1 = __importDefault(require_TransactionNotifier2());
    var RelayerMessenger = class {
      constructor(relayerAddress, socketClient, socketAdmin, channel, queueName) {
        this.subscribedTransactions = {};
        this.socketClient = socketClient;
        this.socketAdmin = socketAdmin;
        this.relayerAddress = relayerAddress;
        this.channel = channel;
        this.queueName = queueName;
      }
      sendTransactionHashGenerated(transactionId, transactionHash, networkId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          yield Promise.all([
            this.socketAdmin.publish({
              channel: `transaction:${transactionId}`,
              data: {
                event: "transactionHashGenerated",
                transactionHash,
                transactionId
              }
            }),
            this.channel.sendToQueue(this.queueName, Buffer.from(JSON.stringify({
              event: "transactionHashGenerated",
              transactionHash,
              transactionId,
              relayerAddress: this.relayerAddress,
              networkId
            })), {
              persistent: true
            })
          ]);
          return new TransactionNotifier_1.default(transactionId, transactionHash, networkId, this.relayerAddress, this.socketClient, { onMined: options.onMined, onDropped: options.onDropped });
        });
      }
      sendTransactionHashChanged(transactionId, transactionHash, networkId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          yield Promise.all([
            this.socketAdmin.publish({
              channel: `transaction:${transactionId}`,
              data: {
                event: "transactionHashChanged",
                transactionHash,
                transactionId
              }
            }),
            this.channel.sendToQueue(this.queueName, Buffer.from(JSON.stringify({
              event: "transactionHashChanged",
              transactionHash,
              transactionId,
              relayerAddress: this.relayerAddress,
              networkId
            })), {
              persistent: true
            })
          ]);
          return new TransactionNotifier_1.default(transactionId, transactionHash, networkId, this.relayerAddress, this.socketClient, { onMined: options.onMined, onDropped: options.onDropped });
        });
      }
      sendErrorMessage(transactionId, errorMessage) {
        return __awaiter(this, void 0, void 0, function* () {
          this.socketAdmin.publish({
            channel: `transaction:${transactionId}`,
            data: {
              event: "error",
              error: errorMessage,
              transactionId
            }
          });
        });
      }
    };
    exports2.default = RelayerMessenger;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/RelayerManagerMessenger/index.js
var require_RelayerManagerMessenger = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/RelayerManagerMessenger/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cent_js_1 = require_dist();
    var centrifuge_1 = __importDefault(require_centrifuge());
    var jsonwebtoken_1 = __importDefault(require_jsonwebtoken());
    var ws_1 = require_browser4();
    var amqplib_1 = __importDefault(require_channel_api());
    var RelayerMessenger_1 = __importDefault(require_RelayerMessenger());
    var RelayerManagerMessenger = class {
      constructor(socketClientEndpoint, socketAdminEndpoint, socketAdminSecret, socketApiKey, queue) {
        this.queue = queue;
        this.socketClient = new centrifuge_1.default(socketClientEndpoint, {
          debug: process.env.BICONOMY_SDK_DEBUG === "true" || process.env.REACT_APP_BICONOMY_SDK_DEBUG === "true",
          websocket: ws_1.WebSocket
        });
        const token = jsonwebtoken_1.default.sign({ sub: "RelayerManager" }, socketAdminSecret);
        this.socketClient.setToken(token);
        this.socketAdmin = new cent_js_1.CentClient({
          url: socketAdminEndpoint,
          token: socketApiKey
        });
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          yield new Promise((resolve) => {
            this.socketClient.on("connect", () => {
              resolve();
            });
            this.socketClient.connect();
          });
          const connection = yield amqplib_1.default.connect(this.queue.url);
          this.channel = yield connection.createChannel();
          this.channel.assertQueue(this.queue.name, {
            durable: true
          });
        });
      }
      getRelayerMessenger(relayerAddress) {
        return new RelayerMessenger_1.default(relayerAddress, this.socketClient, this.socketAdmin, this.channel, this.queue.name);
      }
    };
    exports2.default = RelayerManagerMessenger;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/TransactionListenerMessenger/TransactionMessenger.js
var require_TransactionMessenger = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/TransactionListenerMessenger/TransactionMessenger.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TransactionMessenger = class {
      constructor(transactionId, transactionHash, networkId, relayerAddress, socketClient, socketAdmin) {
        this.socketClient = socketClient;
        this.socketAdmin = socketAdmin;
        this.transactionId = transactionId;
        this.relayerAddress = relayerAddress;
        this.networkId = networkId;
        this.transactionHash = transactionHash;
      }
      sendTransactionMined(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
          yield Promise.all([
            this.socketAdmin.publish({
              channel: `relayer:${this.relayerAddress}`,
              data: {
                event: "transactionMined",
                transactionHash: this.transactionHash,
                transactionId: this.transactionId,
                networkId: this.networkId,
                receipt
              }
            }),
            this.socketAdmin.publish({
              channel: `transaction:${this.transactionId}`,
              data: {
                event: "transactionMined",
                transactionHash: this.transactionHash,
                transactionId: this.transactionId,
                networkId: this.networkId,
                receipt
              }
            })
          ]);
        });
      }
      sendTransactionDropped() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.socketAdmin.publish({
            channel: `relayer:${this.relayerAddress}`,
            data: {
              event: "transactionDropped",
              transactionHash: this.transactionHash,
              transactionId: this.transactionId
            }
          });
        });
      }
    };
    exports2.default = TransactionMessenger;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/TransactionListenerMessenger/index.js
var require_TransactionListenerMessenger = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/TransactionListenerMessenger/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var amqplib_1 = require_channel_api();
    var cent_js_1 = require_dist();
    var centrifuge_1 = __importDefault(require_centrifuge());
    var jsonwebtoken_1 = __importDefault(require_jsonwebtoken());
    var ws_1 = require_browser4();
    var TransactionMessenger_1 = __importDefault(require_TransactionMessenger());
    var TransactionListnerMessenger = class {
      constructor(transactionListenerId, socketClientEndpoint, socketAdminEndpoint, socketAdminSecret, socketApiKey, queue, onTransactionHashChanged, onTransactionHashGenerated) {
        this.socketClient = new centrifuge_1.default(socketClientEndpoint, {
          debug: process.env.BICONOMY_SDK_DEBUG === "true" || process.env.REACT_APP_BICONOMY_SDK_DEBUG === "true",
          websocket: ws_1.WebSocket
        });
        const token = jsonwebtoken_1.default.sign({ sub: `TransactionListener_${transactionListenerId}` }, socketAdminSecret);
        this.socketClient.setToken(token);
        this.socketAdmin = new cent_js_1.CentClient({
          url: socketAdminEndpoint,
          token: socketApiKey
        });
        this.onTransactionHashChanged = onTransactionHashChanged;
        this.onTransactionHashGenerated = onTransactionHashGenerated;
        this.queue = queue;
      }
      transactionListenerMessageHandler(messageCtx) {
        const { transactionId, event, transactionHash, relayerAddress, networkId } = messageCtx.data;
        if (!transactionId)
          throw new Error(`Invalid message received: ${JSON.stringify(messageCtx, void 0, 4)}`);
        if (event === "transactionHashChanged") {
          this.onTransactionHashChanged(new TransactionMessenger_1.default(transactionId, transactionHash, networkId, relayerAddress, this.socketClient, this.socketAdmin));
        } else if (event === "transactionHashGenerated") {
          this.onTransactionHashGenerated(new TransactionMessenger_1.default(transactionId, transactionHash, networkId, relayerAddress, this.socketClient, this.socketAdmin));
        }
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          const connection = yield (0, amqplib_1.connect)(this.queue.url);
          const channel = yield connection.createChannel();
          channel.assertQueue(this.queue.name, {
            durable: true
          });
          channel.consume(this.queue.name, (msg) => __awaiter(this, void 0, void 0, function* () {
            const data = JSON.parse(msg.content.toString());
            this.transactionListenerMessageHandler({
              data
            });
            channel.ack(msg);
          }));
        });
      }
    };
    exports2.default = TransactionListnerMessenger;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/TransactionHandlerMessenger/index.js
var require_TransactionHandlerMessenger = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/TransactionHandlerMessenger/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cent_js_1 = require_dist();
    var TransactionHandlerMessenger = class {
      constructor(socketAdminEndpoint, socketApiKey) {
        this.socketAdmin = new cent_js_1.CentClient({
          url: socketAdminEndpoint,
          token: socketApiKey
        });
      }
      sendErrorMessage(transactionId, errorMessage) {
        return __awaiter(this, void 0, void 0, function* () {
          this.socketAdmin.publish({
            channel: `transaction:${transactionId}`,
            data: {
              event: "error",
              error: errorMessage,
              transactionId
            }
          });
        });
      }
    };
    exports2.default = TransactionHandlerMessenger;
  }
});

// node_modules/@biconomy/gasless-messaging-sdk/build/index.js
var require_build = __commonJS({
  "node_modules/@biconomy/gasless-messaging-sdk/build/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionHandlerMessenger = exports2.TransactionListenerMessenger = exports2.ClientMessenger = exports2.RelayerManagerMessenger = void 0;
    var ClientMessenger_1 = __importDefault(require_ClientMessenger());
    exports2.ClientMessenger = ClientMessenger_1.default;
    var RelayerManagerMessenger_1 = __importDefault(require_RelayerManagerMessenger());
    exports2.RelayerManagerMessenger = RelayerManagerMessenger_1.default;
    var TransactionListenerMessenger_1 = __importDefault(require_TransactionListenerMessenger());
    exports2.TransactionListenerMessenger = TransactionListenerMessenger_1.default;
    var TransactionHandlerMessenger_1 = __importDefault(require_TransactionHandlerMessenger());
    exports2.TransactionHandlerMessenger = TransactionHandlerMessenger_1.default;
  }
});

// node_modules/isomorphic-ws/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => browser_default
});
var ws, browser_default;
var init_browser = __esm({
  "node_modules/isomorphic-ws/browser.js"() {
    init_process();
    init_buffer();
    ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof globalThis !== "undefined") {
      ws = globalThis.WebSocket || globalThis.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    browser_default = ws;
  }
});

// node_modules/@biconomy/relayer/dist/src/RestRelayer.js
var require_RestRelayer = __commonJS({
  "node_modules/@biconomy/relayer/dist/src/RestRelayer.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver2, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state.set(receiver2, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver2, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _RestRelayer_relayServiceBaseUrl;
    var _RestRelayer_socketServerUrl;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestRelayer = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var common_1 = require_src4();
    var MultiSend_1 = require_MultiSend();
    var HttpRequests_1 = require_HttpRequests();
    var gasless_messaging_sdk_1 = require_build();
    var isomorphic_ws_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var RestRelayer = class {
      constructor(options) {
        _RestRelayer_relayServiceBaseUrl.set(this, void 0);
        _RestRelayer_socketServerUrl.set(this, void 0);
        const { url, socketServerUrl } = options;
        this.relayerNodeEthersProvider = {};
        __classPrivateFieldSet(this, _RestRelayer_relayServiceBaseUrl, url, "f");
        __classPrivateFieldSet(this, _RestRelayer_socketServerUrl, socketServerUrl, "f");
      }
      setRelayerNodeEthersProvider(chainId) {
        if (!this.relayerNodeEthersProvider[chainId]) {
          this.relayerNodeEthersProvider[chainId] = new ethers_1.ethers.providers.JsonRpcProvider(__classPrivateFieldGet(this, _RestRelayer_relayServiceBaseUrl, "f"), {
            name: "Not actually connected to network, only talking to the Relayer!",
            chainId
          });
        }
      }
      prepareWalletDeploy(deployWallet) {
        const { config, context, index = 0 } = deployWallet;
        const { walletFactory } = context;
        const { owner } = config;
        const factoryInterface = walletFactory.getInterface();
        return {
          to: walletFactory.getAddress(),
          data: factoryInterface.encodeFunctionData(factoryInterface.getFunction("deployCounterFactualAccount"), [owner, index])
        };
      }
      // if the wallet is deployed baseGas would be coming as part of struct in rawtx
      async relay(relayTransaction, engine) {
        const socketServerUrl = __classPrivateFieldGet(this, _RestRelayer_socketServerUrl, "f");
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
          await clientMessenger.connect();
          common_1.Logger.log("socket connect success");
        }
        const { config, signedTx, context, gasLimit } = relayTransaction;
        const { isDeployed, address } = config;
        const chainId = signedTx.rawTx.chainId;
        this.setRelayerNodeEthersProvider(chainId);
        const { multiSendCall } = context;
        let finalRawRx;
        if (!isDeployed) {
          const prepareWalletDeploy = {
            config,
            context,
            index: 0
          };
          const { to, data } = this.prepareWalletDeploy(prepareWalletDeploy);
          const txs = [
            {
              to,
              value: 0,
              data,
              operation: 0
            },
            {
              to: address,
              value: 0,
              data: signedTx.rawTx.data || "",
              operation: 0
            }
          ];
          const txnData = multiSendCall.getInterface().encodeFunctionData("multiSend", [(0, MultiSend_1.encodeMultiSend)(txs)]);
          finalRawRx = {
            to: multiSendCall.getAddress(),
            data: txnData,
            chainId: signedTx.rawTx.chainId,
            value: 0
          };
        } else {
          finalRawRx = signedTx.rawTx;
        }
        common_1.Logger.log("finalRawTx", finalRawRx);
        const response = await (0, HttpRequests_1.sendRequest)({
          url: `${__classPrivateFieldGet(this, _RestRelayer_relayServiceBaseUrl, "f")}`,
          method: HttpRequests_1.HttpMethod.Post,
          body: {
            method: "eth_sendSmartContractWalletTransaction",
            params: [
              {
                ...finalRawRx,
                // Could send custom high instead of undefined
                gasLimit: gasLimit ? gasLimit.hex : void 0,
                walletInfo: {
                  address
                },
                refundInfo: {
                  tokenGasPrice: signedTx.tx.gasPrice,
                  gasToken: signedTx.tx.gasToken
                }
              }
            ],
            id: 1234,
            jsonrpc: "2.0"
          }
        });
        if (response.data) {
          const transactionId = response.data.transactionId;
          const connectionUrl = response.data.connectionUrl;
          clientMessenger.createTransactionNotifier(transactionId, {
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onMined: (tx) => {
              const txId = tx.transactionId;
              clientMessenger.unsubscribe(txId);
              common_1.Logger.log("Tx Hash mined message received at client", {
                transactionId: txId,
                hash: tx.transactionHash,
                receipt: tx.receipt
              });
              engine.emit("txMined", {
                msg: "txn mined",
                id: txId,
                hash: tx.transactionHash,
                receipt: tx.receipt
              });
            },
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onHashGenerated: async (tx) => {
              const txHash = tx.transactionHash;
              const txId = tx.transactionId;
              common_1.Logger.log("Tx Hash generated message received at client ", {
                transactionId: txId,
                hash: txHash
              });
              engine.emit("txHashGenerated", {
                id: tx.transactionId,
                hash: tx.transactionHash,
                msg: "txn hash generated"
              });
            },
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onHashChanged: async (tx) => {
              if (tx) {
                const txHash = tx.transactionHash;
                const txId = tx.transactionId;
                common_1.Logger.log("Tx Hash changed message received at client ", {
                  transactionId: txId,
                  hash: txHash
                });
                engine.emit("txHashChanged", {
                  id: tx.transactionId,
                  hash: tx.transactionHash,
                  msg: "txn hash changed"
                });
              }
            },
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onError: async (tx) => {
              common_1.Logger.error("Error message received at client", tx);
              const err = tx.error;
              const txId = tx.transactionId;
              clientMessenger.unsubscribe(txId);
              engine.emit("error", {
                id: tx.transactionId,
                error: err,
                msg: "error in txn"
              });
            }
          });
          return {
            connectionUrl,
            transactionId
          };
        } else {
          return {
            error: response.error || "transaction failed"
          };
        }
      }
      async getFeeOptions(chainId) {
        return (0, HttpRequests_1.sendRequest)({
          url: `${__classPrivateFieldGet(this, _RestRelayer_relayServiceBaseUrl, "f")}/feeOptions?chainId=${chainId}`,
          method: HttpRequests_1.HttpMethod.Get
        });
      }
    };
    exports2.RestRelayer = RestRelayer;
    _RestRelayer_relayServiceBaseUrl = /* @__PURE__ */ new WeakMap(), _RestRelayer_socketServerUrl = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@biconomy/relayer/dist/src/FallbackRelayer.js
var require_FallbackRelayer = __commonJS({
  "node_modules/@biconomy/relayer/dist/src/FallbackRelayer.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver2, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state.set(receiver2, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver2, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _FallbackRelayer_relayServiceBaseUrl;
    var _FallbackRelayer_relayerServiceUrl;
    var _FallbackRelayer_dappAPIKey;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FallbackRelayer = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var common_1 = require_src4();
    var HttpRequests_1 = require_HttpRequests();
    var gasless_messaging_sdk_1 = require_build();
    var isomorphic_ws_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var utils_1 = require_utils();
    var FallbackRelayer = class {
      constructor(options) {
        _FallbackRelayer_relayServiceBaseUrl.set(this, void 0);
        _FallbackRelayer_relayerServiceUrl.set(this, void 0);
        _FallbackRelayer_dappAPIKey.set(this, void 0);
        const { url, relayerServiceUrl, dappAPIKey } = options;
        this.relayerNodeEthersProvider = {};
        __classPrivateFieldSet(this, _FallbackRelayer_relayServiceBaseUrl, url, "f");
        __classPrivateFieldSet(this, _FallbackRelayer_relayerServiceUrl, relayerServiceUrl, "f");
        __classPrivateFieldSet(this, _FallbackRelayer_dappAPIKey, dappAPIKey, "f");
      }
      setRelayerNodeEthersProvider(chainId) {
        if (!this.relayerNodeEthersProvider[chainId]) {
          this.relayerNodeEthersProvider[chainId] = new ethers_1.ethers.providers.JsonRpcProvider(__classPrivateFieldGet(this, _FallbackRelayer_relayServiceBaseUrl, "f"), {
            name: "Not actually connected to network, only talking to the Relayer!",
            chainId
          });
        }
      }
      async relay(relayTransaction, engine) {
        const relayerServiceUrl = __classPrivateFieldGet(this, _FallbackRelayer_relayerServiceUrl, "f");
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(relayerServiceUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
          try {
            await clientMessenger.connect();
            common_1.Logger.log("socket connection success");
          } catch (err) {
            common_1.Logger.error("socket connection failure", err);
          }
        }
        const { config, signedTx, gasLimit } = relayTransaction;
        const { address } = config;
        const finalRawRx = signedTx.rawTx;
        const response = await (0, HttpRequests_1.sendRequest)({
          url: `${__classPrivateFieldGet(this, _FallbackRelayer_relayServiceBaseUrl, "f")}`,
          method: HttpRequests_1.HttpMethod.Post,
          body: {
            method: "eth_sendGaslessFallbackTransaction",
            params: [
              {
                ...finalRawRx,
                gasLimit: (gasLimit === null || gasLimit === void 0 ? void 0 : gasLimit.hex) || "",
                walletInfo: {
                  address
                },
                metaData: {
                  dappAPIKey: __classPrivateFieldGet(this, _FallbackRelayer_dappAPIKey, "f")
                }
              }
            ],
            id: 1234,
            jsonrpc: "2.0"
          }
        });
        common_1.Logger.log("rest relayer: ", response);
        if (response.data) {
          const transactionId = response.data.transactionId;
          const waitPromise = new Promise((resolve, reject) => {
            if (clientMessenger && clientMessenger.socketClient.isConnected()) {
              clientMessenger.createTransactionNotifier(transactionId, {
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onMined: (tx) => {
                  const txId = tx.transactionId;
                  clientMessenger.unsubscribe(txId);
                  common_1.Logger.log("Tx Hash mined message received at client", {
                    transactionId: txId,
                    hash: tx.transactionHash,
                    receipt: tx.receipt
                  });
                  const receipt = tx.receipt;
                  engine && engine.emit("txMined", {
                    msg: "txn mined",
                    id: txId,
                    hash: tx.transactionHash,
                    receipt: tx.receipt
                  });
                  resolve(receipt);
                },
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onError: async (err) => {
                  reject(err);
                }
              });
            }
          });
          clientMessenger.createTransactionNotifier(transactionId, {
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onMined: (tx) => {
              const txId = tx.transactionId;
              clientMessenger.unsubscribe(txId);
              common_1.Logger.log("Tx Hash mined message received at client", {
                transactionId: txId,
                hash: tx.transactionHash,
                receipt: tx.receipt
              });
              engine.emit("txMined", {
                msg: "txn mined",
                id: txId,
                hash: tx.transactionHash,
                receipt: tx.receipt
              });
            },
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onHashGenerated: async (tx) => {
              const txHash = tx.transactionHash;
              const txId = tx.transactionId;
              common_1.Logger.log("Tx Hash generated message received at client", {
                transactionId: txId,
                hash: txHash
              });
              common_1.Logger.log(`Receive time for transaction id ${txId}: ${Date.now()}`);
              engine.emit("txHashGenerated", {
                id: tx.transactionId,
                hash: tx.transactionHash,
                msg: "txn hash generated"
              });
            },
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onHashChanged: async (tx) => {
              if (tx) {
                const txHash = tx.transactionHash;
                const txId = tx.transactionId;
                common_1.Logger.log("Tx Hash changed message received at client", {
                  transactionId: txId,
                  hash: txHash
                });
                engine.emit("txHashChanged", {
                  id: tx.transactionId,
                  hash: tx.transactionHash,
                  msg: "txn hash changed"
                });
              }
            },
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            onError: async (tx) => {
              common_1.Logger.error("Error message received at client", tx);
              const err = tx.error;
              const txId = tx.transactionId;
              clientMessenger.unsubscribe(txId);
              engine.emit("error", {
                id: tx.transactionId,
                error: err,
                msg: "error in txn"
              });
            }
          });
          return {
            hash: transactionId,
            confirmations: 0,
            from: signedTx.rawTx.from || "",
            nonce: Number(signedTx.rawTx.nonce),
            gasLimit: ethers_1.BigNumber.from(signedTx.rawTx.gasLimit || 0),
            value: ethers_1.BigNumber.from(0),
            data: (0, utils_1.hexValue)(signedTx.rawTx.data || "0x"),
            chainId: signedTx.rawTx.chainId,
            wait: async (confirmations) => {
              common_1.Logger.log("wait confirmations", confirmations);
              const transactionReceipt = waitPromise.then((receipt) => {
                return receipt;
              });
              return transactionReceipt;
            }
          };
        } else {
          throw new Error(response.error || "transaction failed");
        }
      }
    };
    exports2.FallbackRelayer = FallbackRelayer;
    _FallbackRelayer_relayServiceBaseUrl = /* @__PURE__ */ new WeakMap(), _FallbackRelayer_relayerServiceUrl = /* @__PURE__ */ new WeakMap(), _FallbackRelayer_dappAPIKey = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@biconomy/relayer/dist/src/index.js
var require_src5 = __commonJS({
  "node_modules/@biconomy/relayer/dist/src/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_LocalRelayer(), exports2);
    __exportStar(require_RestRelayer(), exports2);
    __exportStar(require_FallbackRelayer(), exports2);
  }
});

// node_modules/@biconomy/transactions/dist/src/assets/index.js
var require_assets = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/assets/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GasEstimator = exports2.WalletFactory = exports2.SmartWallet = exports2.MultiSendCallOnly = exports2.MultiSend = void 0;
    exports2.MultiSend = {
      defaultAddress: "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
      released: true,
      contractName: "MultiSend",
      version: "1.0.1",
      networkAddresses: {
        "1": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "4": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "5": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "42": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "88": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "100": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "246": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "73799": "0xF9DC4a9B8b551f693a10EcB5F931fE2E1a9156f0",
        "31338": "0x1A3F36c656Da24c18C703B8c2d1829F5D32E8E49"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
    exports2.MultiSendCallOnly = {
      defaultAddress: "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
      released: true,
      contractName: "MultiSendCallOnly",
      version: "1.0.1",
      networkAddresses: {
        "1": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "4": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "5": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "42": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "88": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "100": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "246": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "73799": "0xa72E2c9EC14DDee494F551AAe9885158105F809c",
        "31338": "0x1A3F36c656Da24c18C703B8c2d1829F5D32E8E49"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
    exports2.SmartWallet = {
      defaultAddress: "0x056DcE811A2b695171274855E7246039Df298158",
      released: true,
      contractName: "SmartWallet",
      version: "1.0.1",
      networkAddresses: {
        "1": "0x056DcE811A2b695171274855E7246039Df298158",
        "4": "0x056DcE811A2b695171274855E7246039Df298158",
        "5": "0x056DcE811A2b695171274855E7246039Df298158",
        "42": "0x056DcE811A2b695171274855E7246039Df298158",
        "100": "0x056DcE811A2b695171274855E7246039Df298158",
        "31338": "0x0ba464506a3D66C962121e3C25ed56678A2585B6"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "_scw",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "_oldEOA",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "_newEOA",
              type: "address"
            }
          ],
          name: "EOAChanged",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "oldEntryPoint",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "newEntryPoint",
              type: "address"
            }
          ],
          name: "EntryPointChanged",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "newImplementation",
              type: "address"
            }
          ],
          name: "ImplementationUpdated",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint8",
              name: "version",
              type: "uint8"
            }
          ],
          name: "Initialized",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "to",
                  type: "address"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "data",
                  type: "bytes"
                },
                {
                  internalType: "enum Enum.Operation",
                  name: "operation",
                  type: "uint8"
                },
                {
                  internalType: "uint256",
                  name: "targetTxGas",
                  type: "uint256"
                }
              ],
              internalType: "struct WalletStorage.Transaction",
              name: "_tx",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "baseGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "gasPrice",
                  type: "uint256"
                },
                {
                  internalType: "address",
                  name: "gasToken",
                  type: "address"
                },
                {
                  internalType: "address payable",
                  name: "refundReceiver",
                  type: "address"
                }
              ],
              internalType: "struct WalletStorage.FeeRefund",
              name: "refundInfo",
              type: "tuple"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "entryPoint",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "dest",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "func",
              type: "bytes"
            }
          ],
          name: "exec",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "dest",
              type: "address[]"
            },
            {
              internalType: "bytes[]",
              name: "func",
              type: "bytes[]"
            }
          ],
          name: "execBatch",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "dest",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "func",
              type: "bytes"
            }
          ],
          name: "execFromEntryPoint",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "to",
                  type: "address"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "data",
                  type: "bytes"
                },
                {
                  internalType: "enum Enum.Operation",
                  name: "operation",
                  type: "uint8"
                },
                {
                  internalType: "uint256",
                  name: "targetTxGas",
                  type: "uint256"
                }
              ],
              internalType: "struct WalletStorage.Transaction",
              name: "_tx",
              type: "tuple"
            },
            {
              internalType: "uint256",
              name: "batchId",
              type: "uint256"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "baseGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "gasPrice",
                  type: "uint256"
                },
                {
                  internalType: "address",
                  name: "gasToken",
                  type: "address"
                },
                {
                  internalType: "address payable",
                  name: "refundReceiver",
                  type: "address"
                }
              ],
              internalType: "struct WalletStorage.FeeRefund",
              name: "refundInfo",
              type: "tuple"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "batchId",
              type: "uint256"
            }
          ],
          name: "getNonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "targetTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_owner",
              type: "address"
            },
            {
              internalType: "address",
              name: "_entryPoint",
              type: "address"
            },
            {
              internalType: "address",
              name: "_handler",
              type: "address"
            }
          ],
          name: "init",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          name: "nonces",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "owner",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "token",
              type: "address"
            },
            {
              internalType: "address",
              name: "dest",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "pullTokens",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_newOwner",
              type: "address"
            }
          ],
          name: "setOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "interfaceId",
              type: "bytes4"
            }
          ],
          name: "supportsInterface",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address payable",
              name: "dest",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "transfer",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_entryPoint",
              type: "address"
            }
          ],
          name: "updateEntryPoint",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_implementation",
              type: "address"
            }
          ],
          name: "updateImplementation",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "uint256",
                  name: "nonce",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "initCode",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "callData",
                  type: "bytes"
                },
                {
                  internalType: "uint256",
                  name: "callGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "verificationGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "preVerificationGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxPriorityFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "address",
                  name: "paymaster",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "paymasterData",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                }
              ],
              internalType: "struct UserOperation",
              name: "userOp",
              type: "tuple"
            },
            {
              internalType: "bytes32",
              name: "requestId",
              type: "bytes32"
            },
            {
              internalType: "uint256",
              name: "requiredPrefund",
              type: "uint256"
            }
          ],
          name: "validateUserOp",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
    exports2.WalletFactory = {
      defaultAddress: "0x050bca32264195976Fe00BcA566B548413A9E658",
      released: true,
      contractName: "WalletFactory",
      version: "1.0.1",
      networkAddresses: {
        "1": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "4": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "5": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "42": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "88": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "100": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "246": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "73799": "0x050bca32264195976Fe00BcA566B548413A9E658",
        "31338": "0x85c0995669f8a0173a5B5F6003DA060E8D17f0c3"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "address",
              name: "_baseImpl",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "_proxy",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "_implementation",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "_owner",
              type: "address"
            }
          ],
          name: "WalletCreated",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_owner",
              type: "address"
            },
            {
              internalType: "address",
              name: "_entryPoint",
              type: "address"
            },
            {
              internalType: "address",
              name: "_handler",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_index",
              type: "uint256"
            }
          ],
          name: "deployCounterFactualWallet",
          outputs: [
            {
              internalType: "address",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_owner",
              type: "address"
            },
            {
              internalType: "address",
              name: "_entryPoint",
              type: "address"
            },
            {
              internalType: "address",
              name: "_handler",
              type: "address"
            }
          ],
          name: "deployWallet",
          outputs: [
            {
              internalType: "address",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_index",
              type: "uint256"
            }
          ],
          name: "getAddressForCounterFactualWallet",
          outputs: [
            {
              internalType: "address",
              name: "_wallet",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          name: "isWalletExist",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ]
    };
    exports2.GasEstimator = {
      defaultAddress: "0xc6e8748a08e591250a3eed526e9455859633c6c4",
      released: true,
      contractName: "WalletFactory",
      version: "1.0.1",
      networkAddresses: {
        "5": "0xc6e8748a08e591250a3eed526e9455859633c6c4"
      },
      abi: [
        {
          inputs: [
            { internalType: "address", name: "_to", type: "address" },
            { internalType: "bytes", name: "_data", type: "bytes" }
          ],
          name: "estimate",
          outputs: [
            { internalType: "bool", name: "success", type: "bool" },
            { internalType: "bytes", name: "result", type: "bytes" },
            { internalType: "uint256", name: "gas", type: "uint256" }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@biconomy/transactions/dist/src/Estimator.js
var require_Estimator = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/Estimator.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Estimator = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var assets_1 = require_assets();
    var core_types_1 = require_src3();
    var common_1 = require_src4();
    var Estimator = class {
      // Note: Smart account state should Not be part of constructor
      constructor(nodeClient, contractUtils) {
        this.nodeClient = nodeClient;
        this.contractUtils = contractUtils;
      }
      async estimateTransaction(prepareTransactionDto, createdTransaction, smartAccountState) {
        const { chainId, version } = prepareTransactionDto;
        let estimatedGasUsed = 0;
        const isDeployed = await this.contractUtils.isDeployed(
          chainId,
          smartAccountState.address
          // SmartAccountState
        );
        if (!isDeployed) {
          const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
            chainId,
            version,
            owner: smartAccountState.owner
          });
          common_1.Logger.log("estimateWalletDeployment ", estimateWalletDeployment);
          estimatedGasUsed += estimateWalletDeployment;
        }
        const txn = {
          to: createdTransaction.to,
          value: createdTransaction.value,
          data: createdTransaction.data,
          operation: createdTransaction.operation,
          targetTxGas: createdTransaction.targetTxGas
        };
        txn.targetTxGas = 5e5;
        const refundInfo = {
          baseGas: createdTransaction.baseGas,
          gasPrice: createdTransaction.gasPrice,
          tokenGasPriceFactor: createdTransaction.tokenGasPriceFactor,
          gasToken: createdTransaction.gasToken,
          refundReceiver: createdTransaction.refundReceiver
        };
        const estimateUndeployedContractGasDto = {
          chainId,
          version,
          transaction: txn,
          walletAddress: smartAccountState.address,
          feeRefund: refundInfo,
          signature: core_types_1.FAKE_SIGNATURE
        };
        const ethCallOverrideResponse = await this.nodeClient.estimateUndeployedContractGas(estimateUndeployedContractGasDto);
        const noAuthEstimate = Number(ethCallOverrideResponse.data.gas) + Number(ethCallOverrideResponse.data.txBaseGas);
        common_1.Logger.warn("no auth no refund estimate", noAuthEstimate);
        estimatedGasUsed += noAuthEstimate;
        return estimatedGasUsed;
      }
      async estimateTransactionBatch(getFeeQuotesForBatchDto, createdTransaction, smartAccountState) {
        const { chainId, version } = getFeeQuotesForBatchDto;
        let estimatedGasUsed = 0;
        const isDeployed = await this.contractUtils.isDeployed(chainId, smartAccountState.address);
        if (!isDeployed) {
          const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
            chainId,
            version,
            owner: smartAccountState.owner
          });
          common_1.Logger.log("estimateWalletDeployment ", estimateWalletDeployment);
          estimatedGasUsed += estimateWalletDeployment;
        }
        const txn = {
          to: createdTransaction.to,
          value: createdTransaction.value,
          data: createdTransaction.data,
          operation: createdTransaction.operation,
          targetTxGas: createdTransaction.targetTxGas
        };
        txn.targetTxGas = 5e5;
        const refundInfo = {
          baseGas: createdTransaction.baseGas,
          gasPrice: createdTransaction.gasPrice,
          tokenGasPriceFactor: createdTransaction.tokenGasPriceFactor,
          gasToken: createdTransaction.gasToken,
          refundReceiver: createdTransaction.refundReceiver
        };
        const estimateUndeployedContractGasDto = {
          chainId,
          version,
          transaction: txn,
          walletAddress: smartAccountState.address,
          feeRefund: refundInfo,
          signature: core_types_1.FAKE_SIGNATURE
        };
        const ethCallOverrideResponse = await this.nodeClient.estimateUndeployedContractGas(estimateUndeployedContractGasDto);
        const noAuthEstimate = Number(ethCallOverrideResponse.data.gas) + Number(ethCallOverrideResponse.data.txBaseGas);
        common_1.Logger.log("no auth no refund estimate", noAuthEstimate);
        estimatedGasUsed += noAuthEstimate;
        return estimatedGasUsed;
      }
      // Generic function to estimate gas used for any contract call
      async estimateGasUsed(target, data, chainId) {
        const estimatorInterface = new ethers_1.ethers.utils.Interface(assets_1.GasEstimator.abi);
        const encodedEstimateData = estimatorInterface.encodeFunctionData("estimate", [target, data]);
        const estimateGasUsedResponse = await this.nodeClient.estimateExternalGas({
          chainId,
          encodedData: encodedEstimateData
        });
        return Number(estimateGasUsedResponse.data.gas);
      }
      async estimateSmartAccountDeployment(estimateSmartAccountDeploymentDto) {
        const estimatorInterface = new ethers_1.ethers.utils.Interface(assets_1.GasEstimator.abi);
        const { chainId, version, owner } = estimateSmartAccountDeploymentDto;
        const walletFactoryInterface = this.contractUtils.smartWalletFactoryContract[chainId][version].getInterface();
        const encodedEstimateData = estimatorInterface.encodeFunctionData("estimate", [
          this.contractUtils.smartWalletFactoryContract[chainId][version].getAddress(),
          walletFactoryInterface.encodeFunctionData("deployCounterFactualAccount", [owner, 0])
        ]);
        common_1.Logger.log("encodedEstimate ", encodedEstimateData);
        const deployCostresponse = await this.nodeClient.estimateExternalGas({
          chainId,
          encodedData: encodedEstimateData
        });
        const estimateWalletDeployment = Number(deployCostresponse.data.gas);
        common_1.Logger.log("estimateWalletDeployment ", estimateWalletDeployment);
        return estimateWalletDeployment;
      }
    };
    exports2.Estimator = Estimator;
  }
});

// node_modules/@biconomy/transactions/dist/src/Utils.js
var require_Utils = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/Utils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utils = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var constants_1 = (init_lib8(), __toCommonJS(lib_exports8));
    var common_1 = require_src4();
    var Utils = class {
      constructor() {
        this.buildSmartAccountTransaction = (template) => {
          return {
            to: template.to,
            value: template.value || 0,
            data: template.data || "0x",
            operation: template.operation || 0,
            targetTxGas: template.targetTxGas || 0,
            baseGas: template.baseGas || 0,
            gasPrice: template.gasPrice || 0,
            tokenGasPriceFactor: template.tokenGasPriceFactor || 1,
            gasToken: template.gasToken || constants_1.AddressZero,
            refundReceiver: template.refundReceiver || constants_1.AddressZero,
            nonce: template.nonce
          };
        };
        this.buildSmartAccountTransactions = (transactions) => {
          const txs = [];
          for (let i = 0; i < transactions.length; i++) {
            const innerTx = this.buildSmartAccountTransaction({
              to: transactions[i].to,
              value: transactions[i].value,
              data: transactions[i].data,
              nonce: 0
            });
            txs.push(innerTx);
          }
          return txs;
        };
        this.buildMultiSendSmartAccountTx = (multiSend, txs, nonce, overrides) => {
          return this.buildContractCall(multiSend, "multiSend", [this.encodeMultiSend(txs)], nonce, true, overrides);
        };
        this.buildMultiSendTx = (multiSend, txs, nonce, delegateCall) => {
          const data = multiSend.interface.encodeFunctionData("multiSend", [this.encodeMultiSend(txs)]);
          return this.buildSmartAccountTransaction(Object.assign({
            to: multiSend.address,
            data,
            operation: delegateCall ? 1 : 0,
            nonce
          }));
        };
        this.encodeMultiSend = (txs) => {
          return "0x" + txs.map((tx) => this.encodeMetaTransaction(tx)).join("");
        };
        this.encodeMetaTransaction = (tx) => {
          const data = ethers_1.utils.arrayify(tx.data);
          const encoded = ethers_1.utils.solidityPack(["uint8", "address", "uint256", "uint256", "bytes"], [tx.operation, tx.to, tx.value, data.length, data]);
          return encoded.slice(2);
        };
        this.buildContractCall = (contract, method, params, nonce, delegateCall, overrides) => {
          const data = contract.interface.encodeFunctionData(method, params);
          return this.buildSmartAccountTransaction(Object.assign({
            to: contract.address,
            data,
            operation: delegateCall ? 1 : 0,
            nonce
          }, overrides));
        };
        common_1.Logger.log("Utils initialized");
      }
    };
    exports2.Utils = Utils;
  }
});

// node_modules/@biconomy/transactions/dist/src/TransactionManager.js
var require_TransactionManager = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/TransactionManager.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_types_1 = require_src3();
    var Estimator_1 = require_Estimator();
    var common_1 = require_src4();
    var Utils_1 = require_Utils();
    var TransactionManager = class {
      constructor(smartAccountState) {
        this.smartAccountState = smartAccountState;
        this.utils = new Utils_1.Utils();
      }
      // smart account config and context
      async initialize(relayer, nodeClient, contractUtils) {
        this.nodeClient = nodeClient;
        this.contractUtils = contractUtils;
        this.relayer = relayer;
        this.estimator = new Estimator_1.Estimator(this.nodeClient, this.contractUtils);
      }
      setRelayer(relayer) {
        this.relayer = relayer;
        return this;
      }
      getContractUtilInstance() {
        return this.contractUtils;
      }
      getEstimatorInstance() {
        return this.estimator;
      }
      // review return type
      getNodeClient() {
        return this.nodeClient;
      }
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is without fee refund (gasless)
       * @param transactionDto
       * @returns
       */
      async createTransaction(transactionDto) {
        const { transaction, chainId, version } = transactionDto;
        const batchId = 1;
        const multiSendContract = this.contractUtils.multiSendContract[chainId][version].getContract();
        const isDelegate = transactionDto.transaction.to === multiSendContract.address ? true : false;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        walletContract = walletContract.attach(smartAccountState.address);
        let nonce = 0;
        if (await this.contractUtils.isDeployed(chainId, smartAccountState.address)) {
          nonce = (await walletContract.getNonce(batchId)).toNumber();
        }
        common_1.Logger.log("nonce: ", nonce);
        const operation = isDelegate ? 1 : 0;
        const walletTx = this.utils.buildSmartAccountTransaction({
          to: transaction.to,
          value: transaction.value,
          data: transaction.data,
          nonce,
          operation
        });
        return walletTx;
      }
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is without fee refund (gasless)
       * @param transaction
       * @param chainId
       * @returns
       */
      async createTransactionBatch(transactionBatchDto) {
        const { transactions, chainId, version } = transactionBatchDto;
        const batchId = 1;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        walletContract = walletContract.attach(smartAccountState.address);
        let nonce = 0;
        if (await this.contractUtils.isDeployed(chainId, smartAccountState.address)) {
          nonce = (await walletContract.getNonce(batchId)).toNumber();
        }
        common_1.Logger.log("nonce: ", nonce);
        const txs = [];
        for (let i = 0; i < transactions.length; i++) {
          const innerTx = this.utils.buildSmartAccountTransaction({
            to: transactions[i].to,
            value: transactions[i].value,
            data: transactions[i].data,
            nonce: 0
          });
          txs.push(innerTx);
        }
        const walletTx = this.utils.buildMultiSendSmartAccountTx(this.contractUtils.multiSendContract[chainId][version].getContract(), txs, nonce);
        common_1.Logger.log("wallet txn without refund ", walletTx);
        return walletTx;
      }
      async estimateTransaction(prepareTransactionDto) {
        const { transaction, chainId, version } = prepareTransactionDto;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        const tx = await this.createTransaction({ version, transaction, chainId });
        const estimatedGasUsed = await this.estimator.estimateTransaction(prepareTransactionDto, tx, smartAccountState);
        return estimatedGasUsed;
      }
      // Get Fee Options from relayer and make it available for display
      // We can also show list of transactions to be processed (decodeContractCall)
      /**
       *
       * @param getFeeQuotesDto
       */
      async getFeeQuotes(getFeeQuotesDto) {
        const { transaction, chainId, version } = getFeeQuotesDto;
        const gasPriceQuotesResponse = await this.relayer.getFeeOptions(chainId);
        const feeOptionsAvailable = gasPriceQuotesResponse.data.response;
        const feeQuotes = [];
        const estimatedGasUsed = await this.estimateTransaction({
          version,
          transaction,
          chainId
        });
        feeOptionsAvailable.forEach((feeOption) => {
          const feeTokenTransferGas = feeOption.feeTokenTransferGas;
          const tokenGasPrice = feeOption.tokenGasPrice || 0;
          const offset = feeOption.offset || 1;
          const payment = tokenGasPrice * (estimatedGasUsed + feeTokenTransferGas) / offset;
          const feeQuote = {
            symbol: feeOption.symbol,
            address: feeOption.address,
            decimal: feeOption.decimal,
            logoUrl: feeOption.logoUrl,
            tokenGasPrice: feeOption.tokenGasPrice,
            offset: feeOption.offset,
            payment,
            refundReceiver: feeOption.refundReceiver
          };
          feeQuotes.push(feeQuote);
        });
        return feeQuotes;
      }
      async estimateTransactionBatch(getFeeQuotesForBatchDto) {
        const { transactions, chainId, version } = getFeeQuotesForBatchDto;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        const tx = await this.createTransactionBatch({
          version,
          transactions,
          chainId
        });
        const estimatedGasUsed = await this.estimator.estimateTransactionBatch(getFeeQuotesForBatchDto, tx, smartAccountState);
        return estimatedGasUsed;
      }
      // Get Fee Options from relayer and make it available for display
      // We can also show list of transactions to be processed (decodeContractCall)
      /**
       *
       * @param getFeeQuotesForBatchDto
       */
      async getFeeQuotesForBatch(getFeeQuotesForBatchDto) {
        const { transactions, chainId, version } = getFeeQuotesForBatchDto;
        const gasPriceQuotesResponse = await this.relayer.getFeeOptions(chainId);
        const feeOptionsAvailable = gasPriceQuotesResponse.data.response;
        const feeQuotes = [];
        const estimatedGasUsed = await this.estimateTransactionBatch({
          version,
          transactions,
          chainId
        });
        feeOptionsAvailable.forEach((feeOption) => {
          const feeTokenTransferGas = feeOption.feeTokenTransferGas;
          const tokenGasPrice = feeOption.tokenGasPrice || 0;
          const offset = feeOption.offset || 1;
          const payment = tokenGasPrice * (estimatedGasUsed + feeTokenTransferGas) / offset;
          const feeQuote = {
            symbol: feeOption.symbol,
            address: feeOption.address,
            decimal: feeOption.decimal,
            logoUrl: feeOption.logoUrl,
            tokenGasPrice: feeOption.tokenGasPrice,
            offset: feeOption.offset,
            payment,
            refundReceiver: feeOption.refundReceiver
          };
          feeQuotes.push(feeQuote);
        });
        return feeQuotes;
      }
      async estimateSmartAccountDeployment(estimateSmartAccountDeploymentDto) {
        const estimateWalletDeployment = await this.estimator.estimateSmartAccountDeployment(estimateSmartAccountDeploymentDto);
        return estimateWalletDeployment;
      }
      async estimateGasUsed(target, data, chainId) {
        const gasUsed = await this.estimator.estimateGasUsed(target, data, chainId);
        return gasUsed;
      }
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
       * @param createUserPaidTransactionDto
       * @returns
       */
      async createUserPaidTransaction(createUserPaidTransactionDto) {
        const { transaction, feeQuote, chainId, version } = createUserPaidTransactionDto;
        const batchId = 1;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        walletContract = walletContract.attach(smartAccountState.address);
        let additionalBaseGas = 0;
        let nonce = 0;
        const isDeployed = await this.contractUtils.isDeployed(chainId, smartAccountState.address);
        if (isDeployed) {
          nonce = (await walletContract.getNonce(batchId)).toNumber();
        } else {
          const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
            chainId,
            version,
            owner: smartAccountState.owner
          });
          additionalBaseGas += estimateWalletDeployment;
        }
        common_1.Logger.log("nonce: ", nonce);
        const internalTx = {
          to: transaction.to,
          value: transaction.value || 0,
          data: transaction.data || "0x",
          operation: core_types_1.OperationType.Call
        };
        common_1.Logger.log("internalTx: ", internalTx);
        let targetTxGas, baseGas, handlePaymentEstimate;
        const regularOffSet = core_types_1.GAS_USAGE_OFFSET;
        if (!isDeployed) {
          const estimateRequiredTxGas = {
            chainId,
            walletAddress: smartAccountState.address,
            transaction: internalTx
          };
          const response = await this.nodeClient.estimateRequiredTxGasOverride(estimateRequiredTxGas);
          const requiredTxGasEstimate = Number(response.data.gas) + 7e5;
          common_1.Logger.log("required txgas estimate (with override) ", requiredTxGasEstimate);
          targetTxGas = requiredTxGasEstimate;
          const refundDetails = {
            gasUsed: requiredTxGasEstimate,
            baseGas: requiredTxGasEstimate,
            gasPrice: feeQuote.tokenGasPrice,
            tokenGasPriceFactor: feeQuote.offset || 1,
            gasToken: feeQuote.address,
            refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
          };
          const estimateHandlePaymentGas = {
            chainId,
            version,
            walletAddress: smartAccountState.address,
            feeRefund: refundDetails
          };
          const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGasOverride(estimateHandlePaymentGas);
          handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
          common_1.Logger.log("handlePaymentEstimate (with override) ", handlePaymentEstimate);
          baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas;
        } else {
          const estimateRequiredTxGas = {
            chainId,
            walletAddress: smartAccountState.address,
            transaction: internalTx
          };
          const response = await this.nodeClient.estimateRequiredTxGas(estimateRequiredTxGas);
          const requiredTxGasEstimate = Number(response.data.gas) + 3e4;
          common_1.Logger.log("required txgas estimate ", requiredTxGasEstimate);
          targetTxGas = requiredTxGasEstimate;
          const refundDetails = {
            gasUsed: requiredTxGasEstimate,
            baseGas: requiredTxGasEstimate,
            gasPrice: feeQuote.tokenGasPrice,
            tokenGasPriceFactor: feeQuote.offset || 1,
            gasToken: feeQuote.address,
            refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
          };
          const estimateHandlePaymentGas = {
            chainId,
            version,
            walletAddress: smartAccountState.address,
            feeRefund: refundDetails
          };
          const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGas(estimateHandlePaymentGas);
          handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
          common_1.Logger.log("handlePaymentEstimate ", handlePaymentEstimate);
          baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas;
        }
        const walletTx = this.utils.buildSmartAccountTransaction({
          to: transaction.to,
          value: transaction.value,
          data: transaction.data,
          targetTxGas,
          baseGas,
          refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS,
          gasPrice: feeQuote.tokenGasPrice.toString(),
          tokenGasPriceFactor: feeQuote.offset || 1,
          gasToken: feeQuote.address,
          nonce
        });
        return walletTx;
      }
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
       * @param createUserPaidTransactionBatchDto
       * @returns
       */
      async createUserPaidTransactionBatch(createUserPaidTransactionBatchDto) {
        const { transactions, feeQuote, chainId, version } = createUserPaidTransactionBatchDto;
        const batchId = 1;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        const connectedWallet = smartAccountState.address;
        walletContract = walletContract.attach(connectedWallet);
        const isDeployed = smartAccountState.isDeployed;
        let additionalBaseGas = 0;
        let nonce = 0;
        if (isDeployed) {
          nonce = (await walletContract.getNonce(batchId)).toNumber();
        } else {
          const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
            chainId,
            version,
            owner: smartAccountState.owner
          });
          common_1.Logger.log("estimateWalletDeployment ", estimateWalletDeployment);
          additionalBaseGas += estimateWalletDeployment;
        }
        common_1.Logger.log("nonce: ", nonce);
        const txs = this.utils.buildSmartAccountTransactions(transactions);
        const walletTx = this.utils.buildMultiSendSmartAccountTx(this.contractUtils.multiSendContract[chainId][version].getContract(), txs, nonce);
        common_1.Logger.log("wallet txn with refund ", walletTx);
        const internalTx = {
          to: walletTx.to,
          value: walletTx.value || 0,
          data: walletTx.data || "0x",
          operation: walletTx.operation
        };
        common_1.Logger.log("internalTx ", internalTx);
        let targetTxGas, baseGas;
        const regularOffSet = core_types_1.GAS_USAGE_OFFSET;
        if (!isDeployed) {
          const estimateRequiredTxGas = {
            chainId,
            walletAddress: smartAccountState.address,
            transaction: internalTx
          };
          const response = await this.nodeClient.estimateRequiredTxGasOverride(estimateRequiredTxGas);
          const requiredTxGasEstimate = Number(response.data.gas) + 7e5;
          common_1.Logger.log("required txgas estimate (with override) ", requiredTxGasEstimate);
          targetTxGas = requiredTxGasEstimate;
          const refundDetails = {
            gasUsed: requiredTxGasEstimate,
            baseGas: requiredTxGasEstimate,
            gasPrice: feeQuote.tokenGasPrice,
            tokenGasPriceFactor: feeQuote.offset || 1,
            gasToken: feeQuote.address,
            refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
          };
          const estimateHandlePaymentGas = {
            chainId,
            version,
            walletAddress: smartAccountState.address,
            feeRefund: refundDetails
          };
          const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGasOverride(estimateHandlePaymentGas);
          const handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
          common_1.Logger.log("handlePaymentEstimate (with override) ", handlePaymentEstimate);
          baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas;
        } else {
          const estimateRequiredTxGas = {
            chainId,
            walletAddress: smartAccountState.address,
            transaction: internalTx
          };
          const response = await this.nodeClient.estimateRequiredTxGas(estimateRequiredTxGas);
          const requiredTxGasEstimate = Number(response.data.gas) + 3e4;
          common_1.Logger.log("required txgas estimate ", requiredTxGasEstimate);
          targetTxGas = requiredTxGasEstimate;
          const refundDetails = {
            gasUsed: requiredTxGasEstimate,
            baseGas: requiredTxGasEstimate,
            gasPrice: feeQuote.tokenGasPrice,
            tokenGasPriceFactor: feeQuote.offset || 1,
            gasToken: feeQuote.address,
            refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
          };
          const estimateHandlePaymentGas = {
            chainId,
            version,
            walletAddress: smartAccountState.address,
            feeRefund: refundDetails
          };
          const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGas(estimateHandlePaymentGas);
          const handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
          common_1.Logger.log("handlePaymentEstimate ", handlePaymentEstimate);
          baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas;
        }
        const finalWalletTx = this.utils.buildSmartAccountTransaction({
          to: walletTx.to,
          value: walletTx.value,
          data: walletTx.data,
          operation: walletTx.operation,
          targetTxGas,
          baseGas,
          refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS,
          gasPrice: feeQuote.tokenGasPrice.toString(),
          tokenGasPriceFactor: feeQuote.offset || 1,
          gasToken: feeQuote.address,
          nonce
        });
        return finalWalletTx;
      }
      ethersAdapter(chainId) {
        return this.contractUtils.ethAdapter[chainId];
      }
    };
    exports2.default = TransactionManager;
  }
});

// node_modules/@biconomy/transactions/dist/src/utils/FetchContractsInfo.js
var require_FetchContractsInfo = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/utils/FetchContractsInfo.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findContractAddressesByVersion = exports2.findChainById = exports2.getDefaultCallbackHandlerContract = exports2.getFallbackGasTankContract = exports2.getSmartWalletContract = exports2.getMultiSendCallOnlyContract = exports2.getMultiSendContract = exports2.getSmartWalletFactoryContract = void 0;
    function getSmartWalletFactoryContract(smartAccountVersion, ethAdapter, address) {
      return ethAdapter.getSmartWalletFactoryContract(smartAccountVersion, address);
    }
    exports2.getSmartWalletFactoryContract = getSmartWalletFactoryContract;
    function getMultiSendContract(smartAccountVersion, ethAdapter, address) {
      return ethAdapter.getMultiSendContract(smartAccountVersion, address);
    }
    exports2.getMultiSendContract = getMultiSendContract;
    function getMultiSendCallOnlyContract(smartAccountVersion, ethAdapter, address) {
      return ethAdapter.getMultiSendCallOnlyContract(smartAccountVersion, address);
    }
    exports2.getMultiSendCallOnlyContract = getMultiSendCallOnlyContract;
    function getSmartWalletContract(smartAccountVersion, ethAdapter, address) {
      return ethAdapter.getSmartWalletContract(smartAccountVersion, address);
    }
    exports2.getSmartWalletContract = getSmartWalletContract;
    function getFallbackGasTankContract(smartAccountVersion, ethAdapter, address) {
      return ethAdapter.getFallbackGasTankContract(smartAccountVersion, address);
    }
    exports2.getFallbackGasTankContract = getFallbackGasTankContract;
    function getDefaultCallbackHandlerContract(smartAccountVersion, ethAdapter, address) {
      return ethAdapter.getDefaultCallbackHandlerContract(smartAccountVersion, address);
    }
    exports2.getDefaultCallbackHandlerContract = getDefaultCallbackHandlerContract;
    function findChainById(chainId, chainConfig) {
      const currentChainInfo = chainConfig.find((n) => {
        return n.chainId === chainId;
      });
      if (currentChainInfo)
        return currentChainInfo;
      throw new Error("Chain Not Found");
    }
    exports2.findChainById = findChainById;
    function findContractAddressesByVersion(smartAccountVersion, chainId, chainConfig) {
      var _a, _b, _c, _d, _e, _f;
      const chainInfo = findChainById(chainId, chainConfig);
      const entryPointAddress = (_a = chainInfo.entryPoint.find((element) => {
        return element.version === smartAccountVersion;
      })) === null || _a === void 0 ? void 0 : _a.address;
      const walletFactoryAddress = (_b = chainInfo.walletFactory.find((element) => {
        return element.version === smartAccountVersion;
      })) === null || _b === void 0 ? void 0 : _b.address;
      const walletAddress = (_c = chainInfo.wallet.find((element) => {
        return element.version === smartAccountVersion;
      })) === null || _c === void 0 ? void 0 : _c.address;
      const multiSendAddress = (_d = chainInfo.multiSend.find((element) => {
        return element.version === smartAccountVersion;
      })) === null || _d === void 0 ? void 0 : _d.address;
      const multiSendCallAddress = (_e = chainInfo.multiSendCall.find((element) => {
        return element.version === smartAccountVersion;
      })) === null || _e === void 0 ? void 0 : _e.address;
      const fallBackHandlerAddress = (_f = chainInfo.fallBackHandler.find((element) => {
        return element.version === smartAccountVersion;
      })) === null || _f === void 0 ? void 0 : _f.address;
      if (!chainInfo) {
        throw new Error("Chain Not Found");
      }
      return {
        walletAddress,
        walletFactoryAddress,
        multiSendAddress,
        multiSendCallAddress,
        entryPointAddress,
        fallBackHandlerAddress
      };
    }
    exports2.findContractAddressesByVersion = findContractAddressesByVersion;
  }
});

// node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    init_process();
    init_buffer();
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret2 = this.words[0];
        if (this.length === 2) {
          ret2 += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret2 += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret2 : ret2;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws2[2 * i + 1] / N) * 8192 + Math.round(ws2[2 * i] / N) + carry;
          ws2[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws2[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/number-to-bn/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/number-to-bn/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    init_process();
    init_buffer();
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret2 = this.words[0];
        if (this.length === 2) {
          ret2 += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret2 += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret2 : ret2;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws2[2 * i + 1] / N) * 8192 + Math.round(ws2[2 * i] / N) + carry;
          ws2[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws2[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/number-to-bn/src/index.js
var require_src6 = __commonJS({
  "node_modules/number-to-bn/src/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var BN = require_bn3();
    var stripHexPrefix = require_src();
    module2.exports = function numberToBN(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        var multiplier = new BN(1);
        var formattedString = String(arg).toLowerCase().trim();
        var isHexPrefixed = formattedString.substr(0, 2) === "0x" || formattedString.substr(0, 3) === "-0x";
        var stringArg = stripHexPrefix(formattedString);
        if (stringArg.substr(0, 1) === "-") {
          stringArg = stripHexPrefix(stringArg.slice(1));
          multiplier = new BN(-1, 10);
        }
        stringArg = stringArg === "" ? "0" : stringArg;
        if (!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/) || stringArg.match(/^[a-fA-F]+$/) || isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/)) {
          return new BN(stringArg, 16).mul(multiplier);
        }
        if ((stringArg.match(/^-?[0-9]+$/) || stringArg === "") && isHexPrefixed === false) {
          return new BN(stringArg, 10).mul(multiplier);
        }
      } else if (typeof arg === "object" && arg.toString && (!arg.pop && !arg.push)) {
        if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
          return new BN(arg.toString(10), 10);
        }
      }
      throw new Error("[number-to-bn] while converting number " + JSON.stringify(arg) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.");
    };
  }
});

// node_modules/ethjs-unit/lib/index.js
var require_lib = __commonJS({
  "node_modules/ethjs-unit/lib/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var BN = require_bn2();
    var numberToBN = require_src6();
    var zero = new BN(0);
    var negative1 = new BN(-1);
    var unitMap = {
      "noether": "0",
      // eslint-disable-line
      "wei": "1",
      // eslint-disable-line
      "kwei": "1000",
      // eslint-disable-line
      "Kwei": "1000",
      // eslint-disable-line
      "babbage": "1000",
      // eslint-disable-line
      "femtoether": "1000",
      // eslint-disable-line
      "mwei": "1000000",
      // eslint-disable-line
      "Mwei": "1000000",
      // eslint-disable-line
      "lovelace": "1000000",
      // eslint-disable-line
      "picoether": "1000000",
      // eslint-disable-line
      "gwei": "1000000000",
      // eslint-disable-line
      "Gwei": "1000000000",
      // eslint-disable-line
      "shannon": "1000000000",
      // eslint-disable-line
      "nanoether": "1000000000",
      // eslint-disable-line
      "nano": "1000000000",
      // eslint-disable-line
      "szabo": "1000000000000",
      // eslint-disable-line
      "microether": "1000000000000",
      // eslint-disable-line
      "micro": "1000000000000",
      // eslint-disable-line
      "finney": "1000000000000000",
      // eslint-disable-line
      "milliether": "1000000000000000",
      // eslint-disable-line
      "milli": "1000000000000000",
      // eslint-disable-line
      "ether": "1000000000000000000",
      // eslint-disable-line
      "kether": "1000000000000000000000",
      // eslint-disable-line
      "grand": "1000000000000000000000",
      // eslint-disable-line
      "mether": "1000000000000000000000000",
      // eslint-disable-line
      "gether": "1000000000000000000000000000",
      // eslint-disable-line
      "tether": "1000000000000000000000000000000"
    };
    function getValueOfUnit(unitInput) {
      var unit = unitInput ? unitInput.toLowerCase() : "ether";
      var unitValue = unitMap[unit];
      if (typeof unitValue !== "string") {
        throw new Error("[ethjs-unit] the unit provided " + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
      }
      return new BN(unitValue, 10);
    }
    function numberToString(arg) {
      if (typeof arg === "string") {
        if (!arg.match(/^-?[0-9.]+$/)) {
          throw new Error("while converting number to string, invalid number value '" + arg + "', should be a number matching (^-?[0-9.]+).");
        }
        return arg;
      } else if (typeof arg === "number") {
        return String(arg);
      } else if (typeof arg === "object" && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
        if (arg.toPrecision) {
          return String(arg.toPrecision());
        } else {
          return arg.toString(10);
        }
      }
      throw new Error("while converting number to string, invalid number value '" + arg + "' type " + typeof arg + ".");
    }
    function fromWei(weiInput, unit, optionsInput) {
      var wei = numberToBN(weiInput);
      var negative = wei.lt(zero);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var options = optionsInput || {};
      if (negative) {
        wei = wei.mul(negative1);
      }
      var fraction = wei.mod(base).toString(10);
      while (fraction.length < baseLength) {
        fraction = "0" + fraction;
      }
      if (!options.pad) {
        fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      }
      var whole = wei.div(base).toString(10);
      if (options.commify) {
        whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      var value = "" + whole + (fraction == "0" ? "" : "." + fraction);
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    function toWei(etherInput, unit) {
      var ether = numberToString(etherInput);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var negative = ether.substring(0, 1) === "-";
      if (negative) {
        ether = ether.substring(1);
      }
      if (ether === ".") {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, invalid value");
      }
      var comps = ether.split(".");
      if (comps.length > 2) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei,  too many decimal points");
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      if (fraction.length > baseLength) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, too many decimal places");
      }
      while (fraction.length < baseLength) {
        fraction += "0";
      }
      whole = new BN(whole);
      fraction = new BN(fraction);
      var wei = whole.mul(base).add(fraction);
      if (negative) {
        wei = wei.mul(negative1);
      }
      return new BN(wei.toString(10), 10);
    }
    module2.exports = {
      unitMap,
      numberToString,
      getValueOfUnit,
      fromWei,
      toWei
    };
  }
});

// node_modules/utf8/utf8.js
var require_utf8 = __commonJS({
  "node_modules/utf8/utf8.js"(exports2) {
    init_process();
    init_buffer();
    (function(root) {
      var stringFromCharCode = String.fromCharCode;
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        var value;
        var extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        var length = array.length;
        var index = -1;
        var value;
        var output = "";
        while (++index < length) {
          value = array[index];
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
        }
        return output;
      }
      function checkScalarValue(codePoint) {
        if (codePoint >= 55296 && codePoint <= 57343) {
          throw Error(
            "Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value"
          );
        }
      }
      function createByte(codePoint, shift) {
        return stringFromCharCode(codePoint >> shift & 63 | 128);
      }
      function encodeCodePoint(codePoint) {
        if ((codePoint & 4294967168) == 0) {
          return stringFromCharCode(codePoint);
        }
        var symbol = "";
        if ((codePoint & 4294965248) == 0) {
          symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
        } else if ((codePoint & 4294901760) == 0) {
          checkScalarValue(codePoint);
          symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
          symbol += createByte(codePoint, 6);
        } else if ((codePoint & 4292870144) == 0) {
          symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
          symbol += createByte(codePoint, 12);
          symbol += createByte(codePoint, 6);
        }
        symbol += stringFromCharCode(codePoint & 63 | 128);
        return symbol;
      }
      function utf8encode(string) {
        var codePoints = ucs2decode(string);
        var length = codePoints.length;
        var index = -1;
        var codePoint;
        var byteString = "";
        while (++index < length) {
          codePoint = codePoints[index];
          byteString += encodeCodePoint(codePoint);
        }
        return byteString;
      }
      function readContinuationByte() {
        if (byteIndex >= byteCount) {
          throw Error("Invalid byte index");
        }
        var continuationByte = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((continuationByte & 192) == 128) {
          return continuationByte & 63;
        }
        throw Error("Invalid continuation byte");
      }
      function decodeSymbol() {
        var byte1;
        var byte2;
        var byte3;
        var byte4;
        var codePoint;
        if (byteIndex > byteCount) {
          throw Error("Invalid byte index");
        }
        if (byteIndex == byteCount) {
          return false;
        }
        byte1 = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((byte1 & 128) == 0) {
          return byte1;
        }
        if ((byte1 & 224) == 192) {
          byte2 = readContinuationByte();
          codePoint = (byte1 & 31) << 6 | byte2;
          if (codePoint >= 128) {
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 240) == 224) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
          if (codePoint >= 2048) {
            checkScalarValue(codePoint);
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 248) == 240) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          byte4 = readContinuationByte();
          codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (codePoint >= 65536 && codePoint <= 1114111) {
            return codePoint;
          }
        }
        throw Error("Invalid UTF-8 detected");
      }
      var byteArray;
      var byteCount;
      var byteIndex;
      function utf8decode(byteString) {
        byteArray = ucs2decode(byteString);
        byteCount = byteArray.length;
        byteIndex = 0;
        var codePoints = [];
        var tmp;
        while ((tmp = decodeSymbol()) !== false) {
          codePoints.push(tmp);
        }
        return ucs2encode(codePoints);
      }
      root.version = "3.0.0";
      root.encode = utf8encode;
      root.decode = utf8decode;
    })(typeof exports2 === "undefined" ? exports2.utf8 = {} : exports2);
  }
});

// node_modules/rlp/dist.browser/index.js
var require_dist2 = __commonJS({
  "node_modules/rlp/dist.browser/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLength = exports2.decode = exports2.encode = void 0;
    var bn_js_1 = __importDefault(require_bn());
    function encode(input) {
      if (Array.isArray(input)) {
        var output = [];
        for (var i = 0; i < input.length; i++) {
          output.push(encode(input[i]));
        }
        var buf = Buffer.concat(output);
        return Buffer.concat([encodeLength(buf.length, 192), buf]);
      } else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
      }
    }
    exports2.encode = encode;
    function safeParseInt(v, base) {
      if (v[0] === "0" && v[1] === "0") {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseInt(v, base);
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Buffer.from([len + offset]);
      } else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, "hex");
      }
    }
    function decode(input, stream) {
      if (stream === void 0) {
        stream = false;
      }
      if (!input || input.length === 0) {
        return Buffer.from([]);
      }
      var inputBuffer = toBuffer(input);
      var decoded = _decode(inputBuffer);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid remainder");
      }
      return decoded.data;
    }
    exports2.decode = decode;
    function getLength(input) {
      if (!input || input.length === 0) {
        return Buffer.from([]);
      }
      var inputBuffer = toBuffer(input);
      var firstByte = inputBuffer[0];
      if (firstByte <= 127) {
        return inputBuffer.length;
      } else if (firstByte <= 183) {
        return firstByte - 127;
      } else if (firstByte <= 191) {
        return firstByte - 182;
      } else if (firstByte <= 247) {
        return firstByte - 191;
      } else {
        var llength = firstByte - 246;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
        return llength + length_1;
      }
    }
    exports2.getLength = getLength;
    function _decode(input) {
      var length, llength, data, innerRemainder, d;
      var decoded = [];
      var firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Buffer.from([]);
        } else {
          data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid rlp encoding: byte must be less 0x80");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
          throw new Error("invalid RLP: not enough bytes for string");
        }
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid rlp: total length is larger than the data");
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
          throw new Error("invalid rlp, List has a invalid length");
        }
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    function isHexPrefixed(str) {
      return str.slice(0, 2) === "0x";
    }
    function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function intToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      var hex = integer.toString(16);
      return hex.length % 2 ? "0" + hex : hex;
    }
    function padToEven(a) {
      return a.length % 2 ? "0" + a : a;
    }
    function intToBuffer(integer) {
      var hex = intToHex(integer);
      return Buffer.from(hex, "hex");
    }
    function toBuffer(v) {
      if (!Buffer.isBuffer(v)) {
        if (typeof v === "string") {
          if (isHexPrefixed(v)) {
            return Buffer.from(padToEven(stripHexPrefix(v)), "hex");
          } else {
            return Buffer.from(v);
          }
        } else if (typeof v === "number" || typeof v === "bigint") {
          if (!v) {
            return Buffer.from([]);
          } else {
            return intToBuffer(v);
          }
        } else if (v === null || v === void 0) {
          return Buffer.from([]);
        } else if (v instanceof Uint8Array) {
          return Buffer.from(v);
        } else if (bn_js_1.default.isBN(v)) {
          return Buffer.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    }
  }
});

// node_modules/ethereumjs-util/dist.browser/externals.js
var require_externals = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/externals.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rlp = exports2.BN = void 0;
    var bn_js_1 = __importDefault(require_bn());
    exports2.BN = bn_js_1.default;
    var rlp = __importStar(require_dist2());
    exports2.rlp = rlp;
  }
});

// node_modules/ethereumjs-util/dist.browser/constants.js
var require_constants = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/constants.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KECCAK256_RLP = exports2.KECCAK256_RLP_S = exports2.KECCAK256_RLP_ARRAY = exports2.KECCAK256_RLP_ARRAY_S = exports2.KECCAK256_NULL = exports2.KECCAK256_NULL_S = exports2.TWO_POW256 = exports2.MAX_INTEGER = exports2.MAX_UINT64 = void 0;
    var buffer_1 = require_buffer();
    var externals_1 = require_externals();
    exports2.MAX_UINT64 = new externals_1.BN("ffffffffffffffff", 16);
    exports2.MAX_INTEGER = new externals_1.BN("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports2.TWO_POW256 = new externals_1.BN("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports2.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports2.KECCAK256_NULL = buffer_1.Buffer.from(exports2.KECCAK256_NULL_S, "hex");
    exports2.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports2.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports2.KECCAK256_RLP_ARRAY_S, "hex");
    exports2.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports2.KECCAK256_RLP = buffer_1.Buffer.from(exports2.KECCAK256_RLP_S, "hex");
  }
});

// node_modules/secp256k1/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/secp256k1/lib/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var errors = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert(cond, msg) {
      if (!cond)
        throw new Error(msg);
    }
    function isUint8Array(name, value, length) {
      assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
      if (length !== void 0) {
        if (Array.isArray(length)) {
          const numbers = length.join(", ");
          const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
          assert(length.includes(value.length), msg);
        } else {
          const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
          assert(value.length === length, msg);
        }
      }
    }
    function isCompressed(value) {
      assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
      if (typeof output === "function")
        output = output(length);
      isUint8Array("output", output, length);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module2.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert(
            seed === null || seed instanceof Uint8Array,
            "Expected seed to be an Uint8Array or null"
          );
          if (seed !== null)
            isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SECKEY_INVALID);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj2 = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj2, sig)) {
            case 0:
              return output.slice(0, obj2.outputlen);
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0)
            assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj2 = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj2, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj2;
            case 1:
              throw new Error(errors.SIGN);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert(
            toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
            "Expected recovery id to be a Number within interval [0, 3]"
          );
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.RECOVER);
            case 3:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0)
              isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0)
              isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.ECDH);
          }
        }
      };
    };
  }
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/secp256k1/lib/elliptic.js"(exports2, module2) {
    init_process();
    init_buffer();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    var BN = ecparams.n.constructor;
    function loadCompressedPublicKey(first, xbuf) {
      let x = new BN(xbuf);
      if (x.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
      if (first === 3 !== y.isOdd())
        y = y.redNeg();
      return ec.keyPair({ pub: { x, y } });
    }
    function loadUncompressedPublicKey(first, xbuf, ybuf) {
      let x = new BN(xbuf);
      let y = new BN(ybuf);
      if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      y = y.toRed(ecparams.red);
      if ((first === 6 || first === 7) && y.isOdd() !== (first === 7))
        return null;
      const x3 = x.redSqr().redIMul(x);
      if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
        return null;
      return ec.keyPair({ pub: { x, y } });
    }
    function loadPublicKey(pubkey) {
      const first = pubkey[0];
      switch (first) {
        case 2:
        case 3:
          if (pubkey.length !== 33)
            return null;
          return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i = 0; i < output.length; ++i)
        output[i] = pubkey[i];
    }
    module2.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn = new BN(seckey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn = new BN(seckey);
        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0)
          return 1;
        bn.iadd(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn.isub(ecparams.n);
        if (bn.isZero())
          return 1;
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        bn.imul(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn = bn.umod(ecparams.n);
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn = new BN(seckey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        const point = ec.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs = new Array(pubkeys.length);
        for (let i = 0; i < pubkeys.length; ++i) {
          pairs[i] = loadPublicKey(pubkeys[i]);
          if (pairs[i] === null)
            return 1;
        }
        let point = pairs[0].getPublic();
        for (let i = 1; i < pairs.length; ++i)
          point = point.add(pairs[i].pub);
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0)
          return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
          return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r = new BN(sig.subarray(0, 32));
        const s = new BN(sig.subarray(32, 64));
        if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0)
          return 1;
        if (s.cmp(ec.nh) === 1) {
          sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureExport(obj2, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN(sigR).cmp(ecparams.n) >= 0)
          return 1;
        if (new BN(sigS).cmp(ecparams.n) >= 0)
          return 1;
        const { output } = obj2;
        let r = output.subarray(4, 4 + 33);
        r[0] = 0;
        r.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR)
          ;
        r = r.subarray(posR);
        if (r[0] & 128)
          return 1;
        if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
          return 1;
        let s = output.subarray(6 + 33, 6 + 33 + 33);
        s[0] = 0;
        s.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS)
          ;
        s = s.subarray(posS);
        if (s[0] & 128)
          return 1;
        if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
          return 1;
        obj2.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj2.outputlen - 2;
        output[2] = 2;
        output[3] = r.length;
        output.set(r, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s.length;
        output.set(s, 6 + lenR);
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureImport(output, sig) {
        if (sig.length < 8)
          return 1;
        if (sig.length > 72)
          return 1;
        if (sig[0] !== 48)
          return 1;
        if (sig[1] !== sig.length - 2)
          return 1;
        if (sig[2] !== 2)
          return 1;
        const lenR = sig[3];
        if (lenR === 0)
          return 1;
        if (5 + lenR >= sig.length)
          return 1;
        if (sig[4 + lenR] !== 2)
          return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0)
          return 1;
        if (6 + lenR + lenS !== sig.length)
          return 1;
        if (sig[4] & 128)
          return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
          return 1;
        if (sig[lenR + 6] & 128)
          return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
          return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0)
          sigR = sigR.subarray(1);
        if (sigR.length > 32)
          return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0)
          sigS = sigS.slice(1);
        if (sigS.length > 32)
          throw new Error("S length is too long");
        let r = new BN(sigR);
        if (r.cmp(ecparams.n) >= 0)
          r = new BN(0);
        let s = new BN(sig.subarray(6 + lenR));
        if (s.cmp(ecparams.n) >= 0)
          s = new BN(0);
        output.set(r.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj2, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid)
              throw new Error("This is the way");
            return new BN(nonce);
          };
        }
        const d = new BN(seckey);
        if (d.cmp(ecparams.n) >= 0 || d.isZero())
          return 1;
        let sig;
        try {
          sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj2.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj2.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj2.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
          return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 2;
        const point = pair.getPublic();
        const isValid = ec.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigr.isZero() || sigs.isZero())
          return 2;
        let point;
        try {
          point = ec.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const scalar = new BN(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
          return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha256 = ec.hash().update(data2).digest();
          for (let i = 0; i < 32; ++i)
            output[i] = sha256[i];
        } else {
          if (!xbuf)
            xbuf = new Uint8Array(32);
          const x = point.getX().toArray("be", 32);
          for (let i = 0; i < 32; ++i)
            xbuf[i] = x[i];
          if (!ybuf)
            ybuf = new Uint8Array(32);
          const y = point.getY().toArray("be", 32);
          for (let i = 0; i < 32; ++i)
            ybuf[i] = y[i];
          const hash = hashfn(xbuf, ybuf, data);
          const isValid = hash instanceof Uint8Array && hash.length === output.length;
          if (!isValid)
            return 2;
          output.set(hash);
        }
        return 0;
      }
    };
  }
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/secp256k1/elliptic.js"(exports2, module2) {
    init_process();
    init_buffer();
    module2.exports = require_lib2()(require_elliptic2());
  }
});

// node_modules/ethereum-cryptography/random.js
var require_random = __commonJS({
  "node_modules/ethereum-cryptography/random.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var randombytes = require_browser();
    function getRandomBytes(bytes) {
      return new Promise(function(resolve, reject) {
        randombytes(bytes, function(err, resp) {
          if (err) {
            reject(err);
            return;
          }
          resolve(resp);
        });
      });
    }
    exports2.getRandomBytes = getRandomBytes;
    function getRandomBytesSync(bytes) {
      return randombytes(bytes);
    }
    exports2.getRandomBytesSync = getRandomBytesSync;
  }
});

// node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/ethereum-cryptography/secp256k1.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    function __export2(m) {
      for (var p in m)
        if (!exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var secp256k1_1 = require_elliptic3();
    var random_1 = require_random();
    var SECP256K1_PRIVATE_KEY_SIZE = 32;
    function createPrivateKey() {
      return __awaiter(this, void 0, void 0, function() {
        var pk;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (false)
                return [3, 2];
              return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
            case 1:
              pk = _a.sent();
              if (secp256k1_1.privateKeyVerify(pk)) {
                return [2, pk];
              }
              return [3, 0];
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports2.createPrivateKey = createPrivateKey;
    function createPrivateKeySync() {
      while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
          return pk;
        }
      }
    }
    exports2.createPrivateKeySync = createPrivateKeySync;
    __export2(require_elliptic3());
  }
});

// node_modules/ethereumjs-util/dist.browser/internal.js
var require_internal = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/internal.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHexString = exports2.getKeys = exports2.fromAscii = exports2.fromUtf8 = exports2.toAscii = exports2.arrayContainsArray = exports2.getBinarySize = exports2.padToEven = exports2.stripHexPrefix = exports2.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[isHexPrefixed] input must be type 'string', received type ".concat(typeof str));
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports2.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix = function(str) {
      if (typeof str !== "string")
        throw new Error("[stripHexPrefix] input must be type 'string', received ".concat(typeof str));
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports2.stripHexPrefix = stripHexPrefix;
    function padToEven(value) {
      var a = value;
      if (typeof a !== "string") {
        throw new Error("[padToEven] value must be type 'string', received ".concat(typeof a));
      }
      if (a.length % 2)
        a = "0".concat(a);
      return a;
    }
    exports2.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[getBinarySize] method requires input type 'string', recieved ".concat(typeof str));
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports2.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[arrayContainsArray] method requires input 'superset' to be an array, got type '".concat(typeof superset, "'"));
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[arrayContainsArray] method requires input 'subset' to be an array, got type '".concat(typeof subset, "'"));
      }
      return subset[some ? "some" : "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    exports2.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      var str = "";
      var i = 0;
      var l = hex.length;
      if (hex.substring(0, 2) === "0x")
        i = 2;
      for (; i < l; i += 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports2.toAscii = toAscii;
    function fromUtf8(stringValue) {
      var str = Buffer.from(stringValue, "utf8");
      return "0x".concat(padToEven(str.toString("hex")).replace(/^0+|0+$/g, ""));
    }
    exports2.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      var hex = "";
      for (var i = 0; i < stringValue.length; i++) {
        var code = stringValue.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0".concat(n) : n;
      }
      return "0x".concat(hex);
    }
    exports2.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[getKeys] method expects input 'params' to be an array, got ".concat(typeof params));
      }
      if (typeof key !== "string") {
        throw new Error("[getKeys] method expects input 'key' to be type 'string', got ".concat(typeof params));
      }
      var result = [];
      for (var i = 0; i < params.length; i++) {
        var value = params[i][key];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi - expected type 'string', received ".concat(typeof value));
        }
        result.push(value);
      }
      return result;
    }
    exports2.getKeys = getKeys;
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (length && value.length !== 2 + 2 * length)
        return false;
      return true;
    }
    exports2.isHexString = isHexString;
  }
});

// node_modules/ethereumjs-util/dist.browser/helpers.js
var require_helpers = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/helpers.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertIsString = exports2.assertIsArray = exports2.assertIsBuffer = exports2.assertIsHexString = void 0;
    var internal_1 = require_internal();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        var msg = "This method only supports 0x-prefixed hex strings but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports2.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        var msg = "This method only supports Buffer but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports2.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        var msg = "This method only supports number arrays but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports2.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        var msg = "This method only supports strings but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports2.assertIsString = assertIsString;
  }
});

// node_modules/ethereumjs-util/dist.browser/bytes.js
var require_bytes = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/bytes.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufArrToArr = exports2.arrToBufArr = exports2.validateNoLeadingZeroes = exports2.baToJSON = exports2.toUtf8 = exports2.addHexPrefix = exports2.toUnsigned = exports2.fromSigned = exports2.bufferToHex = exports2.bufferToInt = exports2.toBuffer = exports2.unpadHexString = exports2.unpadArray = exports2.unpadBuffer = exports2.setLengthRight = exports2.setLengthLeft = exports2.zeros = exports2.intToBuffer = exports2.intToHex = void 0;
    var externals_1 = require_externals();
    var internal_1 = require_internal();
    var helpers_1 = require_helpers();
    var intToHex = function(i) {
      if (!Number.isSafeInteger(i) || i < 0) {
        throw new Error("Received an invalid integer type: ".concat(i));
      }
      return "0x".concat(i.toString(16));
    };
    exports2.intToHex = intToHex;
    var intToBuffer = function(i) {
      var hex = (0, exports2.intToHex)(i);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports2.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports2.zeros = zeros;
    var setLength = function(msg, length, right) {
      var buf = (0, exports2.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports2.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports2.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports2.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
    };
    exports2.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return stripZeros(a);
    };
    exports2.unpadHexString = unpadHexString;
    var toBuffer = function(v) {
      if (v === null || v === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_1.isHexString)(v)) {
          throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ".concat(v));
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports2.intToBuffer)(v);
      }
      if (externals_1.BN.isBN(v)) {
        if (v.isNeg()) {
          throw new Error("Cannot convert negative BN to buffer. Given: ".concat(v));
        }
        return v.toArrayLike(Buffer);
      }
      if (v.toArray) {
        return Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports2.toBuffer = toBuffer;
    var bufferToInt = function(buf) {
      return new externals_1.BN((0, exports2.toBuffer)(buf)).toNumber();
    };
    exports2.bufferToInt = bufferToInt;
    var bufferToHex = function(buf) {
      buf = (0, exports2.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports2.bufferToHex = bufferToHex;
    var fromSigned = function(num) {
      return new externals_1.BN(num).fromTwos(256);
    };
    exports2.fromSigned = fromSigned;
    var toUnsigned = function(num) {
      return Buffer.from(num.toTwos(256).toArray());
    };
    exports2.toUnsigned = toUnsigned;
    var addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports2.addHexPrefix = addHexPrefix;
    var toUtf8 = function(hex) {
      var zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      var bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports2.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return "0x".concat(ba.toString("hex"));
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push((0, exports2.baToJSON)(ba[i]));
        }
        return array;
      }
    };
    exports2.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      var e_1, _a;
      try {
        for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
          if (v !== void 0 && v.length > 0 && v[0] === 0) {
            throw new Error("".concat(k, " cannot have leading zeroes, received: ").concat(v.toString("hex")));
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    exports2.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map(function(a) {
        return arrToBufArr(a);
      });
    }
    exports2.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);
      }
      return arr.map(function(a) {
        return bufArrToArr(a);
      });
    }
    exports2.bufArrToArr = bufArrToArr;
  }
});

// node_modules/ethereum-cryptography/hash-utils.js
var require_hash_utils = __commonJS({
  "node_modules/ethereum-cryptography/hash-utils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function createHashFunction(hashConstructor) {
      return function(msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
      };
    }
    exports2.createHashFunction = createHashFunction;
  }
});

// node_modules/ethereum-cryptography/keccak.js
var require_keccak = __commonJS({
  "node_modules/ethereum-cryptography/keccak.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hash_utils_1 = require_hash_utils();
    var createKeccakHash = require_js();
    exports2.keccak224 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak224");
    });
    exports2.keccak256 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak256");
    });
    exports2.keccak384 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak384");
    });
    exports2.keccak512 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak512");
    });
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_readable_browser().Transform;
    var inherits2 = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer2.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer2.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits2(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer2.isBuffer(data))
        data = Buffer2.from(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; )
          block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0)
          this._length[j] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i)
        this._length[i] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module2.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits2(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i)
        M[i] = this._block.readInt32LE(i * 4);
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b, M[2], 606105819, 17);
      b = fnF(b, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b, M[6], 2821735955, 17);
      b = fnF(b, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b, M[10], 4294925233, 17);
      b = fnF(b, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b, M[14], 2792965006, 17);
      b = fnF(b, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b, M[11], 643717713, 14);
      b = fnG(b, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b, M[15], 3634488961, 14);
      b = fnG(b, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b, M[3], 4107603335, 14);
      b = fnG(b, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b, M[7], 1735328473, 14);
      b = fnG(b, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b, M[11], 1839030562, 16);
      b = fnH(b, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b, M[7], 4139469664, 16);
      b = fnH(b, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b, M[3], 3572445317, 16);
      b = fnH(b, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b, M[15], 530742520, 16);
      b = fnH(b, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b, M[14], 2878612391, 15);
      b = fnI(b, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b, M[10], 4293915773, 15);
      b = fnI(b, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b, M[6], 2734768916, 15);
      b = fnI(b, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b, M[2], 718787259, 15);
      b = fnI(b, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    module2.exports = MD5;
  }
});

// node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/ripemd160/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_buffer().Buffer;
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits2(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var words = ARRAY16;
      for (var j = 0; j < 16; ++j)
        words[j] = this._block.readInt32LE(j * 4);
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;
      for (var i = 0; i < 80; i += 1) {
        var tl;
        var tr;
        if (i < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
          tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
          tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
          tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
          tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
          tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = tr;
      }
      var t = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fn1(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
    }
    function fn2(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
    }
    function fn3(a, b, c, d, e, m, k, s) {
      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
    }
    function fn4(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
    }
    function fn5(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
    }
    module2.exports = RIPEMD160;
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports2, module2) {
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0)
        return b & c | ~b & d;
      if (s === 2)
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i)
        W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i)
        W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports2, module2) {
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0)
        return b & c | ~b & d;
      if (s === 2)
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i)
        W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i)
        W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports2, module2) {
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i)
        W2[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i)
        W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports2, module2) {
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports2, module2) {
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W2[i] = M.readInt32BE(i * 4);
        W2[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W2[i - 15 * 2];
        var xl = W2[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i - 2 * 2];
        xl = W2[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i - 7 * 2];
        var Wi7l = W2[i - 7 * 2 + 1];
        var Wi16h = W2[i - 16 * 2];
        var Wi16l = W2[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i] = Wih;
        W2[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports2, module2) {
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var exports2 = module2.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports2[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports2.sha = require_sha();
    exports2.sha1 = require_sha1();
    exports2.sha224 = require_sha224();
    exports2.sha256 = require_sha256();
    exports2.sha384 = require_sha384();
    exports2.sha512 = require_sha512();
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var StringDecoder = require_string_decoder().StringDecoder;
    var inherits2 = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits2(CipherBase, Transform);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer2.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode)
        return this;
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e) {
        err = e;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer2.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc)
        throw new Error("can't switch encodings");
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module2.exports = CipherBase;
  }
});

// node_modules/create-hash/browser.js
var require_browser6 = __commonJS({
  "node_modules/create-hash/browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha2();
    var Base = require_cipher_base();
    function Hash(hash) {
      Base.call(this, "digest");
      this._hash = hash;
    }
    inherits2(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    module2.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5")
        return new MD5();
      if (alg === "rmd160" || alg === "ripemd160")
        return new RIPEMD160();
      return new Hash(sha(alg));
    };
  }
});

// node_modules/ethereumjs-util/dist.browser/hash.js
var require_hash2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/hash.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rlphash = exports2.ripemd160FromArray = exports2.ripemd160FromString = exports2.ripemd160 = exports2.sha256FromArray = exports2.sha256FromString = exports2.sha256 = exports2.keccakFromArray = exports2.keccakFromHexString = exports2.keccakFromString = exports2.keccak256 = exports2.keccak = void 0;
    var keccak_1 = require_keccak();
    var createHash = require_browser6();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var helpers_1 = require_helpers();
    var keccak = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsBuffer)(a);
      switch (bits) {
        case 224: {
          return (0, keccak_1.keccak224)(a);
        }
        case 256: {
          return (0, keccak_1.keccak256)(a);
        }
        case 384: {
          return (0, keccak_1.keccak384)(a);
        }
        case 512: {
          return (0, keccak_1.keccak512)(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak".concat(bits));
        }
      }
    };
    exports2.keccak = keccak;
    var keccak256 = function(a) {
      return (0, exports2.keccak)(a);
    };
    exports2.keccak256 = keccak256;
    var keccakFromString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsString)(a);
      var buf = Buffer.from(a, "utf8");
      return (0, exports2.keccak)(buf, bits);
    };
    exports2.keccakFromString = keccakFromString;
    var keccakFromHexString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsHexString)(a);
      return (0, exports2.keccak)((0, bytes_1.toBuffer)(a), bits);
    };
    exports2.keccakFromHexString = keccakFromHexString;
    var keccakFromArray = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsArray)(a);
      return (0, exports2.keccak)((0, bytes_1.toBuffer)(a), bits);
    };
    exports2.keccakFromArray = keccakFromArray;
    var _sha256 = function(a) {
      a = (0, bytes_1.toBuffer)(a);
      return createHash("sha256").update(a).digest();
    };
    var sha256 = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return _sha256(a);
    };
    exports2.sha256 = sha256;
    var sha256FromString = function(a) {
      (0, helpers_1.assertIsString)(a);
      return _sha256(a);
    };
    exports2.sha256FromString = sha256FromString;
    var sha256FromArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return _sha256(a);
    };
    exports2.sha256FromArray = sha256FromArray;
    var _ripemd160 = function(a, padded) {
      a = (0, bytes_1.toBuffer)(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return (0, bytes_1.setLengthLeft)(hash, 32);
      } else {
        return hash;
      }
    };
    var ripemd160 = function(a, padded) {
      (0, helpers_1.assertIsBuffer)(a);
      return _ripemd160(a, padded);
    };
    exports2.ripemd160 = ripemd160;
    var ripemd160FromString = function(a, padded) {
      (0, helpers_1.assertIsString)(a);
      return _ripemd160(a, padded);
    };
    exports2.ripemd160FromString = ripemd160FromString;
    var ripemd160FromArray = function(a, padded) {
      (0, helpers_1.assertIsArray)(a);
      return _ripemd160(a, padded);
    };
    exports2.ripemd160FromArray = ripemd160FromArray;
    var rlphash = function(a) {
      return (0, exports2.keccak)(externals_1.rlp.encode(a));
    };
    exports2.rlphash = rlphash;
  }
});

// node_modules/ethereumjs-util/dist.browser/types.js
var require_types = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/types.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toType = exports2.TypeOutput = exports2.bnToRlp = exports2.bnToUnpaddedBuffer = exports2.bnToHex = void 0;
    var externals_1 = require_externals();
    var internal_1 = require_internal();
    var bytes_1 = require_bytes();
    function bnToHex(value) {
      return "0x".concat(value.toString(16));
    }
    exports2.bnToHex = bnToHex;
    function bnToUnpaddedBuffer(value) {
      return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));
    }
    exports2.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
    function bnToRlp(value) {
      return bnToUnpaddedBuffer(value);
    }
    exports2.bnToRlp = bnToRlp;
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BN"] = 1] = "BN";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports2.TypeOutput || (exports2.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error("A string must be provided with a 0x-prefix, given: ".concat(input));
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      var output = (0, bytes_1.toBuffer)(input);
      if (outputType === TypeOutput.Buffer) {
        return output;
      } else if (outputType === TypeOutput.BN) {
        return new externals_1.BN(output);
      } else if (outputType === TypeOutput.Number) {
        var bn = new externals_1.BN(output);
        var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());
        if (bn.gt(max)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        }
        return bn.toNumber();
      } else {
        return "0x".concat(output.toString("hex"));
      }
    }
    exports2.toType = toType;
  }
});

// node_modules/ethereumjs-util/dist.browser/account.js
var require_account = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/account.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isZeroAddress = exports2.zeroAddress = exports2.importPublic = exports2.privateToAddress = exports2.privateToPublic = exports2.publicToAddress = exports2.pubToAddress = exports2.isValidPublic = exports2.isValidPrivate = exports2.generateAddress2 = exports2.generateAddress = exports2.isValidChecksumAddress = exports2.toChecksumAddress = exports2.isValidAddress = exports2.Account = void 0;
    var assert_1 = __importDefault(require_assert());
    var externals_1 = require_externals();
    var secp256k1_1 = require_secp256k1();
    var internal_1 = require_internal();
    var constants_1 = require_constants();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash2();
    var helpers_1 = require_helpers();
    var types_1 = require_types();
    var Account = (
      /** @class */
      function() {
        function Account2(nonce, balance, stateRoot, codeHash) {
          if (nonce === void 0) {
            nonce = new externals_1.BN(0);
          }
          if (balance === void 0) {
            balance = new externals_1.BN(0);
          }
          if (stateRoot === void 0) {
            stateRoot = constants_1.KECCAK256_RLP;
          }
          if (codeHash === void 0) {
            codeHash = constants_1.KECCAK256_NULL;
          }
          this.nonce = nonce;
          this.balance = balance;
          this.stateRoot = stateRoot;
          this.codeHash = codeHash;
          this._validate();
        }
        Account2.fromAccountData = function(accountData) {
          var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;
          return new Account2(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : void 0, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : void 0, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : void 0, codeHash ? (0, bytes_1.toBuffer)(codeHash) : void 0);
        };
        Account2.fromRlpSerializedAccount = function(serialized) {
          var values = externals_1.rlp.decode(serialized);
          if (!Array.isArray(values)) {
            throw new Error("Invalid serialized account input. Must be array");
          }
          return this.fromValuesArray(values);
        };
        Account2.fromValuesArray = function(values) {
          var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];
          return new Account2(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);
        };
        Account2.prototype._validate = function() {
          if (this.nonce.lt(new externals_1.BN(0))) {
            throw new Error("nonce must be greater than zero");
          }
          if (this.balance.lt(new externals_1.BN(0))) {
            throw new Error("balance must be greater than zero");
          }
          if (this.stateRoot.length !== 32) {
            throw new Error("stateRoot must have a length of 32");
          }
          if (this.codeHash.length !== 32) {
            throw new Error("codeHash must have a length of 32");
          }
        };
        Account2.prototype.raw = function() {
          return [
            (0, types_1.bnToUnpaddedBuffer)(this.nonce),
            (0, types_1.bnToUnpaddedBuffer)(this.balance),
            this.stateRoot,
            this.codeHash
          ];
        };
        Account2.prototype.serialize = function() {
          return externals_1.rlp.encode(this.raw());
        };
        Account2.prototype.isContract = function() {
          return !this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        Account2.prototype.isEmpty = function() {
          return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        return Account2;
      }()
    );
    exports2.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports2.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      var prefix = "";
      if (eip1191ChainId) {
        var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);
        prefix = chainId.toString() + "0x";
      }
      var hash = (0, hash_1.keccakFromString)(prefix + address).toString("hex");
      var ret2 = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret2 += address[i].toUpperCase();
        } else {
          ret2 += address[i];
        }
      }
      return ret2;
    };
    exports2.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports2.isValidAddress)(hexAddress) && (0, exports2.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports2.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      var nonceBN = new externals_1.BN(nonce);
      if (nonceBN.isZero()) {
        return (0, hash_1.rlphash)([from, null]).slice(-20);
      }
      return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);
    };
    exports2.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      (0, assert_1.default)(from.length === 20);
      (0, assert_1.default)(salt.length === 32);
      var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, hash_1.keccak256)(initCode)]));
      return address.slice(-20);
    };
    exports2.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return (0, secp256k1_1.privateKeyVerify)(privateKey);
    };
    exports2.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return (0, secp256k1_1.publicKeyVerify)(publicKey);
    };
    exports2.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));
      }
      (0, assert_1.default)(pubKey.length === 64);
      return (0, hash_1.keccak)(pubKey).slice(-20);
    };
    exports2.pubToAddress = pubToAddress;
    exports2.publicToAddress = exports2.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);
    };
    exports2.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports2.publicToAddress)((0, exports2.privateToPublic)(privateKey));
    };
    exports2.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));
      }
      return publicKey;
    };
    exports2.importPublic = importPublic;
    var zeroAddress = function() {
      var addressLength = 20;
      var addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports2.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      var zeroAddr = (0, exports2.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports2.isZeroAddress = isZeroAddress;
  }
});

// node_modules/ethereumjs-util/dist.browser/address.js
var require_address = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/address.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address = void 0;
    var assert_1 = __importDefault(require_assert());
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var account_1 = require_account();
    var Address = (
      /** @class */
      function() {
        function Address2(buf) {
          (0, assert_1.default)(buf.length === 20, "Invalid address length");
          this.buf = buf;
        }
        Address2.zero = function() {
          return new Address2((0, bytes_1.zeros)(20));
        };
        Address2.fromString = function(str) {
          (0, assert_1.default)((0, account_1.isValidAddress)(str), "Invalid address");
          return new Address2((0, bytes_1.toBuffer)(str));
        };
        Address2.fromPublicKey = function(pubKey) {
          (0, assert_1.default)(Buffer.isBuffer(pubKey), "Public key should be Buffer");
          var buf = (0, account_1.pubToAddress)(pubKey);
          return new Address2(buf);
        };
        Address2.fromPrivateKey = function(privateKey) {
          (0, assert_1.default)(Buffer.isBuffer(privateKey), "Private key should be Buffer");
          var buf = (0, account_1.privateToAddress)(privateKey);
          return new Address2(buf);
        };
        Address2.generate = function(from, nonce) {
          (0, assert_1.default)(externals_1.BN.isBN(nonce));
          return new Address2((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));
        };
        Address2.generate2 = function(from, salt, initCode) {
          (0, assert_1.default)(Buffer.isBuffer(salt));
          (0, assert_1.default)(Buffer.isBuffer(initCode));
          return new Address2((0, account_1.generateAddress2)(from.buf, salt, initCode));
        };
        Address2.prototype.equals = function(address) {
          return this.buf.equals(address.buf);
        };
        Address2.prototype.isZero = function() {
          return this.equals(Address2.zero());
        };
        Address2.prototype.isPrecompileOrSystemAddress = function() {
          var addressBN = new externals_1.BN(this.buf);
          var rangeMin = new externals_1.BN(0);
          var rangeMax = new externals_1.BN("ffff", "hex");
          return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);
        };
        Address2.prototype.toString = function() {
          return "0x" + this.buf.toString("hex");
        };
        Address2.prototype.toBuffer = function() {
          return Buffer.from(this.buf);
        };
        return Address2;
      }()
    );
    exports2.Address = Address;
  }
});

// node_modules/ethereumjs-util/dist.browser/signature.js
var require_signature = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/signature.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashPersonalMessage = exports2.isValidSignature = exports2.fromRpcSig = exports2.toCompactSig = exports2.toRpcSig = exports2.ecrecover = exports2.ecsign = void 0;
    var secp256k1_1 = require_secp256k1();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash2();
    var helpers_1 = require_helpers();
    var types_1 = require_types();
    function ecsign(msgHash, privateKey, chainId) {
      var _a = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey), signature = _a.signature, recovery = _a.recid;
      var r = Buffer.from(signature.slice(0, 32));
      var s = Buffer.from(signature.slice(32, 64));
      if (!chainId || typeof chainId === "number") {
        if (chainId && !Number.isSafeInteger(chainId)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
        }
        var v_1 = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;
        return { r, s, v: v_1 };
      }
      var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
      var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);
      return { r, s, v };
    }
    exports2.ecsign = ecsign;
    function calculateSigRecovery(v, chainId) {
      var vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);
      if (vBN.eqn(0) || vBN.eqn(1))
        return (0, types_1.toType)(v, types_1.TypeOutput.BN);
      if (!chainId) {
        return vBN.subn(27);
      }
      var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
      return vBN.sub(chainIdBN.muln(2).addn(35));
    }
    function isValidSigRecovery(recovery) {
      var rec = new externals_1.BN(recovery);
      return rec.eqn(0) || rec.eqn(1);
    }
    var ecrecover = function(msgHash, v, r, s, chainId) {
      var signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);
      return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));
    };
    exports2.ecrecover = ecrecover;
    var toRpcSig = function(v, r, s, chainId) {
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
    };
    exports2.toRpcSig = toRpcSig;
    var toCompactSig = function(v, r, s, chainId) {
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);
      var ss = s;
      if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {
        ss = Buffer.from(s);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports2.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      var buf = (0, bytes_1.toBuffer)(sig);
      var r;
      var s;
      var v;
      if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;
        s[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r,
        s
      };
    };
    exports2.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v, r, s, homesteadOrLater, chainId) {
      if (homesteadOrLater === void 0) {
        homesteadOrLater = true;
      }
      var SECP256K1_N_DIV_2 = new externals_1.BN("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new externals_1.BN("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      var rBN = new externals_1.BN(r);
      var sBN = new externals_1.BN(s);
      if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
      }
      if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports2.isValidSignature = isValidSignature;
    var hashPersonalMessage = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      var prefix = Buffer.from("Ethereum Signed Message:\n".concat(message.length), "utf-8");
      return (0, hash_1.keccak)(Buffer.concat([prefix, message]));
    };
    exports2.hashPersonalMessage = hashPersonalMessage;
  }
});

// node_modules/ethereumjs-util/dist.browser/object.js
var require_object = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/object.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineProperties = void 0;
    var assert_1 = __importDefault(require_assert());
    var internal_1 = require_internal();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label === void 0) {
          label = false;
        }
        if (label) {
          var obj_1 = {};
          self2._fields.forEach(function(field) {
            obj_1[field] = "0x".concat(self2[field].toString("hex"));
          });
          return obj_1;
        }
        return (0, bytes_1.baToJSON)(self2.raw);
      };
      self2.serialize = function serialize() {
        return externals_1.rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i];
        }
        function setter(v) {
          v = (0, bytes_1.toBuffer)(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = (0, bytes_1.unpadBuffer)(v);
            (0, assert_1.default)(field.length >= v.length, "The field ".concat(field.name, " must not have more ").concat(field.length, " bytes"));
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            (0, assert_1.default)(field.length === v.length, "The field ".concat(field.name, " must have byte length of ").concat(field.length));
          }
          self2.raw[i] = v;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer.from((0, internal_1.stripHexPrefix)(data), "hex");
        }
        if (Buffer.isBuffer(data)) {
          data = externals_1.rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self2[self2._fields[i]] = (0, bytes_1.toBuffer)(d);
          });
        } else if (typeof data === "object") {
          var keys_1 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys_1.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys_1.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
    exports2.defineProperties = defineProperties;
  }
});

// node_modules/ethereumjs-util/dist.browser/index.js
var require_dist3 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHexString = exports2.getKeys = exports2.fromAscii = exports2.fromUtf8 = exports2.toAscii = exports2.arrayContainsArray = exports2.getBinarySize = exports2.padToEven = exports2.stripHexPrefix = exports2.isHexPrefixed = void 0;
    __exportStar(require_constants(), exports2);
    __exportStar(require_account(), exports2);
    __exportStar(require_address(), exports2);
    __exportStar(require_hash2(), exports2);
    __exportStar(require_signature(), exports2);
    __exportStar(require_bytes(), exports2);
    __exportStar(require_object(), exports2);
    __exportStar(require_externals(), exports2);
    __exportStar(require_types(), exports2);
    var internal_1 = require_internal();
    Object.defineProperty(exports2, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports2, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports2, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports2, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports2, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports2, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    Object.defineProperty(exports2, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports2, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports2, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports2, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
  }
});

// node_modules/ethereum-bloom-filters/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/utils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sha3 = require_sha3();
    function keccak256(data) {
      return "0x" + sha3.keccak_256(toByteArray(data));
    }
    exports2.keccak256 = keccak256;
    exports2.padLeft = (value, chars) => {
      const hasPrefix = /^0x/i.test(value) || typeof value === "number";
      value = value.toString().replace(/^0x/i, "");
      const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join("0") + value;
    };
    function bytesToHex(bytes) {
      const hex = [];
      for (let i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return `0x${hex.join("").replace(/^0+/, "")}`;
    }
    exports2.bytesToHex = bytesToHex;
    function toByteArray(value) {
      if (value == null) {
        throw new Error("cannot convert null value to array");
      }
      if (typeof value === "string") {
        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);
        if (!match) {
          throw new Error("invalid hexidecimal string");
        }
        if (match[1] !== "0x") {
          throw new Error("hex string must have 0x prefix");
        }
        value = value.substring(2);
        if (value.length % 2) {
          value = "0" + value;
        }
        const result = [];
        for (let i = 0; i < value.length; i += 2) {
          result.push(parseInt(value.substr(i, 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isByteArray(value)) {
        return addSlice(new Uint8Array(value));
      }
      throw new Error("invalid arrayify value");
    }
    exports2.toByteArray = toByteArray;
    function isByteArray(value) {
      if (!value || // tslint:disable-next-line: radix
      parseInt(String(value.length)) != value.length || typeof value === "string") {
        return false;
      }
      for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {
          return false;
        }
      }
      return true;
    }
    function addSlice(array) {
      if (array.slice !== void 0) {
        return array;
      }
      array.slice = () => {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
  }
});

// node_modules/ethereum-bloom-filters/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils3();
    function isBloom(bloom) {
      if (typeof bloom !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
      }
      if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
      }
      return false;
    }
    exports2.isBloom = isBloom;
    function isInBloom(bloom, value) {
      if (typeof value === "object" && value.constructor === Uint8Array) {
        value = utils_1.bytesToHex(value);
      }
      const hash = utils_1.keccak256(value).replace("0x", "");
      for (let i = 0; i < 12; i += 4) {
        const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047;
        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
        const offset = 1 << bitpos % 4;
        if ((code & offset) !== offset) {
          return false;
        }
      }
      return true;
    }
    exports2.isInBloom = isInBloom;
    function codePointToInt(codePoint) {
      if (codePoint >= 48 && codePoint <= 57) {
        return codePoint - 48;
      }
      if (codePoint >= 65 && codePoint <= 70) {
        return codePoint - 55;
      }
      if (codePoint >= 97 && codePoint <= 102) {
        return codePoint - 87;
      }
      throw new Error("invalid bloom");
    }
    function isUserEthereumAddressInBloom(bloom, ethereumAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(ethereumAddress)) {
        throw new Error(`Invalid ethereum address given: "${ethereumAddress}"`);
      }
      const address = utils_1.padLeft(ethereumAddress, 64);
      return isInBloom(bloom, address);
    }
    exports2.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;
    function isContractAddressInBloom(bloom, contractAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(contractAddress)) {
        throw new Error(`Invalid contract address given: "${contractAddress}"`);
      }
      return isInBloom(bloom, contractAddress);
    }
    exports2.isContractAddressInBloom = isContractAddressInBloom;
    function isTopicInBloom(bloom, topic) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isTopic(topic)) {
        throw new Error("Invalid topic");
      }
      return isInBloom(bloom, topic);
    }
    exports2.isTopicInBloom = isTopicInBloom;
    function isTopic(topic) {
      if (typeof topic !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
      }
      return false;
    }
    exports2.isTopic = isTopic;
    function isAddress(address) {
      if (typeof address !== "string") {
        return false;
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        return true;
      }
      if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        return true;
      }
      return false;
    }
    exports2.isAddress = isAddress;
  }
});

// node_modules/web3-utils/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/web3-utils/lib/utils.js"(exports2, module2) {
    init_process();
    init_buffer();
    var BN = require_bn();
    var numberToBN = require_src6();
    var utf8 = require_utf8();
    var ethereumjsUtil = require_dist3();
    var ethereumBloomFilters = require_dist4();
    var isBN = function(object) {
      return BN.isBN(object);
    };
    var isBigNumber = function(object) {
      return object && object.constructor && object.constructor.name === "BigNumber";
    };
    var toBN = function(number) {
      try {
        return numberToBN.apply(null, arguments);
      } catch (e) {
        throw new Error(e + ' Given value: "' + number + '"');
      }
    };
    var toTwosComplement = function(number) {
      return "0x" + toBN(number).toTwos(256).toString(16, 64);
    };
    var isAddress = function(address) {
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return checkAddressChecksum(address);
      }
    };
    var checkAddressChecksum = function(address) {
      address = address.replace(/^0x/i, "");
      var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, "");
      for (var i = 0; i < 40; i++) {
        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
          return false;
        }
      }
      return true;
    };
    var leftPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join(sign ? sign : "0") + string;
    };
    var rightPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + string + new Array(padding).join(sign ? sign : "0");
    };
    var utf8ToHex = function(str) {
      str = utf8.encode(str);
      var hex = "";
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var hexToUtf8 = function(hex) {
      if (!isHexStrict(hex))
        throw new Error('The parameter "' + hex + '" must be a valid HEX string.');
      var str = "";
      var code = 0;
      hex = hex.replace(/^0x/i, "");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      var l = hex.length;
      for (var i = 0; i < l; i += 2) {
        code = parseInt(hex.slice(i, i + 2), 16);
        str += String.fromCharCode(code);
      }
      return utf8.decode(str);
    };
    var hexToNumber = function(value, bigIntOnOverflow = false) {
      if (!value) {
        return value;
      }
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      const n = toBN(value);
      if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {
        return BigInt(n);
      }
      return n.toNumber();
    };
    var hexToNumberString = function(value) {
      if (!value)
        return value;
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      return toBN(value).toString(10);
    };
    var numberToHex = function(value) {
      if (value === null || value === void 0) {
        return value;
      }
      if (!isFinite(value) && !isHexStrict(value)) {
        throw new Error('Given input "' + value + '" is not a number.');
      }
      var number = toBN(value);
      var result = number.toString(16);
      return number.lt(new BN(0)) ? "-0x" + result.slice(1) : "0x" + result;
    };
    var bytesToHex = function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return "0x" + hex.join("");
    };
    var hexToBytes = function(hex) {
      hex = hex.toString(16);
      if (!isHexStrict(hex)) {
        throw new Error('Given value "' + hex + '" is not a valid hex string.');
      }
      hex = hex.replace(/^0x/i, "");
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.slice(c, c + 2), 16));
      return bytes;
    };
    var toHex = function(value, returnType) {
      if (isAddress(value)) {
        return returnType ? "address" : "0x" + value.toLowerCase().replace(/^0x/i, "");
      }
      if (typeof value === "boolean") {
        return returnType ? "bool" : value ? "0x01" : "0x00";
      }
      if (Buffer.isBuffer(value)) {
        return "0x" + value.toString("hex");
      }
      if (typeof value === "object" && !!value && !isBigNumber(value) && !isBN(value)) {
        return returnType ? "string" : utf8ToHex(JSON.stringify(value));
      }
      if (typeof value === "string") {
        if (value.indexOf("-0x") === 0 || value.indexOf("-0X") === 0) {
          return returnType ? "int256" : numberToHex(value);
        } else if (value.indexOf("0x") === 0 || value.indexOf("0X") === 0) {
          return returnType ? "bytes" : value;
        } else if (!isFinite(value)) {
          return returnType ? "string" : utf8ToHex(value);
        }
      }
      return returnType ? value < 0 ? "int256" : "uint256" : numberToHex(value);
    };
    var isHexStrict = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
    };
    var isHex = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);
    };
    var stripHexPrefix = function(str) {
      if (str !== 0 && isHex(str))
        return str.replace(/^(-)?0x/i, "$1");
      return str;
    };
    var isBloom = function(bloom) {
      return ethereumBloomFilters.isBloom(bloom);
    };
    var isUserEthereumAddressInBloom = function(bloom, ethereumAddress) {
      return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);
    };
    var isContractAddressInBloom = function(bloom, contractAddress) {
      return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);
    };
    var isTopic = function(topic) {
      return ethereumBloomFilters.isTopic(topic);
    };
    var isTopicInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isTopicInBloom(bloom, topic);
    };
    var isInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isInBloom(bloom, topic);
    };
    var SHA3_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    var sha3 = function(value) {
      if (isBN(value)) {
        value = value.toString();
      }
      if (isHexStrict(value) && /^0x/i.test(value.toString())) {
        value = ethereumjsUtil.toBuffer(value);
      } else if (typeof value === "string") {
        value = Buffer.from(value, "utf-8");
      }
      var returnValue = ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(value));
      if (returnValue === SHA3_NULL_S) {
        return null;
      } else {
        return returnValue;
      }
    };
    sha3._Hash = ethereumjsUtil.keccak256;
    var sha3Raw = function(value) {
      value = sha3(value);
      if (value === null) {
        return SHA3_NULL_S;
      }
      return value;
    };
    var toNumber = function(value, bigIntOnOverflow = false) {
      return typeof value === "number" ? value : hexToNumber(toHex(value), bigIntOnOverflow);
    };
    var BNwrapped = function(value) {
      if (typeof value == "string" && value.includes("0x")) {
        const [negative, hexValue] = value.toLocaleLowerCase().startsWith("-") ? ["-", value.slice(3)] : ["", value.slice(2)];
        return new BN(negative + hexValue, 16);
      } else {
        return new BN(value);
      }
    };
    Object.setPrototypeOf(BNwrapped, BN);
    Object.setPrototypeOf(BNwrapped.prototype, BN.prototype);
    module2.exports = {
      BN: BNwrapped,
      isBN,
      isBigNumber,
      toBN,
      isAddress,
      isBloom,
      isUserEthereumAddressInBloom,
      isContractAddressInBloom,
      isTopic,
      isTopicInBloom,
      isInBloom,
      checkAddressChecksum,
      utf8ToHex,
      hexToUtf8,
      hexToNumber,
      hexToNumberString,
      numberToHex,
      toHex,
      hexToBytes,
      bytesToHex,
      isHex,
      isHexStrict,
      stripHexPrefix,
      leftPad,
      rightPad,
      toTwosComplement,
      sha3,
      sha3Raw,
      toNumber
    };
  }
});

// node_modules/web3-utils/lib/soliditySha3.js
var require_soliditySha3 = __commonJS({
  "node_modules/web3-utils/lib/soliditySha3.js"(exports2, module2) {
    init_process();
    init_buffer();
    var BN = require_bn();
    var utils = require_utils4();
    var _elementaryName = function(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    };
    var _parseTypeN = function(type) {
      var typesize = /^\D+(\d+).*$/.exec(type);
      return typesize ? parseInt(typesize[1], 10) : null;
    };
    var _parseTypeNArray = function(type) {
      var arraySize = /^\D+\d*\[(\d+)\]$/.exec(type);
      return arraySize ? parseInt(arraySize[1], 10) : null;
    };
    var _parseNumber = function(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (utils.isHexStrict(arg)) {
          return new BN(arg.replace(/0x/i, ""), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (utils.isBigNumber(arg)) {
        return new BN(arg.toString(10));
      } else if (utils.isBN(arg)) {
        return arg;
      } else {
        throw new Error(arg + " is not a number");
      }
    };
    var _solidityPack = function(type, value, arraySize) {
      var size, num;
      type = _elementaryName(type);
      if (type === "bytes") {
        if (value.replace(/^0x/i, "").length % 2 !== 0) {
          throw new Error("Invalid bytes characters " + value.length);
        }
        return value;
      } else if (type === "string") {
        return utils.utf8ToHex(value);
      } else if (type === "bool") {
        return value ? "01" : "00";
      } else if (type.startsWith("address")) {
        if (arraySize) {
          size = 64;
        } else {
          size = 40;
        }
        if (!utils.isAddress(value)) {
          throw new Error(value + " is not a valid address, or the checksum is invalid.");
        }
        return utils.leftPad(value.toLowerCase(), size);
      }
      size = _parseTypeN(type);
      if (type.startsWith("bytes")) {
        if (!size) {
          throw new Error("bytes[] not yet supported in solidity");
        }
        if (arraySize) {
          size = 32;
        }
        if (size < 1 || size > 32 || size < value.replace(/^0x/i, "").length / 2) {
          throw new Error("Invalid bytes" + size + " for " + value);
        }
        return utils.rightPad(value, size * 2);
      } else if (type.startsWith("uint")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          throw new Error("Supplied uint " + num.toString() + " is negative");
        }
        return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
      } else if (type.startsWith("int")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          return num.toTwos(size).toString("hex");
        } else {
          return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
        }
      } else {
        throw new Error("Unsupported or invalid type: " + type);
      }
    };
    var _processSolidityEncodePackedArgs = function(arg) {
      if (Array.isArray(arg)) {
        throw new Error("Autodetection of array types is not supported.");
      }
      var type, value = "";
      var hexArg, arraySize;
      if (!!arg && typeof arg === "object" && (arg.hasOwnProperty("v") || arg.hasOwnProperty("t") || arg.hasOwnProperty("value") || arg.hasOwnProperty("type"))) {
        type = arg.hasOwnProperty("t") ? arg.t : arg.type;
        value = arg.hasOwnProperty("v") ? arg.v : arg.value;
      } else {
        type = utils.toHex(arg, true);
        value = utils.toHex(arg);
        if (!type.startsWith("int") && !type.startsWith("uint")) {
          type = "bytes";
        }
      }
      if ((type.startsWith("int") || type.startsWith("uint")) && typeof value === "string" && !/^(-)?0x/i.test(value)) {
        value = new BN(value);
      }
      if (Array.isArray(value)) {
        arraySize = _parseTypeNArray(type);
        if (arraySize && value.length !== arraySize) {
          throw new Error(type + " is not matching the given array " + JSON.stringify(value));
        } else {
          arraySize = value.length;
        }
      }
      if (Array.isArray(value)) {
        hexArg = value.map(function(val) {
          return _solidityPack(type, val, arraySize).toString("hex").replace("0x", "");
        });
        return hexArg.join("");
      } else {
        hexArg = _solidityPack(type, value, arraySize);
        return hexArg.toString("hex").replace("0x", "");
      }
    };
    var soliditySha3 = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return utils.sha3("0x" + hexArgs.join(""));
    };
    var soliditySha3Raw = function() {
      return utils.sha3Raw("0x" + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(""));
    };
    var encodePacked = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return "0x" + hexArgs.join("").toLowerCase();
    };
    module2.exports = {
      soliditySha3,
      soliditySha3Raw,
      encodePacked
    };
  }
});

// node_modules/web3-utils/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/web3-utils/lib/index.js"(exports2, module2) {
    init_process();
    init_buffer();
    var ethjsUnit = require_lib();
    var utils = require_utils4();
    var soliditySha3 = require_soliditySha3();
    var randombytes = require_browser();
    var BN = require_bn();
    var _fireError = function(error, emitter, reject, callback, optionalData) {
      if (!!error && typeof error === "object" && !(error instanceof Error) && error.data) {
        if (!!error.data && typeof error.data === "object" || Array.isArray(error.data)) {
          error.data = JSON.stringify(error.data, null, 2);
        }
        error = error.message + "\n" + error.data;
      }
      if (typeof error === "string") {
        error = new Error(error);
      }
      if (typeof callback === "function") {
        callback(error, optionalData);
      }
      if (typeof reject === "function") {
        if (emitter && (typeof emitter.listeners === "function" && emitter.listeners("error").length) || typeof callback === "function") {
          emitter.catch(function() {
          });
        }
        setTimeout(function() {
          reject(error);
        }, 1);
      }
      if (emitter && typeof emitter.emit === "function") {
        setTimeout(function() {
          emitter.emit("error", error, optionalData);
          emitter.removeAllListeners();
        }, 1);
      }
      return emitter;
    };
    var _jsonInterfaceMethodToString = function(json) {
      if (!!json && typeof json === "object" && json.name && json.name.indexOf("(") !== -1) {
        return json.name;
      }
      return json.name + "(" + _flattenTypes(false, json.inputs).join(",") + ")";
    };
    var _flattenTypes = function(includeTuple, puts) {
      var types = [];
      puts.forEach(function(param) {
        if (typeof param.components === "object") {
          if (param.type.substring(0, 5) !== "tuple") {
            throw new Error("components found but type is not tuple; report on GitHub");
          }
          var suffix = "";
          var arrayBracket = param.type.indexOf("[");
          if (arrayBracket >= 0) {
            suffix = param.type.substring(arrayBracket);
          }
          var result = _flattenTypes(includeTuple, param.components);
          if (Array.isArray(result) && includeTuple) {
            types.push("tuple(" + result.join(",") + ")" + suffix);
          } else if (!includeTuple) {
            types.push("(" + result.join(",") + ")" + suffix);
          } else {
            types.push("(" + result + ")");
          }
        } else {
          types.push(param.type);
        }
      });
      return types;
    };
    var randomHex = function(size) {
      return "0x" + randombytes(size).toString("hex");
    };
    var hexToAscii = function(hex) {
      if (!utils.isHexStrict(hex))
        throw new Error("The parameter must be a valid HEX string.");
      var str = "";
      var i = 0, l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex.slice(i, i + 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    };
    var asciiToHex = function(str) {
      if (!str)
        return "0x00";
      var hex = "";
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var getUnitValue = function(unit) {
      unit = unit ? unit.toLowerCase() : "ether";
      if (!ethjsUnit.unitMap[unit]) {
        throw new Error('This unit "' + unit + `" doesn't exist, please use the one of the following units` + JSON.stringify(ethjsUnit.unitMap, null, 2));
      }
      return unit;
    };
    var fromWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);
    };
    var toWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);
    };
    var toChecksumAddress = function(address) {
      if (typeof address === "undefined")
        return "";
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address))
        throw new Error('Given address "' + address + '" is not a valid Ethereum address.');
      address = address.toLowerCase().replace(/^0x/i, "");
      var addressHash = utils.sha3(address).replace(/^0x/i, "");
      var checksumAddress = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
          checksumAddress += address[i];
        }
      }
      return checksumAddress;
    };
    var compareBlockNumbers = function(a, b) {
      if (a === b) {
        return 0;
      } else if (("genesis" === a || "earliest" === a || 0 === a) && ("genesis" === b || "earliest" === b || 0 === b)) {
        return 0;
      } else if ("genesis" === a || "earliest" === a || a === 0) {
        return -1;
      } else if ("genesis" === b || "earliest" === b || b === 0) {
        return 1;
      } else if (a === "latest" || a === "finalized") {
        if (b === "pending") {
          return -1;
        } else {
          return 1;
        }
      } else if (b === "latest" || b === "finalized") {
        if (a === "pending") {
          return 1;
        } else {
          return -1;
        }
      } else if (a === "pending") {
        return 1;
      } else if (b === "pending") {
        return -1;
      } else if (a === "safe" || b === "safe") {
        return void 0;
      } else {
        let bnA = new BN(a);
        let bnB = new BN(b);
        if (bnA.lt(bnB)) {
          return -1;
        } else if (bnA.eq(bnB)) {
          return 0;
        } else {
          return 1;
        }
      }
    };
    module2.exports = {
      _fireError,
      _jsonInterfaceMethodToString,
      _flattenTypes,
      // extractDisplayName: extractDisplayName,
      // extractTypeName: extractTypeName,
      randomHex,
      BN: utils.BN,
      isBN: utils.isBN,
      isBigNumber: utils.isBigNumber,
      isHex: utils.isHex,
      isHexStrict: utils.isHexStrict,
      sha3: utils.sha3,
      sha3Raw: utils.sha3Raw,
      keccak256: utils.sha3,
      soliditySha3: soliditySha3.soliditySha3,
      soliditySha3Raw: soliditySha3.soliditySha3Raw,
      encodePacked: soliditySha3.encodePacked,
      isAddress: utils.isAddress,
      checkAddressChecksum: utils.checkAddressChecksum,
      toChecksumAddress,
      toHex: utils.toHex,
      toBN: utils.toBN,
      bytesToHex: utils.bytesToHex,
      hexToBytes: utils.hexToBytes,
      hexToNumberString: utils.hexToNumberString,
      hexToNumber: utils.hexToNumber,
      toDecimal: utils.hexToNumber,
      numberToHex: utils.numberToHex,
      fromDecimal: utils.numberToHex,
      hexToUtf8: utils.hexToUtf8,
      hexToString: utils.hexToUtf8,
      toUtf8: utils.hexToUtf8,
      stripHexPrefix: utils.stripHexPrefix,
      utf8ToHex: utils.utf8ToHex,
      stringToHex: utils.utf8ToHex,
      fromUtf8: utils.utf8ToHex,
      hexToAscii,
      toAscii: hexToAscii,
      asciiToHex,
      fromAscii: asciiToHex,
      unitMap: ethjsUnit.unitMap,
      toWei,
      fromWei,
      padLeft: utils.leftPad,
      leftPad: utils.leftPad,
      padRight: utils.rightPad,
      rightPad: utils.rightPad,
      toTwosComplement: utils.toTwosComplement,
      isBloom: utils.isBloom,
      isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,
      isContractAddressInBloom: utils.isContractAddressInBloom,
      isTopic: utils.isTopic,
      isTopicInBloom: utils.isTopicInBloom,
      isInBloom: utils.isInBloom,
      compareBlockNumbers,
      toNumber: utils.toNumber
    };
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/eip-3770/config.js
var require_config = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/eip-3770/config.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.networks = void 0;
    exports2.networks = [
      { chainId: 1, shortName: "eth" },
      { chainId: 3, shortName: "rop" },
      { chainId: 4, shortName: "rin" },
      { chainId: 5, shortName: "gor" },
      { chainId: 10, shortName: "oeth" },
      { chainId: 11, shortName: "meta" },
      { chainId: 12, shortName: "kal" },
      { chainId: 25, shortName: "cro" },
      { chainId: 28, shortName: "bobarinkeby" },
      { chainId: 40, shortName: "telosevm" },
      { chainId: 41, shortName: "telosevmtestnet" },
      { chainId: 42, shortName: "kov" },
      { chainId: 56, shortName: "bnb" },
      { chainId: 61, shortName: "etc" },
      { chainId: 63, shortName: "metc" },
      { chainId: 69, shortName: "okov" },
      { chainId: 82, shortName: "meter" },
      { chainId: 83, shortName: "meter-test" },
      { chainId: 97, shortName: "bnbt" },
      { chainId: 100, shortName: "gno" },
      { chainId: 106, shortName: "vlx" },
      { chainId: 111, shortName: "etl" },
      { chainId: 122, shortName: "fuse" },
      { chainId: 123, shortName: "spark" },
      { chainId: 137, shortName: "matic" },
      { chainId: 246, shortName: "ewt" },
      { chainId: 250, shortName: "ftm" },
      { chainId: 288, shortName: "boba" },
      { chainId: 300, shortName: "ogn" },
      { chainId: 321, shortName: "kcs" },
      { chainId: 322, shortName: "kcst" },
      { chainId: 336, shortName: "sdn" },
      { chainId: 338, shortName: "tcro" },
      { chainId: 420, shortName: "ogor" },
      { chainId: 588, shortName: "metis-stardust" },
      { chainId: 592, shortName: "astr" },
      { chainId: 595, shortName: "maca" },
      { chainId: 686, shortName: "kar" },
      { chainId: 787, shortName: "aca" },
      { chainId: 1001, shortName: "baobab" },
      { chainId: 1008, shortName: "eun" },
      { chainId: 1088, shortName: "metis-andromeda" },
      { chainId: 1284, shortName: "mbeam" },
      { chainId: 1285, shortName: "mriver" },
      { chainId: 1287, shortName: "mbase" },
      { chainId: 1294, shortName: "bobabeam" },
      { chainId: 1807, shortName: "rana" },
      { chainId: 1984, shortName: "euntest" },
      { chainId: 2001, shortName: "milkada" },
      { chainId: 2002, shortName: "milkalgo" },
      { chainId: 2008, shortName: "cloudwalk_testnet" },
      { chainId: 2019, shortName: "pmint_test" },
      { chainId: 4002, shortName: "tftm" },
      { chainId: 2020, shortName: "pmint" },
      { chainId: 2221, shortName: "tkava" },
      { chainId: 2222, shortName: "kava" },
      { chainId: 4918, shortName: "txvm" },
      { chainId: 4919, shortName: "xvm" },
      { chainId: 7341, shortName: "shyft" },
      { chainId: 7700, shortName: "canto" },
      { chainId: 8217, shortName: "cypress" },
      { chainId: 9e3, shortName: "evmos-testnet" },
      { chainId: 9001, shortName: "evmos" },
      { chainId: 1e4, shortName: "smartbch" },
      { chainId: 10001, shortName: "smartbchtest" },
      { chainId: 11437, shortName: "shyftt" },
      { chainId: 12357, shortName: "rei-testnet" },
      { chainId: 42161, shortName: "arb1" },
      { chainId: 42170, shortName: "arb-nova" },
      { chainId: 42220, shortName: "celo" },
      { chainId: 43113, shortName: "fuji" },
      { chainId: 43114, shortName: "avax" },
      { chainId: 47805, shortName: "rei" },
      { chainId: 71401, shortName: "gw-testnet-v1" },
      { chainId: 73799, shortName: "vt" },
      { chainId: 80001, shortName: "maticmum" },
      { chainId: 200101, shortName: "milktada" },
      { chainId: 200202, shortName: "milktalgo" },
      { chainId: 333999, shortName: "olympus" },
      { chainId: 421611, shortName: "arb-rinkeby" },
      { chainId: 421613, shortName: "arb-goerli" },
      { chainId: 11155111, shortName: "sep" },
      { chainId: 1313161554, shortName: "aurora" },
      { chainId: 1313161555, shortName: "aurora-testnet" },
      { chainId: 16666e5, shortName: "hmy-s0" },
      { chainId: 16667e5, shortName: "hmy-b-s0" },
      { chainId: 11297108099, shortName: "tpalm" },
      { chainId: 11297108109, shortName: "palm" }
    ];
    if (process.env.TEST_NETWORK === "hardhat") {
      exports2.networks.push({ shortName: "local", chainId: 31337 });
    } else if (process.env.TEST_NETWORK === "ganache") {
      exports2.networks.push({ shortName: "local", chainId: 1337 });
    }
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/eip-3770/index.js
var require_eip_3770 = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/eip-3770/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateEip3770Address = exports2.validateEthereumAddress = exports2.validateEip3770NetworkPrefix = exports2.isValidEip3770NetworkPrefix = exports2.getEip3770NetworkPrefixFromChainId = exports2.parseEip3770Address = void 0;
    var web3_utils_1 = require_lib3();
    var config_1 = require_config();
    function parseEip3770Address(fullAddress) {
      const parts = fullAddress.split(":");
      const address = parts.length > 1 ? parts[1] : parts[0];
      const prefix = parts.length > 1 ? parts[0] : "";
      return { prefix, address };
    }
    exports2.parseEip3770Address = parseEip3770Address;
    function getEip3770NetworkPrefixFromChainId(chainId) {
      const network = config_1.networks.find((network2) => chainId === network2.chainId);
      if (!network) {
        throw new Error("No network prefix supported for the current chainId");
      }
      return network.shortName;
    }
    exports2.getEip3770NetworkPrefixFromChainId = getEip3770NetworkPrefixFromChainId;
    function isValidEip3770NetworkPrefix(prefix) {
      return config_1.networks.some(({ shortName }) => shortName === prefix);
    }
    exports2.isValidEip3770NetworkPrefix = isValidEip3770NetworkPrefix;
    function validateEip3770NetworkPrefix(prefix, currentChainId) {
      const isCurrentNetworkPrefix = prefix === getEip3770NetworkPrefixFromChainId(currentChainId);
      if (!isValidEip3770NetworkPrefix(prefix) || !isCurrentNetworkPrefix) {
        throw new Error("The network prefix must match the current network");
      }
    }
    exports2.validateEip3770NetworkPrefix = validateEip3770NetworkPrefix;
    function validateEthereumAddress(address) {
      const isValidAddress = (0, web3_utils_1.isHexStrict)(address) && (0, web3_utils_1.isAddress)(address);
      if (!isValidAddress) {
        throw new Error(`Invalid Ethereum address ${address}`);
      }
    }
    exports2.validateEthereumAddress = validateEthereumAddress;
    function validateEip3770Address(fullAddress, currentChainId) {
      const { address, prefix } = parseEip3770Address(fullAddress);
      validateEthereumAddress(address);
      if (prefix) {
        validateEip3770NetworkPrefix(prefix, currentChainId);
      }
      return { address, prefix };
    }
    exports2.validateEip3770Address = validateEip3770Address;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret2 = new Yallist();
      if (to < from || to < 0) {
        return ret2;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret2.push(walker.value);
      }
      return ret2;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret2 = new Yallist();
      if (to < from || to < 0) {
        return ret2;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret2.push(walker.value);
      }
      return ret2;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret2 = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret2.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret2;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    init_process();
    init_buffer();
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/constants.js"(exports2, module2) {
    init_process();
    init_buffer();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/debug.js"(exports2, module2) {
    init_process();
    init_buffer();
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/re.js"(exports2, module2) {
    init_process();
    init_buffer();
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants2();
    var debug = require_debug2();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    init_process();
    init_buffer();
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/classes/semver.js
var require_semver2 = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/classes/semver.js"(exports2, module2) {
    init_process();
    init_buffer();
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${require_util2().inspect(version)}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/compare.js"(exports2, module2) {
    init_process();
    init_buffer();
    var SemVer = require_semver2();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/eq.js"(exports2, module2) {
    init_process();
    init_buffer();
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/neq.js"(exports2, module2) {
    init_process();
    init_buffer();
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/gt.js"(exports2, module2) {
    init_process();
    init_buffer();
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/gte.js"(exports2, module2) {
    init_process();
    init_buffer();
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/lt.js"(exports2, module2) {
    init_process();
    init_buffer();
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/lte.js"(exports2, module2) {
    init_process();
    init_buffer();
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/cmp.js"(exports2, module2) {
    init_process();
    init_buffer();
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/classes/comparator.js"(exports2, module2) {
    init_process();
    init_buffer();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver2();
    var Range = require_range();
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/classes/range.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver2();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceTilde(c, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret2;
        if (isX(M)) {
          ret2 = "";
        } else if (isX(m)) {
          ret2 = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret2 = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret2 = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret2);
        return ret2;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceCaret(c, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret2;
        if (isX(M)) {
          ret2 = "";
        } else if (isX(m)) {
          ret2 = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret2 = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret2 = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret2 = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret2 = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret2 = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret2 = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret2);
        return ret2;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => {
        return replaceXRange(c, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret2, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret2, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret2 = "<0.0.0-0";
          } else {
            ret2 = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret2 = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret2 = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret2 = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret2);
        return ret2;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    init_process();
    init_buffer();
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/eip-712/index.js
var require_eip_712 = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/eip-712/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateTypedData = exports2.getEip712MessageTypes = exports2.EIP712_DOMAIN = exports2.EIP712_DOMAIN_BEFORE_V130 = void 0;
    var bignumber_1 = (init_lib3(), __toCommonJS(lib_exports3));
    var satisfies_1 = __importDefault(require_satisfies());
    var EQ_OR_GT_1_3_0 = ">=1.3.0";
    exports2.EIP712_DOMAIN_BEFORE_V130 = [
      {
        type: "address",
        name: "verifyingContract"
      }
    ];
    exports2.EIP712_DOMAIN = [
      {
        type: "uint256",
        name: "chainId"
      },
      {
        type: "address",
        name: "verifyingContract"
      }
    ];
    function getEip712MessageTypes(safeVersion) {
      const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
      return {
        EIP712Domain: eip712WithChainId ? exports2.EIP712_DOMAIN : exports2.EIP712_DOMAIN_BEFORE_V130,
        SafeTx: [
          { type: "address", name: "to" },
          { type: "uint256", name: "value" },
          { type: "bytes", name: "data" },
          { type: "uint8", name: "operation" },
          { type: "uint256", name: "safeTxGas" },
          { type: "uint256", name: "baseGas" },
          { type: "uint256", name: "gasPrice" },
          { type: "address", name: "gasToken" },
          { type: "address", name: "refundReceiver" },
          { type: "uint256", name: "nonce" }
        ]
      };
    }
    exports2.getEip712MessageTypes = getEip712MessageTypes;
    function generateTypedData({ safeAddress, safeVersion, chainId, safeTransactionData }) {
      const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
      const typedData = {
        types: getEip712MessageTypes(safeVersion),
        domain: {
          verifyingContract: safeAddress
        },
        primaryType: "SafeTx",
        message: {
          ...safeTransactionData,
          value: bignumber_1.BigNumber.from(safeTransactionData.value),
          safeTxGas: bignumber_1.BigNumber.from(safeTransactionData.safeTxGas),
          baseGas: bignumber_1.BigNumber.from(safeTransactionData.baseGas),
          gasPrice: bignumber_1.BigNumber.from(safeTransactionData.gasPrice),
          nonce: bignumber_1.BigNumber.from(safeTransactionData.nonce)
        }
      };
      if (eip712WithChainId) {
        typedData.domain.chainId = chainId;
      }
      return typedData;
    }
    exports2.generateTypedData = generateTypedData;
  }
});

// node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/index.js
var require_src7 = __commonJS({
  "node_modules/@gnosis.pm/safe-core-sdk-utils/dist/src/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_eip_3770(), exports2);
    __exportStar(require_eip_712(), exports2);
  }
});

// node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/SmartWalletContractV100__factory.js
var require_SmartWalletContractV100_factory = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/SmartWalletContractV100__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartWalletContractV100__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "anEntryPoint",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "smartAccount",
            type: "address"
          }
        ],
        name: "AlreadyInitialized",
        type: "error"
      },
      {
        inputs: [],
        name: "BaseImplementationCannotBeZero",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "caller",
            type: "address"
          }
        ],
        name: "CallerIsNotAnEntryPoint",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "caller",
            type: "address"
          }
        ],
        name: "CallerIsNotEntryPointOrOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "caller",
            type: "address"
          }
        ],
        name: "CallerIsNotOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "caller",
            type: "address"
          }
        ],
        name: "CallerIsNotSelf",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "targetTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        name: "CanNotEstimateGas",
        type: "error"
      },
      {
        inputs: [],
        name: "EntryPointCannotBeZero",
        type: "error"
      },
      {
        inputs: [],
        name: "ExecutionFailed",
        type: "error"
      },
      {
        inputs: [],
        name: "HandlerCannotBeZero",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "implementationAddress",
            type: "address"
          }
        ],
        name: "InvalidImplementation",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "restoredSigner",
            type: "address"
          },
          {
            internalType: "address",
            name: "expectedSigner",
            type: "address"
          }
        ],
        name: "InvalidSignature",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "nonceProvided",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonceExpected",
            type: "uint256"
          }
        ],
        name: "InvalidUserOpNonceProvided",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "caller",
            type: "address"
          }
        ],
        name: "MixedAuthFail",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ModuleAlreadyEnabled",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "expectedModule",
            type: "address"
          },
          {
            internalType: "address",
            name: "returnedModule",
            type: "address"
          },
          {
            internalType: "address",
            name: "prevModule",
            type: "address"
          }
        ],
        name: "ModuleAndPrevModuleMismatch",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ModuleCannotBeZeroOrSentinel",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ModuleNotEnabled",
        type: "error"
      },
      {
        inputs: [],
        name: "ModulesAlreadyInitialized",
        type: "error"
      },
      {
        inputs: [],
        name: "ModulesSetupExecutionFailed",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "gasLeft",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasRequired",
            type: "uint256"
          }
        ],
        name: "NotEnoughGasLeft",
        type: "error"
      },
      {
        inputs: [],
        name: "OwnerCannotBeZero",
        type: "error"
      },
      {
        inputs: [],
        name: "ReentrancyProtectionActivated",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "dest",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "TokenTransferFailed",
        type: "error"
      },
      {
        inputs: [],
        name: "TransferToZeroAddressAttempt",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "destLength",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "valueLength",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "funcLength",
            type: "uint256"
          }
        ],
        name: "WrongBatchProvided",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "contractSignature",
            type: "bytes"
          }
        ],
        name: "WrongContractSignature",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "uintS",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "contractSignatureLength",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "signatureLength",
            type: "uint256"
          }
        ],
        name: "WrongContractSignatureFormat",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "AccountHandlePayment",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousHandler",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "ChangedFallbackHandler",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "_scw",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "_oldEOA",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "_newEOA",
            type: "address"
          }
        ],
        name: "EOAChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "txGas",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "txGas",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "oldImplementation",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newImplementation",
            type: "address"
          }
        ],
        name: "ImplementationUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "module",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "ModuleTransaction",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "SmartAccountReceivedNativeToken",
        type: "event"
      },
      {
        stateMutability: "nonpayable",
        type: "fallback"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "addDeposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "checkSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "value",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "data",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "targetTxGas",
                type: "uint256"
              }
            ],
            internalType: "struct Transaction",
            name: "_tx",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "tokenGasPriceFactor",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "gasToken",
                type: "address"
              },
              {
                internalType: "address payable",
                name: "refundReceiver",
                type: "address"
              }
            ],
            internalType: "struct FeeRefund",
            name: "refundInfo",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "value",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "data",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "targetTxGas",
                type: "uint256"
              }
            ],
            internalType: "struct Transaction",
            name: "_tx",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "tokenGasPriceFactor",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "gasToken",
                type: "address"
              },
              {
                internalType: "address payable",
                name: "refundReceiver",
                type: "address"
              }
            ],
            internalType: "struct FeeRefund",
            name: "refundInfo",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "value",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "data",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "targetTxGas",
                type: "uint256"
              }
            ],
            internalType: "struct Transaction",
            name: "_tx",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "baseGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "tokenGasPriceFactor",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "gasToken",
                type: "address"
              },
              {
                internalType: "address payable",
                name: "refundReceiver",
                type: "address"
              }
            ],
            internalType: "struct FeeRefund",
            name: "refundInfo",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction_S6W",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "dest",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "value",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "func",
            type: "bytes[]"
          }
        ],
        name: "executeBatchCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "dest",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "value",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "func",
            type: "bytes[]"
          }
        ],
        name: "executeBatchCall_4by",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "dest",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "func",
            type: "bytes"
          }
        ],
        name: "executeCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "dest",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "func",
            type: "bytes"
          }
        ],
        name: "executeCall_s1m",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getChainId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getFallbackHandler",
        outputs: [
          {
            internalType: "address",
            name: "_handler",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getImplementation",
        outputs: [
          {
            internalType: "address",
            name: "_implementation",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "batchId",
            type: "uint256"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "targetTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenGasPriceFactor",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "gasUsed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenGasPriceFactor",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          }
        ],
        name: "handlePaymentRevert",
        outputs: [
          {
            internalType: "uint256",
            name: "requiredGas",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "_handler",
            type: "address"
          }
        ],
        name: "init",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "isModuleEnabled",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "dest",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "pullTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "dest",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_implementation",
            type: "address"
          }
        ],
        name: "updateImplementation",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "missingAccountFunds",
            type: "uint256"
          }
        ],
        name: "validateUserOp",
        outputs: [
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawDepositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var _bytecode = "0x60e06040523480156200001157600080fd5b5060405162003a1f38038062003a1f8339810160408190526200003491620000a3565b60016031553060c052603280546001600160a01b03191673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee179055806001600160a01b0381166200008c5760405163091748f960e21b815260040160405180910390fd5b6001600160a01b0316608052504660a052620000d5565b600060208284031215620000b657600080fd5b81516001600160a01b0381168114620000ce57600080fd5b9392505050565b60805160a05160c0516138f06200012f60003960006102af015260006105210152600081816107bb01528181610ea801528181611005015281816110b201528181611a0e01528181611a9f015261212801526138f06000f3fe6080604052600436106102a05760003560e01c80638da5cb5b1161016e578063c399ec88116100cb578063f08a03231161007f578063f698da2511610064578063f698da25146108c2578063fc7d3d791461092b578063ffa1ad741461093e57610350565b8063f08a032314610882578063f09a4016146108a257610350565b8063cc2f8452116100b0578063cc2f845214610814578063e009cfde14610842578063ed516d511461086257610350565b8063c399ec88146107df578063c4ca3a9c146107f457610350565b8063aaf10f4211610122578063ac85dca711610107578063ac85dca714610777578063affed0e014610797578063b0d691fe146107ac57610350565b8063aaf10f4214610743578063abc1b7451461075757610350565b80639e5d4c49116101535780639e5d4c49146106e3578063a18f51e514610703578063a9059cbb1461072357610350565b80638da5cb5b146106a3578063912ccaa3146106c357610350565b80633a871cdd1161021c5780635229073f116101d0578063610b5925116101b5578063610b5925146106285780637455ce3c14610648578063856dfd991461065b57610350565b80635229073f146105cd5780635c0ba299146105fb57610350565b8063468721a711610201578063468721a7146105925780634a58db19146105b25780634d44560d146105ba57610350565b80633a871cdd146105455780633d46b8191461056557610350565b806313af4035116102735780631626ba7e116102585780631626ba7e146104b95780632d9ad53d146104f25780633408e4701461051257610350565b806313af40351461045e578063141a468c1461047e57610350565b80610772146103b65780618f2d146103d857806301ffc9a7146103f8578063025b22bc1461043e57610350565b36610350576001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036103225760405162461bcd60e51b815260206004820152601d60248201527f6f6e6c7920616c6c6f776564207669612064656c656761746543616c6c00000060448201526064015b60405180910390fd5b604051349033907ed05ab44e279ac59e855cb75dc2ae23b200ad994797b6f1f028f96a46ecce0290600090a3005b34801561035c57600080fd5b507f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d480548061038757005b36600080373360601b365260008060143601600080855af190503d6000803e806103b0573d6000fd5b503d6000f35b3480156103c257600080fd5b506103d66103d1366004612bba565b610987565b005b3480156103e457600080fd5b506103d66103f3366004612c5b565b6109d6565b34801561040457600080fd5b50610429610413366004612d0b565b6001600160e01b0319166301ffc9a760e01b1490565b60405190151581526020015b60405180910390f35b34801561044a57600080fd5b506103d6610459366004612d28565b610ae2565b34801561046a57600080fd5b506103d6610479366004612d28565b610bea565b34801561048a57600080fd5b506104ab610499366004612d45565b60336020526000908152604090205481565b604051908152602001610435565b3480156104c557600080fd5b506104d96104d4366004612e2a565b610d96565b6040516001600160e01b03199091168152602001610435565b3480156104fe57600080fd5b5061042961050d366004612d28565b610e63565b34801561051e57600080fd5b507f00000000000000000000000000000000000000000000000000000000000000006104ab565b34801561055157600080fd5b506104ab610560366004612e71565b610e9b565b34801561057157600080fd5b506104ab610580366004612d45565b60009081526033602052604090205490565b34801561059e57600080fd5b506104296105ad366004612ed4565b610f04565b6103d6611003565b6103d66105c8366004612f3e565b611083565b3480156105d957600080fd5b506105ed6105e8366004612ed4565b611139565b604051610435929190612fba565b34801561060757600080fd5b5061061b6106163660046130b5565b61116f565b604051610435919061310d565b34801561063457600080fd5b506103d6610643366004612d28565b6112c9565b610429610656366004613120565b6113ef565b34801561066757600080fd5b507f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4545b6040516001600160a01b039091168152602001610435565b3480156106af57600080fd5b5060325461068b906001600160a01b031681565b3480156106cf57600080fd5b506103d66106de366004612c5b565b61162d565b3480156106ef57600080fd5b506103d66106fe366004612bba565b61163b565b34801561070f57600080fd5b506104ab61071e366004613195565b611647565b34801561072f57600080fd5b506103d661073e366004612f3e565b6117e0565b34801561074f57600080fd5b50305461068b565b34801561076357600080fd5b506104ab6107723660046131f3565b61187e565b34801561078357600080fd5b506103d66107923660046132bb565b611951565b3480156107a357600080fd5b506104ab6119e7565b3480156107b857600080fd5b507f000000000000000000000000000000000000000000000000000000000000000061068b565b3480156107eb57600080fd5b506104ab611a7f565b34801561080057600080fd5b506104ab61080f3660046132fc565b611ace565b34801561082057600080fd5b5061083461082f366004612f3e565b611b47565b60405161043592919061336d565b34801561084e57600080fd5b506103d661085d3660046133ca565b611c40565b34801561086e57600080fd5b506103d661087d366004612e2a565b611d72565b34801561088e57600080fd5b506103d661089d366004612d28565b612004565b3480156108ae57600080fd5b506103d66108bd3660046133ca565b61207b565b3480156108ce57600080fd5b506104ab604080517f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692186020820152469181019190915230606082015260009060800160405160208183030381529060405280519060200120905090565b610429610939366004613120565b612110565b34801561094a57600080fd5b5061061b6040518060400160405280600581526020017f312e302e3000000000000000000000000000000000000000000000000000000081525081565b61098f61211d565b6109d0848484848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061218392505050565b50505050565b6109de61211d565b8415806109eb5750848314155b806109f65750828114155b15610a2557604051630a0c0a9160e31b8152600481018690526024810184905260448101829052606401610319565b60005b85811015610ad957610ad1878783818110610a4557610a45613403565b9050602002016020810190610a5a9190612d28565b868684818110610a6c57610a6c613403565b90506020020135858585818110610a8557610a85613403565b9050602002810190610a979190613419565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061218392505050565b600101610a28565b50505050505050565b6032546001600160a01b03163314801590610afd5750333014155b15610b1d576040516308a0b0a560e11b8152336004820152602401610319565b6001600160a01b038116610b735760405162461bcd60e51b815260206004820152601660248201527f416464726573732063616e6e6f74206265207a65726f000000000000000000006044820152606401610319565b6001600160a01b0381163b610ba657604051630c76093760e01b81526001600160a01b0382166004820152602401610319565b308054908290556040516001600160a01b0380841691908316907faa3f731066a578e5f39b4215468d826cdd15373cbc0dfc9cb9bdc649718ef7da90600090a35050565b6032546001600160a01b03163314801590610c055750333014155b15610c25576040516308a0b0a560e11b8152336004820152602401610319565b6001600160a01b038116610c4c57604051639b15e16f60e01b815260040160405180910390fd5b306001600160a01b03821603610cca5760405162461bcd60e51b815260206004820152603460248201527f536d617274204163636f756e743a3a206e6577205369676e61746f727920616460448201527f64726573732063616e6e6f742062652073656c660000000000000000000000006064820152608401610319565b6032546001600160a01b0390811690821603610d4e5760405162461bcd60e51b815260206004820152602f60248201527f6e6577205369676e61746f727920616464726573732063616e6e6f742062652060448201527f73616d65206173206f6c64206f6e6500000000000000000000000000000000006064820152608401610319565b60328054908290556040516001600160a01b0391821691831690829030907ff2c2b1b5312b1e31ad49a7d85acd6322ae6facc51488810b882ecdb4df861cd490600090a45050565b6032546000906001600160a01b03163b15610e2557603254604051630b135d3f60e11b81526001600160a01b0390911690631626ba7e90610ddd9086908690600401613460565b602060405180830381865afa158015610dfa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e1e9190613479565b9050610e5d565b610e2f83836121a1565b6032546001600160a01b03918216911603610e525750630b135d3f60e11b610e5d565b506001600160e01b03195b92915050565b600060016001600160a01b03831614801590610e5d5750506001600160a01b0390811660009081526020819052604090205416151590565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610ee857604051635dac3db760e11b8152336004820152602401610319565b610ef284846121c5565b9050610efd826123b6565b9392505050565b60003360011480610f2b5750336000908152602081905260409020546001600160a01b0316155b15610f4b576040516321ac7c5f60e01b8152336004820152602401610319565b610f58858585855a612401565b90508015610fcf577f8c014e41cffd68ba64f3e7830b8b2e4ee860509d8deab25ebbcbba2f0405e2da3386868686604051610f979594939291906134ce565b60405180910390a160405133907f6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb890600090a2610ffb565b60405133907facd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd37590600090a25b949350505050565b7f000000000000000000000000000000000000000000000000000000000000000060405163b760faf960e01b81523060048201526001600160a01b03919091169063b760faf99034906024016000604051808303818588803b15801561106857600080fd5b505af115801561107c573d6000803e3d6000fd5b5050505050565b6032546001600160a01b031633146110b05760405163d4ed9a1760e01b8152336004820152602401610319565b7f000000000000000000000000000000000000000000000000000000000000000060405163040b850f60e31b81526001600160a01b03848116600483015260248201849052919091169063205c287890604401600060405180830381600087803b15801561111d57600080fd5b505af1158015611131573d6000803e3d6000fd5b505050505050565b6000606061114986868686610f04565b915060405160203d0181016040523d81523d6000602083013e8091505094509492505050565b606060007fda033865d68bf4a40a5a7cb4159a99e33dba8569e65ea3e38222eb12d9e66eee60001b856000015186604001518760600151805190602001208860200151896080015189600001518a602001518b604001518c606001518d608001518d6040516020016111ec9c9b9a99989796959493929190613519565b60408051601f1981840301815291905280516020909101209050601960f81b600160f81b61126c604080517f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692186020820152469181019190915230606082015260009060800160405160208183030381529060405280519060200120905090565b6040517fff0000000000000000000000000000000000000000000000000000000000000093841660208201529290911660218301526022820152604281018290526062016040516020818303038152906040529150509392505050565b6112d1612508565b6001600160a01b03811615806112f057506001600160a01b0381166001145b156113195760405163cadb248f60e01b81526001600160a01b0382166004820152602401610319565b6001600160a01b03818116600090815260208190526040902054161561135d5760405163b29d459560e01b81526001600160a01b0382166004820152602401610319565b600060208181527fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d80546001600160a01b0385811680865260408087208054939094166001600160a01b03199384161790935560019095528254168417909155519182527fecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f8440910160405180910390a150565b600060026031540361141457604051637465d9d160e01b815260040160405180910390fd5b600260315560005a6001600090815260336020527f10f6f77027d502f219862b0303542eb5dd005b06fa23ff4d1775aaa45bbf947780549293509091829161146e91899189919085611465836135a8565b9190505561116f565b80516020820120925090506114838286611d72565b506114b2603f60068860800151901b61149c91906135c1565b60808801516114ad906109c46135e3565b61252a565b6114be906101f46135e3565b5a101561151d575a6114ef603f60068960800151901b6114de91906135c1565b60808901516114ad906109c46135e3565b6114fb906101f46135e3565b604051633b4daac960e01b815260048101929092526024820152604401610319565b61155d8660000151876040015188606001518960200151896020015160001461154a578a60800151612401565b6109c45a61155891906135f6565b612401565b92508215801561156f57506080860151155b801561157d57506020850151155b156115b65760808601516020860151604051631061f87f60e31b8152600481019290925260248201528315156044820152606401610319565b6000856020015160001461161e576115ed5a6115d290856135f6565b8751602089015160408a015160608b015160808c0151612540565b905080827f3fd74c38c9f1b6f0499c6d0128fbf77a796dbacc7eda0369b13006dc977bb56b60405160405180910390a35b50506001603155509392505050565b6111318686868686866109d6565b6109d084848484610987565b6000836000036116995760405162461bcd60e51b815260206004820152601b60248201527f696e76616c696420746f6b656e4761735072696365466163746f7200000000006044820152606401610319565b60005a905060006001600160a01b038416156116b557836116b7565b325b90506001600160a01b03851661173a5760003a88106116d6573a6116d8565b875b6116e28a8c6135e3565b6116ec9190613609565b9050600080600080600085875af19050806117335760405163190eecf360e31b8152600060048201526001600160a01b038416602482015260448101839052606401610319565b50506117a2565b600086886117488b8d6135e3565b6117529190613609565b61175c91906135c1565b905061176986838361269a565b6117a05760405163190eecf360e31b81526001600160a01b0380881660048301528316602482015260448101829052606401610319565b505b5a82039250826040516020016117ba91815260200190565b60408051601f198184030181529082905262461bcd60e51b82526103199160040161310d565b6032546001600160a01b0316331461180d5760405163d4ed9a1760e01b8152336004820152602401610319565b6001600160a01b038216611834576040516309293b1960e41b815260040160405180910390fd5b600080600080600085875af19050806118795760405163190eecf360e31b8152600060048201526001600160a01b038416602482015260448101839052606401610319565b505050565b6000806040518060a001604052808f6001600160a01b031681526020018b60018111156118ad576118ad613496565b81526020018e81526020018d8d8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525060209081018b90526040805160a0810182528b81529182018a905281018890526001600160a01b0380881660608301528616608082015290915061193682828661116f565b80519060200120925050509c9b505050505050505050505050565b6032546001600160a01b0316331461197e5760405163d4ed9a1760e01b8152336004820152602401610319565b6001600160a01b0382166119a5576040516309293b1960e41b815260040160405180910390fd5b6119b083838361269a565b6118795760405163190eecf360e31b81526001600160a01b0380851660048301528316602482015260448101829052606401610319565b604051631aab3f0d60e11b8152306004820152600060248201819052906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906335567e1a906044015b602060405180830381865afa158015611a56573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a7a9190613620565b905090565b6040516370a0823160e01b81523060048201526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401611a39565b6000805a9050611b17878787878080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525089925050505a612401565b611b3457604051632b3f6d1160e21b815260040160405180910390fd5b5a604080519183036020830152016117ba565b606060008267ffffffffffffffff811115611b6457611b64612d5e565b604051908082528060200260200182016040528015611b8d578160200160208202803683370190505b506001600160a01b0380861660009081526020819052604081205492945091165b6001600160a01b03811615801590611bd057506001600160a01b038116600114155b8015611bdb57508482105b15611c325780848381518110611bf357611bf3613403565b6001600160a01b039283166020918202929092018101919091529181166000908152918290526040909120541681611c2a816135a8565b925050611bae565b908352919491935090915050565b611c48612508565b6001600160a01b0381161580611c6757506001600160a01b0381166001145b15611c905760405163cadb248f60e01b81526001600160a01b0382166004820152602401610319565b6001600160a01b03828116600090815260208190526040902054811690821614611cf8576001600160a01b0382811660008181526020819052604090819020549051633103525b60e21b81528484166004820152921660248301526044820152606401610319565b6001600160a01b03818116600081815260208181526040808320805488871685528285208054919097166001600160a01b03199182161790965592849052825490941690915591519081527faab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace4054276910160405180910390a15050565b604181511015611dc45760405162461bcd60e51b815260206004820152601960248201527f496e76616c6964207369676e617475726573206c656e677468000000000000006044820152606401610319565b600080600080611de7856020810151604082015160419092015160ff1692909190565b9195509350915060ff8416600003611f2c5750816041821015611e2e576040516338a245ff60e11b8152600481018390526000602482018190526044820152606401610319565b6020828601810151865190918290611e479086906135e3565b611e5191906135e3565b1115611e845785516040516338a245ff60e11b815260048101859052602481018390526044810191909152606401610319565b604051630b135d3f60e11b808252878501602001916001600160a01b03851690631626ba7e90611eba908c908690600401613460565b602060405180830381865afa158015611ed7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611efb9190613479565b6001600160e01b03191614611f25578060405163605d348960e01b8152600401610319919061310d565b5050611fbf565b601e8460ff161115611faf57611fa7611f46600486613639565b8484611f9f8a6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b9291906127eb565b509050611fbf565b611fbb868585856127eb565b5090505b6032546001600160a01b03828116911614611131576032546040516310b5d43760e21b81526001600160a01b0380841660048301529091166024820152604401610319565b61200c612508565b7f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d454612037826128af565b816001600160a01b0316816001600160a01b03167f06be9a1bea257286cf2afa8205ed494ca9d6a4b41aa58d04238deebada20fb0c60405160405180910390a35050565b6032546001600160a01b0316156120a7576040516393360fbf60e01b8152306004820152602401610319565b6001600160a01b0382166120ce57604051639b15e16f60e01b815260040160405180910390fd5b603280546001600160a01b0319166001600160a01b0384161790556120f2816128af565b61210c6000604051806020016040528060008152506128fa565b5050565b6000610ffb8484846113ef565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161480159061216157506032546001600160a01b03163314155b15612181576040516332dbd3c760e11b8152336004820152602401610319565b565b60008082516020840185875af16040513d6000823e8161107c573d81fd5b60008060006121b085856129c4565b915091506121bd81612a09565b509392505050565b600036816121d66060860186613419565b909250905080156122dd5760006121f06004828486613652565b6121f99161367c565b90506361a2b3b760e01b6001600160e01b03198216016122db57600080806122248560048189613652565b81019061223191906136ac565b6001600160a01b03808416600090815260208190526040902054939650919450925016156122d757604051631179c1f560e11b81526001600160a01b038416906322f383ea90612287908c908c9060040161376a565b6020604051808303816000875af11580156122a6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122ca9190613620565b9650505050505050610e5d565b5050505b505b6000612336856040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b9050612386612349610140880188613419565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525085939250506121a19050565b6032546001600160a01b039081169116146123a75760019350505050610e5d565b50600095945050505050565b50565b80156123b35760405133906000199083906000818181858888f193505050503d80600081146109d0576040519150601f19603f3d011682016040523d82523d6000602084013e6109d0565b6000600183600181111561241757612417613496565b0361242f576000808551602087018986f4905061243f565b600080855160208701888a87f190505b80156124a457836040516124539190613883565b604051809103902085876001600160a01b03167f81d12fffced46c214dfae8ab8fa0b9f7b69f70c9d500e33f612f2105deb261ee868660405161249792919061389f565b60405180910390a46124ff565b836040516124b29190613883565b604051809103902085876001600160a01b03167f3ddd038f78c876172d5dbfd730b14c9f8692dfa197ef104eaac6df3f85a0874a86866040516124f692919061389f565b60405180910390a45b95945050505050565b333014612181576040516301478e3360e21b8152336004820152602401610319565b60008183116125395781610efd565b5090919050565b6000836000036125925760405162461bcd60e51b815260206004820152601b60248201527f696e76616c696420746f6b656e4761735072696365466163746f7200000000006044820152606401610319565b60006001600160a01b038316156125a957826125ab565b325b90506001600160a01b03841661262b573a86106125c8573a6125ca565b855b6125d4888a6135e3565b6125de9190613609565b9150600080600080600086865af19050806126255760405163190eecf360e31b8152600060048201526001600160a01b038316602482015260448101849052606401610319565b5061268f565b8486612637898b6135e3565b6126419190613609565b61264b91906135c1565b915061265884828461269a565b61268f5760405163190eecf360e31b81526001600160a01b0380861660048301528216602482015260448101839052606401610319565b509695505050505050565b60006001600160a01b0384166126f25760405162461bcd60e51b815260206004820152601d60248201527f746f6b656e2063616e206e6f74206265207a65726f20616464726573730000006044820152606401610319565b6000846001600160a01b03163b1161274c5760405162461bcd60e51b815260206004820152601c60248201527f746f6b656e20636f6e747261637420646f65736e2774206578697374000000006044820152606401610319565b604080516001600160a01b03851660248201526044808201859052825180830390910181526064909101909152602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663a9059cbb60e01b178152825160009182896127105a03f13d80156127ce57602081146127d657600093506127e1565b8193506127e1565b600051158215171593505b5050509392505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561282257506000905060036128a6565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015612876573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661289f576000600192509250506128a6565b9150600090505b94509492505050565b6001600160a01b0381166128d65760405163dd449f5f60e01b815260040160405180910390fd5b7f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d455565b600160009081526020527fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d546001600160a01b03161561294d5760405163df8cc4e360e01b815260040160405180910390fd5b600160008181526020527fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d80546001600160a01b03191690911790556001600160a01b0382161561210c576129a78260008360015a612401565b61210c5760405163032e3a3960e51b815260040160405180910390fd5b60008082516041036129fa5760208301516040840151606085015160001a6129ee878285856127eb565b94509450505050612a02565b506000905060025b9250929050565b6000816004811115612a1d57612a1d613496565b03612a255750565b6001816004811115612a3957612a39613496565b03612a865760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610319565b6002816004811115612a9a57612a9a613496565b03612ae75760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610319565b6003816004811115612afb57612afb613496565b036123b35760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610319565b6001600160a01b03811681146123b357600080fd5b8035612b7381612b53565b919050565b60008083601f840112612b8a57600080fd5b50813567ffffffffffffffff811115612ba257600080fd5b602083019150836020828501011115612a0257600080fd5b60008060008060608587031215612bd057600080fd5b8435612bdb81612b53565b935060208501359250604085013567ffffffffffffffff811115612bfe57600080fd5b612c0a87828801612b78565b95989497509550505050565b60008083601f840112612c2857600080fd5b50813567ffffffffffffffff811115612c4057600080fd5b6020830191508360208260051b8501011115612a0257600080fd5b60008060008060008060608789031215612c7457600080fd5b863567ffffffffffffffff80821115612c8c57600080fd5b612c988a838b01612c16565b90985096506020890135915080821115612cb157600080fd5b612cbd8a838b01612c16565b90965094506040890135915080821115612cd657600080fd5b50612ce389828a01612c16565b979a9699509497509295939492505050565b6001600160e01b0319811681146123b357600080fd5b600060208284031215612d1d57600080fd5b8135610efd81612cf5565b600060208284031215612d3a57600080fd5b8135610efd81612b53565b600060208284031215612d5757600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715612d9757612d97612d5e565b60405290565b600082601f830112612dae57600080fd5b813567ffffffffffffffff80821115612dc957612dc9612d5e565b604051601f8301601f19908116603f01168101908282118183101715612df157612df1612d5e565b81604052838152866020858801011115612e0a57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215612e3d57600080fd5b82359150602083013567ffffffffffffffff811115612e5b57600080fd5b612e6785828601612d9d565b9150509250929050565b600080600060608486031215612e8657600080fd5b833567ffffffffffffffff811115612e9d57600080fd5b84016101608187031215612eb057600080fd5b95602085013595506040909401359392505050565b803560028110612b7357600080fd5b60008060008060808587031215612eea57600080fd5b8435612ef581612b53565b935060208501359250604085013567ffffffffffffffff811115612f1857600080fd5b612f2487828801612d9d565b925050612f3360608601612ec5565b905092959194509250565b60008060408385031215612f5157600080fd5b8235612f5c81612b53565b946020939093013593505050565b60005b83811015612f85578181015183820152602001612f6d565b50506000910152565b60008151808452612fa6816020860160208601612f6a565b601f01601f19169290920160200192915050565b8215158152604060208201526000610ffb6040830184612f8e565b600060a08284031215612fe757600080fd5b612fef612d74565b90508135612ffc81612b53565b815261300a60208301612ec5565b602082015260408201356040820152606082013567ffffffffffffffff81111561303357600080fd5b61303f84828501612d9d565b6060830152506080820135608082015292915050565b600060a0828403121561306757600080fd5b61306f612d74565b9050813581526020820135602082015260408201356040820152606082013561309781612b53565b606082015260808201356130aa81612b53565b608082015292915050565b600080600060e084860312156130ca57600080fd5b833567ffffffffffffffff8111156130e157600080fd5b6130ed86828701612fd5565b9350506130fd8560208601613055565b915060c084013590509250925092565b602081526000610efd6020830184612f8e565b600080600060e0848603121561313557600080fd5b833567ffffffffffffffff8082111561314d57600080fd5b61315987838801612fd5565b94506131688760208801613055565b935060c086013591508082111561317e57600080fd5b5061318b86828701612d9d565b9150509250925092565b60008060008060008060c087890312156131ae57600080fd5b8635955060208701359450604087013593506060870135925060808701356131d581612b53565b915060a08701356131e581612b53565b809150509295509295509295565b6000806000806000806000806000806000806101608d8f03121561321657600080fd5b6132208d35612b53565b8c359b5060208d01359a5067ffffffffffffffff60408e0135111561324457600080fd5b6132548e60408f01358f01612b78565b909a50985061326560608e01612ec5565b975060808d0135965060a08d0135955060c08d0135945060e08d013593506101008d013561329281612b53565b92506132a16101208e01612b68565b91506101408d013590509295989b509295989b509295989b565b6000806000606084860312156132d057600080fd5b83356132db81612b53565b925060208401356132eb81612b53565b929592945050506040919091013590565b60008060008060006080868803121561331457600080fd5b853561331f81612b53565b945060208601359350604086013567ffffffffffffffff81111561334257600080fd5b61334e88828901612b78565b9094509250613361905060608701612ec5565b90509295509295909350565b604080825283519082018190526000906020906060840190828701845b828110156133af5781516001600160a01b03168452928401929084019060010161338a565b5050506001600160a01b039490941692019190915250919050565b600080604083850312156133dd57600080fd5b82356133e881612b53565b915060208301356133f881612b53565b809150509250929050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261343057600080fd5b83018035915067ffffffffffffffff82111561344b57600080fd5b602001915036819003821315612a0257600080fd5b828152604060208201526000610ffb6040830184612f8e565b60006020828403121561348b57600080fd5b8151610efd81612cf5565b634e487b7160e01b600052602160045260246000fd5b600281106134ca57634e487b7160e01b600052602160045260246000fd5b9052565b60006001600160a01b03808816835280871660208401525084604083015260a0606083015261350060a0830185612f8e565b905061350f60808301846134ac565b9695505050505050565b6000610180820190508d82526001600160a01b03808e1660208401528c60408401528b606084015261354e608084018c6134ac565b8960a08401528860c08401528760e08401528661010084015280861661012084015280851661014084015250826101608301529d9c50505050505050505050505050565b634e487b7160e01b600052601160045260246000fd5b6000600182016135ba576135ba613592565b5060010190565b6000826135de57634e487b7160e01b600052601260045260246000fd5b500490565b80820180821115610e5d57610e5d613592565b81810381811115610e5d57610e5d613592565b8082028115828204841417610e5d57610e5d613592565b60006020828403121561363257600080fd5b5051919050565b60ff8281168282160390811115610e5d57610e5d613592565b6000808585111561366257600080fd5b8386111561366f57600080fd5b5050820193919092039150565b6001600160e01b031981358181169160048510156136a45780818660040360031b1b83161692505b505092915050565b6000806000606084860312156136c157600080fd5b83356136cc81612b53565b925060208401359150604084013567ffffffffffffffff8111156136ef57600080fd5b61318b86828701612d9d565b6000808335601e1984360301811261371257600080fd5b830160208101925035905067ffffffffffffffff81111561373257600080fd5b803603821315612a0257600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6040815261378b6040820161377e85612b68565b6001600160a01b03169052565b6020830135606082015260006137a460408501856136fb565b6101608060808601526137bc6101a086018385613741565b92506137cb60608801886136fb565b9250603f19808786030160a08801526137e5858584613741565b9450608089013560c088015260a089013560e0880152610100935060c089013584880152610120915060e089013582880152610140848a01358189015261382e838b018b6136fb565b95509250818887030184890152613846868685613741565b9550613854818b018b6136fb565b955093505080878603016101808801525050613871838383613741565b93505050508260208301529392505050565b60008251613895818460208701612f6a565b9190910192915050565b604081016138ad82856134ac565b826020830152939250505056fea2646970667358221220750920d060980345ed31d08cecba460ebce481c1400f500a2e5520be161a819a64736f6c63430008110033";
    var isSuperArgs = (xs) => xs.length > 1;
    var SmartWalletContractV100__factory = class extends ethers_1.ContractFactory {
      constructor(...args) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        this.contractName = "SmartWalletContractV100";
      }
      deploy(anEntryPoint, overrides) {
        return super.deploy(anEntryPoint, overrides || {});
      }
      getDeployTransaction(anEntryPoint, overrides) {
        return super.getDeployTransaction(anEntryPoint, overrides || {});
      }
      attach(address) {
        return super.attach(address);
      }
      connect(signer) {
        return super.connect(signer);
      }
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports2.SmartWalletContractV100__factory = SmartWalletContractV100__factory;
    SmartWalletContractV100__factory.bytecode = _bytecode;
    SmartWalletContractV100__factory.abi = _abi;
  }
});

// node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/MultiSendContractV100__factory.js
var require_MultiSendContractV100_factory = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/MultiSendContractV100__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiSendContractV100__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x60a060405234801561001057600080fd5b503060805260805161027961002f6000396000605c01526102796000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80638d80ff0a14610030575b600080fd5b61004361003e366004610192565b610045565b005b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036100f45760405162461bcd60e51b815260206004820152603060248201527f4d756c746953656e642073686f756c64206f6e6c792062652063616c6c65642060448201527f7669612064656c656761746563616c6c00000000000000000000000000000000606482015260840160405180910390fd5b805160205b81811015610177578083015160f81c6001820184015160601c60158301850151603584018601516055850187016000856000811461013e576001811461014e57610159565b6000808585888a5af19150610159565b6000808585895af491505b508061016457600080fd5b50508060550185019450505050506100f9565b505050565b634e487b7160e01b600052604160045260246000fd5b6000602082840312156101a457600080fd5b813567ffffffffffffffff808211156101bc57600080fd5b818401915084601f8301126101d057600080fd5b8135818111156101e2576101e261017c565b604051601f8201601f19908116603f0116810190838211818310171561020a5761020a61017c565b8160405282815287602084870101111561022357600080fd5b82602086016020830137600092810160200192909252509594505050505056fea2646970667358221220e7de57142c74be7ac43b03d3f5c380fb16ed147daff64b7f340af44dc997e49964736f6c63430008110033";
    var isSuperArgs = (xs) => xs.length > 1;
    var MultiSendContractV100__factory = class extends ethers_1.ContractFactory {
      constructor(...args) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        this.contractName = "MultiSendContractV100";
      }
      deploy(overrides) {
        return super.deploy(overrides || {});
      }
      getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
      }
      attach(address) {
        return super.attach(address);
      }
      connect(signer) {
        return super.connect(signer);
      }
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports2.MultiSendContractV100__factory = MultiSendContractV100__factory;
    MultiSendContractV100__factory.bytecode = _bytecode;
    MultiSendContractV100__factory.abi = _abi;
  }
});

// node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/MultiSendCallOnlyContractV100__factory.js
var require_MultiSendCallOnlyContractV100_factory = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/MultiSendCallOnlyContractV100__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiSendCallOnlyContractV100__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x608060405234801561001057600080fd5b506101bb806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80638d80ff0a14610030575b600080fd5b61004361003e3660046100d4565b610045565b005b805160205b818110156100b9578083015160f81c6001820184015160601c60158301850151603584018601516055850187016000856000811461008f576001811461002b5761009b565b6000808585888a5af191505b50806100a657600080fd5b505080605501850194505050505061004a565b505050565b634e487b7160e01b600052604160045260246000fd5b6000602082840312156100e657600080fd5b813567ffffffffffffffff808211156100fe57600080fd5b818401915084601f83011261011257600080fd5b813581811115610124576101246100be565b604051601f8201601f19908116603f0116810190838211818310171561014c5761014c6100be565b8160405282815287602084870101111561016557600080fd5b82602086016020830137600092810160200192909252509594505050505056fea26469706673582212206c9f5ae8336b4795414528c4904de4b4ca198579055517e5d132fe9c67d789e064736f6c63430008110033";
    var isSuperArgs = (xs) => xs.length > 1;
    var MultiSendCallOnlyContractV100__factory = class extends ethers_1.ContractFactory {
      constructor(...args) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        this.contractName = "MultiSendCallOnlyContractV100";
      }
      deploy(overrides) {
        return super.deploy(overrides || {});
      }
      getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
      }
      attach(address) {
        return super.attach(address);
      }
      connect(signer) {
        return super.connect(signer);
      }
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports2.MultiSendCallOnlyContractV100__factory = MultiSendCallOnlyContractV100__factory;
    MultiSendCallOnlyContractV100__factory.bytecode = _bytecode;
    MultiSendCallOnlyContractV100__factory.abi = _abi;
  }
});

// node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/SmartWalletFactoryContractV100__factory.js
var require_SmartWalletFactoryContractV100_factory = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/SmartWalletFactoryContractV100__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartWalletFactoryContractV100__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_basicImplementation",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "AccountCreation",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AccountCreationWithoutIndex",
        type: "event"
      },
      {
        inputs: [],
        name: "accountCreationCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "basicImplementation",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          }
        ],
        name: "deployAccount",
        outputs: [
          {
            internalType: "address",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          }
        ],
        name: "deployCounterFactualAccount",
        outputs: [
          {
            internalType: "address",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          }
        ],
        name: "getAddressForCounterFactualAccount",
        outputs: [
          {
            internalType: "address",
            name: "_account",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimalHandler",
        outputs: [
          {
            internalType: "contract DefaultCallbackHandler",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var _bytecode = "0x60c060405234801561001057600080fd5b50604051610f5d380380610f5d83398101604081905261002f916100e1565b806001600160a01b03811661008a5760405162461bcd60e51b815260206004820152601d60248201527f696d706c656d656e746174696f6e2063616e6e6f74206265207a65726f000000604482015260640160405180910390fd5b6001600160a01b0381166080526040516100a3906100d4565b604051809103906000f0801580156100bf573d6000803e3d6000fd5b506001600160a01b031660a052506101119050565b6105e68061097783390190565b6000602082840312156100f357600080fd5b81516001600160a01b038116811461010a57600080fd5b9392505050565b60805160a0516108266101516000396000818160c1015261056501526000818161010e015281816101b10152818161032b015261043f01526108266000f3fe608060405234801561001057600080fd5b50600436106100725760003560e01c8063d668bfa811610050578063d668bfa8146100e3578063da9fc1ae146100f6578063daf0dfc81461010957600080fd5b8063088924ef1461007757806331c884df146100a75780633b3cb143146100bc575b600080fd5b61008a6100853660046105fe565b610130565b6040516001600160a01b0390911681526020015b60405180910390f35b6100af6102bd565b60405161009e919061064c565b61008a7f000000000000000000000000000000000000000000000000000000000000000081565b61008a6100f13660046105fe565b6102e7565b61008a61010436600461067f565b610408565b61008a7f000000000000000000000000000000000000000000000000000000000000000081565b60008061013c84610550565b90506000818051906020012084604051602001610163929190918252602082015260400190565b60405160208183030381529060405280519060200120905060006040518060200161018d906105d5565b601f1982820381018352601f9091011660408190526101da91906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906020016106a1565b6040516020818303038152906040529050818151826020016000f593506001600160a01b0384166102525760405162461bcd60e51b815260206004820152601360248201527f437265617465322063616c6c206661696c65640000000000000000000000000060448201526064015b60405180910390fd5b8251156102735760008060008551602087016000895af10361027357600080fd5b84866001600160a01b0316856001600160a01b03167f8967dcaa00d8fcb9bb2b5beff4aaf8c020063512cf08fbe11fec37a1e3a150f260405160405180910390a450505092915050565b6060604051806020016102cf906105d5565b601f1982820381018352601f90910116604052919050565b6000806102f384610550565b9050600060405180602001610307906105d5565b601f1982820381018352601f90910116604081905261035491906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906020016106a1565b60408051808303601f1901815282825284516020958601208584015282820196909652805180830382018152606080840183528151918601919091208751978601979097207fff0000000000000000000000000000000000000000000000000000000000000060808501523090911b6bffffffffffffffffffffffff19166081840152609583019690965260b5808301969096528051808303909601865260d5909101905250825192019190912092915050565b6000806040518060200161041b906105d5565b601f1982820381018352601f90910116604081905261046891906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906020016106a1565b60405160208183030381529060405290508051816020016000f091506001600160a01b0382166104da5760405162461bcd60e51b815260206004820152601260248201527f4372656174652063616c6c206661696c656400000000000000000000000000006044820152606401610249565b60006104e584610550565b8051909150156105095760008060008351602085016000885af10361050957600080fd5b836001600160a01b0316836001600160a01b03167f9a6cbf173278cf7dfadb45414d824f7828c0c94479f1b15e45453653070cf65760405160405180910390a35050919050565b6040516001600160a01b0380831660248301527f000000000000000000000000000000000000000000000000000000000000000016604482015260609060640160408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663784d200b60e11b17905292915050565b61012d806106c483390190565b80356001600160a01b03811681146105f957600080fd5b919050565b6000806040838503121561061157600080fd5b61061a836105e2565b946020939093013593505050565b60005b8381101561064357818101518382015260200161062b565b50506000910152565b602081526000825180602084015261066b816040850160208701610628565b601f01601f19169190910160400192915050565b60006020828403121561069157600080fd5b61069a826105e2565b9392505050565b600083516106b3818460208801610628565b919091019182525060200191905056fe608060405234801561001057600080fd5b5060405161012d38038061012d83398101604081905261002f91610090565b6001600160a01b0381166100895760405162461bcd60e51b815260206004820152601e60248201527f496e76616c696420696d706c656d656e746174696f6e20616464726573730000604482015260640160405180910390fd5b30556100c0565b6000602082840312156100a257600080fd5b81516001600160a01b03811681146100b957600080fd5b9392505050565b605f806100ce6000396000f3fe608060405230543660008037600080366000845af43d6000803e8080156024573d6000f35b3d6000fdfea2646970667358221220f2d66a9647723ed0fbdcd50881ba01c263f54fcb9ae508e35da65055a787b16b64736f6c63430008110033a264697066735822122064a7b688f9fbb161d37f98304ce0326855e0bf930ce052d5f0c2d8aa8447cf8c64736f6c63430008110033608060405234801561001057600080fd5b506105c6806100206000396000f3fe608060405234801561001057600080fd5b506004361061007c5760003560e01c8063a3f4df7e1161005b578063a3f4df7e146100fb578063bc197c8114610144578063f23a6e6114610166578063ffa1ad741461018657600080fd5b806223de291461008157806301ffc9a71461009b578063150b7a02146100c3575b600080fd5b61009961008f3660046102a0565b5050505050505050565b005b6100ae6100a936600461034b565b6101c2565b60405190151581526020015b60405180910390f35b6100e26100d136600461037c565b630a85bd0160e11b95945050505050565b6040516001600160e01b031990911681526020016100ba565b6101376040518060400160405280601881526020017f44656661756c742043616c6c6261636b2048616e646c6572000000000000000081525081565b6040516100ba91906103eb565b6100e261015236600461047e565b63bc197c8160e01b98975050505050505050565b6100e2610174366004610518565b63f23a6e6160e01b9695505050505050565b6101376040518060400160405280600581526020017f312e302e3000000000000000000000000000000000000000000000000000000081525081565b60006001600160e01b03198216630271189760e51b14806101f357506001600160e01b03198216630a85bd0160e11b145b8061020d57506001600160e01b031982166223de2960e01b145b8061022857506001600160e01b031982166301ffc9a760e01b145b92915050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461025257600080fd5b919050565b60008083601f84011261026957600080fd5b50813567ffffffffffffffff81111561028157600080fd5b60208301915083602082850101111561029957600080fd5b9250929050565b60008060008060008060008060c0898b0312156102bc57600080fd5b6102c58961022e565b97506102d360208a0161022e565b96506102e160408a0161022e565b955060608901359450608089013567ffffffffffffffff8082111561030557600080fd5b6103118c838d01610257565b909650945060a08b013591508082111561032a57600080fd5b506103378b828c01610257565b999c989b5096995094979396929594505050565b60006020828403121561035d57600080fd5b81356001600160e01b03198116811461037557600080fd5b9392505050565b60008060008060006080868803121561039457600080fd5b61039d8661022e565b94506103ab6020870161022e565b935060408601359250606086013567ffffffffffffffff8111156103ce57600080fd5b6103da88828901610257565b969995985093965092949392505050565b600060208083528351808285015260005b81811015610418578581018301518582016040015282016103fc565b506000604082860101526040601f19601f8301168501019250505092915050565b60008083601f84011261044b57600080fd5b50813567ffffffffffffffff81111561046357600080fd5b6020830191508360208260051b850101111561029957600080fd5b60008060008060008060008060a0898b03121561049a57600080fd5b6104a38961022e565b97506104b160208a0161022e565b9650604089013567ffffffffffffffff808211156104ce57600080fd5b6104da8c838d01610439565b909850965060608b01359150808211156104f357600080fd5b6104ff8c838d01610439565b909650945060808b013591508082111561032a57600080fd5b60008060008060008060a0878903121561053157600080fd5b61053a8761022e565b95506105486020880161022e565b94506040870135935060608701359250608087013567ffffffffffffffff81111561057257600080fd5b61057e89828a01610257565b979a969950949750929593949250505056fea2646970667358221220c92bdd96a0891eb9802656e4884a0099633e3e5d01c253fa3f3cfc4ffd2e91d764736f6c63430008110033";
    var isSuperArgs = (xs) => xs.length > 1;
    var SmartWalletFactoryContractV100__factory = class extends ethers_1.ContractFactory {
      constructor(...args) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        this.contractName = "SmartWalletFactoryContractV100";
      }
      deploy(_basicImplementation, overrides) {
        return super.deploy(_basicImplementation, overrides || {});
      }
      getDeployTransaction(_basicImplementation, overrides) {
        return super.getDeployTransaction(_basicImplementation, overrides || {});
      }
      attach(address) {
        return super.attach(address);
      }
      connect(signer) {
        return super.connect(signer);
      }
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports2.SmartWalletFactoryContractV100__factory = SmartWalletFactoryContractV100__factory;
    SmartWalletFactoryContractV100__factory.bytecode = _bytecode;
    SmartWalletFactoryContractV100__factory.abi = _abi;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/utils/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toTxResult = exports2.sameString = void 0;
    function sameString(str1, str2) {
      return str1.toLowerCase() === str2.toLowerCase();
    }
    exports2.sameString = sameString;
    function toTxResult(transactionResponse, options) {
      return {
        hash: transactionResponse.hash,
        options,
        transactionResponse
      };
    }
    exports2.toTxResult = toTxResult;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/SmartWallet/v1.0.0/SmartWalletContractEthers.js
var require_SmartWalletContractEthers = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/SmartWallet/v1.0.0/SmartWalletContractEthers.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils5();
    var SmartWalletContractEthers = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getInterface() {
        return this.contract.interface;
      }
      getContract() {
        return this.contract;
      }
      getAddress() {
        return this.contract.address;
      }
      setAddress(address) {
        this.contract.attach(address);
      }
      async getOwner() {
        return await this.contract.owner();
      }
      async getVersion() {
        return await this.contract.VERSION();
      }
      async getNonce(batchId) {
        return await this.contract.getNonce(batchId);
      }
      async nonce() {
        return await this.contract.nonce();
      }
      async isValidSignature(_dataHash, _signature) {
        return this.contract.isValidSignature(_dataHash, _signature);
      }
      async getTransactionHash(smartAccountTrxData) {
        return this.contract.getTransactionHash(smartAccountTrxData.to, smartAccountTrxData.value, smartAccountTrxData.data, smartAccountTrxData.operation, smartAccountTrxData.targetTxGas, smartAccountTrxData.baseGas, smartAccountTrxData.gasPrice, smartAccountTrxData.tokenGasPriceFactor, smartAccountTrxData.gasToken, smartAccountTrxData.refundReceiver, smartAccountTrxData.nonce);
      }
      async execTransaction(_tx, refundInfo, signatures) {
        const txResponse = await this.contract.execTransaction(_tx, refundInfo, signatures);
        return (0, utils_1.toTxResult)(txResponse);
      }
    };
    exports2.default = SmartWalletContractEthers;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/MultiSend/v1.0.0/MultiSendEthersContract.js
var require_MultiSendEthersContract = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/MultiSend/v1.0.0/MultiSendEthersContract.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MultiSendEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
      getContract() {
        return this.contract;
      }
      getInterface() {
        return this.contract.interface;
      }
    };
    exports2.default = MultiSendEthersContract;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/MultiSendCallOnly/v1.0.0/MultiSendCallOnlyEthersContract.js
var require_MultiSendCallOnlyEthersContract = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/MultiSendCallOnly/v1.0.0/MultiSendCallOnlyEthersContract.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MultiSendCallOnlyEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
      getContract() {
        return this.contract;
      }
      getInterface() {
        return this.contract.interface;
      }
    };
    exports2.default = MultiSendCallOnlyEthersContract;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/SmartWalletFactory/v1.0.0/SmartWalletProxyFactoryEthersContract.js
var require_SmartWalletProxyFactoryEthersContract = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/SmartWalletFactory/v1.0.0/SmartWalletProxyFactoryEthersContract.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils5();
    var SmartWalletFactoryContractEthers = class {
      constructor(contract) {
        this.contract = contract;
      }
      getInterface() {
        return this.contract.interface;
      }
      getContract() {
        return this.contract;
      }
      getAddress() {
        return this.contract.address;
      }
      setAddress(address) {
        this.contract.attach(address);
      }
      async deployCounterFactualAccount(owner, index) {
        const resultSet = await this.contract.deployCounterFactualAccount(owner, index);
        return (0, utils_1.toTxResult)(resultSet);
      }
      async deployAccount(owner) {
        const resultSet = await this.contract.deployAccount(owner);
        return (0, utils_1.toTxResult)(resultSet);
      }
      async getAddressForCounterFactualAccount(owner, index) {
        return this.contract.getAddressForCounterFactualAccount(owner, index);
      }
    };
    exports2.default = SmartWalletFactoryContractEthers;
  }
});

// node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/EntryPointContractV100__factory.js
var require_EntryPointContractV100_factory = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/EntryPointContractV100__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntryPointContractV100__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "paid",
            type: "uint256"
          },
          {
            internalType: "uint48",
            name: "validAfter",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "validUntil",
            type: "uint48"
          },
          {
            internalType: "bool",
            name: "targetSuccess",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "targetResult",
            type: "bytes"
          }
        ],
        name: "ExecutionResult",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "opIndex",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "reason",
            type: "string"
          }
        ],
        name: "FailedOp",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "SenderAddressResult",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "aggregator",
            type: "address"
          }
        ],
        name: "SignatureValidationFailed",
        type: "error"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "bool",
                name: "sigFailed",
                type: "bool"
              },
              {
                internalType: "uint48",
                name: "validAfter",
                type: "uint48"
              },
              {
                internalType: "uint48",
                name: "validUntil",
                type: "uint48"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          }
        ],
        name: "ValidationResult",
        type: "error"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "bool",
                name: "sigFailed",
                type: "bool"
              },
              {
                internalType: "uint48",
                name: "validAfter",
                type: "uint48"
              },
              {
                internalType: "uint48",
                name: "validUntil",
                type: "uint48"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "aggregator",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "uint256",
                    name: "stake",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "unstakeDelaySec",
                    type: "uint256"
                  }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "stakeInfo",
                type: "tuple"
              }
            ],
            internalType: "struct IEntryPoint.AggregatorStakeInfo",
            name: "aggregatorInfo",
            type: "tuple"
          }
        ],
        name: "ValidationResultWithAggregation",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "factory",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "paymaster",
            type: "address"
          }
        ],
        name: "AccountDeployed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "BeforeExecution",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalDeposit",
            type: "uint256"
          }
        ],
        name: "Deposited",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "aggregator",
            type: "address"
          }
        ],
        name: "SignatureAggregatorChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalStaked",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        name: "StakeLocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "withdrawTime",
            type: "uint256"
          }
        ],
        name: "StakeUnlocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "StakeWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "paymaster",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "actualGasUsed",
            type: "uint256"
          }
        ],
        name: "UserOperationEvent",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "revertReason",
            type: "bytes"
          }
        ],
        name: "UserOperationRevertReason",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrawn",
        type: "event"
      },
      {
        inputs: [],
        name: "SIG_VALIDATION_FAILED",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          }
        ],
        name: "_validateSenderAndPaymaster",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "depositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "deposits",
        outputs: [
          {
            internalType: "uint112",
            name: "deposit",
            type: "uint112"
          },
          {
            internalType: "bool",
            name: "staked",
            type: "bool"
          },
          {
            internalType: "uint112",
            name: "stake",
            type: "uint112"
          },
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          },
          {
            internalType: "uint48",
            name: "withdrawTime",
            type: "uint48"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getDepositInfo",
        outputs: [
          {
            components: [
              {
                internalType: "uint112",
                name: "deposit",
                type: "uint112"
              },
              {
                internalType: "bool",
                name: "staked",
                type: "bool"
              },
              {
                internalType: "uint112",
                name: "stake",
                type: "uint112"
              },
              {
                internalType: "uint32",
                name: "unstakeDelaySec",
                type: "uint32"
              },
              {
                internalType: "uint48",
                name: "withdrawTime",
                type: "uint48"
              }
            ],
            internalType: "struct IStakeManager.DepositInfo",
            name: "info",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          }
        ],
        name: "getSenderAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          }
        ],
        name: "getUserOpHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "sender",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "nonce",
                    type: "uint256"
                  },
                  {
                    internalType: "bytes",
                    name: "initCode",
                    type: "bytes"
                  },
                  {
                    internalType: "bytes",
                    name: "callData",
                    type: "bytes"
                  },
                  {
                    internalType: "uint256",
                    name: "callGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "verificationGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "preVerificationGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxPriorityFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "bytes",
                    name: "paymasterAndData",
                    type: "bytes"
                  },
                  {
                    internalType: "bytes",
                    name: "signature",
                    type: "bytes"
                  }
                ],
                internalType: "struct UserOperation[]",
                name: "userOps",
                type: "tuple[]"
              },
              {
                internalType: "contract IAggregator",
                name: "aggregator",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
            name: "opsPerAggregator",
            type: "tuple[]"
          },
          {
            internalType: "address payable",
            name: "beneficiary",
            type: "address"
          }
        ],
        name: "handleAggregatedOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation[]",
            name: "ops",
            type: "tuple[]"
          },
          {
            internalType: "address payable",
            name: "beneficiary",
            type: "address"
          }
        ],
        name: "handleOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "incrementNonce",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "sender",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "nonce",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "callGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "verificationGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "preVerificationGas",
                    type: "uint256"
                  },
                  {
                    internalType: "address",
                    name: "paymaster",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "maxFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxPriorityFeePerGas",
                    type: "uint256"
                  }
                ],
                internalType: "struct EntryPoint.MemoryUserOp",
                name: "mUserOp",
                type: "tuple"
              },
              {
                internalType: "bytes32",
                name: "userOpHash",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "contextOffset",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              }
            ],
            internalType: "struct EntryPoint.UserOpInfo",
            name: "opInfo",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          }
        ],
        name: "innerHandleOp",
        outputs: [
          {
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "",
            type: "uint192"
          }
        ],
        name: "nonceSequenceNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "op",
            type: "tuple"
          },
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "targetCallData",
            type: "bytes"
          }
        ],
        name: "simulateHandleOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          }
        ],
        name: "simulateValidation",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "withdrawAmount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var _bytecode = "0x60a0604052604051620000129062000055565b604051809103906000f0801580156200002f573d6000803e3d6000fd5b506001600160a01b03166080523480156200004957600080fd5b50600160025562000063565b61022080620041ed83390190565b608051614167620000866000396000818161131f0152612f8901526141676000f3fe6080604052600436106101635760003560e01c80638f41ec5a116100c0578063bb9fe6bf11610074578063d6383f9411610059578063d6383f94146104af578063ee219423146104cf578063fc7e286d146104ef57600080fd5b8063bb9fe6bf1461047a578063c23a5cea1461048f57600080fd5b80639b249f69116100a55780639b249f6914610427578063a619353114610447578063b760faf91461046757600080fd5b80638f41ec5a146103f2578063957122ab1461040757600080fd5b8063205c2878116101175780634b1d7cf5116100fc5780634b1d7cf5146102765780635287ce121461029657806370a08231146103b357600080fd5b8063205c28781461023657806335567e1a1461025657600080fd5b80631b2e01b8116101485780631b2e01b8146101ab5780631d732756146101f65780631fad948c1461021657600080fd5b80630396cb60146101785780630bd28e3b1461018b57600080fd5b3661017357610171336105a4565b005b600080fd5b61017161018636600461325c565b61060b565b34801561019757600080fd5b506101716101a636600461329e565b6108c9565b3480156101b757600080fd5b506101e36101c63660046132d9565b600160209081526000928352604080842090915290825290205481565b6040519081526020015b60405180910390f35b34801561020257600080fd5b506101e36102113660046134d8565b610900565b34801561022257600080fd5b506101716102313660046135e3565b610a73565b34801561024257600080fd5b5061017161025136600461363a565b610bf0565b34801561026257600080fd5b506101e36102713660046132d9565b610d7e565b34801561028257600080fd5b506101716102913660046135e3565b610dc4565b3480156102a257600080fd5b5061035b6102b1366004613666565b6040805160a081018252600080825260208201819052918101829052606081018290526080810191909152506001600160a01b031660009081526020818152604091829020825160a08101845281546001600160701b038082168352600160701b820460ff16151594830194909452600160781b90049092169282019290925260019091015463ffffffff81166060830152640100000000900465ffffffffffff16608082015290565b6040805182516001600160701b03908116825260208085015115159083015283830151169181019190915260608083015163ffffffff169082015260809182015165ffffffffffff169181019190915260a0016101ed565b3480156103bf57600080fd5b506101e36103ce366004613666565b6001600160a01b03166000908152602081905260409020546001600160701b031690565b3480156103fe57600080fd5b506101e3600181565b34801561041357600080fd5b50610171610422366004613683565b611208565b34801561043357600080fd5b50610171610442366004613708565b611305565b34801561045357600080fd5b506101e3610462366004613763565b6113c0565b610171610475366004613666565b6105a4565b34801561048657600080fd5b50610171611402565b34801561049b57600080fd5b506101716104aa366004613666565b611555565b3480156104bb57600080fd5b506101716104ca366004613798565b6117ab565b3480156104db57600080fd5b506101716104ea366004613763565b6118a6565b3480156104fb57600080fd5b5061055e61050a366004613666565b600060208190529081526040902080546001909101546001600160701b0380831692600160701b810460ff1692600160781b9091049091169063ffffffff811690640100000000900465ffffffffffff1685565b604080516001600160701b0396871681529415156020860152929094169183019190915263ffffffff16606082015265ffffffffffff909116608082015260a0016101ed565b6105ae8134611b48565b6001600160a01b03811660008181526020818152604091829020805492516001600160701b03909316835292917f2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c491015b60405180910390a25050565b33600090815260208190526040902063ffffffff82166106725760405162461bcd60e51b815260206004820152601a60248201527f6d757374207370656369667920756e7374616b652064656c617900000000000060448201526064015b60405180910390fd5b600181015463ffffffff90811690831610156106d05760405162461bcd60e51b815260206004820152601c60248201527f63616e6e6f7420646563726561736520756e7374616b652074696d65000000006044820152606401610669565b80546000906106f0903490600160781b90046001600160701b0316613810565b9050600081116107425760405162461bcd60e51b815260206004820152601260248201527f6e6f207374616b652073706563696669656400000000000000000000000000006044820152606401610669565b6001600160701b038111156107995760405162461bcd60e51b815260206004820152600e60248201527f7374616b65206f766572666c6f770000000000000000000000000000000000006044820152606401610669565b6040805160a08101825283546001600160701b0390811682526001602080840182815286841685870190815263ffffffff808b16606088019081526000608089018181523380835296829052908a902098518954955194518916600160781b027fffffff0000000000000000000000000000ffffffffffffffffffffffffffffff951515600160701b026effffffffffffffffffffffffffffff199097169190991617949094179290921695909517865551949092018054925165ffffffffffff166401000000000269ffffffffffffffffffff19909316949093169390931717905590517fa5ae833d0bb1dcd632d98a8b70973e8516812898e19bf27b70071ebc8dc52c01906108bc908490879091825263ffffffff16602082015260400190565b60405180910390a2505050565b3360009081526001602090815260408083206001600160c01b038516845290915281208054916108f883613823565b919050555050565b6000805a90503330146109555760405162461bcd60e51b815260206004820152601760248201527f4141393220696e7465726e616c2063616c6c206f6e6c790000000000000000006044820152606401610669565b8451604081015160608201518101611388015a101561097f5763deaddead60e01b60005260206000fd5b875160009015610a1357600061099c846000015160008c86611bf8565b905080610a115760006109b0610800611c10565b805190915015610a0b5784600001516001600160a01b03168a602001517f1c4fada7374c0a9ee8841fc38afe82932dc0f8e69012e927f061a8bae611a201876020015184604051610a0292919061388c565b60405180910390a35b60019250505b505b600088608001515a8603019050610a656000838b8b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250611c3c915050565b9a9950505050505050505050565b610a7b611f3e565b8160008167ffffffffffffffff811115610a9757610a9761330e565b604051908082528060200260200182016040528015610ad057816020015b610abd6131d2565b815260200190600190039081610ab55790505b50905060005b82811015610b49576000828281518110610af257610af26138a5565b60200260200101519050600080610b2d848a8a87818110610b1557610b156138a5565b9050602002810190610b2791906138bb565b85611f95565b91509150610b3e8483836000612180565b505050600101610ad6565b506040516000907fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972908290a160005b83811015610bd357610bc781888884818110610b9657610b966138a5565b9050602002810190610ba891906138bb565b858481518110610bba57610bba6138a5565b602002602001015161232e565b90910190600101610b78565b50610bde8482612463565b505050610beb6001600255565b505050565b33600090815260208190526040902080546001600160701b0316821115610c595760405162461bcd60e51b815260206004820152601960248201527f576974686472617720616d6f756e7420746f6f206c61726765000000000000006044820152606401610669565b8054610c6f9083906001600160701b03166138dc565b81546dffffffffffffffffffffffffffff19166001600160701b0391909116178155604080516001600160a01b03851681526020810184905233917fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb910160405180910390a26000836001600160a01b03168360405160006040518083038185875af1925050503d8060008114610d22576040519150601f19603f3d011682016040523d82523d6000602084013e610d27565b606091505b5050905080610d785760405162461bcd60e51b815260206004820152601260248201527f6661696c656420746f20776974686472617700000000000000000000000000006044820152606401610669565b50505050565b6001600160a01b03821660009081526001602090815260408083206001600160c01b038516845290915290819020549082901b67ffffffffffffffff1916175b92915050565b610dcc611f3e565b816000805b82811015610f405736868683818110610dec57610dec6138a5565b9050602002810190610dfe91906138ef565b9050366000610e0d8380613905565b90925090506000610e246040850160208601613666565b90506000196001600160a01b03821601610e805760405162461bcd60e51b815260206004820152601760248201527f4141393620696e76616c69642061676772656761746f720000000000000000006044820152606401610669565b6001600160a01b03811615610f1d576001600160a01b03811663e3563a4f8484610ead604089018961394f565b6040518563ffffffff1660e01b8152600401610ecc9493929190613afc565b60006040518083038186803b158015610ee457600080fd5b505afa925050508015610ef5575060015b610f1d5760405163086a9f7560e41b81526001600160a01b0382166004820152602401610669565b610f278287613810565b9550505050508080610f3890613823565b915050610dd1565b5060008167ffffffffffffffff811115610f5c57610f5c61330e565b604051908082528060200260200182016040528015610f9557816020015b610f826131d2565b815260200190600190039081610f7a5790505b506040519091507fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f97290600090a16000805b848110156110aa5736888883818110610fe157610fe16138a5565b9050602002810190610ff391906138ef565b90503660006110028380613905565b909250905060006110196040850160208601613666565b90508160005b8181101561109157600089898151811061103b5761103b6138a5565b6020026020010151905060008061105e8b898987818110610b1557610b156138a5565b9150915061106e84838389612180565b8a61107881613823565b9b5050505050808061108990613823565b91505061101f565b50505050505080806110a290613823565b915050610fc6565b50600080915060005b858110156111c357368989838181106110ce576110ce6138a5565b90506020028101906110e091906138ef565b90506110f26040820160208301613666565b6001600160a01b03167f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d60405160405180910390a23660006111348380613905565b90925090508060005b818110156111ab5761117f8885858481811061115b5761115b6138a5565b905060200281019061116d91906138bb565b8b8b81518110610bba57610bba6138a5565b6111899088613810565b96508761119581613823565b98505080806111a390613823565b91505061113d565b505050505080806111bb90613823565b9150506110b3565b506040516000907f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d908290a26111f98682612463565b5050505050610beb6001600255565b8315801561121e57506001600160a01b0383163b155b1561126b5760405162461bcd60e51b815260206004820152601960248201527f41413230206163636f756e74206e6f74206465706c6f796564000000000000006044820152606401610669565b601481106112e35760006112826014828486613b79565b61128b91613ba3565b60601c9050803b6000036112e15760405162461bcd60e51b815260206004820152601b60248201527f41413330207061796d6173746572206e6f74206465706c6f79656400000000006044820152606401610669565b505b60405162461bcd60e51b81526020600482015260006024820152604401610669565b604051632b870d1b60e11b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063570e1a36906113569086908690600401613bd8565b6020604051808303816000875af1158015611375573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113999190613bec565b604051633653dc0360e11b81526001600160a01b0382166004820152909150602401610669565b60006113cb8261255c565b6040805160208101929092523090820152466060820152608001604051602081830303815290604052805190602001209050919050565b3360009081526020819052604081206001810154909163ffffffff909116900361146e5760405162461bcd60e51b815260206004820152600a60248201527f6e6f74207374616b6564000000000000000000000000000000000000000000006044820152606401610669565b8054600160701b900460ff166114c65760405162461bcd60e51b815260206004820152601160248201527f616c726561647920756e7374616b696e670000000000000000000000000000006044820152606401610669565b60018101546000906114de9063ffffffff1642613c09565b60018301805469ffffffffffff00000000191664010000000065ffffffffffff84169081029190911790915583546eff00000000000000000000000000001916845560405190815290915033907ffa9b3c14cc825c412c9ed81b3ba365a5b459439403f18829e572ed53a4180f0a906020016105ff565b3360009081526020819052604090208054600160781b90046001600160701b0316806115c35760405162461bcd60e51b815260206004820152601460248201527f4e6f207374616b6520746f2077697468647261770000000000000000000000006044820152606401610669565b6001820154640100000000900465ffffffffffff166116245760405162461bcd60e51b815260206004820152601d60248201527f6d7573742063616c6c20756e6c6f636b5374616b6528292066697273740000006044820152606401610669565b60018201544264010000000090910465ffffffffffff1611156116895760405162461bcd60e51b815260206004820152601b60248201527f5374616b65207769746864726177616c206973206e6f742064756500000000006044820152606401610669565b60018201805469ffffffffffffffffffff1916905581547fffffff0000000000000000000000000000ffffffffffffffffffffffffffffff168255604080516001600160a01b03851681526020810183905233917fb7c918e0e249f999e965cafeb6c664271b3f4317d296461500e71da39f0cbda3910160405180910390a26000836001600160a01b03168260405160006040518083038185875af1925050503d8060008114611755576040519150601f19603f3d011682016040523d82523d6000602084013e61175a565b606091505b5050905080610d785760405162461bcd60e51b815260206004820152601860248201527f6661696c656420746f207769746864726177207374616b6500000000000000006044820152606401610669565b6117b36131d2565b6117bc85612575565b6000806117cb60008885611f95565b9150915060006117db838361264f565b90506117e643600052565b60006117f460008a8761232e565b90506117ff43600052565b600060606001600160a01b038a161561187557896001600160a01b0316898960405161182c929190613c2f565b6000604051808303816000865af19150503d8060008114611869576040519150601f19603f3d011682016040523d82523d6000602084013e61186e565b606091505b5090925090505b866080015183856020015186604001518585604051630116f59360e71b815260040161066996959493929190613c3f565b6118ae6131d2565b6118b782612575565b6000806118c660008585611f95565b845160a00151604080518082018252600080825260208083018281526001600160a01b03958616835282825284832080546001600160701b03600160781b918290048116875260019283015463ffffffff9081169094528d51518851808a018a5287815280870188815291909a1687528686528887208054939093049091168952910154909116905283518085019094528184528301529395509193509036600061197460408a018a61394f565b90925090506000601482101561198b5760006119a6565b611999601460008486613b79565b6119a291613ba3565b60601c5b604080518082018252600080825260208083018281526001600160a01b0386168352908290529290208054600160781b90046001600160701b031682526001015463ffffffff1690915290915093505050506000611a04868661264f565b9050600081600001519050600060016001600160a01b0316826001600160a01b031614905060006040518060c001604052808b6080015181526020018b6040015181526020018315158152602001856020015165ffffffffffff168152602001856040015165ffffffffffff168152602001611a818c6060015190565b905290506001600160a01b03831615801590611aa757506001600160a01b038316600114155b15611b27576040805180820182526001600160a01b0385168082528251808401845260008082526020808301828152938252818152908590208054600160781b90046001600160701b031683526001015463ffffffff16909252908201529051633ebb2d3960e21b8152610669908390899089908c908690600401613ce1565b8086868960405163e0cff05f60e01b81526004016106699493929190613d61565b6001600160a01b03821660009081526020819052604081208054909190611b799084906001600160701b0316613810565b90506001600160701b03811115611bd25760405162461bcd60e51b815260206004820152601060248201527f6465706f736974206f766572666c6f77000000000000000000000000000000006044820152606401610669565b81546dffffffffffffffffffffffffffff19166001600160701b03919091161790555050565b6000806000845160208601878987f195945050505050565b60603d82811115611c1e5750815b604051602082018101604052818152816000602083013e9392505050565b6000805a855190915060009081611c528261271b565b60a08301519091506001600160a01b038116611c715782519350611e23565b809350600088511115611e2357868202955060028a6002811115611c9757611c97613db8565b14611d0957606083015160405163a9a2340960e01b81526001600160a01b0383169163a9a2340991611cd1908e908d908c90600401613dce565b600060405180830381600088803b158015611ceb57600080fd5b5087f1158015611cff573d6000803e3d6000fd5b5050505050611e23565b606083015160405163a9a2340960e01b81526001600160a01b0383169163a9a2340991611d3e908e908d908c90600401613dce565b600060405180830381600088803b158015611d5857600080fd5b5087f193505050508015611d6a575060015b611e2357611d76613e15565b806308c379a003611dcf5750611d8a613e31565b80611d955750611dd1565b8b81604051602001611da79190613ebb565b60408051601f1981840301815290829052631101335b60e11b8252610669929160040161388c565b505b8a604051631101335b60e11b81526004016106699181526040602082018190526012908201527f4141353020706f73744f70207265766572740000000000000000000000000000606082015260800190565b5a85038701965081870295508589604001511015611e8c578a604051631101335b60e11b815260040161066991815260406020808301829052908201527f414135312070726566756e642062656c6f772061637475616c476173436f7374606082015260800190565b6040890151869003611e9e8582611b48565b6000808c6002811115611eb357611eb3613db8565b1490508460a001516001600160a01b031685600001516001600160a01b03168c602001517f49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f8860200151858d8f604051611f26949392919093845291151560208401526040830152606082015260800190565b60405180910390a45050505050505095945050505050565b6002805403611f8f5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610669565b60028055565b60008060005a8451909150611faa868261274b565b611fb3866113c0565b6020860152604081015160608201516080830151171760e087013517610100870135176effffffffffffffffffffffffffffff8111156120355760405162461bcd60e51b815260206004820152601860248201527f41413934206761732076616c756573206f766572666c6f7700000000000000006044820152606401610669565b60008061204184612844565b905061204f8a8a8a84612891565b855160208701519199509193506120669190612ad7565b6120bc5789604051631101335b60e11b8152600401610669918152604060208201819052601a908201527f4141323520696e76616c6964206163636f756e74206e6f6e6365000000000000606082015260800190565b6120c543600052565b60a08401516060906001600160a01b0316156120ed576120e88b8b8b8587612b25565b975090505b60005a87039050808b60a001351015612152578b604051631101335b60e11b8152600401610669918152604060208201819052601e908201527f41413430206f76657220766572696669636174696f6e4761734c696d69740000606082015260800190565b60408a018390528160608b015260c08b01355a8803018a608001818152505050505050505050935093915050565b60008061218c85612d4f565b91509150816001600160a01b0316836001600160a01b0316146121fb5785604051631101335b60e11b81526004016106699181526040602082018190526014908201527f41413234207369676e6174757265206572726f72000000000000000000000000606082015260800190565b80156122535785604051631101335b60e11b81526004016106699181526040602082018190526017908201527f414132322065787069726564206f72206e6f7420647565000000000000000000606082015260800190565b600061225e85612d4f565b925090506001600160a01b038116156122c35786604051631101335b60e11b81526004016106699181526040602082018190526014908201527f41413334207369676e6174757265206572726f72000000000000000000000000606082015260800190565b81156123255786604051631101335b60e11b81526004016106699181526040602082018190526021908201527f41413332207061796d61737465722065787069726564206f72206e6f742064756060820152606560f81b608082015260a00190565b50505050505050565b6000805a90506000612341846060015190565b905030631d732756612356606088018861394f565b87856040518563ffffffff1660e01b81526004016123779493929190613f00565b6020604051808303816000875af19250505080156123b2575060408051601f3d908101601f191682019092526123af91810190613fb4565b60015b61245757600060206000803e50600051632152215360e01b81016124225786604051631101335b60e11b8152600401610669918152604060208201819052600f908201527f41413935206f7574206f66206761730000000000000000000000000000000000606082015260800190565b600085608001515a61243490866138dc565b61243e9190613810565b905061244e886002888685611c3c565b9450505061245a565b92505b50509392505050565b6001600160a01b0382166124b95760405162461bcd60e51b815260206004820152601860248201527f4141393020696e76616c69642062656e656669636961727900000000000000006044820152606401610669565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114612506576040519150601f19603f3d011682016040523d82523d6000602084013e61250b565b606091505b5050905080610beb5760405162461bcd60e51b815260206004820152601f60248201527f41413931206661696c65642073656e6420746f2062656e6566696369617279006044820152606401610669565b600061256782612da2565b805190602001209050919050565b3063957122ab612588604084018461394f565b6125956020860186613666565b6125a361012087018761394f565b6040518663ffffffff1660e01b81526004016125c3959493929190613fcd565b60006040518083038186803b1580156125db57600080fd5b505afa9250505080156125ec575060015b61264c576125f8613e15565b806308c379a003612640575061260c613e31565b806126175750612642565b80511561263c57600081604051631101335b60e11b815260040161066992919061388c565b5050565b505b3d6000803e3d6000fd5b50565b604080516060810182526000808252602082018190529181018290529061267584612e75565b9050600061268284612e75565b82519091506001600160a01b038116612699575080515b602080840151604080860151928501519085015191929165ffffffffffff80831690851610156126c7578193505b8065ffffffffffff168365ffffffffffff1611156126e3578092505b5050604080516060810182526001600160a01b03909416845265ffffffffffff92831660208501529116908201529250505092915050565b60c081015160e082015160009190808203612737575092915050565b61274382488301612ee6565b949350505050565b6127586020830183613666565b6001600160a01b0316815260208083013590820152608080830135604083015260a0830135606083015260c0808401359183019190915260e08084013591830191909152610100830135908201523660006127b761012085018561394f565b909250905080156128375760148110156128135760405162461bcd60e51b815260206004820152601d60248201527f4141393320696e76616c6964207061796d6173746572416e64446174610000006044820152606401610669565b612821601460008385613b79565b61282a91613ba3565b60601c60a0840152610d78565b600060a084015250505050565b60a081015160009081906001600160a01b0316612862576001612865565b60035b60ff16905060008360800151828560600151028560400151010190508360c00151810292505050919050565b60008060005a85518051919250906128b689886128b160408c018c61394f565b612efe565b60a08201516128c443600052565b60006001600160a01b03821661290c576001600160a01b0383166000908152602081905260409020546001600160701b031688811161290557808903612908565b60005b9150505b606084015160208a0151604051633a871cdd60e01b81526001600160a01b03861692633a871cdd929091612946918f918790600401614003565b60206040518083038160008887f193505050508015612982575060408051601f3d908101601f1916820190925261297f91810190613fb4565b60015b612a135761298e613e15565b806308c379a0036129bf57506129a2613e31565b806129ad57506129c1565b8b81604051602001611da79190614028565b505b8a604051631101335b60e11b81526004016106699181526040602082018190526016908201527f4141323320726576657274656420286f72204f4f472900000000000000000000606082015260800190565b95506001600160a01b038216612ac4576001600160a01b038316600090815260208190526040902080546001600160701b0316808a1115612aa0578c604051631101335b60e11b81526004016106699181526040602082018190526017908201527f41413231206469646e2774207061792070726566756e64000000000000000000606082015260800190565b81546dffffffffffffffffffffffffffff1916908a90036001600160701b03161790555b5a85039650505050505094509492505050565b6001600160a01b038216600090815260016020908152604080832084821c808552925282208054849167ffffffffffffffff8316919085612b1783613823565b909155501495945050505050565b82516060818101519091600091848111612b815760405162461bcd60e51b815260206004820152601f60248201527f4141343120746f6f206c6974746c6520766572696669636174696f6e476173006044820152606401610669565b60a08201516001600160a01b038116600090815260208190526040902080548784039291906001600160701b031689811015612c09578c604051631101335b60e11b8152600401610669918152604060208201819052601e908201527f41413331207061796d6173746572206465706f73697420746f6f206c6f770000606082015260800190565b8981038260000160006101000a8154816001600160701b0302191690836001600160701b03160217905550826001600160a01b031663f465c77e858e8e602001518e6040518563ffffffff1660e01b8152600401612c6993929190614003565b60006040518083038160008887f193505050508015612caa57506040513d6000823e601f3d908101601f19168201604052612ca7919081019061406d565b60015b612d3b57612cb6613e15565b806308c379a003612ce75750612cca613e31565b80612cd55750612ce9565b8d81604051602001611da791906140f9565b505b8c604051631101335b60e11b81526004016106699181526040602082018190526016908201527f4141333320726576657274656420286f72204f4f472900000000000000000000606082015260800190565b909e909d509b505050505050505050505050565b60008082600003612d6557506000928392509050565b6000612d7084612e75565b9050806040015165ffffffffffff16421180612d975750806020015165ffffffffffff1642105b905194909350915050565b6060813560208301356000612dc2612dbd604087018761394f565b6131bf565b90506000612dd6612dbd606088018861394f565b9050608086013560a087013560c088013560e08901356101008a01356000612e05612dbd6101208e018e61394f565b604080516001600160a01b039c909c1660208d01528b81019a909a5260608b019890985250608089019590955260a088019390935260c087019190915260e08601526101008501526101208401526101408084019190915281518084039091018152610160909201905292915050565b60408051606081018252600080825260208201819052918101919091528160a081901c65ffffffffffff8116600003612eb1575065ffffffffffff5b604080516060810182526001600160a01b03909316835260d09490941c602083015265ffffffffffff16928101929092525090565b6000818310612ef55781612ef7565b825b9392505050565b8015610d78578251516001600160a01b0381163b15612f695784604051631101335b60e11b8152600401610669918152604060208201819052601f908201527f414131302073656e64657220616c726561647920636f6e737472756374656400606082015260800190565b835160600151604051632b870d1b60e11b81526000916001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169163570e1a369190612fc19088908890600401613bd8565b60206040518083038160008887f1158015612fe0573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906130059190613bec565b90506001600160a01b0381166130675785604051631101335b60e11b8152600401610669918152604060208201819052601b908201527f4141313320696e6974436f6465206661696c6564206f72204f4f470000000000606082015260800190565b816001600160a01b0316816001600160a01b0316146130d15785604051631101335b60e11b815260040161066991815260406020808301829052908201527f4141313420696e6974436f6465206d7573742072657475726e2073656e646572606082015260800190565b806001600160a01b03163b6000036131345785604051631101335b60e11b815260040161066991815260406020808301829052908201527f4141313520696e6974436f6465206d757374206372656174652073656e646572606082015260800190565b60006131436014828688613b79565b61314c91613ba3565b60601c9050826001600160a01b031686602001517fd51a9c61267aa6196961883ecf5ff2da6619c37dac0fa92122513fb32c032d2d83896000015160a001516040516131ae9291906001600160a01b0392831681529116602082015260400190565b60405180910390a350505050505050565b6000604051828085833790209392505050565b6040518060a0016040528061323760405180610100016040528060006001600160a01b031681526020016000815260200160008152602001600081526020016000815260200160006001600160a01b0316815260200160008152602001600081525090565b8152602001600080191681526020016000815260200160008152602001600081525090565b60006020828403121561326e57600080fd5b813563ffffffff81168114612ef757600080fd5b80356001600160c01b038116811461329957600080fd5b919050565b6000602082840312156132b057600080fd5b612ef782613282565b6001600160a01b038116811461264c57600080fd5b8035613299816132b9565b600080604083850312156132ec57600080fd5b82356132f7816132b9565b915061330560208401613282565b90509250929050565b634e487b7160e01b600052604160045260246000fd5b60a0810181811067ffffffffffffffff821117156133445761334461330e565b60405250565b610100810181811067ffffffffffffffff821117156133445761334461330e565b601f8201601f1916810167ffffffffffffffff811182821017156133915761339161330e565b6040525050565b600067ffffffffffffffff8211156133b2576133b261330e565b50601f01601f191660200190565b60008183036101808112156133d457600080fd5b6040516133e081613324565b809250610100808312156133f357600080fd5b60405192506134018361334a565b61340a856132ce565b83526020850135602084015260408501356040840152606085013560608401526080850135608084015261344060a086016132ce565b60a084015260c085013560c084015260e085013560e084015282825280850135602083015250610120840135604082015261014084013560608201526101608401356080820152505092915050565b60008083601f8401126134a157600080fd5b50813567ffffffffffffffff8111156134b957600080fd5b6020830191508360208285010111156134d157600080fd5b9250929050565b6000806000806101c085870312156134ef57600080fd5b843567ffffffffffffffff8082111561350757600080fd5b818701915087601f83011261351b57600080fd5b813561352681613398565b604051613533828261336b565b8281528a602084870101111561354857600080fd5b8260208601602083013760006020848301015280985050505061356e88602089016133c0565b94506101a087013591508082111561358557600080fd5b506135928782880161348f565b95989497509550505050565b60008083601f8401126135b057600080fd5b50813567ffffffffffffffff8111156135c857600080fd5b6020830191508360208260051b85010111156134d157600080fd5b6000806000604084860312156135f857600080fd5b833567ffffffffffffffff81111561360f57600080fd5b61361b8682870161359e565b909450925050602084013561362f816132b9565b809150509250925092565b6000806040838503121561364d57600080fd5b8235613658816132b9565b946020939093013593505050565b60006020828403121561367857600080fd5b8135612ef7816132b9565b60008060008060006060868803121561369b57600080fd5b853567ffffffffffffffff808211156136b357600080fd5b6136bf89838a0161348f565b9097509550602088013591506136d4826132b9565b909350604087013590808211156136ea57600080fd5b506136f78882890161348f565b969995985093965092949392505050565b6000806020838503121561371b57600080fd5b823567ffffffffffffffff81111561373257600080fd5b61373e8582860161348f565b90969095509350505050565b6000610160828403121561375d57600080fd5b50919050565b60006020828403121561377557600080fd5b813567ffffffffffffffff81111561378c57600080fd5b6127438482850161374a565b600080600080606085870312156137ae57600080fd5b843567ffffffffffffffff808211156137c657600080fd5b6137d28883890161374a565b9550602087013591506137e4826132b9565b9093506040860135908082111561358557600080fd5b634e487b7160e01b600052601160045260246000fd5b80820180821115610dbe57610dbe6137fa565b600060018201613835576138356137fa565b5060010190565b60005b8381101561385757818101518382015260200161383f565b50506000910152565b6000815180845261387881602086016020860161383c565b601f01601f19169290920160200192915050565b8281526040602082015260006127436040830184613860565b634e487b7160e01b600052603260045260246000fd5b6000823561015e198336030181126138d257600080fd5b9190910192915050565b81810381811115610dbe57610dbe6137fa565b60008235605e198336030181126138d257600080fd5b6000808335601e1984360301811261391c57600080fd5b83018035915067ffffffffffffffff82111561393757600080fd5b6020019150600581901b36038213156134d157600080fd5b6000808335601e1984360301811261396657600080fd5b83018035915067ffffffffffffffff82111561398157600080fd5b6020019150368190038213156134d157600080fd5b6000808335601e198436030181126139ad57600080fd5b830160208101925035905067ffffffffffffffff8111156139cd57600080fd5b8036038213156134d157600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000610160613a2484613a17856132ce565b6001600160a01b03169052565b60208301356020850152613a3b6040840184613996565b826040870152613a4e83870182846139dc565b92505050613a5f6060840184613996565b8583036060870152613a728382846139dc565b925050506080830135608085015260a083013560a085015260c083013560c085015260e083013560e0850152610100808401358186015250610120613ab981850185613996565b86840383880152613acb8482846139dc565b9350505050610140613adf81850185613996565b86840383880152613af18482846139dc565b979650505050505050565b6040808252810184905260006060600586901b830181019083018783805b89811015613b6257868503605f190184528235368c900361015e19018112613b40578283fd5b613b4c868d8301613a05565b9550506020938401939290920191600101613b1a565b505050508281036020840152613af18185876139dc565b60008085851115613b8957600080fd5b83861115613b9657600080fd5b5050820193919092039150565b6bffffffffffffffffffffffff198135818116916014851015613bd05780818660140360031b1b83161692505b505092915050565b6020815260006127436020830184866139dc565b600060208284031215613bfe57600080fd5b8151612ef7816132b9565b65ffffffffffff818116838216019080821115613c2857613c286137fa565b5092915050565b8183823760009101908152919050565b868152856020820152600065ffffffffffff8087166040840152808616606084015250831515608083015260c060a0830152613c7e60c0830184613860565b98975050505050505050565b80518252602081015160208301526040810151151560408301526000606082015165ffffffffffff8082166060860152806080850151166080860152505060a082015160c060a085015261274360c0850182613860565b6000610140808352613cf581840189613c8a565b915050613d0f602083018780518252602090810151910152565b845160608301526020948501516080830152835160a08301529284015160c082015281516001600160a01b031660e0820152908301518051610100830152909201516101209092019190915292915050565b60e081526000613d7460e0830187613c8a565b9050613d8d602083018680518252602090810151910152565b8351606083015260208401516080830152825160a0830152602083015160c083015295945050505050565b634e487b7160e01b600052602160045260246000fd5b600060038510613dee57634e487b7160e01b600052602160045260246000fd5b84825260606020830152613e056060830185613860565b9050826040830152949350505050565b600060033d1115613e2e5760046000803e5060005160e01c5b90565b600060443d1015613e3f5790565b6040516003193d81016004833e81513d67ffffffffffffffff8160248401118184111715613e6f57505050505090565b8285019150815181811115613e875750505050505090565b843d8701016020828501011115613ea15750505050505090565b613eb06020828601018761336b565b509095945050505050565b7f4141353020706f73744f702072657665727465643a2000000000000000000000815260008251613ef381601685016020870161383c565b9190910160160192915050565b60006101c0808352613f1581840187896139dc565b905084516001600160a01b03808251166020860152602082015160408601526040820151606086015260608201516080860152608082015160a08601528060a08301511660c08601525060c081015160e085015260e08101516101008501525060208501516101208401526040850151610140840152606085015161016084015260808501516101808401528281036101a0840152613af18185613860565b600060208284031215613fc657600080fd5b5051919050565b606081526000613fe16060830187896139dc565b6001600160a01b03861660208401528281036040840152613c7e8185876139dc565b6060815260006140166060830186613a05565b60208301949094525060400152919050565b7f414132332072657665727465643a20000000000000000000000000000000000081526000825161406081600f85016020870161383c565b91909101600f0192915050565b6000806040838503121561408057600080fd5b825167ffffffffffffffff81111561409757600080fd5b8301601f810185136140a857600080fd5b80516140b381613398565b6040516140c0828261336b565b8281528760208486010111156140d557600080fd5b6140e683602083016020870161383c565b6020969096015195979596505050505050565b7f414133332072657665727465643a20000000000000000000000000000000000081526000825161406081600f85016020870161383c56fea2646970667358221220e4fe057e0c0aa334dbf8ef877e654ee8f50c20e031ae960d2faafd8cc9467daa64736f6c63430008110033608060405234801561001057600080fd5b50610200806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063570e1a3614610030575b600080fd5b61004361003e3660046100f9565b61006c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b60008061007c601482858761016b565b61008591610195565b60601c90506000610099846014818861016b565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525084519495509360209350849250905082850182875af190506000519350806100f057600093505b50505092915050565b6000806020838503121561010c57600080fd5b823567ffffffffffffffff8082111561012457600080fd5b818501915085601f83011261013857600080fd5b81358181111561014757600080fd5b86602082850101111561015957600080fd5b60209290920196919550909350505050565b6000808585111561017b57600080fd5b8386111561018857600080fd5b5050820193919092039150565b6bffffffffffffffffffffffff1981358181169160148510156101c25780818660140360031b1b83161692505b50509291505056fea2646970667358221220ac89c515e44676fb3ceb61dac6e5e14e758a1c802ddb043034780422ff13514b64736f6c63430008110033";
    var isSuperArgs = (xs) => xs.length > 1;
    var EntryPointContractV100__factory = class extends ethers_1.ContractFactory {
      constructor(...args) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        this.contractName = "EntryPointContractV100";
      }
      deploy(overrides) {
        return super.deploy(overrides || {});
      }
      getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
      }
      attach(address) {
        return super.attach(address);
      }
      connect(signer) {
        return super.connect(signer);
      }
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports2.EntryPointContractV100__factory = EntryPointContractV100__factory;
    EntryPointContractV100__factory.bytecode = _bytecode;
    EntryPointContractV100__factory.abi = _abi;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/EntryPointContract/v1.0.0/EntryPointEthersContract.js
var require_EntryPointEthersContract = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/EntryPointContract/v1.0.0/EntryPointEthersContract.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils5();
    var EntryPointEthersContract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.address;
      }
      async getSenderAddress(initCode) {
        const resultSet = await this.contract.getSenderAddress(initCode);
        return (0, utils_1.toTxResult)(resultSet);
      }
      getContract() {
        return this.contract;
      }
      async simulateValidation(userOperation) {
        const resultSet = await this.contract.simulateValidation(userOperation);
        return (0, utils_1.toTxResult)(resultSet);
      }
      async getUserOpHash(userOperation) {
        return this.contract.getUserOpHash(userOperation);
      }
      async handleOps(userOperations, beneficiary) {
        const resultSet = await this.contract.handleOps(userOperations, beneficiary);
        return (0, utils_1.toTxResult)(resultSet);
      }
    };
    exports2.default = EntryPointEthersContract;
  }
});

// node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/FallbackGasTankContractV100__factory.js
var require_FallbackGasTankContractV100_factory = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/FallbackGasTankContractV100__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FallbackGasTankContractV100__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "_verifyingSigner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint128",
            name: "newBaseGas",
            type: "uint128"
          },
          {
            indexed: true,
            internalType: "address",
            name: "actor",
            type: "address"
          }
        ],
        name: "BaseGasChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "dappIdentifier",
            type: "address"
          }
        ],
        name: "Deposit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "GasTankEmpty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "_dappIdentifier",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_actor",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "_value",
            type: "uint256"
          }
        ],
        name: "GasWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "relayer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "address",
            name: "dappIdentifier",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "GaslessTxExecuted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "baseGas",
        outputs: [
          {
            internalType: "uint128",
            name: "",
            type: "uint128"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "dappIdentifierBalances",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "dappIdentifier",
            type: "address"
          }
        ],
        name: "depositFor",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_dappIdentifier",
            type: "address"
          }
        ],
        name: "getBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "balance",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "address",
                name: "target",
                type: "address"
              },
              {
                internalType: "address",
                name: "dappIdentifier",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct FallbackUserOperation",
            name: "fallbackUserOp",
            type: "tuple"
          }
        ],
        name: "getHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_sender",
            type: "address"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "address",
                name: "target",
                type: "address"
              },
              {
                internalType: "address",
                name: "dappIdentifier",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct FallbackUserOperation",
            name: "fallbackUserOp",
            type: "tuple"
          }
        ],
        name: "handleFallbackUserOp",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "ret",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint128",
            name: "gas",
            type: "uint128"
          }
        ],
        name: "setBaseGas",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newVerifyingSigner",
            type: "address"
          }
        ],
        name: "setSigner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "verifyingSigner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "dappIdentifier",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawGasForDapp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x6080604052600480546001600160801b0319166152081790553480156200002557600080fd5b506040516200153c3803806200153c83398101604081905262000048916200019c565b818162000055336200012f565b600180556001600160a01b038116620000b55760405162461bcd60e51b815260206004820152601f60248201527f7369676e6572206f66206761732074616e6b2063616e206e6f7420626520300060448201526064015b60405180910390fd5b600380546001600160a01b0319166001600160a01b038381169190911790915582166200011a5760405162461bcd60e51b815260206004820152601260248201527106f776e65722063616e206e6f7420626520360741b6044820152606401620000ac565b62000125826200012f565b50505050620001d4565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b03811681146200019757600080fd5b919050565b60008060408385031215620001b057600080fd5b620001bb836200017f565b9150620001cb602084016200017f565b90509250929050565b61135880620001e46000396000f3fe6080604052600436106100dd5760003560e01c8063b66672731161007f578063dc9ee2c411610059578063dc9ee2c414610282578063f2fde38b146102a2578063f7bebe91146102c2578063f8b2cb4f146102f057600080fd5b8063b666727314610215578063c6fdc77c14610242578063ccb844e11461026257600080fd5b80636c19e783116100bb5780636c19e783146101ad578063715018a6146101cf5780638da5cb5b146101e4578063aa67c9191461020257600080fd5b806323d9ac9b146100e25780632d0335ab1461011f578063583bbc4014610163575b600080fd5b3480156100ee57600080fd5b50600354610102906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561012b57600080fd5b5061015561013a36600461108c565b6001600160a01b031660009081526005602052604090205490565b604051908152602001610116565b34801561016f57600080fd5b5060045461018c906fffffffffffffffffffffffffffffffff1681565b6040516fffffffffffffffffffffffffffffffff9091168152602001610116565b3480156101b957600080fd5b506101cd6101c836600461108c565b610326565b005b3480156101db57600080fd5b506101cd6103de565b3480156101f057600080fd5b506000546001600160a01b0316610102565b6101cd61021036600461108c565b6103f2565b34801561022157600080fd5b5061015561023036600461108c565b60026020526000908152604090205481565b34801561024e57600080fd5b506101cd61025d3660046110b0565b6104d0565b34801561026e57600080fd5b506101cd61027d3660046110f1565b610653565b34801561028e57600080fd5b5061015561029d366004611123565b6106ba565b3480156102ae57600080fd5b506101cd6102bd36600461108c565b610780565b3480156102ce57600080fd5b506102e26102dd366004611123565b6107f6565b6040516101169291906111a4565b3480156102fc57600080fd5b5061015561030b36600461108c565b6001600160a01b031660009081526002602052604090205490565b61032e610af7565b6001600160a01b0381166103af5760405162461bcd60e51b815260206004820152603360248201527f46616c6c6261636b47617354616e6b3a206e6577207369676e65722063616e2060448201527f6e6f74206265207a65726f20616464726573730000000000000000000000000060648201526084015b60405180910390fd5b6003805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6103e6610af7565b6103f06000610b51565b565b6103fa610bae565b6001600160a01b03811661045f5760405162461bcd60e51b815260206004820152602660248201527f646170704964656e7469666965722063616e206e6f74206265207a65726f206160448201526564647265737360d01b60648201526084016103a6565b6001600160a01b038116600090815260026020526040812080543492906104879084906111dd565b90915550506040516001600160a01b03821690349033907fe31c7b8d08ee7db0afa68782e1028ef92305caeea8626633ad44d413e30f6b2f90600090a46104cd60018055565b50565b6104d8610af7565b6104e0610bae565b6001600160a01b038316600090815260026020526040902054808211156105495760405162461bcd60e51b815260206004820152601f60248201527f496e73756666696369656e7420616d6f756e7420746f2077697468647261770060448201526064016103a6565b6001600160a01b03848116600090815260026020526040808220858503905551909185169084908381818185875af1925050503d80600081146105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50509050806105fe5760405162461bcd60e51b815260206004820152601260248201527f6661696c656420746f207769746864726177000000000000000000000000000060448201526064016103a6565b60405133815283906001600160a01b0380871691908816907f22340e3e4a7d4f4d0e875deb08fc85297154dcf683a28ef4fc92247034da9ade9060200160405180910390a4505061064e60018055565b505050565b61065b610af7565b600480546fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff83169081179091556040513391907f4f3d358cdb708bab4128f27f8d1b39ce593bc6935cf706075d56b0f4c47581bd90600090a350565b60006106c9602083018361108c565b6106d9604084016020850161108c565b60608401356106eb60a08601866111f0565b6040516106f9929190611237565b60405180910390208560800135866040016020810190610719919061108c565b604080516001600160a01b039788166020820152958716908601526060850193909352608084019190915260a083015290911660c08201524660e082015230610100820152610120015b604051602081830303815290604052805190602001209050919050565b610788610af7565b6001600160a01b0381166107ed5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016103a6565b6104cd81610b51565b60006060610802610bae565b60005a90506000610819604086016020870161108c565b90506001600160a01b0381166108715760405162461bcd60e51b815260206004820152601460248201527f63616c6c20746f206e756c6c206164647265737300000000000000000000000060448201526064016103a6565b3332146108c05760405162461bcd60e51b815260206004820152601060248201527f6f6e6c7920454f412072656c617965720000000000000000000000000000000060448201526064016103a6565b336108ca86610c07565b6108d386610d4f565b6001600160a01b03821660808701356108ef60a08901896111f0565b6040516108fd929190611237565b60006040518083038160008787f1925050503d806000811461093b576040519150601f19603f3d011682016040523d82523d6000602084013e610940565b606091505b50809550819650505061096c85856040518060600160405280602d81526020016112f6602d9139610d94565b60005a60045490850391506000903a90610998906fffffffffffffffffffffffffffffffff16846111dd565b6109a29190611247565b90506000836001600160a01b03168260405160006040518083038185875af1925050503d80600081146109f1576040519150601f19603f3d011682016040523d82523d6000602084013e6109f6565b606091505b5050905080610a29576040517f16efe5f1c5f195265253edf71c305f1f70e94288561662bc7a1f49a2b9d80b3790600090a15b8160026000610a3e60608d0160408e0161108c565b6001600160a01b03166001600160a01b031681526020019081526020016000206000828254610a6d919061125e565b90915550829050610a8160208b018b61108c565b6001600160a01b0316337f4526b5685831d86268d0c12c475d3b67fea0d61d4579edf3144e5ff10c44c6c5610ab960a08e018e6111f0565b8e6040016020810190610acc919061108c565b604051610adb93929190611271565b60405180910390a4505050505050610af260018055565b915091565b6000546001600160a01b031633146103f05760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016103a6565b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600260015403610c005760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016103a6565b6002600155565b6000610c12826106ba565b90506000610c2360c08401846111f0565b91505060418114610c9c5760405162461bcd60e51b815260206004820152603b60248201527f46616c6c6261636b47617354616e6b3a20696e76616c6964207369676e61747560448201527f7265206c656e67746820696e2066616c6c6261636b557365724f70000000000060648201526084016103a6565b610cf2610cac60c08501856111f0565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610cec9250869150610dc39050565b90610dfe565b6003546001600160a01b0390811691161461064e5760405162461bcd60e51b815260206004820181905260248201527f46616c6c6261636b47617354616e6b3a2077726f6e67207369676e617475726560448201526064016103a6565b60056000610d60602084018461108c565b6001600160a01b03166001600160a01b0316815260200190815260200160002060008154610d8d906112b3565b9091555050565b8261064e57815115610da95781518083602001fd5b8060405162461bcd60e51b81526004016103a691906112cc565b6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01610763565b6000806000610e0d8585610e24565b91509150610e1a81610e69565b5090505b92915050565b6000808251604103610e5a5760208301516040840151606085015160001a610e4e87828585610fb3565b94509450505050610e62565b506000905060025b9250929050565b6000816004811115610e7d57610e7d6112df565b03610e855750565b6001816004811115610e9957610e996112df565b03610ee65760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016103a6565b6002816004811115610efa57610efa6112df565b03610f475760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016103a6565b6003816004811115610f5b57610f5b6112df565b036104cd5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016103a6565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115610fea575060009050600361106e565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa15801561103e573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166110675760006001925092505061106e565b9150600090505b94509492505050565b6001600160a01b03811681146104cd57600080fd5b60006020828403121561109e57600080fd5b81356110a981611077565b9392505050565b6000806000606084860312156110c557600080fd5b83356110d081611077565b925060208401356110e081611077565b929592945050506040919091013590565b60006020828403121561110357600080fd5b81356fffffffffffffffffffffffffffffffff811681146110a957600080fd5b60006020828403121561113557600080fd5b813567ffffffffffffffff81111561114c57600080fd5b820160e081850312156110a957600080fd5b6000815180845260005b8181101561118457602081850181015186830182015201611168565b506000602082860101526020601f19601f83011685010191505092915050565b82151581526040602082015260006111bf604083018461115e565b949350505050565b634e487b7160e01b600052601160045260246000fd5b80820180821115610e1e57610e1e6111c7565b6000808335601e1984360301811261120757600080fd5b83018035915067ffffffffffffffff82111561122257600080fd5b602001915036819003821315610e6257600080fd5b8183823760009101908152919050565b8082028115828204841417610e1e57610e1e6111c7565b81810381811115610e1e57610e1e6111c7565b604081528260408201528284606083013760006060848301015260006060601f19601f86011683010190506001600160a01b0383166020830152949350505050565b6000600182016112c5576112c56111c7565b5060010190565b6020815260006110a9602083018461115e565b634e487b7160e01b600052602160045260246000fdfe466f727761726465642063616c6c20746f2064657374696e6174696f6e20646964206e6f742073756363656564a26469706673582212201ab076600184c4548c2597164d8d99dd8487435ca7ea264e51ba7d1428e05f6864736f6c63430008110033";
    var isSuperArgs = (xs) => xs.length > 1;
    var FallbackGasTankContractV100__factory = class extends ethers_1.ContractFactory {
      constructor(...args) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        this.contractName = "FallbackGasTankContractV100";
      }
      deploy(_owner, _verifyingSigner, overrides) {
        return super.deploy(_owner, _verifyingSigner, overrides || {});
      }
      getDeployTransaction(_owner, _verifyingSigner, overrides) {
        return super.getDeployTransaction(_owner, _verifyingSigner, overrides || {});
      }
      attach(address) {
        return super.attach(address);
      }
      connect(signer) {
        return super.connect(signer);
      }
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports2.FallbackGasTankContractV100__factory = FallbackGasTankContractV100__factory;
    FallbackGasTankContractV100__factory.bytecode = _bytecode;
    FallbackGasTankContractV100__factory.abi = _abi;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/FallbackGasTank/v1.0.0/FallbackGasTankEthersContract.js
var require_FallbackGasTankEthersContract = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/FallbackGasTank/v1.0.0/FallbackGasTankEthersContract.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FallbackGasTankEthersContract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.address;
      }
      getContract() {
        return this.contract;
      }
      async getBalance(_dappIdentifier) {
        return this.contract.getBalance(_dappIdentifier);
      }
      async getNonce(_sender) {
        return this.contract.getNonce(_sender);
      }
      async getHash(fallbackUserOp) {
        return this.contract.getHash(fallbackUserOp);
      }
      getInterface() {
        return this.contract.interface;
      }
    };
    exports2.default = FallbackGasTankEthersContract;
  }
});

// node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/DefaultCallbackHandlerV100__factory.js
var require_DefaultCallbackHandlerV100_factory = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/DefaultCallbackHandlerV100__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultCallbackHandlerV100__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var _bytecode = "0x608060405234801561001057600080fd5b506105c6806100206000396000f3fe608060405234801561001057600080fd5b506004361061007c5760003560e01c8063a3f4df7e1161005b578063a3f4df7e146100fb578063bc197c8114610144578063f23a6e6114610166578063ffa1ad741461018657600080fd5b806223de291461008157806301ffc9a71461009b578063150b7a02146100c3575b600080fd5b61009961008f3660046102a0565b5050505050505050565b005b6100ae6100a936600461034b565b6101c2565b60405190151581526020015b60405180910390f35b6100e26100d136600461037c565b630a85bd0160e11b95945050505050565b6040516001600160e01b031990911681526020016100ba565b6101376040518060400160405280601881526020017f44656661756c742043616c6c6261636b2048616e646c6572000000000000000081525081565b6040516100ba91906103eb565b6100e261015236600461047e565b63bc197c8160e01b98975050505050505050565b6100e2610174366004610518565b63f23a6e6160e01b9695505050505050565b6101376040518060400160405280600581526020017f312e302e3000000000000000000000000000000000000000000000000000000081525081565b60006001600160e01b03198216630271189760e51b14806101f357506001600160e01b03198216630a85bd0160e11b145b8061020d57506001600160e01b031982166223de2960e01b145b8061022857506001600160e01b031982166301ffc9a760e01b145b92915050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461025257600080fd5b919050565b60008083601f84011261026957600080fd5b50813567ffffffffffffffff81111561028157600080fd5b60208301915083602082850101111561029957600080fd5b9250929050565b60008060008060008060008060c0898b0312156102bc57600080fd5b6102c58961022e565b97506102d360208a0161022e565b96506102e160408a0161022e565b955060608901359450608089013567ffffffffffffffff8082111561030557600080fd5b6103118c838d01610257565b909650945060a08b013591508082111561032a57600080fd5b506103378b828c01610257565b999c989b5096995094979396929594505050565b60006020828403121561035d57600080fd5b81356001600160e01b03198116811461037557600080fd5b9392505050565b60008060008060006080868803121561039457600080fd5b61039d8661022e565b94506103ab6020870161022e565b935060408601359250606086013567ffffffffffffffff8111156103ce57600080fd5b6103da88828901610257565b969995985093965092949392505050565b600060208083528351808285015260005b81811015610418578581018301518582016040015282016103fc565b506000604082860101526040601f19601f8301168501019250505092915050565b60008083601f84011261044b57600080fd5b50813567ffffffffffffffff81111561046357600080fd5b6020830191508360208260051b850101111561029957600080fd5b60008060008060008060008060a0898b03121561049a57600080fd5b6104a38961022e565b97506104b160208a0161022e565b9650604089013567ffffffffffffffff808211156104ce57600080fd5b6104da8c838d01610439565b909850965060608b01359150808211156104f357600080fd5b6104ff8c838d01610439565b909650945060808b013591508082111561032a57600080fd5b60008060008060008060a0878903121561053157600080fd5b61053a8761022e565b95506105486020880161022e565b94506040870135935060608701359250608087013567ffffffffffffffff81111561057257600080fd5b61057e89828a01610257565b979a969950949750929593949250505056fea26469706673582212206f9a1f9a5ca42f0117480a42f9da011f61d3cff893c7884f2882240c427475b564736f6c63430008110033";
    var isSuperArgs = (xs) => xs.length > 1;
    var DefaultCallbackHandlerV100__factory = class extends ethers_1.ContractFactory {
      constructor(...args) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        this.contractName = "DefaultCallbackHandlerV100";
      }
      deploy(overrides) {
        return super.deploy(overrides || {});
      }
      getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
      }
      attach(address) {
        return super.attach(address);
      }
      connect(signer) {
        return super.connect(signer);
      }
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports2.DefaultCallbackHandlerV100__factory = DefaultCallbackHandlerV100__factory;
    DefaultCallbackHandlerV100__factory.bytecode = _bytecode;
    DefaultCallbackHandlerV100__factory.abi = _abi;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/DefaultCallbackHandlerContract/v1.0.0/DefaultCallbackHandlerEthersContract.js
var require_DefaultCallbackHandlerEthersContract = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/DefaultCallbackHandlerContract/v1.0.0/DefaultCallbackHandlerEthersContract.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DefaultCallbackHandlerEthersContract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.address;
      }
      getInterface() {
        return this.contract.interface;
      }
      getContract() {
        return this.contract;
      }
    };
    exports2.default = DefaultCallbackHandlerEthersContract;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/contracts/contractInstancesEthers.js
var require_contractInstancesEthers = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/contracts/contractInstancesEthers.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultCallbackHandlerInstance = exports2.getFallbackGasTankContractInstance = exports2.getEntryPointFactoryContractInstance = exports2.getSmartWalletFactoryContractInstance = exports2.getMultiSendCallOnlyContractInstance = exports2.getMultiSendContractInstance = exports2.getSmartWalletContractInstance = void 0;
    var SmartWalletContractV100__factory_1 = require_SmartWalletContractV100_factory();
    var MultiSendContractV100__factory_1 = require_MultiSendContractV100_factory();
    var MultiSendCallOnlyContractV100__factory_1 = require_MultiSendCallOnlyContractV100_factory();
    var SmartWalletFactoryContractV100__factory_1 = require_SmartWalletFactoryContractV100_factory();
    var SmartWalletContractEthers_1 = __importDefault(require_SmartWalletContractEthers());
    var MultiSendEthersContract_1 = __importDefault(require_MultiSendEthersContract());
    var MultiSendCallOnlyEthersContract_1 = __importDefault(require_MultiSendCallOnlyEthersContract());
    var SmartWalletProxyFactoryEthersContract_1 = __importDefault(require_SmartWalletProxyFactoryEthersContract());
    var EntryPointContractV100__factory_1 = require_EntryPointContractV100_factory();
    var EntryPointEthersContract_1 = __importDefault(require_EntryPointEthersContract());
    var FallbackGasTankContractV100__factory_1 = require_FallbackGasTankContractV100_factory();
    var FallbackGasTankEthersContract_1 = __importDefault(require_FallbackGasTankEthersContract());
    var DefaultCallbackHandlerV100__factory_1 = require_DefaultCallbackHandlerV100_factory();
    var DefaultCallbackHandlerEthersContract_1 = __importDefault(require_DefaultCallbackHandlerEthersContract());
    function getSmartWalletContractInstance(smartAccountVersion, contractAddress, provider) {
      let walletContract;
      switch (smartAccountVersion) {
        case "1.0.0":
          walletContract = SmartWalletContractV100__factory_1.SmartWalletContractV100__factory.connect(contractAddress, provider);
          return new SmartWalletContractEthers_1.default(walletContract);
        default:
          walletContract = SmartWalletContractV100__factory_1.SmartWalletContractV100__factory.connect(contractAddress, provider);
          return new SmartWalletContractEthers_1.default(walletContract);
      }
    }
    exports2.getSmartWalletContractInstance = getSmartWalletContractInstance;
    function getMultiSendContractInstance(smartAccountVersion, contractAddress, provider) {
      let multiSendContract;
      switch (smartAccountVersion) {
        case "1.0.0":
          multiSendContract = MultiSendContractV100__factory_1.MultiSendContractV100__factory.connect(contractAddress, provider);
          return new MultiSendEthersContract_1.default(multiSendContract);
        default:
          multiSendContract = MultiSendContractV100__factory_1.MultiSendContractV100__factory.connect(contractAddress, provider);
          return new MultiSendEthersContract_1.default(multiSendContract);
      }
    }
    exports2.getMultiSendContractInstance = getMultiSendContractInstance;
    function getMultiSendCallOnlyContractInstance(smartAccountVersion, contractAddress, provider) {
      let multiSendCallContract;
      switch (smartAccountVersion) {
        case "1.0.0":
          multiSendCallContract = MultiSendCallOnlyContractV100__factory_1.MultiSendCallOnlyContractV100__factory.connect(contractAddress, provider);
          return new MultiSendCallOnlyEthersContract_1.default(multiSendCallContract);
        default:
          multiSendCallContract = MultiSendCallOnlyContractV100__factory_1.MultiSendCallOnlyContractV100__factory.connect(contractAddress, provider);
          return new MultiSendCallOnlyEthersContract_1.default(multiSendCallContract);
      }
    }
    exports2.getMultiSendCallOnlyContractInstance = getMultiSendCallOnlyContractInstance;
    function getSmartWalletFactoryContractInstance(smartAccountVersion, contractAddress, provider) {
      let walletFactoryContract;
      switch (smartAccountVersion) {
        case "1.0.0":
          walletFactoryContract = SmartWalletFactoryContractV100__factory_1.SmartWalletFactoryContractV100__factory.connect(contractAddress, provider);
          return new SmartWalletProxyFactoryEthersContract_1.default(walletFactoryContract);
        default:
          walletFactoryContract = SmartWalletFactoryContractV100__factory_1.SmartWalletFactoryContractV100__factory.connect(contractAddress, provider);
          return new SmartWalletProxyFactoryEthersContract_1.default(walletFactoryContract);
      }
    }
    exports2.getSmartWalletFactoryContractInstance = getSmartWalletFactoryContractInstance;
    function getEntryPointFactoryContractInstance(smartAccountVersion, contractAddress, provider) {
      let walletFactoryContract;
      switch (smartAccountVersion) {
        case "1.0.0":
          walletFactoryContract = EntryPointContractV100__factory_1.EntryPointContractV100__factory.connect(contractAddress, provider);
          return new EntryPointEthersContract_1.default(walletFactoryContract);
        default:
          walletFactoryContract = EntryPointContractV100__factory_1.EntryPointContractV100__factory.connect(contractAddress, provider);
          return new EntryPointEthersContract_1.default(walletFactoryContract);
      }
    }
    exports2.getEntryPointFactoryContractInstance = getEntryPointFactoryContractInstance;
    function getFallbackGasTankContractInstance(smartAccountVersion, contractAddress, provider) {
      let fallbackGasTankContract;
      switch (smartAccountVersion) {
        case "1.0.0":
          fallbackGasTankContract = FallbackGasTankContractV100__factory_1.FallbackGasTankContractV100__factory.connect(contractAddress, provider);
          return new FallbackGasTankEthersContract_1.default(fallbackGasTankContract);
        case "1.0.1":
        default:
          fallbackGasTankContract = FallbackGasTankContractV100__factory_1.FallbackGasTankContractV100__factory.connect(contractAddress, provider);
          return new FallbackGasTankEthersContract_1.default(fallbackGasTankContract);
      }
    }
    exports2.getFallbackGasTankContractInstance = getFallbackGasTankContractInstance;
    function getDefaultCallbackHandlerInstance(smartAccountVersion, contractAddress, provider) {
      let defaultCallbackHandlerContract;
      switch (smartAccountVersion) {
        case "1.0.0":
          defaultCallbackHandlerContract = DefaultCallbackHandlerV100__factory_1.DefaultCallbackHandlerV100__factory.connect(contractAddress, provider);
          return new DefaultCallbackHandlerEthersContract_1.default(defaultCallbackHandlerContract);
        default:
          defaultCallbackHandlerContract = DefaultCallbackHandlerV100__factory_1.DefaultCallbackHandlerV100__factory.connect(contractAddress, provider);
          return new DefaultCallbackHandlerEthersContract_1.default(defaultCallbackHandlerContract);
      }
    }
    exports2.getDefaultCallbackHandlerInstance = getDefaultCallbackHandlerInstance;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/EvmNetworkManager.js
var require_EvmNetworkManager = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/EvmNetworkManager.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver2, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state.set(receiver2, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver2, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
    };
    var _EvmNetworkManager_ethers;
    var _EvmNetworkManager_signer;
    var _EvmNetworkManager_provider;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bignumber_1 = (init_lib3(), __toCommonJS(lib_exports3));
    var safe_core_sdk_utils_1 = require_src7();
    var contractInstancesEthers_1 = require_contractInstancesEthers();
    var EvmNetworkManager = class {
      constructor({ ethers, signer, provider }) {
        _EvmNetworkManager_ethers.set(this, void 0);
        _EvmNetworkManager_signer.set(this, void 0);
        _EvmNetworkManager_provider.set(this, void 0);
        if (!ethers) {
          throw new Error("ethers property missing from options");
        }
        if (!signer.provider) {
          throw new Error("Signer must be connected to a provider");
        }
        __classPrivateFieldSet(this, _EvmNetworkManager_signer, signer, "f");
        __classPrivateFieldSet(this, _EvmNetworkManager_provider, provider, "f");
        __classPrivateFieldSet(this, _EvmNetworkManager_ethers, ethers, "f");
      }
      // Review
      getProvider() {
        return __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f");
      }
      getSigner() {
        return __classPrivateFieldGet(this, _EvmNetworkManager_signer, "f");
      }
      async getEip3770Address(fullAddress) {
        const chainId = await this.getChainId();
        return (0, safe_core_sdk_utils_1.validateEip3770Address)(fullAddress, chainId);
      }
      async getBalance(address) {
        return bignumber_1.BigNumber.from(await __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f").getBalance(address));
      }
      async getChainId() {
        return (await __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f").getNetwork()).chainId;
      }
      getSmartWalletContract(smartAccountVersion, address) {
        if (!address) {
          throw new Error("Invalid Smart Wallet contract address");
        }
        return (0, contractInstancesEthers_1.getSmartWalletContractInstance)(smartAccountVersion, address, __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f"));
      }
      getMultiSendContract(smartAccountVersion, address) {
        if (!address) {
          throw new Error("Invalid Multi Send contract address");
        }
        return (0, contractInstancesEthers_1.getMultiSendContractInstance)(smartAccountVersion, address, __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f"));
      }
      getMultiSendCallOnlyContract(smartAccountVersion, address) {
        if (!address) {
          throw new Error("Invalid Multi Send Call Only contract address");
        }
        return (0, contractInstancesEthers_1.getMultiSendCallOnlyContractInstance)(smartAccountVersion, address, __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f"));
      }
      getSmartWalletFactoryContract(smartAccountVersion, address) {
        if (!address) {
          throw new Error("Invalid Wallet Factory contract address");
        }
        return (0, contractInstancesEthers_1.getSmartWalletFactoryContractInstance)(smartAccountVersion, address, __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f"));
      }
      getFallbackGasTankContract(smartAccountVersion, address) {
        if (!address) {
          throw new Error("Invalid Fallback Gas Tank contract address");
        }
        return (0, contractInstancesEthers_1.getFallbackGasTankContractInstance)(smartAccountVersion, address, __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f"));
      }
      getDefaultCallbackHandlerContract(smartAccountVersion, address) {
        if (!address) {
          throw new Error("Invalid Default Callback Handler contract address");
        }
        return (0, contractInstancesEthers_1.getDefaultCallbackHandlerInstance)(smartAccountVersion, address, __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f"));
      }
      async getContractCode(address) {
        return __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f").getCode(address);
      }
      async isContractDeployed(address) {
        let contractCode;
        try {
          contractCode = await __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f").getCode(address);
          return contractCode !== "0x";
        } catch (error) {
          throw new Error("Unable to get Contract details");
        }
      }
      async getTransaction(transactionHash) {
        return __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f").getTransaction(transactionHash);
      }
      async getSignerAddress() {
        return __classPrivateFieldGet(this, _EvmNetworkManager_signer, "f").getAddress();
      }
      signMessage(message) {
        const messageArray = __classPrivateFieldGet(this, _EvmNetworkManager_ethers, "f").utils.arrayify(message);
        return __classPrivateFieldGet(this, _EvmNetworkManager_signer, "f").signMessage(messageArray);
      }
      // Review
      async estimateGas(transaction) {
        return (await __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f").estimateGas(transaction)).toNumber();
      }
      call(transaction) {
        return __classPrivateFieldGet(this, _EvmNetworkManager_provider, "f").call(transaction);
      }
    };
    _EvmNetworkManager_ethers = /* @__PURE__ */ new WeakMap(), _EvmNetworkManager_signer = /* @__PURE__ */ new WeakMap(), _EvmNetworkManager_provider = /* @__PURE__ */ new WeakMap();
    exports2.default = EvmNetworkManager;
  }
});

// node_modules/@biconomy/ethers-lib/dist/src/index.js
var require_src8 = __commonJS({
  "node_modules/@biconomy/ethers-lib/dist/src/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntryPointEthersContract_v1_0_0 = exports2.EntryPointFactoryContractV100 = exports2.SmartWalletContractFactoryV100 = exports2.MultiSendCallOnlyContractV100 = exports2.MultiSendContractV100 = exports2.SmartWalletFactoryV100 = void 0;
    var EvmNetworkManager_1 = __importDefault(require_EvmNetworkManager());
    var SmartWalletContractV100__factory_1 = require_SmartWalletContractV100_factory();
    Object.defineProperty(exports2, "SmartWalletFactoryV100", { enumerable: true, get: function() {
      return SmartWalletContractV100__factory_1.SmartWalletContractV100__factory;
    } });
    var MultiSendContractV100__factory_1 = require_MultiSendContractV100_factory();
    Object.defineProperty(exports2, "MultiSendContractV100", { enumerable: true, get: function() {
      return MultiSendContractV100__factory_1.MultiSendContractV100__factory;
    } });
    var MultiSendCallOnlyContractV100__factory_1 = require_MultiSendCallOnlyContractV100_factory();
    Object.defineProperty(exports2, "MultiSendCallOnlyContractV100", { enumerable: true, get: function() {
      return MultiSendCallOnlyContractV100__factory_1.MultiSendCallOnlyContractV100__factory;
    } });
    var SmartWalletFactoryContractV100__factory_1 = require_SmartWalletFactoryContractV100_factory();
    Object.defineProperty(exports2, "SmartWalletContractFactoryV100", { enumerable: true, get: function() {
      return SmartWalletFactoryContractV100__factory_1.SmartWalletFactoryContractV100__factory;
    } });
    var EntryPointContractV100__factory_1 = require_EntryPointContractV100_factory();
    Object.defineProperty(exports2, "EntryPointFactoryContractV100", { enumerable: true, get: function() {
      return EntryPointContractV100__factory_1.EntryPointContractV100__factory;
    } });
    var EntryPointEthersContract_1 = __importDefault(require_EntryPointEthersContract());
    exports2.EntryPointEthersContract_v1_0_0 = EntryPointEthersContract_1.default;
    exports2.default = EvmNetworkManager_1.default;
  }
});

// node_modules/@biconomy/transactions/dist/src/ContractUtils.js
var require_ContractUtils = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/ContractUtils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FetchContractsInfo_1 = require_FetchContractsInfo();
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var ethers_lib_1 = __importDefault(require_src8());
    var common_1 = require_src4();
    var ContractUtils = class {
      constructor(chainConfig) {
        this.chainConfig = chainConfig;
        this.ethAdapter = {};
        this.smartWalletContract = {};
        this.multiSendContract = {};
        this.multiSendCallOnlyContract = {};
        this.smartWalletFactoryContract = {};
        this.fallbackGasTankContract = {};
      }
      initializeContracts(signer, readProvider, walletInfo, chaininfo) {
        this.ethAdapter[walletInfo.chainId] = new ethers_lib_1.default({
          ethers: ethers_1.ethers,
          signer,
          provider: readProvider
        });
        this.smartWalletFactoryContract[walletInfo.chainId] = {};
        this.smartWalletContract[walletInfo.chainId] = {};
        this.multiSendContract[walletInfo.chainId] = {};
        this.multiSendCallOnlyContract[walletInfo.chainId] = {};
        this.fallbackGasTankContract[walletInfo.chainId] = {};
        const version = walletInfo.version;
        common_1.Logger.log("version ", version);
        this.smartWalletFactoryContract[walletInfo.chainId][version] = (0, FetchContractsInfo_1.getSmartWalletFactoryContract)(version, this.ethAdapter[walletInfo.chainId], walletInfo.factoryAddress);
        common_1.Logger.log("Factory Address ", walletInfo.factoryAddress);
        this.smartWalletContract[walletInfo.chainId][version] = (0, FetchContractsInfo_1.getSmartWalletContract)(version, this.ethAdapter[walletInfo.chainId], walletInfo.smartAccountAddress);
        common_1.Logger.log("SmartAccount Address ", walletInfo.smartAccountAddress);
        this.multiSendContract[walletInfo.chainId][version] = (0, FetchContractsInfo_1.getMultiSendContract)(version, this.ethAdapter[walletInfo.chainId], chaininfo.multiSend[chaininfo.multiSend.length - 1].address);
        this.multiSendCallOnlyContract[walletInfo.chainId][version] = (0, FetchContractsInfo_1.getMultiSendCallOnlyContract)(version, this.ethAdapter[walletInfo.chainId], chaininfo.multiSendCall[chaininfo.multiSendCall.length - 1].address);
        this.fallbackGasTankContract[walletInfo.chainId][version] = (0, FetchContractsInfo_1.getFallbackGasTankContract)(version, this.ethAdapter[walletInfo.chainId], chaininfo.fallBackGasTankAddress);
      }
      async isDeployed(chainId, address) {
        return await this.ethAdapter[chainId].isContractDeployed(address);
      }
      //
      /**
       * Serves smart contract instances associated with Smart Account for requested ChainId
       * Context is useful when relayer is deploying a wallet
       * @param chainId requested chain : default is active chain
       * @returns object containing relevant contract instances
       */
      getSmartAccountContext(chainId, version) {
        const context = {
          baseWallet: this.smartWalletContract[chainId][version],
          walletFactory: this.smartWalletFactoryContract[chainId][version],
          multiSend: this.multiSendContract[chainId][version],
          multiSendCall: this.multiSendCallOnlyContract[chainId][version]
          // Could be added dex router for chain in the future
        };
        return context;
      }
      setSmartAccountState(smartAccountState) {
        this.smartAccountState = smartAccountState;
      }
      getSmartAccountState() {
        return this.smartAccountState;
      }
      attachWalletContract(chainId, version, address) {
        const walletContract = this.smartWalletContract[chainId][version].getContract();
        return walletContract.attach(address);
      }
    };
    exports2.default = ContractUtils;
  }
});

// node_modules/@biconomy/transactions/dist/src/AccountUtils.js
var require_AccountUtils = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/AccountUtils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeTransferFrom = exports2.encodeTransfer = exports2.Erc20Interface = exports2.Erc20 = exports2.getSignatureParameters = exports2.getBalance = exports2.createWalletOwner = exports2.FIVE_ETH = exports2.TWO_ETH = exports2.ONE_ETH = exports2.HashZero = exports2.AddressZero = void 0;
    var utils_1 = require_utils();
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var ethereumjs_util_1 = require_dist3();
    exports2.AddressZero = ethers_1.ethers.constants.AddressZero;
    exports2.HashZero = ethers_1.ethers.constants.HashZero;
    exports2.ONE_ETH = (0, utils_1.parseEther)("1");
    exports2.TWO_ETH = (0, utils_1.parseEther)("2");
    exports2.FIVE_ETH = (0, utils_1.parseEther)("5");
    var counter = 0;
    function createWalletOwner() {
      const privateKey = (0, ethereumjs_util_1.keccak256)(Buffer.from((0, utils_1.arrayify)(ethers_1.BigNumber.from(++counter))));
      return new ethers_1.ethers.Wallet(privateKey, ethers_1.ethers.providers.getDefaultProvider());
    }
    exports2.createWalletOwner = createWalletOwner;
    async function getBalance(address) {
      const balance = await ethers_1.ethers.providers.getDefaultProvider().getBalance(address);
      return parseInt(balance.toString());
    }
    exports2.getBalance = getBalance;
    function getSignatureParameters(signature) {
      if (!ethers_1.ethers.utils.isHexString(signature)) {
        throw new Error('Given value "'.concat(signature, '" is not a valid hex string.'));
      }
      const r = signature.slice(0, 66);
      const s = "0x".concat(signature.slice(66, 130));
      let v = ethers_1.ethers.BigNumber.from("0x".concat(signature.slice(130, 132))).toNumber();
      if (![27, 28].includes(v))
        v += 27;
      return {
        r,
        s,
        v
      };
    }
    exports2.getSignatureParameters = getSignatureParameters;
    exports2.Erc20 = [
      "function transfer(address _receiver, uint256 _value) public returns (bool success)",
      "function transferFrom(address, address, uint) public returns (bool)",
      "function approve(address _spender, uint256 _value) public returns (bool success)",
      "function allowance(address _owner, address _spender) public view returns (uint256 remaining)",
      "function balanceOf(address _owner) public view returns (uint256 balance)",
      "event Approval(address indexed _owner, address indexed _spender, uint256 _value)"
    ];
    exports2.Erc20Interface = new ethers_1.ethers.utils.Interface(exports2.Erc20);
    var encodeTransfer = (target, amount) => {
      return exports2.Erc20Interface.encodeFunctionData("transfer", [target, amount]);
    };
    exports2.encodeTransfer = encodeTransfer;
    var encodeTransferFrom = (from, target, amount) => {
      return exports2.Erc20Interface.encodeFunctionData("transferFrom", [from, target, amount]);
    };
    exports2.encodeTransferFrom = encodeTransferFrom;
  }
});

// node_modules/@biconomy/transactions/dist/src/Execution.js
var require_Execution = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/Execution.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildSmartAccountTransaction = exports2.executeContractCallWithSigners = exports2.executeTxWithSigners = exports2.buildContractCall = exports2.populateExecuteTx = exports2.executeTx = exports2.buildSignatureBytes = exports2.smartAccountSignMessage = exports2.signHash = exports2.smartAccountSignTypedData = exports2.calculateSmartAccountMessageHash = exports2.calculateSmartAccountTransactionHash = exports2.preimageWalletTransactionHash = exports2.calculateSmartAccountDomainSeparator = exports2.EIP712_SMART_ACCOUNT_MESSAGE_TYPE = exports2.EIP712_ACCOUNT_TX_TYPE = exports2.EIP_DOMAIN = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var constants_1 = (init_lib8(), __toCommonJS(lib_exports8));
    exports2.EIP_DOMAIN = {
      EIP712Domain: [
        { type: "uint256", name: "chainId" },
        { type: "address", name: "verifyingContract" }
      ]
    };
    exports2.EIP712_ACCOUNT_TX_TYPE = {
      // "AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)"
      AccountTx: [
        { type: "address", name: "to" },
        { type: "uint256", name: "value" },
        { type: "bytes", name: "data" },
        { type: "uint8", name: "operation" },
        { type: "uint256", name: "targetTxGas" },
        { type: "uint256", name: "baseGas" },
        { type: "uint256", name: "gasPrice" },
        { type: "uint256", name: "tokenGasPriceFactor" },
        { type: "address", name: "gasToken" },
        { type: "address", name: "refundReceiver" },
        { type: "uint256", name: "nonce" }
      ]
    };
    exports2.EIP712_SMART_ACCOUNT_MESSAGE_TYPE = {
      // "SmartAccountMessage(bytes message)"
      SmartAccountMessage: [{ type: "bytes", name: "message" }]
    };
    var calculateSmartAccountDomainSeparator = (wallet, chainId) => {
      return ethers_1.utils._TypedDataEncoder.hashDomain({
        verifyingContract: wallet.address,
        chainId
      });
    };
    exports2.calculateSmartAccountDomainSeparator = calculateSmartAccountDomainSeparator;
    var preimageWalletTransactionHash = (wallet, SmartAccountTx, chainId) => {
      return ethers_1.utils._TypedDataEncoder.encode({ verifyingContract: wallet.address, chainId }, exports2.EIP712_ACCOUNT_TX_TYPE, SmartAccountTx);
    };
    exports2.preimageWalletTransactionHash = preimageWalletTransactionHash;
    var calculateSmartAccountTransactionHash = (wallet, SmartAccountTx, chainId) => {
      return ethers_1.utils._TypedDataEncoder.hash({ verifyingContract: wallet.address, chainId }, exports2.EIP712_ACCOUNT_TX_TYPE, SmartAccountTx);
    };
    exports2.calculateSmartAccountTransactionHash = calculateSmartAccountTransactionHash;
    var calculateSmartAccountMessageHash = (wallet, message, chainId) => {
      return ethers_1.utils._TypedDataEncoder.hash({ verifyingContract: wallet.address, chainId }, exports2.EIP712_SMART_ACCOUNT_MESSAGE_TYPE, { message });
    };
    exports2.calculateSmartAccountMessageHash = calculateSmartAccountMessageHash;
    var smartAccountSignTypedData = async (signer, wallet, SmartAccountTx, chainId) => {
      var _a;
      if (!chainId && !(signer === null || signer === void 0 ? void 0 : signer.provider))
        throw Error("Provider required to retrieve chainId");
      const cid = chainId !== null && chainId !== void 0 ? chainId : (_a = await signer.provider.getNetwork()) === null || _a === void 0 ? void 0 : _a.chainId;
      const signerAddress = await signer.getAddress();
      return {
        signer: signerAddress,
        data: await signer._signTypedData({ verifyingContract: wallet.address, chainId: cid }, exports2.EIP712_ACCOUNT_TX_TYPE, SmartAccountTx)
      };
    };
    exports2.smartAccountSignTypedData = smartAccountSignTypedData;
    var signHash = async (signer, hash) => {
      const typedDataHash = ethers_1.utils.arrayify(hash);
      const signerAddress = await signer.getAddress();
      return {
        signer: signerAddress,
        data: (await signer.signMessage(typedDataHash)).replace(/1b$/, "1f").replace(/1c$/, "20")
      };
    };
    exports2.signHash = signHash;
    var smartAccountSignMessage = async (signer, wallet, SmartAccountTx, chainId) => {
      if (!chainId && !(signer === null || signer === void 0 ? void 0 : signer.provider))
        throw Error("Provider required to retrieve chainId");
      const cid = chainId !== null && chainId !== void 0 ? chainId : (await signer.provider.getNetwork()).chainId;
      if (!cid) {
        throw Error("smartAccountSignMessage: Chain Id Not Found");
      }
      return (0, exports2.signHash)(signer, (0, exports2.calculateSmartAccountTransactionHash)(wallet, SmartAccountTx, cid));
    };
    exports2.smartAccountSignMessage = smartAccountSignMessage;
    var buildSignatureBytes = (signatures) => {
      signatures.sort((left, right) => left.signer.toLowerCase().localeCompare(right.signer.toLowerCase()));
      let signatureBytes = "0x";
      for (const sig of signatures) {
        signatureBytes += sig.data.slice(2);
      }
      return signatureBytes;
    };
    exports2.buildSignatureBytes = buildSignatureBytes;
    var executeTx = async (wallet, SmartAccountTx, signatures, overrides) => {
      const signatureBytes = (0, exports2.buildSignatureBytes)(signatures);
      const transaction = {
        to: SmartAccountTx.to,
        value: SmartAccountTx.value,
        data: SmartAccountTx.data,
        operation: SmartAccountTx.operation,
        targetTxGas: SmartAccountTx.targetTxGas
      };
      const refundInfo = {
        baseGas: SmartAccountTx.baseGas,
        gasPrice: SmartAccountTx.gasPrice,
        tokenGasPriceFactor: SmartAccountTx.tokenGasPriceFactor,
        gasToken: SmartAccountTx.gasToken,
        refundReceiver: SmartAccountTx.refundReceiver
      };
      return wallet.execTransaction(transaction, refundInfo, signatureBytes, overrides || {});
    };
    exports2.executeTx = executeTx;
    var populateExecuteTx = async (wallet, SmartAccountTx, signatures, overrides) => {
      const signatureBytes = (0, exports2.buildSignatureBytes)(signatures);
      const transaction = {
        to: SmartAccountTx.to,
        value: SmartAccountTx.value,
        data: SmartAccountTx.data,
        operation: SmartAccountTx.operation,
        targetTxGas: SmartAccountTx.targetTxGas
      };
      const refundInfo = {
        baseGas: SmartAccountTx.baseGas,
        gasPrice: SmartAccountTx.gasPrice,
        tokenGasPriceFactor: SmartAccountTx.tokenGasPriceFactor,
        gasToken: SmartAccountTx.gasToken,
        refundReceiver: SmartAccountTx.refundReceiver
      };
      return wallet.populateTransaction.execTransaction(transaction, refundInfo, signatureBytes, overrides || {});
    };
    exports2.populateExecuteTx = populateExecuteTx;
    var buildContractCall = (contract, method, params, nonce, delegateCall, overrides) => {
      const data = contract.interface.encodeFunctionData(method, params);
      return (0, exports2.buildSmartAccountTransaction)(Object.assign({
        to: contract.address,
        data,
        operation: delegateCall ? 1 : 0,
        nonce
      }, overrides));
    };
    exports2.buildContractCall = buildContractCall;
    var executeTxWithSigners = async (wallet, tx, signers, overrides) => {
      const sigs = await Promise.all(signers.map((signer) => (0, exports2.smartAccountSignTypedData)(signer, wallet, tx)));
      return (0, exports2.executeTx)(wallet, tx, sigs, overrides);
    };
    exports2.executeTxWithSigners = executeTxWithSigners;
    var executeContractCallWithSigners = async (wallet, contract, method, params, signers, delegateCall, overrides) => {
      const tx = (0, exports2.buildContractCall)(
        contract,
        method,
        params,
        await wallet.getNonce(0),
        //default batchId @review
        delegateCall,
        overrides
      );
      return (0, exports2.executeTxWithSigners)(wallet, tx, signers);
    };
    exports2.executeContractCallWithSigners = executeContractCallWithSigners;
    var buildSmartAccountTransaction = (template) => {
      return {
        to: template.to,
        value: template.value || 0,
        data: template.data || "0x",
        operation: template.operation || 0,
        targetTxGas: template.targetTxGas || 0,
        baseGas: template.baseGas || 0,
        gasPrice: template.gasPrice || 0,
        tokenGasPriceFactor: template.tokenGasPriceFactor || 1,
        gasToken: template.gasToken || constants_1.AddressZero,
        refundReceiver: template.refundReceiver || constants_1.AddressZero,
        nonce: template.nonce
      };
    };
    exports2.buildSmartAccountTransaction = buildSmartAccountTransaction;
  }
});

// node_modules/@biconomy/transactions/dist/src/MultiSend.js
var require_MultiSend2 = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/MultiSend.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildMultiSendSmartAccountTx = exports2.encodeMultiSend = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var Execution_1 = require_Execution();
    var encodeMetaTransaction = (tx) => {
      const data = ethers_1.utils.arrayify(tx.data);
      const encoded = ethers_1.utils.solidityPack(["uint8", "address", "uint256", "uint256", "bytes"], [tx.operation, tx.to, tx.value, data.length, data]);
      return encoded.slice(2);
    };
    var encodeMultiSend = (txs) => {
      return "0x" + txs.map((tx) => encodeMetaTransaction(tx)).join("");
    };
    exports2.encodeMultiSend = encodeMultiSend;
    var buildMultiSendSmartAccountTx = (multiSend, txs, nonce, overrides) => {
      return (0, Execution_1.buildContractCall)(multiSend, "multiSend", [(0, exports2.encodeMultiSend)(txs)], nonce, true, overrides);
    };
    exports2.buildMultiSendSmartAccountTx = buildMultiSendSmartAccountTx;
  }
});

// node_modules/@biconomy/transactions/dist/src/index.js
var require_src9 = __commonJS({
  "node_modules/@biconomy/transactions/dist/src/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractUtils = void 0;
    var TransactionManager_1 = __importDefault(require_TransactionManager());
    var ContractUtils_1 = __importDefault(require_ContractUtils());
    exports2.ContractUtils = ContractUtils_1.default;
    exports2.default = TransactionManager_1.default;
    __exportStar(require_AccountUtils(), exports2);
    __exportStar(require_Execution(), exports2);
    __exportStar(require_MultiSend2(), exports2);
  }
});

// node_modules/@biconomy/smart-account/dist/src/signers/SmartAccountSigner.js
var require_SmartAccountSigner = __commonJS({
  "node_modules/@biconomy/smart-account/dist/src/signers/SmartAccountSigner.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartAccountSigner = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var abstract_signer_1 = (init_lib13(), __toCommonJS(lib_exports13));
    var SmartAccountSigner = class extends abstract_signer_1.Signer {
      constructor(provider, defaultChainId) {
        super();
        this.provider = provider;
        this.defaultChainId = defaultChainId;
      }
      /**
       * Note: When you do getAddress it could use provider.getAddress / provider.getSmartAccountAddress or directly access SmartAccountAPI
       */
      async getAddress() {
        if (this._address)
          return this._address;
        const accounts = await this.provider.send("eth_accounts", []);
        this._address = accounts[0];
        return ethers_1.ethers.utils.getAddress(this._address);
      }
      async getChainId() {
        return (await this.provider.getNetwork()).chainId;
      }
      async signTransaction(transaction) {
        if (!this.provider) {
          throw new Error("missing provider");
        }
        const signature = await this.provider.send("eth_signTransaction", [transaction]);
        return signature;
      }
      // signMessage matches implementation from ethers JsonRpcSigner for compatibility
      async signMessage(message) {
        if (!this.provider) {
          throw new Error("missing provider");
        }
        const data = typeof message === "string" ? ethers_1.ethers.utils.toUtf8Bytes(message) : message;
        const address = await this.getAddress();
        return await this.provider.send("personal_sign", [ethers_1.ethers.utils.hexlify(data), address]);
      }
      // signTypedData matches implementation from ethers JsonRpcSigner for compatibility
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      async signTypedData(domain, types, message, chainId) {
        const activeChainId = chainId ? chainId : await this.getChainId();
        const domainChainId = domain.chainId ? ethers_1.BigNumber.from(domain.chainId).toNumber() : void 0;
        if (domainChainId && domainChainId !== activeChainId) {
          throw new Error("Domain chainId is different from active chainId.");
        }
        return await this.provider.send("eth_signTypedData_v4", [
          await this.getAddress(),
          JSON.stringify(ethers_1.ethers.utils._TypedDataEncoder.getPayload(domain, types, message))
        ]);
      }
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      async _signTypedData(domain, types, message, chainId) {
        return this.signTypedData(domain, types, message, chainId);
      }
      connectUnchecked() {
        throw new Error("connectUnchecked is unsupported");
      }
      connect(_provider) {
        if (_provider) {
          return new SmartAccountSigner(_provider);
        }
        throw new Error("unsupported: cannot get JSON-RPC Signer connection");
      }
    };
    exports2.SmartAccountSigner = SmartAccountSigner;
  }
});

// node_modules/@biconomy/smart-account/dist/src/config.js
var require_config2 = __commonJS({
  "node_modules/@biconomy/smart-account/dist/src/config.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DevelopmentConfig = exports2.StagingConfig = exports2.ProductionConfig = void 0;
    var core_types_1 = require_src3();
    exports2.ProductionConfig = {
      activeNetworkId: core_types_1.ChainId.POLYGON_MAINNET,
      supportedNetworksIds: [
        core_types_1.ChainId.GOERLI,
        core_types_1.ChainId.POLYGON_MUMBAI,
        core_types_1.ChainId.POLYGON_MAINNET,
        core_types_1.ChainId.BSC_TESTNET,
        core_types_1.ChainId.MAINNET
      ],
      signType: core_types_1.SignTypeMethod.EIP712_SIGN,
      backendUrl: "https://sdk-backend.prod.biconomy.io/v1",
      relayerUrl: "https://sdk-relayer.prod.biconomy.io/api/v1/relay",
      socketServerUrl: "wss://sdk-ws.prod.biconomy.io/connection/websocket",
      bundlerUrl: "https://sdk-relayer.prod.biconomy.io/api/v1/relay",
      biconomySigningServiceUrl: "https://paymaster-signing-service.prod.biconomy.io/api/v1/sign",
      strictSponsorshipMode: false,
      networkConfig: [
        {
          chainId: core_types_1.ChainId.GOERLI,
          providerUrl: "https://eth-goerli.alchemyapi.io/v2/lmW2og_aq-OXWKYRoRu-X6Yl6wDQYt_2"
        },
        {
          chainId: core_types_1.ChainId.MAINNET,
          providerUrl: "https://eth-mainnet.g.alchemy.com/v2/oIGKtCZoQ2AQUt0sfD46oXB6mv47u9yy"
        },
        {
          chainId: core_types_1.ChainId.POLYGON_MUMBAI,
          providerUrl: "https://polygon-mumbai.g.alchemy.com/v2/Q4WqQVxhEEmBYREX22xfsS2-s5EXWD31"
        },
        {
          chainId: core_types_1.ChainId.BSC_TESTNET,
          providerUrl: "https://data-seed-prebsc-1-s1.binance.org:8545"
        },
        {
          chainId: core_types_1.ChainId.POLYGON_MAINNET,
          providerUrl: "https://polygon-mainnet.g.alchemy.com/v2/6Tn--QDkp1vRBXzRV3Cc8fLXayr5Yoij"
        }
      ]
    };
    exports2.StagingConfig = {
      activeNetworkId: core_types_1.ChainId.POLYGON_MUMBAI,
      supportedNetworksIds: [
        core_types_1.ChainId.GOERLI,
        core_types_1.ChainId.POLYGON_MUMBAI,
        core_types_1.ChainId.BSC_TESTNET,
        core_types_1.ChainId.POLYGON_MAINNET
      ],
      signType: core_types_1.SignTypeMethod.EIP712_SIGN,
      backendUrl: "https://sdk-backend.staging.biconomy.io/v1",
      relayerUrl: "https://sdk-relayer.staging.biconomy.io/api/v1/relay",
      socketServerUrl: "wss://sdk-testing-ws.staging.biconomy.io/connection/websocket",
      bundlerUrl: "https://sdk-relayer.staging.biconomy.io/api/v1/relay",
      biconomySigningServiceUrl: "https://paymaster-signing-service.staging.biconomy.io/api/v1/sign",
      strictSponsorshipMode: false,
      networkConfig: [
        {
          chainId: core_types_1.ChainId.GOERLI,
          providerUrl: "https://eth-goerli.alchemyapi.io/v2/lmW2og_aq-OXWKYRoRu-X6Yl6wDQYt_2"
        },
        {
          chainId: core_types_1.ChainId.POLYGON_MUMBAI,
          providerUrl: "https://polygon-mumbai.g.alchemy.com/v2/Q4WqQVxhEEmBYREX22xfsS2-s5EXWD31"
        },
        {
          chainId: core_types_1.ChainId.BSC_TESTNET,
          providerUrl: "https://data-seed-prebsc-1-s1.binance.org:8545"
        },
        {
          chainId: core_types_1.ChainId.POLYGON_MAINNET,
          providerUrl: "https://polygon-mainnet.g.alchemy.com/v2/6Tn--QDkp1vRBXzRV3Cc8fLXayr5Yoij"
        }
      ]
    };
    exports2.DevelopmentConfig = {
      activeNetworkId: core_types_1.ChainId.POLYGON_MUMBAI,
      supportedNetworksIds: [core_types_1.ChainId.GOERLI, core_types_1.ChainId.POLYGON_MUMBAI, core_types_1.ChainId.BSC_TESTNET],
      signType: core_types_1.SignTypeMethod.EIP712_SIGN,
      backendUrl: "https://sdk-backend.test.biconomy.io/v1",
      relayerUrl: "https://sdk-relayer.test.biconomy.io/api/v1/relay",
      socketServerUrl: "wss://sdk-testing-ws.test.biconomy.io/connection/websocket",
      bundlerUrl: "https://sdk-relayer.test.biconomy.io/api/v1/relay",
      biconomySigningServiceUrl: "https://paymaster-signing-service.test.biconomy.io/api/v1/sign",
      strictSponsorshipMode: false,
      networkConfig: [
        {
          chainId: core_types_1.ChainId.GOERLI,
          providerUrl: "https://eth-goerli.alchemyapi.io/v2/lmW2og_aq-OXWKYRoRu-X6Yl6wDQYt_2"
        },
        {
          chainId: core_types_1.ChainId.POLYGON_MUMBAI,
          providerUrl: "https://polygon-mumbai.g.alchemy.com/v2/Q4WqQVxhEEmBYREX22xfsS2-s5EXWD31"
        },
        {
          chainId: core_types_1.ChainId.BSC_TESTNET,
          providerUrl: "https://data-seed-prebsc-1-s1.binance.org:8545"
        }
      ]
    };
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/BaseAccountAPI.js
var require_BaseAccountAPI = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/BaseAccountAPI.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseAccountAPI = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var ethers_lib_1 = require_src8();
    var utils_1 = require_utils();
    var common_1 = require_src4();
    var BaseAccountAPI = class {
      /**
       * base constructor.
       * subclass SHOULD add parameters that define the owner (signer) of this wallet
       * @param provider - read-only provider for view calls
       * @param entryPointAddress - the entryPoint to send requests through (used to calculate the request-id, and for gas estimations)
       * @param accountAddress. may be empty for new wallet (using factory to determine address)
       */
      constructor(provider, entryPoint, clientConfig, accountAddress, overheads) {
        this.provider = provider;
        this.entryPoint = entryPoint;
        this.clientConfig = clientConfig;
        this.accountAddress = accountAddress;
        this.overheads = overheads;
        this.isDeployed = false;
      }
      // placeholder to replace paymaster
      connectPaymaster(newPaymasterAPI) {
        this.paymasterAPI = newPaymasterAPI;
        return this;
      }
      // based on provider chainId we maintain smartWalletContract..
      async _getSmartAccountContract() {
        if (this.accountContract == null) {
          this.accountContract = ethers_lib_1.SmartWalletFactoryV100.connect(await this.getAccountAddress(), this.provider);
        }
        return this.accountContract;
      }
      async init() {
        await this.getAccountAddress();
        return this;
      }
      /**
       * check if the wallet is already deployed.
       */
      async checkAccountDeployed() {
        if (this.isDeployed) {
          return this.isDeployed;
        }
        const senderAddressCode = await this.provider.getCode(await this.getAccountAddress());
        if (senderAddressCode.length > 2) {
          common_1.Logger.log("Smart account Contract already deployed at", this.senderAddress);
          this.isDeployed = true;
        } else {
        }
        return this.isDeployed;
      }
      /**
       * calculate the wallet address even before it is deployed
       */
      async getCounterFactualAddress() {
        const initCode = await this.getAccountInitCode();
        try {
          await this.entryPoint.callStatic.getSenderAddress(initCode);
        } catch (e) {
          return e.errorArgs.sender;
        }
        throw new Error("must handle revert");
      }
      /**
       * return initCode value to into the UserOp.
       * (either deployment code, or empty hex if contract already deployed)
       */
      async getInitCode() {
        if (!await this.checkAccountDeployed()) {
          return await this.getAccountInitCode();
        }
        return "0x";
      }
      /**
       * ABI-encode a user operation. used for calldata cost estimation
       */
      packUserOp(userOp) {
        return (0, common_1.packUserOp)(userOp, false);
      }
      async encodeUserOpCallDataAndGasLimit(detailsForUserOp) {
        var _a;
        function parseNumber(a) {
          if (a == null || a === "")
            return null;
          return ethers_1.BigNumber.from(a.toString());
        }
        let callData;
        if (detailsForUserOp.target.length == 1) {
          if (detailsForUserOp && detailsForUserOp.target[0] === "" && detailsForUserOp.data[0] === "") {
            return {
              callData: "0x",
              callGasLimit: ethers_1.BigNumber.from("21000")
            };
          }
          const value = (_a = parseNumber(detailsForUserOp.value[0])) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from(0);
          callData = await this.encodeExecuteCall(detailsForUserOp.target[0], value, detailsForUserOp.data[0]);
        } else {
          callData = await this.encodeExecuteBatchCall(detailsForUserOp.target, detailsForUserOp.value, detailsForUserOp.data);
        }
        let callGasLimit = ethers_1.BigNumber.from(0);
        await this.checkAccountDeployed();
        if (!this.isDeployed) {
          callGasLimit = ethers_1.BigNumber.from(6e5);
          return {
            callData,
            callGasLimit
          };
        }
        common_1.Logger.log("detailsForUserOp.gasLimit ", detailsForUserOp.gasLimit);
        if (!detailsForUserOp.gasLimit) {
          const chainId = this.clientConfig.chainId;
          common_1.Logger.log("chainId is ", chainId);
          try {
            callGasLimit = await this.provider.estimateGas({
              from: this.entryPoint.address,
              to: await this.getAccountAddress(),
              data: callData
            });
          } catch (error) {
            common_1.Logger.log("gas estimation failed for chainId ", chainId);
            common_1.Logger.error(" Call Gas Limit Estimation Failed with error", error.toString());
            throw new Error(" Call Gas Limit Estimation Failed ");
          }
        } else {
          callGasLimit = ethers_1.BigNumber.from(detailsForUserOp.gasLimit);
        }
        return {
          callData,
          callGasLimit
        };
      }
      /**
       * return userOpHash for signing.
       * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)
       * @param userOp userOperation, (signature field ignored)
       */
      async getUserOpHash(userOp) {
        const chainId = await this.provider.getNetwork().then((net) => net.chainId);
        const userOpHash = (0, utils_1.keccak256)((0, common_1.packUserOp)(userOp, true));
        const enc = utils_1.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, this.entryPoint.address, chainId]);
        return (0, utils_1.keccak256)(enc);
      }
      /**
       * return the wallet's address.
       * this value is valid even before deploying the wallet.
       */
      async getAccountAddress() {
        if (this.senderAddress == null) {
          if (this.accountAddress != null) {
            this.senderAddress = this.accountAddress;
          } else {
            this.senderAddress = await this.getCounterFactualAddress();
          }
        }
        return this.senderAddress;
      }
      async estimateCreationGas(initCode) {
        if (initCode == null || initCode === "0x")
          return 0;
        const deployerAddress = initCode.substring(0, 42);
        const deployerCallData = "0x" + initCode.substring(42);
        return await this.provider.estimateGas({ to: deployerAddress, data: deployerCallData });
      }
      /**
       * Sign the filled userOp.
       * @param userOp the UserOperation to sign (with signature field ignored)
       */
      // Note: could be moved in Account specific API class
      // for example BiconomySmartAccountAPI could reject if length is not accurate
      async signUserOp(userOp) {
        common_1.Logger.log("signUserOp", userOp);
        const userOpHash = await this.getUserOpHash(userOp);
        let signature = await this.signUserOpHash(userOpHash);
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
          const correctV = potentiallyIncorrectV + 27;
          signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== "0x")
          signature = "0x" + signature;
        common_1.Logger.log("userOp signature: ", signature);
        return {
          ...userOp,
          signature
        };
      }
      /**
       * helper method: create and sign a user operation.
       * @param info transaction details for the userOp
       */
      async createSignedUserOp(info) {
        return await this.signUserOp(await this.createUnsignedUserOp(info));
      }
      /**
       * get the transaction that has this userOpHash mined, or null if not found
       * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)
       * @param timeout stop waiting after this timeout
       * @param interval time to wait between polls.
       * @return the transactionHash this userOp was mined, or null if not found.
       */
      async getUserOpReceipt(userOpHash, timeout = 3e4, interval = 5e3) {
        const endtime = Date.now() + timeout;
        while (Date.now() < endtime) {
          const events = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationEvent(userOpHash));
          if (events.length > 0) {
            return events[0].transactionHash;
          }
          await new Promise((resolve) => setTimeout(resolve, interval));
        }
        return null;
      }
    };
    exports2.BaseAccountAPI = BaseAccountAPI;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/utils/httpRequests.js
var require_httpRequests = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/utils/httpRequests.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sendRequest = exports2.HttpMethod = void 0;
    var node_fetch_1 = __importDefault(require_browser2());
    var HttpMethod;
    (function(HttpMethod2) {
      HttpMethod2["Get"] = "get";
      HttpMethod2["Post"] = "post";
      HttpMethod2["Delete"] = "delete";
    })(HttpMethod = exports2.HttpMethod || (exports2.HttpMethod = {}));
    async function sendRequest({ url, method, body, headers = {} }) {
      const response = await (0, node_fetch_1.default)(url, {
        method,
        headers: {
          ...headers,
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      let jsonResponse;
      try {
        jsonResponse = await response.json();
      } catch (error) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }
      }
      if (response.ok) {
        return jsonResponse;
      }
      if (jsonResponse.error) {
        throw new Error(jsonResponse.error);
      }
      if (jsonResponse.message) {
        throw new Error(jsonResponse.message);
      }
      if (jsonResponse.msg) {
        throw new Error(jsonResponse.msg);
      }
      if (jsonResponse.data) {
        throw new Error(jsonResponse.data);
      }
      if (jsonResponse.detail) {
        throw new Error(jsonResponse.detail);
      }
      if (jsonResponse.message) {
        throw new Error(jsonResponse.message);
      }
      if (jsonResponse.nonFieldErrors) {
        throw new Error(jsonResponse.nonFieldErrors);
      }
      if (jsonResponse.delegate) {
        throw new Error(jsonResponse.delegate);
      }
      throw new Error(response.statusText);
    }
    exports2.sendRequest = sendRequest;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/BiconomyPaymasterAPI.js
var require_BiconomyPaymasterAPI = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/BiconomyPaymasterAPI.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BiconomyPaymasterAPI = void 0;
    var properties_1 = (init_lib4(), __toCommonJS(lib_exports4));
    var httpRequests_1 = require_httpRequests();
    var common_1 = require_src4();
    var BiconomyPaymasterAPI = class {
      constructor(paymasterConfig) {
        this.paymasterConfig = paymasterConfig;
      }
      async getPaymasterAndData(userOp) {
        try {
          userOp = await (0, properties_1.resolveProperties)(userOp);
          userOp.nonce = Number(userOp.nonce);
          userOp.callGasLimit = Number(userOp.callGasLimit);
          userOp.verificationGasLimit = Number(userOp.verificationGasLimit);
          userOp.maxFeePerGas = Number(userOp.maxFeePerGas);
          userOp.maxPriorityFeePerGas = Number(userOp.maxPriorityFeePerGas);
          userOp.preVerificationGas = Number(userOp.preVerificationGas);
          userOp.signature = "0x";
          userOp.paymasterAndData = "0x";
          const result = await (0, httpRequests_1.sendRequest)({
            url: `${this.paymasterConfig.signingServiceUrl}/user-op`,
            method: httpRequests_1.HttpMethod.Post,
            headers: { "x-api-key": this.paymasterConfig.dappAPIKey },
            body: { userOp }
          });
          common_1.Logger.log("verifying and signing service response", result);
          if (result && result.data && result.statusCode === 200) {
            return result.data.paymasterAndData;
          } else {
            if (!this.paymasterConfig.strictSponsorshipMode) {
              return "0x";
            }
            if (result.error) {
              common_1.Logger.log(result.error.toString());
              throw new Error("Error in verifying gas sponsorship. Reason: ".concat(result.error.toString()));
            }
            throw new Error("Error in verifying gas sponsorship. Reason unknown");
          }
        } catch (err) {
          if (!this.paymasterConfig.strictSponsorshipMode) {
            common_1.Logger.log("sending paymasterAndData 0x");
            common_1.Logger.log("Reason ", err.toString());
            return "0x";
          }
          common_1.Logger.error("Error in verifying gas sponsorship.", err.toString());
          throw new Error("Error in verifying gas sponsorship. Reason: ".concat(err.toString()));
        }
      }
    };
    exports2.BiconomyPaymasterAPI = BiconomyPaymasterAPI;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/calcPreVerificationGas.js
var require_calcPreVerificationGas = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/calcPreVerificationGas.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calcPreVerificationGas = exports2.DefaultGasOverheads = void 0;
    var common_1 = require_src4();
    var utils_1 = require_utils();
    exports2.DefaultGasOverheads = {
      fixed: 21e3,
      perUserOp: 18300,
      perUserOpWord: 4,
      zeroByte: 4,
      nonZeroByte: 16,
      bundleSize: 1,
      sigSize: 65
    };
    function calcPreVerificationGas(userOp, overheads) {
      const ov = { ...exports2.DefaultGasOverheads, ...overheads !== null && overheads !== void 0 ? overheads : {} };
      const p = {
        // dummy values, in case the UserOp is incomplete.
        preVerificationGas: 21e3,
        signature: (0, utils_1.hexlify)(Buffer.alloc(ov.sigSize, 1)),
        ...userOp
      };
      const packed = (0, utils_1.arrayify)((0, common_1.packUserOp)(p, false));
      const lengthInWord = (packed.length + 31) / 32;
      const callDataCost = packed.map((x) => x === 0 ? ov.zeroByte : ov.nonZeroByte).reduce((sum, x) => sum + x);
      const ret2 = Math.round(callDataCost + ov.fixed / ov.bundleSize + ov.perUserOp + ov.perUserOpWord * lengthInWord);
      return ret2;
    }
    exports2.calcPreVerificationGas = calcPreVerificationGas;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/SmartAccountAPI.js
var require_SmartAccountAPI = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/SmartAccountAPI.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartAccountAPI = exports2.DefaultGasLimits = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var utils_1 = require_utils();
    var BaseAccountAPI_1 = require_BaseAccountAPI();
    var BiconomyPaymasterAPI_1 = require_BiconomyPaymasterAPI();
    var utils_2 = require_utils();
    var calcPreVerificationGas_1 = require_calcPreVerificationGas();
    var common_1 = require_src4();
    exports2.DefaultGasLimits = {
      validateUserOpGas: 71943,
      validatePaymasterUserOpGas: 25101,
      postOpGas: 10877
    };
    var SmartAccountAPI = class extends BaseAccountAPI_1.BaseAccountAPI {
      /**
       * base constructor.
       * subclass SHOULD add parameters that define the owner (signer) of this wallet
       * @param provider - read-only provider for view calls
       * @param entryPointAddress - the entryPoint to send requests through (used to calculate the request-id, and for gas estimations)
       * @param walletAddress optional wallet address, if connecting to an existing contract.
       * @param owner the signer object for the wallet owner
       * @param factoryAddress address of contract "factory" to deploy new contracts
       * @param index nonce value used when creating multiple wallets for the same owner
       */
      constructor(provider, entryPoint, clientConfig, accountAddress, implementationAddress, owner, handlerAddress, factoryAddress, index = 0, overheads) {
        super(provider, entryPoint, clientConfig, accountAddress, overheads);
        this.entryPoint = entryPoint;
        this.clientConfig = clientConfig;
        this.implementationAddress = implementationAddress;
        this.owner = owner;
        this.handlerAddress = handlerAddress;
        this.factoryAddress = factoryAddress;
        this.index = index;
        if (!clientConfig.dappAPIKey || clientConfig.dappAPIKey === "") {
          this.paymasterAPI = void 0;
        } else if (clientConfig.customPaymasterAPI) {
          this.paymasterAPI = clientConfig.customPaymasterAPI;
        } else {
          this.paymasterAPI = new BiconomyPaymasterAPI_1.BiconomyPaymasterAPI({
            signingServiceUrl: clientConfig.biconomySigningServiceUrl,
            dappAPIKey: clientConfig.dappAPIKey,
            strictSponsorshipMode: clientConfig.strictSponsorshipMode ? clientConfig.strictSponsorshipMode : false
          });
        }
      }
      /**
       * return the value to put into the "initCode" field, if the wallet is not yet deployed.
       * this value holds the "factory" address, followed by this wallet's information
       */
      async getAccountInitCode() {
        const deployWalletCallData = await (0, common_1.deployCounterFactualEncodedData)({
          chainId: (await this.provider.getNetwork()).chainId,
          owner: await this.owner.getAddress(),
          txServiceUrl: this.clientConfig.txServiceUrl,
          index: this.index
        });
        return (0, utils_1.hexConcat)([this.factoryAddress, deployWalletCallData]);
      }
      async nonce() {
        common_1.Logger.log("checking nonce");
        if (!await this.checkAccountDeployed()) {
          return ethers_1.BigNumber.from(0);
        }
        const walletContract = await this._getSmartAccountContract();
        const nonce = await walletContract.nonce();
        return nonce;
      }
      /**
       * should cover cost of putting calldata on-chain, and some overhead.
       * actual overhead depends on the expected bundle size
       */
      async getPreVerificationGas(userOp) {
        const p = await (0, utils_2.resolveProperties)(userOp);
        return (0, calcPreVerificationGas_1.calcPreVerificationGas)(p, this.overheads);
      }
      /**
       * return maximum gas used for verification.
       * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.
       */
      async getVerificationGasLimit() {
        const initCode = await this.getInitCode();
        const initGas = await this.estimateCreationGas(initCode);
        console.log("initgas estimated is ", initGas);
        let verificationGasLimit = initGas;
        const validateUserOpGas = exports2.DefaultGasLimits.validatePaymasterUserOpGas + exports2.DefaultGasLimits.validateUserOpGas;
        const postOpGas = exports2.DefaultGasLimits.postOpGas;
        verificationGasLimit = ethers_1.BigNumber.from(validateUserOpGas).add(initGas);
        if (ethers_1.BigNumber.from(postOpGas).gt(verificationGasLimit)) {
          verificationGasLimit = postOpGas;
        }
        return verificationGasLimit;
      }
      async encodeExecuteCall(target, value, data) {
        const walletContract = await this._getSmartAccountContract();
        return walletContract.interface.encodeFunctionData("executeCall", [target, value, data]);
      }
      async encodeExecuteBatchCall(target, value, data) {
        const walletContract = await this._getSmartAccountContract();
        const encodeData = walletContract.interface.encodeFunctionData("executeBatchCall", [
          target,
          value,
          data
        ]);
        common_1.Logger.log("encodeData ", encodeData);
        return encodeData;
      }
      /**
       * create a UserOperation, filling all details (except signature)
       * - if wallet is not yet created, add initCode to deploy it.
       * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the wallet is created)
       * @param info
       */
      async createUnsignedUserOp(info) {
        var _a, _b, _c, _d, _e, _f;
        const { callData, callGasLimit } = await this.encodeUserOpCallDataAndGasLimit(info);
        console.log(callData, callGasLimit);
        const initCode = await this.getInitCode();
        const verificationGasLimit = ethers_1.BigNumber.from(await this.getVerificationGasLimit());
        let { maxFeePerGas, maxPriorityFeePerGas } = info;
        if (maxFeePerGas == null || maxPriorityFeePerGas == null) {
          const feeData = await this.provider.getFeeData();
          common_1.Logger.log("EIP1559 feeData", feeData);
          const chainId = this.clientConfig.chainId;
          common_1.Logger.log("chainId is", chainId);
          if (common_1.EIP1559_UNSUPPORTED_NETWORKS.includes(chainId)) {
            maxFeePerGas = (_b = (_a = feeData.gasPrice) !== null && _a !== void 0 ? _a : await this.provider.getGasPrice()) !== null && _b !== void 0 ? _b : void 0;
            maxPriorityFeePerGas = (_d = (_c = feeData.gasPrice) !== null && _c !== void 0 ? _c : await this.provider.getGasPrice()) !== null && _d !== void 0 ? _d : void 0;
          }
          if (maxFeePerGas == null) {
            maxFeePerGas = (_e = feeData.maxFeePerGas) !== null && _e !== void 0 ? _e : void 0;
          }
          if (maxPriorityFeePerGas == null) {
            maxPriorityFeePerGas = (_f = feeData.maxPriorityFeePerGas) !== null && _f !== void 0 ? _f : void 0;
          }
        }
        if (!maxFeePerGas || !maxPriorityFeePerGas) {
          throw new Error("maxFeePerGas or maxPriorityFeePerGas values cannot be null");
        }
        common_1.Logger.log("fees being used: maxFeePerGas ", maxFeePerGas);
        common_1.Logger.log("fees being used: maxPriorityFeePerGas ", maxPriorityFeePerGas);
        const partialUserOp = {
          sender: await this.getAccountAddress(),
          nonce: await this.nonce(),
          initCode,
          callData,
          callGasLimit,
          verificationGasLimit,
          maxFeePerGas,
          maxPriorityFeePerGas
        };
        partialUserOp.paymasterAndData = "0x";
        const preVerificationGas = await this.getPreVerificationGas(partialUserOp);
        partialUserOp.preVerificationGas = preVerificationGas;
        partialUserOp.paymasterAndData = !this.paymasterAPI ? "0x" : await this.paymasterAPI.getPaymasterAndData(partialUserOp);
        return {
          ...partialUserOp,
          signature: ""
        };
      }
      async signUserOpHash(userOpHash) {
        return await this.owner.signMessage((0, utils_1.arrayify)(userOpHash));
      }
    };
    exports2.SmartAccountAPI = SmartAccountAPI;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/FallbackGasTankAPI.js
var require_FallbackGasTankAPI = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/FallbackGasTankAPI.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FallbackGasTankAPI = void 0;
    var properties_1 = (init_lib4(), __toCommonJS(lib_exports4));
    var httpRequests_1 = require_httpRequests();
    var common_1 = require_src4();
    var FallbackGasTankAPI = class {
      constructor(signingServiceUrl, dappAPIKey) {
        this.signingServiceUrl = signingServiceUrl;
        this.dappAPIKey = dappAPIKey;
        this.signingServiceUrl = signingServiceUrl;
        this.dappAPIKey = dappAPIKey;
      }
      async getDappIdentifierAndSign(fallbackUserOp) {
        try {
          if (!this.dappAPIKey || this.dappAPIKey === "") {
            throw new Error("Dapp API Key not found. Please pass dappAPIKey in constructor");
          }
          fallbackUserOp = await (0, properties_1.resolveProperties)(fallbackUserOp);
          fallbackUserOp.sender = fallbackUserOp.sender;
          fallbackUserOp.target = fallbackUserOp.target;
          fallbackUserOp.nonce = Number(fallbackUserOp.nonce);
          fallbackUserOp.callData = fallbackUserOp.callData;
          fallbackUserOp.callGasLimit = fallbackUserOp.callGasLimit;
          fallbackUserOp.dappIdentifier = "";
          fallbackUserOp.signature = "0x";
          const result = await (0, httpRequests_1.sendRequest)({
            url: `${this.signingServiceUrl}/fallback-user-op`,
            method: httpRequests_1.HttpMethod.Post,
            headers: { "x-api-key": this.dappAPIKey },
            body: { fallbackUserOp }
          });
          if (result && result.data && result.statusCode === 200) {
            return result.data;
          } else {
            console.error(result.error);
            throw new Error("Error in fallback signing api");
          }
        } catch (err) {
          common_1.Logger.error("Error in fallback signing api", err);
          throw new Error("Error in fallback signing api");
        }
      }
    };
    exports2.FallbackGasTankAPI = FallbackGasTankAPI;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/BaseAccount__factory.js
var require_BaseAccount_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/BaseAccount__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.BaseAccount__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "missingAccountFunds",
            type: "uint256"
          }
        ],
        name: "validateUserOp",
        outputs: [
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var BaseAccount__factory = (
      /** @class */
      function() {
        function BaseAccount__factory2() {
        }
        BaseAccount__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        BaseAccount__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        BaseAccount__factory2.abi = _abi;
        return BaseAccount__factory2;
      }()
    );
    exports2.BaseAccount__factory = BaseAccount__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/BasePaymaster__factory.js
var require_BasePaymaster_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/BasePaymaster__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.BasePaymaster__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "deposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IPaymaster.PostOpMode",
            name: "mode",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          }
        ],
        name: "postOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "maxCost",
            type: "uint256"
          }
        ],
        name: "validatePaymasterUserOp",
        outputs: [
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var BasePaymaster__factory = (
      /** @class */
      function() {
        function BasePaymaster__factory2() {
        }
        BasePaymaster__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        BasePaymaster__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        BasePaymaster__factory2.abi = _abi;
        return BasePaymaster__factory2;
      }()
    );
    exports2.BasePaymaster__factory = BasePaymaster__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/BrokenBLSAccount__factory.js
var require_BrokenBLSAccount_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/BrokenBLSAccount__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.BrokenBLSAccount__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "anEntryPoint",
            type: "address"
          },
          {
            internalType: "address",
            name: "anAggregator",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "previousAdmin",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "newAdmin",
            type: "address"
          }
        ],
        name: "AdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "beacon",
            type: "address"
          }
        ],
        name: "BeaconUpgraded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256[4]",
            name: "oldPublicKey",
            type: "uint256[4]"
          },
          {
            indexed: false,
            internalType: "uint256[4]",
            name: "newPublicKey",
            type: "uint256[4]"
          }
        ],
        name: "PublicKeyChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "contract IEntryPoint",
            name: "entryPoint",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "SimpleAccountInitialized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        name: "Upgraded",
        type: "event"
      },
      {
        inputs: [],
        name: "addDeposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "aggregator",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "dest",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "func",
            type: "bytes"
          }
        ],
        name: "execute",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "dest",
            type: "address[]"
          },
          {
            internalType: "bytes[]",
            name: "func",
            type: "bytes[]"
          }
        ],
        name: "executeBatch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getBlsPublicKey",
        outputs: [
          {
            internalType: "uint256[4]",
            name: "",
            type: "uint256[4]"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "getDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "anOwner",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256[4]",
            name: "aPublicKey",
            type: "uint256[4]"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "proxiableUUID",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newImplementation",
            type: "address"
          }
        ],
        name: "upgradeTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newImplementation",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "upgradeToAndCall",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "missingAccountFunds",
            type: "uint256"
          }
        ],
        name: "validateUserOp",
        outputs: [
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawDepositTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var _bytecode = "0x60e0604052306080523480156200001557600080fd5b50604051620025443803806200254483398101604081905262000038916200013f565b6001600160a01b03821660a052816200005062000064565b506001600160a01b031660c052506200017e565b600054610100900460ff1615620000d15760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff908116101562000124576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b6001600160a01b03811681146200013c57600080fd5b50565b600080604083850312156200015357600080fd5b8251620001608162000126565b6020840151909250620001738162000126565b809150509250929050565b60805160a05160c051612342620002026000396000818161027d015261093c0152600081816103a40152818161097f01528181610a2601528181610e4a0152818161109b01528181611225015281816115770152611750015260008181610722015281816107d201528181610aea01528181610b9a0152610ce301526123426000f3fe60806040526004361061016d5760003560e01c806352d1902d116100cb578063c399ec881161007f578063e02afbae11610059578063e02afbae1461047a578063ee472f361461049c578063f23a6e61146104bc57600080fd5b8063c399ec8814610430578063c4d66de814610445578063d087d2881461046557600080fd5b8063b0d691fe116100b0578063b0d691fe14610395578063b61d27f6146103c8578063bc197c81146103e857600080fd5b806352d1902d1461034d5780638da5cb5b1461036257600080fd5b80633659cfe6116101225780634a58db19116101075780634a58db19146103125780634d44560d1461031a5780634f1ef2861461033a57600080fd5b80633659cfe6146102c45780633a871cdd146102e457600080fd5b8063150b7a0211610153578063150b7a02146101d557806318dfb3c71461024b578063245a7bfc1461026b57600080fd5b806223de291461017957806301ffc9a7146101a057600080fd5b3661017457005b600080fd5b34801561018557600080fd5b5061019e610194366004611b2f565b5050505050505050565b005b3480156101ac57600080fd5b506101c06101bb366004611be0565b610502565b60405190151581526020015b60405180910390f35b3480156101e157600080fd5b5061021a6101f0366004611c22565b7f150b7a020000000000000000000000000000000000000000000000000000000095945050505050565b6040517fffffffff0000000000000000000000000000000000000000000000000000000090911681526020016101cc565b34801561025757600080fd5b5061019e610266366004611cda565b6105e7565b34801561027757600080fd5b5061029f7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101cc565b3480156102d057600080fd5b5061019e6102df366004611d46565b61070b565b3480156102f057600080fd5b506103046102ff366004611d63565b610910565b6040519081526020016101cc565b61019e61097d565b34801561032657600080fd5b5061019e610335366004611db7565b610a1c565b61019e610348366004611e61565b610ad3565b34801561035957600080fd5b50610304610cc9565b34801561036e57600080fd5b5060005461029f9062010000900473ffffffffffffffffffffffffffffffffffffffff1681565b3480156103a157600080fd5b507f000000000000000000000000000000000000000000000000000000000000000061029f565b3480156103d457600080fd5b5061019e6103e3366004611f27565b610db5565b3480156103f457600080fd5b5061021a610403366004611f77565b7fbc197c810000000000000000000000000000000000000000000000000000000098975050505050505050565b34801561043c57600080fd5b50610304610e04565b34801561045157600080fd5b5061019e610460366004611d46565b610ebb565b34801561047157600080fd5b5061030461104e565b34801561048657600080fd5b5061048f6110ca565b6040516101cc9190612015565b3480156104a857600080fd5b5061019e6104b7366004612046565b6110df565b3480156104c857600080fd5b5061021a6104d73660046120c4565b7ff23a6e61000000000000000000000000000000000000000000000000000000009695505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f150b7a0200000000000000000000000000000000000000000000000000000000148061059557507fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e000000000000000000000000000000000000000000000000000000000145b806105e157507fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a700000000000000000000000000000000000000000000000000000000145b92915050565b6105ef61120d565b82811461065d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f77726f6e67206172726179206c656e677468730000000000000000000000000060448201526064015b60405180910390fd5b60005b83811015610704576106f285858381811061067d5761067d612140565b90506020020160208101906106929190611d46565b60008585858181106106a6576106a6612140565b90506020028101906106b8919061216f565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506112d692505050565b806106fc816121d4565b915050610660565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036107d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610654565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166108457f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff16146108e8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f787900000000000000000000000000000000000000006064820152608401610654565b6108f181611353565b6040805160008082526020820190925261090d9183919061135b565b50565b600061091a61155f565b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168082526000602083018190529190920152610976826115fe565b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006040517fb760faf900000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff919091169063b760faf99034906024016000604051808303818588803b158015610a0857600080fd5b505af1158015610704573d6000803e3d6000fd5b610a24611669565b7f00000000000000000000000000000000000000000000000000000000000000006040517f205c287800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff848116600483015260248201849052919091169063205c287890604401600060405180830381600087803b158015610ab757600080fd5b505af1158015610acb573d6000803e3d6000fd5b505050505050565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610b98576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610654565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16610c0d7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1614610cb0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f787900000000000000000000000000000000000000006064820152608401610654565b610cb982611353565b610cc58282600161135b565b5050565b60003073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610d90576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c00000000000000006064820152608401610654565b507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc90565b610dbd61120d565b610dfe848484848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506112d692505050565b50505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906370a08231906024015b602060405180830381865afa158015610e92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb69190612233565b905090565b600054610100900460ff1615808015610edb5750600054600160ff909116105b80610ef55750303b158015610ef5575060005460ff166001145b610f81576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610654565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558015610fdf57600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b610fe8826116fa565b8015610cc557600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b6040517f35567e1a0000000000000000000000000000000000000000000000000000000081523060048201526000602482018190529073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906335567e1a90604401610e75565b6110d2611aa6565b6110da611aa6565b919050565b600054610100900460ff16158080156110ff5750600054600160ff909116105b806111195750303b158015611119575060005460ff166001145b6111a5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610654565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055801561120357600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b610fe860006116fa565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016148061126e575060005462010000900473ffffffffffffffffffffffffffffffffffffffff1633145b6112d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f6163636f756e743a206e6f74204f776e6572206f7220456e747279506f696e746044820152606401610654565b565b6000808473ffffffffffffffffffffffffffffffffffffffff1684846040516112ff9190612278565b60006040518083038185875af1925050503d806000811461133c576040519150601f19603f3d011682016040523d82523d6000602084013e611341565b606091505b50915091508161070457805160208201fd5b61090d611669565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff16156113935761138e83611799565b505050565b8273ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611418575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261141591810190612233565b60015b6114a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201527f6f6e206973206e6f7420555550530000000000000000000000000000000000006064820152608401610654565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8114611553576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f7860448201527f6961626c655555494400000000000000000000000000000000000000000000006064820152608401610654565b5061138e8383836118a3565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146112d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6163636f756e743a206e6f742066726f6d20456e747279506f696e74000000006044820152606401610654565b801561090d5760405160009033907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90849084818181858888f193505050503d8060008114610704576040519150601f19603f3d011682016040523d82523d6000602084013e610704565b60005462010000900473ffffffffffffffffffffffffffffffffffffffff1633148061169457503330145b6112d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c79206f776e6572000000000000000000000000000000000000000000006044820152606401610654565b600080547fffffffffffffffffffff0000000000000000000000000000000000000000ffff166201000073ffffffffffffffffffffffffffffffffffffffff8481168202929092178084556040519190048216927f0000000000000000000000000000000000000000000000000000000000000000909216917f47e55c76e7a6f1fd8996a1da8008c1ea29699cca35e7bcd057f2dec313b6e5de91a350565b73ffffffffffffffffffffffffffffffffffffffff81163b61183d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152608401610654565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b6118ac836118c8565b6000825111806118b95750805b1561138e57610dfe8383611915565b6118d181611799565b60405173ffffffffffffffffffffffffffffffffffffffff8216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b606061097683836040518060600160405280602781526020016122e66027913960606000808573ffffffffffffffffffffffffffffffffffffffff168560405161195f9190612278565b600060405180830381855af49150503d806000811461199a576040519150601f19603f3d011682016040523d82523d6000602084013e61199f565b606091505b50915091506119b0868383876119ba565b9695505050505050565b60608315611a50578251600003611a495773ffffffffffffffffffffffffffffffffffffffff85163b611a49576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610654565b5081611a5a565b611a5a8383611a62565b949350505050565b815115611a725781518083602001fd5b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106549190612294565b60405180608001604052806004906020820280368337509192915050565b73ffffffffffffffffffffffffffffffffffffffff8116811461090d57600080fd5b60008083601f840112611af857600080fd5b50813567ffffffffffffffff811115611b1057600080fd5b602083019150836020828501011115611b2857600080fd5b9250929050565b60008060008060008060008060c0898b031215611b4b57600080fd5b8835611b5681611ac4565b97506020890135611b6681611ac4565b96506040890135611b7681611ac4565b955060608901359450608089013567ffffffffffffffff80821115611b9a57600080fd5b611ba68c838d01611ae6565b909650945060a08b0135915080821115611bbf57600080fd5b50611bcc8b828c01611ae6565b999c989b5096995094979396929594505050565b600060208284031215611bf257600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461097657600080fd5b600080600080600060808688031215611c3a57600080fd5b8535611c4581611ac4565b94506020860135611c5581611ac4565b935060408601359250606086013567ffffffffffffffff811115611c7857600080fd5b611c8488828901611ae6565b969995985093965092949392505050565b60008083601f840112611ca757600080fd5b50813567ffffffffffffffff811115611cbf57600080fd5b6020830191508360208260051b8501011115611b2857600080fd5b60008060008060408587031215611cf057600080fd5b843567ffffffffffffffff80821115611d0857600080fd5b611d1488838901611c95565b90965094506020870135915080821115611d2d57600080fd5b50611d3a87828801611c95565b95989497509550505050565b600060208284031215611d5857600080fd5b813561097681611ac4565b600080600060608486031215611d7857600080fd5b833567ffffffffffffffff811115611d8f57600080fd5b84016101608187031215611da257600080fd5b95602085013595506040909401359392505050565b60008060408385031215611dca57600080fd5b8235611dd581611ac4565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611e5957611e59611de3565b604052919050565b60008060408385031215611e7457600080fd5b8235611e7f81611ac4565b915060208381013567ffffffffffffffff80821115611e9d57600080fd5b818601915086601f830112611eb157600080fd5b813581811115611ec357611ec3611de3565b611ef3847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611e12565b91508082528784828501011115611f0957600080fd5b80848401858401376000848284010152508093505050509250929050565b60008060008060608587031215611f3d57600080fd5b8435611f4881611ac4565b935060208501359250604085013567ffffffffffffffff811115611f6b57600080fd5b611d3a87828801611ae6565b60008060008060008060008060a0898b031215611f9357600080fd5b8835611f9e81611ac4565b97506020890135611fae81611ac4565b9650604089013567ffffffffffffffff80821115611fcb57600080fd5b611fd78c838d01611c95565b909850965060608b0135915080821115611ff057600080fd5b611ffc8c838d01611c95565b909650945060808b0135915080821115611bbf57600080fd5b60808101818360005b600481101561203d57815183526020928301929091019060010161201e565b50505092915050565b60006080828403121561205857600080fd5b82601f83011261206757600080fd5b6040516080810181811067ffffffffffffffff8211171561208a5761208a611de3565b60405280608084018581111561209f57600080fd5b845b818110156120b95780358352602092830192016120a1565b509195945050505050565b60008060008060008060a087890312156120dd57600080fd5b86356120e881611ac4565b955060208701356120f881611ac4565b94506040870135935060608701359250608087013567ffffffffffffffff81111561212257600080fd5b61212e89828a01611ae6565b979a9699509497509295939492505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126121a457600080fd5b83018035915067ffffffffffffffff8211156121bf57600080fd5b602001915036819003821315611b2857600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361222c577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b60006020828403121561224557600080fd5b5051919050565b60005b8381101561226757818101518382015260200161224f565b83811115610dfe5750506000910152565b6000825161228a81846020870161224c565b9190910192915050565b60208152600082518060208401526122b381604085016020870161224c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212201a293015a642c45bbac015e9c06168162e317c3fdc29a9fc336b746bdf2169a364736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var BrokenBLSAccount__factory = (
      /** @class */
      function(_super) {
        __extends(BrokenBLSAccount__factory2, _super);
        function BrokenBLSAccount__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        BrokenBLSAccount__factory2.prototype.deploy = function(anEntryPoint, anAggregator, overrides) {
          return _super.prototype.deploy.call(this, anEntryPoint, anAggregator, overrides || {});
        };
        BrokenBLSAccount__factory2.prototype.getDeployTransaction = function(anEntryPoint, anAggregator, overrides) {
          return _super.prototype.getDeployTransaction.call(this, anEntryPoint, anAggregator, overrides || {});
        };
        BrokenBLSAccount__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        BrokenBLSAccount__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        BrokenBLSAccount__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        BrokenBLSAccount__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        BrokenBLSAccount__factory2.bytecode = _bytecode;
        BrokenBLSAccount__factory2.abi = _abi;
        return BrokenBLSAccount__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.BrokenBLSAccount__factory = BrokenBLSAccount__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/BrokenBLSAccountFactory__factory.js
var require_BrokenBLSAccountFactory_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/BrokenBLSAccountFactory__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.BrokenBLSAccountFactory__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "entryPoint",
            type: "address"
          },
          {
            internalType: "address",
            name: "aggregator",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "accountImplementation",
        outputs: [
          {
            internalType: "contract BrokenBLSAccount",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "salt",
            type: "uint256"
          },
          {
            internalType: "uint256[4]",
            name: "aPublicKey",
            type: "uint256[4]"
          }
        ],
        name: "createAccount",
        outputs: [
          {
            internalType: "contract BrokenBLSAccount",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "salt",
            type: "uint256"
          },
          {
            internalType: "uint256[4]",
            name: "aPublicKey",
            type: "uint256[4]"
          }
        ],
        name: "getAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var _bytecode = "0x60a060405234801561001057600080fd5b5060405161335c38038061335c83398101604081905261002f916100aa565b818160405161003d90610085565b6001600160a01b03928316815291166020820152604001604051809103906000f080158015610070573d6000803e3d6000fd5b506001600160a01b0316608052506100e49050565b61254480610e1883390190565b6001600160a01b03811681146100a757600080fd5b50565b600080604083850312156100bd57600080fd5b82516100c881610092565b60208401519092506100d981610092565b809150509250929050565b608051610d0d61010b60003960008181604b0152818160f7015261020d0152610d0d6000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806311464fbe1461004657806319c2a1b214610096578063de3398dd146100a9575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61006d6100a436600461038e565b6100bc565b61006d6100b736600461038e565b6101de565b6000806100c984846101de565b905073ffffffffffffffffffffffffffffffffffffffff81163b80156100f1575090506101d8565b8460001b7f0000000000000000000000000000000000000000000000000000000000000000856040516024016101279190610418565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fee472f3600000000000000000000000000000000000000000000000000000000179052516101a790610352565b6101b2929190610479565b8190604051809103906000f59050801580156101d2573d6000803e3d6000fd5b50925050505b92915050565b60006103198360001b604051806020016101f790610352565b6020820181038252601f19601f820116604052507f00000000000000000000000000000000000000000000000000000000000000008560405160240161023d9190610418565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fee472f360000000000000000000000000000000000000000000000000000000017905290516102c293929101610479565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526102fe92916020016104e7565b60405160208183030381529060405280519060200120610320565b9392505050565b60006103198383306000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b6107c18061051783390190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060a083850312156103a157600080fd5b82359150602084603f8501126103b657600080fd5b6040516080810181811067ffffffffffffffff821117156103d9576103d961035f565b6040528060a08601878111156103ee57600080fd5b8387015b8181101561040957803583529184019184016103f2565b50505080925050509250929050565b60808101818360005b6004811015610440578151835260209283019290910190600101610421565b50505092915050565b60005b8381101561046457818101518382015260200161044c565b83811115610473576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff8316815260406020820152600082518060408401526104b4816060850160208701610449565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b600083516104f9818460208801610449565b83519083019061050d818360208801610449565b0194935050505056fe60806040526040516107c13803806107c183398101604081905261002291610321565b61002e82826000610035565b505061043e565b61003e8361006b565b60008251118061004b5750805b156100665761006483836100ab60201b6100291760201c565b505b505050565b610074816100d7565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606100d0838360405180606001604052806027815260200161079a602791396101a9565b9392505050565b6100ea8161022260201b6100551760201c565b6101515760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084015b60405180910390fd5b806101887f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61023160201b6100711760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6060600080856001600160a01b0316856040516101c691906103ef565b600060405180830381855af49150503d8060008114610201576040519150601f19603f3d011682016040523d82523d6000602084013e610206565b606091505b50909250905061021886838387610234565b9695505050505050565b6001600160a01b03163b151590565b90565b606083156102a357825160000361029c576001600160a01b0385163b61029c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610148565b50816102ad565b6102ad83836102b5565b949350505050565b8151156102c55781518083602001fd5b8060405162461bcd60e51b8152600401610148919061040b565b634e487b7160e01b600052604160045260246000fd5b60005b838110156103105781810151838201526020016102f8565b838111156100645750506000910152565b6000806040838503121561033457600080fd5b82516001600160a01b038116811461034b57600080fd5b60208401519092506001600160401b038082111561036857600080fd5b818501915085601f83011261037c57600080fd5b81518181111561038e5761038e6102df565b604051601f8201601f19908116603f011681019083821181831017156103b6576103b66102df565b816040528281528860208487010111156103cf57600080fd5b6103e08360208301602088016102f5565b80955050505050509250929050565b600082516104018184602087016102f5565b9190910192915050565b602081526000825180602084015261042a8160408501602087016102f5565b601f01601f19169190910160400192915050565b61034d8061044d6000396000f3fe60806040523661001357610011610017565b005b6100115b610027610022610074565b6100b9565b565b606061004e83836040518060600160405280602781526020016102f1602791396100dd565b9392505050565b73ffffffffffffffffffffffffffffffffffffffff163b151590565b90565b60006100b47f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b905090565b3660008037600080366000845af43d6000803e8080156100d8573d6000f35b3d6000fd5b60606000808573ffffffffffffffffffffffffffffffffffffffff16856040516101079190610283565b600060405180830381855af49150503d8060008114610142576040519150601f19603f3d011682016040523d82523d6000602084013e610147565b606091505b509150915061015886838387610162565b9695505050505050565b606083156101fd5782516000036101f65773ffffffffffffffffffffffffffffffffffffffff85163b6101f6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b5081610207565b610207838361020f565b949350505050565b81511561021f5781518083602001fd5b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101ed919061029f565b60005b8381101561026e578181015183820152602001610256565b8381111561027d576000848401525b50505050565b60008251610295818460208701610253565b9190910192915050565b60208152600082518060208401526102be816040850160208701610253565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212201cd78ab6a31213989661cff2d7d05fc9b9c38b1a848e8249e2e398659a9eb7e364736f6c634300080f0033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220a86e6be53640933088be7e21e85c3fe3b4f63138c592ce7d2cb1ead6278bd5d664736f6c634300080f003360e0604052306080523480156200001557600080fd5b50604051620025443803806200254483398101604081905262000038916200013f565b6001600160a01b03821660a052816200005062000064565b506001600160a01b031660c052506200017e565b600054610100900460ff1615620000d15760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff908116101562000124576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b6001600160a01b03811681146200013c57600080fd5b50565b600080604083850312156200015357600080fd5b8251620001608162000126565b6020840151909250620001738162000126565b809150509250929050565b60805160a05160c051612342620002026000396000818161027d015261093c0152600081816103a40152818161097f01528181610a2601528181610e4a0152818161109b01528181611225015281816115770152611750015260008181610722015281816107d201528181610aea01528181610b9a0152610ce301526123426000f3fe60806040526004361061016d5760003560e01c806352d1902d116100cb578063c399ec881161007f578063e02afbae11610059578063e02afbae1461047a578063ee472f361461049c578063f23a6e61146104bc57600080fd5b8063c399ec8814610430578063c4d66de814610445578063d087d2881461046557600080fd5b8063b0d691fe116100b0578063b0d691fe14610395578063b61d27f6146103c8578063bc197c81146103e857600080fd5b806352d1902d1461034d5780638da5cb5b1461036257600080fd5b80633659cfe6116101225780634a58db19116101075780634a58db19146103125780634d44560d1461031a5780634f1ef2861461033a57600080fd5b80633659cfe6146102c45780633a871cdd146102e457600080fd5b8063150b7a0211610153578063150b7a02146101d557806318dfb3c71461024b578063245a7bfc1461026b57600080fd5b806223de291461017957806301ffc9a7146101a057600080fd5b3661017457005b600080fd5b34801561018557600080fd5b5061019e610194366004611b2f565b5050505050505050565b005b3480156101ac57600080fd5b506101c06101bb366004611be0565b610502565b60405190151581526020015b60405180910390f35b3480156101e157600080fd5b5061021a6101f0366004611c22565b7f150b7a020000000000000000000000000000000000000000000000000000000095945050505050565b6040517fffffffff0000000000000000000000000000000000000000000000000000000090911681526020016101cc565b34801561025757600080fd5b5061019e610266366004611cda565b6105e7565b34801561027757600080fd5b5061029f7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101cc565b3480156102d057600080fd5b5061019e6102df366004611d46565b61070b565b3480156102f057600080fd5b506103046102ff366004611d63565b610910565b6040519081526020016101cc565b61019e61097d565b34801561032657600080fd5b5061019e610335366004611db7565b610a1c565b61019e610348366004611e61565b610ad3565b34801561035957600080fd5b50610304610cc9565b34801561036e57600080fd5b5060005461029f9062010000900473ffffffffffffffffffffffffffffffffffffffff1681565b3480156103a157600080fd5b507f000000000000000000000000000000000000000000000000000000000000000061029f565b3480156103d457600080fd5b5061019e6103e3366004611f27565b610db5565b3480156103f457600080fd5b5061021a610403366004611f77565b7fbc197c810000000000000000000000000000000000000000000000000000000098975050505050505050565b34801561043c57600080fd5b50610304610e04565b34801561045157600080fd5b5061019e610460366004611d46565b610ebb565b34801561047157600080fd5b5061030461104e565b34801561048657600080fd5b5061048f6110ca565b6040516101cc9190612015565b3480156104a857600080fd5b5061019e6104b7366004612046565b6110df565b3480156104c857600080fd5b5061021a6104d73660046120c4565b7ff23a6e61000000000000000000000000000000000000000000000000000000009695505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f150b7a0200000000000000000000000000000000000000000000000000000000148061059557507fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e000000000000000000000000000000000000000000000000000000000145b806105e157507fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a700000000000000000000000000000000000000000000000000000000145b92915050565b6105ef61120d565b82811461065d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f77726f6e67206172726179206c656e677468730000000000000000000000000060448201526064015b60405180910390fd5b60005b83811015610704576106f285858381811061067d5761067d612140565b90506020020160208101906106929190611d46565b60008585858181106106a6576106a6612140565b90506020028101906106b8919061216f565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506112d692505050565b806106fc816121d4565b915050610660565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036107d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610654565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166108457f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff16146108e8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f787900000000000000000000000000000000000000006064820152608401610654565b6108f181611353565b6040805160008082526020820190925261090d9183919061135b565b50565b600061091a61155f565b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168082526000602083018190529190920152610976826115fe565b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006040517fb760faf900000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff919091169063b760faf99034906024016000604051808303818588803b158015610a0857600080fd5b505af1158015610704573d6000803e3d6000fd5b610a24611669565b7f00000000000000000000000000000000000000000000000000000000000000006040517f205c287800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff848116600483015260248201849052919091169063205c287890604401600060405180830381600087803b158015610ab757600080fd5b505af1158015610acb573d6000803e3d6000fd5b505050505050565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610b98576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610654565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16610c0d7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1614610cb0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f787900000000000000000000000000000000000000006064820152608401610654565b610cb982611353565b610cc58282600161135b565b5050565b60003073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610d90576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c00000000000000006064820152608401610654565b507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc90565b610dbd61120d565b610dfe848484848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506112d692505050565b50505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906370a08231906024015b602060405180830381865afa158015610e92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb69190612233565b905090565b600054610100900460ff1615808015610edb5750600054600160ff909116105b80610ef55750303b158015610ef5575060005460ff166001145b610f81576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610654565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558015610fdf57600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b610fe8826116fa565b8015610cc557600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b6040517f35567e1a0000000000000000000000000000000000000000000000000000000081523060048201526000602482018190529073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906335567e1a90604401610e75565b6110d2611aa6565b6110da611aa6565b919050565b600054610100900460ff16158080156110ff5750600054600160ff909116105b806111195750303b158015611119575060005460ff166001145b6111a5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610654565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055801561120357600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b610fe860006116fa565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016148061126e575060005462010000900473ffffffffffffffffffffffffffffffffffffffff1633145b6112d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f6163636f756e743a206e6f74204f776e6572206f7220456e747279506f696e746044820152606401610654565b565b6000808473ffffffffffffffffffffffffffffffffffffffff1684846040516112ff9190612278565b60006040518083038185875af1925050503d806000811461133c576040519150601f19603f3d011682016040523d82523d6000602084013e611341565b606091505b50915091508161070457805160208201fd5b61090d611669565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff16156113935761138e83611799565b505050565b8273ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611418575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261141591810190612233565b60015b6114a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201527f6f6e206973206e6f7420555550530000000000000000000000000000000000006064820152608401610654565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8114611553576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f7860448201527f6961626c655555494400000000000000000000000000000000000000000000006064820152608401610654565b5061138e8383836118a3565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146112d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6163636f756e743a206e6f742066726f6d20456e747279506f696e74000000006044820152606401610654565b801561090d5760405160009033907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90849084818181858888f193505050503d8060008114610704576040519150601f19603f3d011682016040523d82523d6000602084013e610704565b60005462010000900473ffffffffffffffffffffffffffffffffffffffff1633148061169457503330145b6112d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c79206f776e6572000000000000000000000000000000000000000000006044820152606401610654565b600080547fffffffffffffffffffff0000000000000000000000000000000000000000ffff166201000073ffffffffffffffffffffffffffffffffffffffff8481168202929092178084556040519190048216927f0000000000000000000000000000000000000000000000000000000000000000909216917f47e55c76e7a6f1fd8996a1da8008c1ea29699cca35e7bcd057f2dec313b6e5de91a350565b73ffffffffffffffffffffffffffffffffffffffff81163b61183d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152608401610654565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b6118ac836118c8565b6000825111806118b95750805b1561138e57610dfe8383611915565b6118d181611799565b60405173ffffffffffffffffffffffffffffffffffffffff8216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b606061097683836040518060600160405280602781526020016122e66027913960606000808573ffffffffffffffffffffffffffffffffffffffff168560405161195f9190612278565b600060405180830381855af49150503d806000811461199a576040519150601f19603f3d011682016040523d82523d6000602084013e61199f565b606091505b50915091506119b0868383876119ba565b9695505050505050565b60608315611a50578251600003611a495773ffffffffffffffffffffffffffffffffffffffff85163b611a49576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610654565b5081611a5a565b611a5a8383611a62565b949350505050565b815115611a725781518083602001fd5b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106549190612294565b60405180608001604052806004906020820280368337509192915050565b73ffffffffffffffffffffffffffffffffffffffff8116811461090d57600080fd5b60008083601f840112611af857600080fd5b50813567ffffffffffffffff811115611b1057600080fd5b602083019150836020828501011115611b2857600080fd5b9250929050565b60008060008060008060008060c0898b031215611b4b57600080fd5b8835611b5681611ac4565b97506020890135611b6681611ac4565b96506040890135611b7681611ac4565b955060608901359450608089013567ffffffffffffffff80821115611b9a57600080fd5b611ba68c838d01611ae6565b909650945060a08b0135915080821115611bbf57600080fd5b50611bcc8b828c01611ae6565b999c989b5096995094979396929594505050565b600060208284031215611bf257600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461097657600080fd5b600080600080600060808688031215611c3a57600080fd5b8535611c4581611ac4565b94506020860135611c5581611ac4565b935060408601359250606086013567ffffffffffffffff811115611c7857600080fd5b611c8488828901611ae6565b969995985093965092949392505050565b60008083601f840112611ca757600080fd5b50813567ffffffffffffffff811115611cbf57600080fd5b6020830191508360208260051b8501011115611b2857600080fd5b60008060008060408587031215611cf057600080fd5b843567ffffffffffffffff80821115611d0857600080fd5b611d1488838901611c95565b90965094506020870135915080821115611d2d57600080fd5b50611d3a87828801611c95565b95989497509550505050565b600060208284031215611d5857600080fd5b813561097681611ac4565b600080600060608486031215611d7857600080fd5b833567ffffffffffffffff811115611d8f57600080fd5b84016101608187031215611da257600080fd5b95602085013595506040909401359392505050565b60008060408385031215611dca57600080fd5b8235611dd581611ac4565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611e5957611e59611de3565b604052919050565b60008060408385031215611e7457600080fd5b8235611e7f81611ac4565b915060208381013567ffffffffffffffff80821115611e9d57600080fd5b818601915086601f830112611eb157600080fd5b813581811115611ec357611ec3611de3565b611ef3847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611e12565b91508082528784828501011115611f0957600080fd5b80848401858401376000848284010152508093505050509250929050565b60008060008060608587031215611f3d57600080fd5b8435611f4881611ac4565b935060208501359250604085013567ffffffffffffffff811115611f6b57600080fd5b611d3a87828801611ae6565b60008060008060008060008060a0898b031215611f9357600080fd5b8835611f9e81611ac4565b97506020890135611fae81611ac4565b9650604089013567ffffffffffffffff80821115611fcb57600080fd5b611fd78c838d01611c95565b909850965060608b0135915080821115611ff057600080fd5b611ffc8c838d01611c95565b909650945060808b0135915080821115611bbf57600080fd5b60808101818360005b600481101561203d57815183526020928301929091019060010161201e565b50505092915050565b60006080828403121561205857600080fd5b82601f83011261206757600080fd5b6040516080810181811067ffffffffffffffff8211171561208a5761208a611de3565b60405280608084018581111561209f57600080fd5b845b818110156120b95780358352602092830192016120a1565b509195945050505050565b60008060008060008060a087890312156120dd57600080fd5b86356120e881611ac4565b955060208701356120f881611ac4565b94506040870135935060608701359250608087013567ffffffffffffffff81111561212257600080fd5b61212e89828a01611ae6565b979a9699509497509295939492505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126121a457600080fd5b83018035915067ffffffffffffffff8211156121bf57600080fd5b602001915036819003821315611b2857600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361222c577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b60006020828403121561224557600080fd5b5051919050565b60005b8381101561226757818101518382015260200161224f565b83811115610dfe5750506000910152565b6000825161228a81846020870161224c565b9190910192915050565b60208152600082518060208401526122b381604085016020870161224c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212201a293015a642c45bbac015e9c06168162e317c3fdc29a9fc336b746bdf2169a364736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var BrokenBLSAccountFactory__factory = (
      /** @class */
      function(_super) {
        __extends(BrokenBLSAccountFactory__factory2, _super);
        function BrokenBLSAccountFactory__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        BrokenBLSAccountFactory__factory2.prototype.deploy = function(entryPoint, aggregator, overrides) {
          return _super.prototype.deploy.call(this, entryPoint, aggregator, overrides || {});
        };
        BrokenBLSAccountFactory__factory2.prototype.getDeployTransaction = function(entryPoint, aggregator, overrides) {
          return _super.prototype.getDeployTransaction.call(this, entryPoint, aggregator, overrides || {});
        };
        BrokenBLSAccountFactory__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        BrokenBLSAccountFactory__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        BrokenBLSAccountFactory__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        BrokenBLSAccountFactory__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        BrokenBLSAccountFactory__factory2.bytecode = _bytecode;
        BrokenBLSAccountFactory__factory2.abi = _abi;
        return BrokenBLSAccountFactory__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.BrokenBLSAccountFactory__factory = BrokenBLSAccountFactory__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/DepositPaymaster__factory.js
var require_DepositPaymaster_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/DepositPaymaster__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.DepositPaymaster__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "_entryPoint",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "COST_OF_POST",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "addDepositFor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "contract IOracle",
            name: "tokenPriceOracle",
            type: "address"
          }
        ],
        name: "addToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "balances",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "deposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "depositInfo",
        outputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_unlockBlock",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "lockTokenDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "",
            type: "address"
          }
        ],
        name: "oracles",
        outputs: [
          {
            internalType: "contract IOracle",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IPaymaster.PostOpMode",
            name: "mode",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          }
        ],
        name: "postOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "unlockBlock",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockTokenDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "maxCost",
            type: "uint256"
          }
        ],
        name: "validatePaymasterUserOp",
        outputs: [
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawTokensTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x60a06040523480156200001157600080fd5b5060405162001fa938038062001fa98339810160408190526200003491620000bb565b8062000040336200006b565b6001600160a01b031660805262000064336000908152600360205260409020439055565b50620000ed565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215620000ce57600080fd5b81516001600160a01b0381168114620000e657600080fd5b9392505050565b608051611e6f6200013a600039600081816103b30152818161052b015281816105f50152818161089001528181610957015281816109e701528181610bb90152610ed70152611e6f6000f3fe6080604052600436106101755760003560e01c8063addd5099116100cb578063c399ec881161007f578063d0e30db011610059578063d0e30db014610499578063f2fde38b146104a1578063f465c77e146104c157600080fd5b8063c399ec8814610442578063cc9c837c14610457578063cd8f80c21461047757600080fd5b8063bb9fe6bf116100b0578063bb9fe6bf146103d5578063c23a5cea146103ea578063c23f001f1461040a57600080fd5b8063addd50991461035e578063b0d691fe146103a157600080fd5b80635476bd721161012d5780638da5cb5b116101075780638da5cb5b146102ce5780639ed0fb681461031a578063a9a234091461033e57600080fd5b80635476bd7214610283578063715018a6146102a3578063796d4371146102b857600080fd5b8063382edd9e1161015e578063382edd9e146101af578063493b0170146101cf5780634a6f84cf1461024857600080fd5b80630396cb601461017a578063205c28781461018f575b600080fd5b61018d610188366004611915565b6104ef565b005b34801561019b57600080fd5b5061018d6101aa36600461195d565b6105a1565b3480156101bb57600080fd5b5061018d6101ca366004611989565b610639565b3480156101db57600080fd5b5061022e6101ea3660046119ca565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260026020908152604080832093909416825291825282812054600390925291909120549091565b604080519283526020830191909152015b60405180910390f35b34801561025457600080fd5b50610275610263366004611a03565b60036020526000908152604090205481565b60405190815260200161023f565b34801561028f57600080fd5b5061018d61029e3660046119ca565b61076e565b3480156102af57600080fd5b5061018d610858565b3480156102c457600080fd5b506102756188b881565b3480156102da57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161023f565b34801561032657600080fd5b5061018d336000908152600360205260409020439055565b34801561034a57600080fd5b5061018d610359366004611a20565b61086c565b34801561036a57600080fd5b506102f5610379366004611a03565b60016020526000908152604090205473ffffffffffffffffffffffffffffffffffffffff1681565b3480156103ad57600080fd5b506102f57f000000000000000000000000000000000000000000000000000000000000000081565b3480156103e157600080fd5b5061018d610886565b3480156103f657600080fd5b5061018d610405366004611a03565b61090a565b34801561041657600080fd5b506102756104253660046119ca565b600260209081526000928352604080842090915290825290205481565b34801561044e57600080fd5b506102756109b6565b34801561046357600080fd5b5061018d610472366004611989565b610a6c565b34801561048357600080fd5b5061018d33600090815260036020526040812055565b61018d610b8b565b3480156104ad57600080fd5b5061018d6104bc366004611a03565b610c13565b3480156104cd57600080fd5b506104e16104dc366004611aaf565b610cca565b60405161023f929190611b79565b6104f7610ced565b6040517f0396cb6000000000000000000000000000000000000000000000000000000000815263ffffffff821660048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690630396cb609034906024016000604051808303818588803b15801561058557600080fd5b505af1158015610599573d6000803e3d6000fd5b505050505050565b6105a9610ced565b6040517f205c287800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063205c287890604401600060405180830381600087803b15801561058557600080fd5b61065b73ffffffffffffffffffffffffffffffffffffffff8416333084610d6e565b73ffffffffffffffffffffffffffffffffffffffff838116600090815260016020526040902054166106ee576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f756e737570706f7274656420746f6b656e00000000000000000000000000000060448201526064015b60405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff808416600090815260026020908152604080832093861683529290529081208054839290610732908490611bca565b909155505073ffffffffffffffffffffffffffffffffffffffff821633036107695761076933600090815260036020526040812055565b505050565b610776610ced565b73ffffffffffffffffffffffffffffffffffffffff8281166000908152600160205260409020541615610805576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f546f6b656e20616c72656164792073657400000000000000000000000000000060448201526064016106e5565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260016020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001691909216179055565b610860610ced565b61086a6000610e4a565b565b610874610ebf565b61088084848484610f5e565b50505050565b61088e610ced565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb9fe6bf6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156108f657600080fd5b505af1158015610880573d6000803e3d6000fd5b610912610ced565b6040517fc23a5cea00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063c23a5cea90602401600060405180830381600087803b15801561099b57600080fd5b505af11580156109af573d6000803e3d6000fd5b5050505050565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa158015610a43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a679190611be2565b905090565b3360009081526003602052604090205415801590610a9857503360009081526003602052604090205443115b610b24576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4465706f7369745061796d61737465723a206d75737420756e6c6f636b546f6b60448201527f656e4465706f736974000000000000000000000000000000000000000000000060648201526084016106e5565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260026020908152604080832033845290915281208054839290610b64908490611bfb565b90915550610769905073ffffffffffffffffffffffffffffffffffffffff841683836110d6565b6040517fb760faf90000000000000000000000000000000000000000000000000000000081523060048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b760faf99034906024016000604051808303818588803b15801561099b57600080fd5b610c1b610ced565b73ffffffffffffffffffffffffffffffffffffffff8116610cbe576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016106e5565b610cc781610e4a565b50565b60606000610cd6610ebf565b610ce185858561112c565b91509150935093915050565b60005473ffffffffffffffffffffffffffffffffffffffff16331461086a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016106e5565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526108809085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152611475565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b3373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461086a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f53656e646572206e6f7420456e747279506f696e74000000000000000000000060448201526064016106e5565b600080808080610f7087890189611c12565b9450945094509450945060008183856188b8610f8c9190611c63565b610f96908a611bca565b610fa09190611c63565b610faa9190611ca0565b905060028a6002811115610fc057610fc0611cdb565b14610fec57610fe773ffffffffffffffffffffffffffffffffffffffff8616873084610d6e565b611036565b73ffffffffffffffffffffffffffffffffffffffff8086166000908152600260209081526040808320938a1683529290529081208054839290611030908490611bfb565b90915550505b73ffffffffffffffffffffffffffffffffffffffff85166000908152600260205260408120829161107c60005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546110c59190611bca565b909155505050505050505050505050565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526107699084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401610dc8565b606060006188b88560a00135116111c5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4465706f7369745061796d61737465723a2067617320746f6f206c6f7720666f60448201527f7220706f73744f7000000000000000000000000000000000000000000000000060648201526084016106e5565b3660006111d6610120880188611d0a565b90925090506028811461126b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603560248201527f4465706f7369745061796d61737465723a207061796d6173746572416e64446160448201527f7461206d757374207370656369667920746f6b656e000000000000000000000060648201526084016106e5565b600061127a8260148186611d76565b61128391611da0565b60601c9050873560006112968389611581565b905060006112a38b6116cf565b73ffffffffffffffffffffffffffffffffffffffff841660009081526003602052604090205490915015611358576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4465706f7369745061796d61737465723a206465706f736974206e6f74206c6f60448201527f636b65640000000000000000000000000000000000000000000000000000000060648201526084016106e5565b73ffffffffffffffffffffffffffffffffffffffff80851660009081526002602090815260408083209387168352929052205482111561141a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f4465706f7369745061796d61737465723a206465706f73697420746f6f206c6f60448201527f770000000000000000000000000000000000000000000000000000000000000060648201526084016106e5565b6040805173ffffffffffffffffffffffffffffffffffffffff948516602082015294909316848401526060840152608083015260a0808301979097528051808303909701875260c09091019052509295600095509350505050565b60006114d7826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff166116f69092919063ffffffff16565b80519091501561076957808060200190518101906114f59190611de8565b610769576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016106e5565b73ffffffffffffffffffffffffffffffffffffffff80831660009081526001602052604081205490911680611638576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f4465706f7369745061796d61737465723a20756e737570706f7274656420746f60448201527f6b656e000000000000000000000000000000000000000000000000000000000060648201526084016106e5565b6040517fd1eca9cf0000000000000000000000000000000000000000000000000000000081526004810184905273ffffffffffffffffffffffffffffffffffffffff82169063d1eca9cf90602401602060405180830381865afa1580156116a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116c79190611be2565b949350505050565b600060e08201356101008301358082036116ea575092915050565b6116c782488301611705565b60606116c7848460008561171d565b60008183106117145781611716565b825b9392505050565b6060824710156117af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016106e5565b6000808673ffffffffffffffffffffffffffffffffffffffff1685876040516117d89190611e0a565b60006040518083038185875af1925050503d8060008114611815576040519150601f19603f3d011682016040523d82523d6000602084013e61181a565b606091505b509150915061182b87838387611836565b979650505050505050565b606083156118cc5782516000036118c55773ffffffffffffffffffffffffffffffffffffffff85163b6118c5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106e5565b50816116c7565b6116c783838151156118e15781518083602001fd5b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106e59190611e26565b60006020828403121561192757600080fd5b813563ffffffff8116811461171657600080fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610cc757600080fd5b6000806040838503121561197057600080fd5b823561197b8161193b565b946020939093013593505050565b60008060006060848603121561199e57600080fd5b83356119a98161193b565b925060208401356119b98161193b565b929592945050506040919091013590565b600080604083850312156119dd57600080fd5b82356119e88161193b565b915060208301356119f88161193b565b809150509250929050565b600060208284031215611a1557600080fd5b81356117168161193b565b60008060008060608587031215611a3657600080fd5b843560038110611a4557600080fd5b9350602085013567ffffffffffffffff80821115611a6257600080fd5b818701915087601f830112611a7657600080fd5b813581811115611a8557600080fd5b886020828501011115611a9757600080fd5b95986020929092019750949560400135945092505050565b600080600060608486031215611ac457600080fd5b833567ffffffffffffffff811115611adb57600080fd5b84016101608187031215611aee57600080fd5b95602085013595506040909401359392505050565b60005b83811015611b1e578181015183820152602001611b06565b838111156108805750506000910152565b60008151808452611b47816020860160208601611b03565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b604081526000611b8c6040830185611b2f565b90508260208301529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008219821115611bdd57611bdd611b9b565b500190565b600060208284031215611bf457600080fd5b5051919050565b600082821015611c0d57611c0d611b9b565b500390565b600080600080600060a08688031215611c2a57600080fd5b8535611c358161193b565b94506020860135611c458161193b565b94979496505050506040830135926060810135926080909101359150565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615611c9b57611c9b611b9b565b500290565b600082611cd6577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112611d3f57600080fd5b83018035915067ffffffffffffffff821115611d5a57600080fd5b602001915036819003821315611d6f57600080fd5b9250929050565b60008085851115611d8657600080fd5b83861115611d9357600080fd5b5050820193919092039150565b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008135818116916014851015611de05780818660140360031b1b83161692505b505092915050565b600060208284031215611dfa57600080fd5b8151801515811461171657600080fd5b60008251611e1c818460208701611b03565b9190910192915050565b6020815260006117166020830184611b2f56fea26469706673582212208fc4d35b101eeda5f1b4feab287aa0152884b59a759c99d6ad3954fb1930350064736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var DepositPaymaster__factory = (
      /** @class */
      function(_super) {
        __extends(DepositPaymaster__factory2, _super);
        function DepositPaymaster__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        DepositPaymaster__factory2.prototype.deploy = function(_entryPoint, overrides) {
          return _super.prototype.deploy.call(this, _entryPoint, overrides || {});
        };
        DepositPaymaster__factory2.prototype.getDeployTransaction = function(_entryPoint, overrides) {
          return _super.prototype.getDeployTransaction.call(this, _entryPoint, overrides || {});
        };
        DepositPaymaster__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        DepositPaymaster__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        DepositPaymaster__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        DepositPaymaster__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        DepositPaymaster__factory2.bytecode = _bytecode;
        DepositPaymaster__factory2.abi = _abi;
        return DepositPaymaster__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.DepositPaymaster__factory = DepositPaymaster__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/EntryPoint__factory.js
var require_EntryPoint_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/EntryPoint__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.EntryPoint__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "paid",
            type: "uint256"
          },
          {
            internalType: "uint48",
            name: "validAfter",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "validUntil",
            type: "uint48"
          },
          {
            internalType: "bool",
            name: "targetSuccess",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "targetResult",
            type: "bytes"
          }
        ],
        name: "ExecutionResult",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "opIndex",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "reason",
            type: "string"
          }
        ],
        name: "FailedOp",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "SenderAddressResult",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "aggregator",
            type: "address"
          }
        ],
        name: "SignatureValidationFailed",
        type: "error"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "bool",
                name: "sigFailed",
                type: "bool"
              },
              {
                internalType: "uint48",
                name: "validAfter",
                type: "uint48"
              },
              {
                internalType: "uint48",
                name: "validUntil",
                type: "uint48"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          }
        ],
        name: "ValidationResult",
        type: "error"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "bool",
                name: "sigFailed",
                type: "bool"
              },
              {
                internalType: "uint48",
                name: "validAfter",
                type: "uint48"
              },
              {
                internalType: "uint48",
                name: "validUntil",
                type: "uint48"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "aggregator",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "uint256",
                    name: "stake",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "unstakeDelaySec",
                    type: "uint256"
                  }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "stakeInfo",
                type: "tuple"
              }
            ],
            internalType: "struct IEntryPoint.AggregatorStakeInfo",
            name: "aggregatorInfo",
            type: "tuple"
          }
        ],
        name: "ValidationResultWithAggregation",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "factory",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "paymaster",
            type: "address"
          }
        ],
        name: "AccountDeployed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "BeforeExecution",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalDeposit",
            type: "uint256"
          }
        ],
        name: "Deposited",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "aggregator",
            type: "address"
          }
        ],
        name: "SignatureAggregatorChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalStaked",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        name: "StakeLocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "withdrawTime",
            type: "uint256"
          }
        ],
        name: "StakeUnlocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "StakeWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "paymaster",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "actualGasUsed",
            type: "uint256"
          }
        ],
        name: "UserOperationEvent",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "revertReason",
            type: "bytes"
          }
        ],
        name: "UserOperationRevertReason",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrawn",
        type: "event"
      },
      {
        inputs: [],
        name: "SIG_VALIDATION_FAILED",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          }
        ],
        name: "_validateSenderAndPaymaster",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "depositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "deposits",
        outputs: [
          {
            internalType: "uint112",
            name: "deposit",
            type: "uint112"
          },
          {
            internalType: "bool",
            name: "staked",
            type: "bool"
          },
          {
            internalType: "uint112",
            name: "stake",
            type: "uint112"
          },
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          },
          {
            internalType: "uint48",
            name: "withdrawTime",
            type: "uint48"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getDepositInfo",
        outputs: [
          {
            components: [
              {
                internalType: "uint112",
                name: "deposit",
                type: "uint112"
              },
              {
                internalType: "bool",
                name: "staked",
                type: "bool"
              },
              {
                internalType: "uint112",
                name: "stake",
                type: "uint112"
              },
              {
                internalType: "uint32",
                name: "unstakeDelaySec",
                type: "uint32"
              },
              {
                internalType: "uint48",
                name: "withdrawTime",
                type: "uint48"
              }
            ],
            internalType: "struct IStakeManager.DepositInfo",
            name: "info",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          }
        ],
        name: "getSenderAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          }
        ],
        name: "getUserOpHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "sender",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "nonce",
                    type: "uint256"
                  },
                  {
                    internalType: "bytes",
                    name: "initCode",
                    type: "bytes"
                  },
                  {
                    internalType: "bytes",
                    name: "callData",
                    type: "bytes"
                  },
                  {
                    internalType: "uint256",
                    name: "callGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "verificationGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "preVerificationGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxPriorityFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "bytes",
                    name: "paymasterAndData",
                    type: "bytes"
                  },
                  {
                    internalType: "bytes",
                    name: "signature",
                    type: "bytes"
                  }
                ],
                internalType: "struct UserOperation[]",
                name: "userOps",
                type: "tuple[]"
              },
              {
                internalType: "contract IAggregator",
                name: "aggregator",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
            name: "opsPerAggregator",
            type: "tuple[]"
          },
          {
            internalType: "address payable",
            name: "beneficiary",
            type: "address"
          }
        ],
        name: "handleAggregatedOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation[]",
            name: "ops",
            type: "tuple[]"
          },
          {
            internalType: "address payable",
            name: "beneficiary",
            type: "address"
          }
        ],
        name: "handleOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "incrementNonce",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "sender",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "nonce",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "callGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "verificationGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "preVerificationGas",
                    type: "uint256"
                  },
                  {
                    internalType: "address",
                    name: "paymaster",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "maxFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxPriorityFeePerGas",
                    type: "uint256"
                  }
                ],
                internalType: "struct EntryPoint.MemoryUserOp",
                name: "mUserOp",
                type: "tuple"
              },
              {
                internalType: "bytes32",
                name: "userOpHash",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "contextOffset",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              }
            ],
            internalType: "struct EntryPoint.UserOpInfo",
            name: "opInfo",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          }
        ],
        name: "innerHandleOp",
        outputs: [
          {
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "",
            type: "uint192"
          }
        ],
        name: "nonceSequenceNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "op",
            type: "tuple"
          },
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "targetCallData",
            type: "bytes"
          }
        ],
        name: "simulateHandleOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          }
        ],
        name: "simulateValidation",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "withdrawAmount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var _bytecode = "0x60a080604052346200008957600160025561022c8181016001600160401b038111838210176200007357829162005d18833903906000f080156200006757608052604051615c8990816200008f82396080518181816113df01528181613e9501526141b60152f35b6040513d6000823e3d90fd5b634e487b7160e01b600052604160045260246000fd5b600080fdfe60806040526004361015610023575b361561001957600080fd5b610021615531565b005b60003560e01c80630396cb60146101b35780630bd28e3b146101aa5780631b2e01b8146101a15780631d732756146101985780631fad948c1461018f578063205c28781461018657806335567e1a1461017d5780634b1d7cf5146101745780635287ce121461016b57806370a08231146101625780638f41ec5a14610159578063957122ab146101505780639b249f6914610147578063a61935311461013e578063b760faf914610135578063bb9fe6bf1461012c578063c23a5cea14610123578063d6383f941461011a578063ee219423146101115763fc7e286d0361000e5761010c611bcd565b61000e565b5061010c6119b5565b5061010c61184d565b5061010c6116b4565b5061010c611536565b5061010c6114f7565b5061010c6114d6565b5061010c611337565b5061010c611164565b5061010c611129565b5061010c6110a4565b5061010c610f54565b5061010c610bf8565b5061010c610b33565b5061010c610994565b5061010c6108ba565b5061010c6106e7565b5061010c610467565b5061010c610385565b5060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595760043563ffffffff8116808203610359576103547fa5ae833d0bb1dcd632d98a8b70973e8516812898e19bf27b70071ebc8dc52c01916102716102413373ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b9161024d811515615697565b61026a610261600185015463ffffffff1690565b63ffffffff1690565b11156156fc565b54926103366dffffffffffffffffffffffffffff946102f461029834888460781c166121d5565b966102a4881515615761565b6102b0818911156157c6565b6102d4816102bc6105ec565b941684906dffffffffffffffffffffffffffff169052565b6001602084015287166dffffffffffffffffffffffffffff166040830152565b63ffffffff83166060820152600060808201526103313373ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b61582b565b6040805194855263ffffffff90911660208501523393918291820190565b0390a2005b600080fd5b6024359077ffffffffffffffffffffffffffffffffffffffffffffffff8216820361035957565b50346103595760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595760043577ffffffffffffffffffffffffffffffffffffffffffffffff81168103610359576104149033600052600160205260406000209077ffffffffffffffffffffffffffffffffffffffffffffffff16600052602052604060002090565b61041e8154612491565b9055005b73ffffffffffffffffffffffffffffffffffffffff81160361035957565b6024359061044d82610422565b565b60c4359061044d82610422565b359061044d82610422565b50346103595760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595760206104fc6004356104a881610422565b73ffffffffffffffffffffffffffffffffffffffff6104c561035e565b91166000526001835260406000209077ffffffffffffffffffffffffffffffffffffffffffffffff16600052602052604060002090565b54604051908152f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60a0810190811067ffffffffffffffff82111761055157604052565b610559610505565b604052565b610100810190811067ffffffffffffffff82111761055157604052565b67ffffffffffffffff811161055157604052565b6060810190811067ffffffffffffffff82111761055157604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761055157604052565b6040519061044d82610535565b6040519060c0820182811067ffffffffffffffff82111761055157604052565b604051906040820182811067ffffffffffffffff82111761055157604052565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209267ffffffffffffffff8111610675575b01160190565b61067d610505565b61066f565b92919261068e82610639565b9161069c60405193846105ab565b829481845281830111610359578281602093846000960137010152565b9181601f840112156103595782359167ffffffffffffffff8311610359576020838186019501011161035957565b5034610359576101c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595767ffffffffffffffff60043581811161035957366023820112156103595761074a903690602481600401359101610682565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36016101808112610359576101006040519161078783610535565b12610359576040516107988161055e565b6107a0610440565b815260443560208201526064356040820152608435606082015260a43560808201526107ca61044f565b60a082015260e43560c08201526101043560e082015281526101243560208201526101443560408201526101643560608201526101843560808201526101a4359182116103595761083e9261082661082e9336906004016106b9565b9290916128b1565b6040519081529081906020820190565b0390f35b9060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126103595760043567ffffffffffffffff9283821161035957806023830112156103595781600401359384116103595760248460051b830101116103595760240191906024356108b781610422565b90565b5034610359576108c936610842565b6108d4929192611e3a565b6108dd83611d2d565b60005b84811061095d57506000927fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f9728480a183915b85831061092d576109238585611ed7565b6100216001600255565b909193600190610953610941878987611dec565b61094b8886611dca565b51908861233f565b0194019190610912565b8061098b610984610972600194869896611dca565b5161097e848a88611dec565b84613448565b9083612f30565b019290926108e0565b50346103595760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610359576004356109d081610422565b6024359060009133835282602052604083206dffffffffffffffffffffffffffff81541692838311610ad557848373ffffffffffffffffffffffffffffffffffffffff829593610a788496610a3f610a2c8798610ad29c6121c0565b6dffffffffffffffffffffffffffff1690565b6dffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffff0000000000000000000000000000825416179055565b6040805173ffffffffffffffffffffffffffffffffffffffff831681526020810185905233917fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb91a2165af1610acc611ea7565b50615ba2565b80f35b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f576974686472617720616d6f756e7420746f6f206c61726765000000000000006044820152fd5b50346103595760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610359576020600435610b7181610422565b73ffffffffffffffffffffffffffffffffffffffff610b8e61035e565b911660005260018252610bc98160406000209077ffffffffffffffffffffffffffffffffffffffffffffffff16600052602052604060002090565b547fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000006040519260401b16178152f35b503461035957610c0736610842565b610c0f611e3a565b6000805b838210610df657610c249150611d2d565b7fbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972600080a16000805b848110610d5c57505060008093815b818110610c9357610923868660007f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d8180a2611ed7565b610cf7610ca182848a6124cb565b610ccc610cb3610cb36020840161256d565b73ffffffffffffffffffffffffffffffffffffffff1690565b7f575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d600080a280612519565b906000915b808310610d1457505050610d0f90612491565b610c5c565b90919497610d4f610d49610d5592610d438c8b610d3c82610d368e8b8d611dec565b92611dca565b519161233f565b906121d5565b99612491565b95612491565b9190610cfc565b610d678186886124cb565b6020610d7f610d768380612519565b9290930161256d565b9173ffffffffffffffffffffffffffffffffffffffff60009316905b828410610db45750505050610daf90612491565b610c4d565b90919294610d4f81610de985610de2610dd0610dee968d611dca565b51610ddc8c8b8a611dec565b85613448565b908b613148565b612491565b929190610d9b565b610e018285876124cb565b90610e0c8280612519565b92610e1c610cb36020830161256d565b9173ffffffffffffffffffffffffffffffffffffffff8316610e416001821415612577565b610e62575b505050610e5c91610e56916121d5565b91612491565b90610c13565b909592610e7b6040999693999895989788810190611fc8565b92908a3b156103595789938b918a5193849283927fe3563a4f00000000000000000000000000000000000000000000000000000000845260049e8f850193610ec294612711565b03815a93600094fa9081610f3b575b50610f255786517f86a9f75000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a16818a0190815281906020010390fd5b0390fd5b9497509295509093509181610e56610e5c610e46565b80610f48610f4e9261057b565b8061111e565b38610ed1565b50346103595760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595761083e73ffffffffffffffffffffffffffffffffffffffff600435610fa881610422565b608060409283928351610fba81610535565b60009381858093528260208201528287820152826060820152015216815280602052209061104965ffffffffffff6001835194610ff686610535565b80546dffffffffffffffffffffffffffff8082168852607082901c60ff161515602089015260789190911c1685870152015463ffffffff8116606086015260201c16608084019065ffffffffffff169052565b5191829182919091608065ffffffffffff8160a08401956dffffffffffffffffffffffffffff808251168652602082015115156020870152604082015116604086015263ffffffff6060820151166060860152015116910152565b50346103595760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595773ffffffffffffffffffffffffffffffffffffffff6004356110f581610422565b16600052600060205260206dffffffffffffffffffffffffffff60406000205416604051908152f35b600091031261035957565b50346103595760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261035957602060405160018152f35b50346103595760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261035957600467ffffffffffffffff8135818111610359576111b590369084016106b9565b9050602435916111c483610422565b604435908111610359576111db90369085016106b9565b92909115908161132d575b506112c6576014821015611236575b610f21836040519182917f08c379a0000000000000000000000000000000000000000000000000000000008352820160409060208152600060208201520190565b6112466112529261124c92612b88565b90612b96565b60601c90565b3b1561125f5738806111f5565b610f21906040519182917f08c379a0000000000000000000000000000000000000000000000000000000008352820160609060208152601b60208201527f41413330207061796d6173746572206e6f74206465706c6f796564000000000060408201520190565b610f21836040519182917f08c379a0000000000000000000000000000000000000000000000000000000008352820160609060208152601960208201527f41413230206163636f756e74206e6f74206465706c6f7965640000000000000060408201520190565b90503b15386111e6565b50346103595760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595760043567ffffffffffffffff81116103595761138960249136906004016106b9565b906113bf6040519283927f570e1a3600000000000000000000000000000000000000000000000000000000845260048401612d2c565b0360208273ffffffffffffffffffffffffffffffffffffffff92816000857f0000000000000000000000000000000000000000000000000000000000000000165af1918215611471575b600092611441575b50604051917f6ca7b806000000000000000000000000000000000000000000000000000000008352166004820152fd5b61146391925060203d811161146a575b61145b81836105ab565b810190612d17565b9038611411565b503d611451565b611479612183565b611409565b90816101609103126103595790565b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc820112610359576004359067ffffffffffffffff8211610359576108b79160040161147e565b50346103595760206114ef6114ea3661148d565b612a0c565b604051908152f35b5060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595761002160043561153181610422565b61562b565b5034610359576000807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126116b1573381528060205260408120600181019063ffffffff825416908115611653576115f06115b5611618936115a76115a2855460ff9060701c1690565b61598f565b65ffffffffffff42166159f4565b84547fffffffffffffffffffffffffffffffffffffffffffff000000000000ffffffff16602082901b69ffffffffffff000000001617909455565b7fffffffffffffffffffffffffffffffffff00ffffffffffffffffffffffffffff8154169055565b60405165ffffffffffff91909116815233907ffa9b3c14cc825c412c9ed81b3ba365a5b459439403f18829e572ed53a4180f0a90602090a280f35b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6e6f74207374616b6564000000000000000000000000000000000000000000006044820152fd5b80fd5b50346103595760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610359576004356116f081610422565b610ad273ffffffffffffffffffffffffffffffffffffffff6117323373ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b926117ea611755610a2c86546dffffffffffffffffffffffffffff9060781c1690565b94611761861515615a0e565b6117c26001820161179a65ffffffffffff611786835465ffffffffffff9060201c1690565b16611792811515615a73565b421015615ad8565b80547fffffffffffffffffffffffffffffffffffffffffffff00000000000000000000169055565b7fffffff0000000000000000000000000000ffffffffffffffffffffffffffffff8154169055565b6040805173ffffffffffffffffffffffffffffffffffffffff831681526020810186905233917fb7c918e0e249f999e965cafeb6c664271b3f4317d296461500e71da39f0cbda391a2600080809581948294165af1611847611ea7565b50615b3d565b50346103595760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595767ffffffffffffffff6004358181116103595761189e90369060040161147e565b602435916118ab83610422565b604435908111610359576118c6610f219136906004016106b9565b6118ce611caa565b6118d785612e2b565b6118ea6118e48287613240565b906153ba565b946118fa826000924384526121e2565b96438252819360609573ffffffffffffffffffffffffffffffffffffffff8316611981575b50505050608001519361194e6040611940602084015165ffffffffffff1690565b92015165ffffffffffff1690565b906040519687967f8b7ac980000000000000000000000000000000000000000000000000000000008852600488016127e1565b8395508394965061199b60409492939451809481936127d3565b03925af19060806119aa611ea7565b92919038808061191f565b5034610359576119c43661148d565b6119cc611caa565b6119d582612e2b565b6119df8183613240565b825160a00151919391611a0c9073ffffffffffffffffffffffffffffffffffffffff166154dc565b6154dc565b90611a30611a07855173ffffffffffffffffffffffffffffffffffffffff90511690565b94611a39612b50565b50611a68611a4c60409586810190611fc8565b90600060148310611bc55750611246611a079261124c92612b88565b91611a72916153ba565b805173ffffffffffffffffffffffffffffffffffffffff169073ffffffffffffffffffffffffffffffffffffffff821660018114916080880151978781015191886020820151611ac79065ffffffffffff1690565b91015165ffffffffffff16916060015192611ae06105f9565b9a8b5260208b0152841515898b015265ffffffffffff1660608a015265ffffffffffff16608089015260a088015215159081611bbc575b50611b515750610f2192519485947fe0cff05f00000000000000000000000000000000000000000000000000000000865260048601612cbd565b9190610f2193611b60846154dc565b611b87611b6b610619565b73ffffffffffffffffffffffffffffffffffffffff9096168652565b6020850152519586957ffaecb4e400000000000000000000000000000000000000000000000000000000875260048701612c2b565b90501538611b17565b9150506154dc565b50346103595760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103595773ffffffffffffffffffffffffffffffffffffffff600435611c1e81610422565b16600052600060205260a0604060002065ffffffffffff60018254920154604051926dffffffffffffffffffffffffffff90818116855260ff8160701c161515602086015260781c16604084015263ffffffff8116606084015260201c166080820152f35b60209067ffffffffffffffff8111611c9d575b60051b0190565b611ca5610505565b611c96565b60405190611cb782610535565b604051608083610100830167ffffffffffffffff811184821017611d20575b60405260009283815283602082015283604082015283606082015283838201528360a08201528360c08201528360e082015281528260208201528260408201528260608201520152565b611d28610505565b611cd6565b90611d3782611c83565b611d4460405191826105ab565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611d728294611c83565b019060005b828110611d8357505050565b602090611d8e611caa565b82828501015201611d77565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020918151811015611ddf575b60051b010190565b611de7611d9a565b611dd7565b9190811015611e2d575b60051b810135907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffea181360301821215610359570190565b611e35611d9a565b611df6565b6002805414611e495760028055565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152fd5b3d15611ed2573d90611eb882610639565b91611ec660405193846105ab565b82523d6000602084013e565b606090565b73ffffffffffffffffffffffffffffffffffffffff168015611f6a57600080809381935af1611f04611ea7565b5015611f0c57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f41413931206661696c65642073656e6420746f2062656e6566696369617279006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4141393020696e76616c69642062656e656669636961727900000000000000006044820152fd5b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe181360301821215610359570180359067ffffffffffffffff82116103595760200191813603831361035957565b90816020910312610359575190565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0938186528686013760008582860101520116010190565b60005b83811061207a5750506000910152565b818101518382015260200161206a565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f6020936120c681518092818752878088019101612067565b0116010190565b906120e76080916108b796946101c0808652850191612028565b9360e0815173ffffffffffffffffffffffffffffffffffffffff80825116602087015260208201516040870152604082015160608701526060820151858701528482015160a087015260a08201511660c086015260c081015182860152015161010084015260208101516101208401526040810151610140840152606081015161016084015201516101808201526101a081840391015261208a565b506040513d6000823e3d90fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b919082039182116121cd57565b61044d612190565b919082018092116121cd57565b905a918160206121fb6060830151936060810190611fc8565b906122348560405195869485947f1d732756000000000000000000000000000000000000000000000000000000008652600486016120cd565b03816000305af16000918161230f575b50612308575060206000803e7fdeaddead000000000000000000000000000000000000000000000000000000006000511461229b5761229561228a6108b7945a906121c0565b6080840151906121d5565b91614afc565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152600f60408201527f41413935206f7574206f6620676173000000000000000000000000000000000060608201520190565b9250505090565b61233191925060203d8111612338575b61232981836105ab565b810190612019565b9038612244565b503d61231f565b909291925a9380602061235b6060830151946060810190611fc8565b906123948660405195869485947f1d732756000000000000000000000000000000000000000000000000000000008652600486016120cd565b03816000305af160009181612471575b5061246a575060206000803e7fdeaddead00000000000000000000000000000000000000000000000000000000600051146123fc576123f66123eb6108b795965a906121c0565b6080830151906121d5565b92614ddf565b610f21836040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152600f60408201527f41413935206f7574206f6620676173000000000000000000000000000000000060608201520190565b9450505050565b61248a91925060203d81116123385761232981836105ab565b90386123a4565b6001907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146124bf570190565b6124c7612190565b0190565b919081101561250c575b60051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa181360301821215610359570190565b612514611d9a565b6124d5565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe181360301821215610359570180359067ffffffffffffffff821161035957602001918160051b3603831361035957565b356108b781610422565b1561257e57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4141393620696e76616c69642061676772656761746f720000000000000000006044820152fd5b90357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18236030181121561035957016020813591019167ffffffffffffffff821161035957813603831361035957565b6108b7916126578161263d8461045c565b73ffffffffffffffffffffffffffffffffffffffff169052565b602082013560208201526126f26126a361268861267760408601866125dc565b610160806040880152860191612028565b61269560608601866125dc565b908583036060870152612028565b6080840135608084015260a084013560a084015260c084013560c084015260e084013560e084015261010080850135908401526101206126e5818601866125dc565b9185840390860152612028565b9161270361014091828101906125dc565b929091818503910152612028565b949391929083604087016040885252606086019360608160051b8801019482600090815b848310612754575050505050508460206108b795968503910152612028565b9091929394977fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08b820301855288357ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffea1843603018112156127cf57600191846127bd920161262c565b98602090810196950193019190612735565b8280fd5b908092918237016000815290565b9290936108b796959260c0958552602085015265ffffffffffff8092166040850152166060830152151560808201528160a0820152019061208a565b1561282457565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4141393220696e7465726e616c2063616c6c206f6e6c790000000000000000006044820152fd5b9060406108b79260008152816020820152019061208a565b6040906108b793928152816020820152019061208a565b909291925a936128c230331461281d565b8151946040860151955a6113886060830151890101116129e2576108b7966000958051612909575b50505090612903915a9003608084015101943691610682565b91615047565b612938916129349161292f855173ffffffffffffffffffffffffffffffffffffffff1690565b615c12565b1590565b612944575b80806128ea565b61290392919450612953615c24565b908151612967575b5050600193909161293d565b7f1c4fada7374c0a9ee8841fc38afe82932dc0f8e69012e927f061a8bae611a20173ffffffffffffffffffffffffffffffffffffffff6020870151926129d860206129c6835173ffffffffffffffffffffffffffffffffffffffff1690565b9201519560405193849316968361289a565b0390a3388061295b565b7fdeaddead0000000000000000000000000000000000000000000000000000000060005260206000fd5b612a22612a1c6040830183611fc8565b90615c07565b90612a33612a1c6060830183611fc8565b90612ae9612a48612a1c610120840184611fc8565b60405194859360208501956101008201359260e08301359260c08101359260a08201359260808301359273ffffffffffffffffffffffffffffffffffffffff60208201359135168c9693909a9998959261012098959273ffffffffffffffffffffffffffffffffffffffff6101408a019d168952602089015260408801526060870152608086015260a085015260c084015260e08301526101008201520152565b0391612b1b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0938481018352826105ab565b51902060408051602081019283523091810191909152466060820152608092830181529091612b4a90826105ab565b51902090565b604051906040820182811067ffffffffffffffff821117612b7b575b60405260006020838281520152565b612b83610505565b612b6c565b906014116103595790601490565b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000009035818116939260148110612bcb57505050565b60140360031b82901b16169150565b9060c060a06108b793805184526020810151602085015260408101511515604085015265ffffffffffff80606083015116606086015260808201511660808501520151918160a0820152019061208a565b9294612c8c61044d95612c7a610100959998612c68612c54602097610140808c528b0190612bda565b9b878a019060208091805184520151910152565b80516060890152602001516080880152565b805160a08701526020015160c0860152565b73ffffffffffffffffffffffffffffffffffffffff81511660e0850152015191019060208091805184520151910152565b612d0661044d94612cf4612cdf60a0959998969960e0865260e0860190612bda565b98602085019060208091805184520151910152565b80516060840152602001516080830152565b019060208091805184520151910152565b9081602091031261035957516108b781610422565b9160206108b7938181520191612028565b90612d6c73ffffffffffffffffffffffffffffffffffffffff916108b797959694606085526060850191612028565b941660208201526040818503910152612028565b60009060033d11612d8d57565b905060046000803e60005160e01c90565b600060443d106108b7576040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc91823d016004833e815167ffffffffffffffff918282113d602484011117612e1a57818401948551938411612e22573d85010160208487010111612e1a57506108b7929101602001906105ab565b949350505050565b50949350505050565b612e386040820182611fc8565b612e50612e448461256d565b93610120810190611fc8565b9290303b1561035957600093612e949160405196879586957f957122ab00000000000000000000000000000000000000000000000000000000875260048701612d3d565b0381305afa9081612f1d575b5061044d576001612eaf612d80565b6308c379a014612ec8575b612ec057565b61044d612183565b612ed0612d9e565b80612edc575b50612eba565b80516000925015612ed657610f21906040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301612882565b80610f48612f2a9261057b565b38612ea0565b9190612f3b9061317f565b73ffffffffffffffffffffffffffffffffffffffff929183166130da5761306c57612f659061317f565b9116612ffe57612f725750565b604080517f220266b600000000000000000000000000000000000000000000000000000000815260048101929092526024820152602160448201527f41413332207061796d61737465722065787069726564206f72206e6f7420647560648201527f6500000000000000000000000000000000000000000000000000000000000000608482015260a490fd5b610f21826040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601460408201527f41413334207369676e6174757265206572726f7200000000000000000000000060608201520190565b610f21836040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601760408201527f414132322065787069726564206f72206e6f742064756500000000000000000060608201520190565b610f21846040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601460408201527f41413234207369676e6174757265206572726f7200000000000000000000000060608201520190565b9291906131549061317f565b909273ffffffffffffffffffffffffffffffffffffffff808095169116036130da5761306c57612f65905b80156131d25761318e9061535f565b73ffffffffffffffffffffffffffffffffffffffff65ffffffffffff8060408401511642119081156131c2575b5091511691565b90506020830151164210386131bb565b50600090600090565b156131e257565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f41413934206761732076616c756573206f766572666c6f7700000000000000006044820152fd5b916000915a9381519061325382826136b3565b61325c81612a0c565b602084015261329a6effffffffffffffffffffffffffffff60808401516060850151176040850151176101008401359060e0850135171711156131db565b6132a382613775565b6132ae818584613836565b97906132df6129346132d4875173ffffffffffffffffffffffffffffffffffffffff1690565b60208801519061546c565b6133db576132ec43600052565b73ffffffffffffffffffffffffffffffffffffffff61332460a0606097015173ffffffffffffffffffffffffffffffffffffffff1690565b166133c1575b505a810360a0840135106133545760809360c092604087015260608601525a900391013501910152565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601e60408201527f41413430206f76657220766572696669636174696f6e4761734c696d6974000060608201520190565b909350816133d2929750858461455c565b9590923861332a565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601a60408201527f4141323520696e76616c6964206163636f756e74206e6f6e636500000000000060608201520190565b9290916000925a825161345b81846136b3565b61346483612a0c565b60208501526134a26effffffffffffffffffffffffffffff60808301516060840151176040840151176101008601359060e0870135171711156131db565b6134ab81613775565b6134b78186868b613ba2565b98906134e86129346134dd865173ffffffffffffffffffffffffffffffffffffffff1690565b60208701519061546c565b6135e0576134f543600052565b73ffffffffffffffffffffffffffffffffffffffff61352d60a0606096015173ffffffffffffffffffffffffffffffffffffffff1690565b166135c5575b505a840360a08601351061355f5750604085015260608401526080919060c0905a900391013501910152565b604080517f220266b600000000000000000000000000000000000000000000000000000000815260048101929092526024820152601e60448201527f41413430206f76657220766572696669636174696f6e4761734c696d697400006064820152608490fd5b909250816135d79298508686856147ef565b96909138613533565b610f21826040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601a60408201527f4141323520696e76616c6964206163636f756e74206e6f6e636500000000000060608201520190565b1561365557565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4141393320696e76616c6964207061796d6173746572416e64446174610000006044820152fd5b613725906136dd6136c38261256d565b73ffffffffffffffffffffffffffffffffffffffff168452565b602081013560208401526080810135604084015260a0810135606084015260c0810135608084015260e081013560c084015261010081013560e0840152610120810190611fc8565b90811561376a5761374f61124c6112468460a09461374a601461044d9998101561364e565b612b88565b73ffffffffffffffffffffffffffffffffffffffff16910152565b505060a06000910152565b60a081015173ffffffffffffffffffffffffffffffffffffffff16156137b75760c060035b60ff60408401519116606084015102016080830151019101510290565b60c0600161379a565b6137d86040929594939560608352606083019061262c565b9460208201520152565b9061044d602f60405180947f414132332072657665727465643a20000000000000000000000000000000000060208301526138268151809260208686019101612067565b810103600f8101855201836105ab565b916000926000925a936139046020835193613865855173ffffffffffffffffffffffffffffffffffffffff1690565b9561387d6138766040830183611fc8565b9084613e0d565b60a086015173ffffffffffffffffffffffffffffffffffffffff16906138a243600052565b85809373ffffffffffffffffffffffffffffffffffffffff809416159889613b3a575b60600151908601516040517f3a871cdd0000000000000000000000000000000000000000000000000000000081529788968795869390600485016137c0565b03938a1690f1829181613b1a575b50613b115750600190613923612d80565b6308c379a014613abd575b50613a50575b613941575b50505a900391565b61396b9073ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b613986610a2c82546dffffffffffffffffffffffffffff1690565b8083116139e3576139dc926dffffffffffffffffffffffffffff9103166dffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffff0000000000000000000000000000825416179055565b3880613939565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601760408201527f41413231206469646e2774207061792070726566756e6400000000000000000060608201520190565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601660408201527f4141323320726576657274656420286f72204f4f47290000000000000000000060608201520190565b613ac5612d9e565b9081613ad1575061392e565b610f2191613adf91506137e2565b6040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301612882565b95506139349050565b613b3391925060203d81116123385761232981836105ab565b9038613912565b9450613b80610a2c613b6c8c73ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b546dffffffffffffffffffffffffffff1690565b8b811115613b975750856060835b969150506138c5565b606087918d03613b8e565b90926000936000935a94613beb6020835193613bd2855173ffffffffffffffffffffffffffffffffffffffff1690565b9561387d613be36040830183611fc8565b90848c61412b565b03938a1690f1829181613ded575b50613de45750600190613c0a612d80565b6308c379a014613d8e575b50613d20575b613c29575b5050505a900391565b613c539073ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b91613c6f610a2c84546dffffffffffffffffffffffffffff1690565b90818311613cba575082547fffffffffffffffffffffffffffffffffffff0000000000000000000000000000169190036dffffffffffffffffffffffffffff16179055388080613c20565b604080517f220266b600000000000000000000000000000000000000000000000000000000815260048101929092526024820152601760448201527f41413231206469646e2774207061792070726566756e640000000000000000006064820152608490fd5b610f21846040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601660408201527f4141323320726576657274656420286f72204f4f47290000000000000000000060608201520190565b613d96612d9e565b9081613da25750613c15565b8691613dae91506137e2565b90610f216040519283927f220266b60000000000000000000000000000000000000000000000000000000084526004840161289a565b9650613c1b9050565b613e0691925060203d81116123385761232981836105ab565b9038613bf9565b909180613e1957505050565b81515173ffffffffffffffffffffffffffffffffffffffff1692833b6140be57606083510151604051907f570e1a3600000000000000000000000000000000000000000000000000000000825260208280613e78878760048401612d2c565b0381600073ffffffffffffffffffffffffffffffffffffffff95867f00000000000000000000000000000000000000000000000000000000000000001690f19182156140b1575b600092614091575b508082169586156140245716809503613fb7573b15613f4a5761124c6112467fd51a9c61267aa6196961883ecf5ff2da6619c37dac0fa92122513fb32c032d2d93613f1193612b88565b602083810151935160a001516040805173ffffffffffffffffffffffffffffffffffffffff9485168152939091169183019190915290a3565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152602060408201527f4141313520696e6974436f6465206d757374206372656174652073656e64657260608201520190565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152602060408201527f4141313420696e6974436f6465206d7573742072657475726e2073656e64657260608201520190565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601b60408201527f4141313320696e6974436f6465206661696c6564206f72204f4f47000000000060608201520190565b6140aa91925060203d811161146a5761145b81836105ab565b9038613ec7565b6140b9612183565b613ebf565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601f60408201527f414131302073656e64657220616c726561647920636f6e73747275637465640060608201520190565b9290918161413a575b50505050565b82515173ffffffffffffffffffffffffffffffffffffffff1693843b6143e257606084510151604051907f570e1a3600000000000000000000000000000000000000000000000000000000825260208280614199888860048401612d2c565b0381600073ffffffffffffffffffffffffffffffffffffffff95867f00000000000000000000000000000000000000000000000000000000000000001690f19182156143d5575b6000926143b5575b5080821696871561434757168096036142d9573b15614273575061124c6112467fd51a9c61267aa6196961883ecf5ff2da6619c37dac0fa92122513fb32c032d2d9361423393612b88565b602083810151935160a001516040805173ffffffffffffffffffffffffffffffffffffffff9485168152939091169183019190915290a338808080614134565b604080517f220266b600000000000000000000000000000000000000000000000000000000815260048101929092526024820152602060448201527f4141313520696e6974436f6465206d757374206372656174652073656e6465726064820152608490fd5b610f21826040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152602060408201527f4141313420696e6974436f6465206d7573742072657475726e2073656e64657260608201520190565b610f21846040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601b60408201527f4141313320696e6974436f6465206661696c6564206f72204f4f47000000000060608201520190565b6143ce91925060203d811161146a5761145b81836105ab565b90386141e8565b6143dd612183565b6141e0565b604080517f220266b600000000000000000000000000000000000000000000000000000000815260048101929092526024820152601f60448201527f414131302073656e64657220616c726561647920636f6e7374727563746564006064820152608490fd5b1561444f57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f4141343120746f6f206c6974746c6520766572696669636174696f6e476173006044820152fd5b919060408382031261035957825167ffffffffffffffff81116103595783019080601f83011215610359578151916144e483610639565b916144f260405193846105ab565b838352602084830101116103595760209261451291848085019101612067565b92015190565b9061044d602f60405180947f414133332072657665727465643a20000000000000000000000000000000000060208301526138268151809260208686019101612067565b93919260609460009460009380519261459b60a08a86015195614580888811614448565b015173ffffffffffffffffffffffffffffffffffffffff1690565b916145c68373ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b946145e2610a2c87546dffffffffffffffffffffffffffff1690565b968588106147825773ffffffffffffffffffffffffffffffffffffffff60208a98946146588a966dffffffffffffffffffffffffffff8b6146919e03166dffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffff0000000000000000000000000000825416179055565b015194604051998a98899788937ff465c77e000000000000000000000000000000000000000000000000000000008552600485016137c0565b0395169103f190818391849361475c575b506147555750506001906146b4612d80565b6308c379a014614733575b506146c657565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601660408201527f4141333320726576657274656420286f72204f4f47290000000000000000000060608201520190565b61473b612d9e565b908161474757506146bf565b610f2191613adf9150614518565b9450925050565b90925061477b91503d8085833e61477381836105ab565b8101906144ad565b91386146a2565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601e60408201527f41413331207061796d6173746572206465706f73697420746f6f206c6f77000060608201520190565b91949293909360609560009560009382519061481660a08b84015193614580848611614448565b936148418573ffffffffffffffffffffffffffffffffffffffff166000526000602052604060002090565b61485c610a2c82546dffffffffffffffffffffffffffff1690565b8781106149b7579273ffffffffffffffffffffffffffffffffffffffff60208a989693946146588a966dffffffffffffffffffffffffffff8d6148d69e9c9a03166dffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffff0000000000000000000000000000825416179055565b0395169103f1908183918493614999575b506149915750506001906148f9612d80565b6308c379a014614972575b5061490c5750565b604080517f220266b600000000000000000000000000000000000000000000000000000000815260048101929092526024820152601660448201527f4141333320726576657274656420286f72204f4f4729000000000000000000006064820152608490fd5b61497a612d9e565b90816149865750614904565b613dae925050614518565b955093505050565b9092506149b091503d8085833e61477381836105ab565b91386148e7565b610f218a6040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601e60408201527f41413331207061796d6173746572206465706f73697420746f6f206c6f77000060608201520190565b60031115614a2f57565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b929190614a7c6040916002865260606020870152606086019061208a565b930152565b939291906003811015614a2f57604091614a7c91865260606020870152606086019061208a565b9061044d603660405180947f4141353020706f73744f702072657665727465643a20000000000000000000006020830152614aec8151809260208686019101612067565b81010360168101855201836105ab565b929190925a93600091805191614b1183615318565b9260a0810195614b35875173ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff93908481169081614ca457505050614b76825173ffffffffffffffffffffffffffffffffffffffff1690565b985b5a90030193840297604084019089825110614c37577f49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f94614bc26020928c614c329551039061553a565b015194896020614c04614be9865173ffffffffffffffffffffffffffffffffffffffff1690565b9a5173ffffffffffffffffffffffffffffffffffffffff1690565b9401519785604051968796169a16988590949392606092608083019683521515602083015260408201520152565b0390a4565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152602060408201527f414135312070726566756e642062656c6f772061637475616c476173436f737460608201520190565b9a918051614cb4575b5050614b78565b6060850151600099509091803b15614ddb579189918983614d07956040518097819682957fa9a234090000000000000000000000000000000000000000000000000000000084528c029060048401614a5e565b0393f19081614dc8575b50614dc3576001614d20612d80565b6308c379a014614da4575b614d37575b3880614cad565b6040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601260408201527f4141353020706f73744f7020726576657274000000000000000000000000000060608201520190565b614dac612d9e565b80614db75750614d2b565b613adf610f2191614aa8565b614d30565b80610f48614dd59261057b565b38614d11565b8980fd5b9392915a90600092805190614df382615318565b9360a0830196614e17885173ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff95908681169081614f0d57505050614e58845173ffffffffffffffffffffffffffffffffffffffff1690565b915b5a9003019485029860408301908a825110614ea757507f49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f949392614bc2614c32938c60209451039061553a565b604080517f220266b600000000000000000000000000000000000000000000000000000000815260048101929092526024820152602060448201527f414135312070726566756e642062656c6f772061637475616c476173436f73746064820152608490fd5b93918051614f1d575b5050614e5a565b606087015160009a509091803b1561504357918a918a83614f70956040518097819682957fa9a234090000000000000000000000000000000000000000000000000000000084528c029060048401614a5e565b0393f19081615030575b5061502b576001614f89612d80565b6308c379a01461500e575b614fa0575b3880614f16565b610f218b6040519182917f220266b600000000000000000000000000000000000000000000000000000000835260048301608091815260406020820152601260408201527f4141353020706f73744f7020726576657274000000000000000000000000000060608201520190565b615016612d9e565b806150215750614f94565b613dae8d91614aa8565b614f99565b80610f4861503d9261057b565b38614f7a565b8a80fd5b909392915a9480519161505983615318565b9260a081019561507d875173ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff938185169182615165575050506150bd825173ffffffffffffffffffffffffffffffffffffffff1690565b985b5a90030193840297604084019089825110614c37577f49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f946151096020928c614c329551039061553a565b61511288614a25565b015194896020615139614be9865173ffffffffffffffffffffffffffffffffffffffff1690565b940151604080519182529815602082015297880152606087015290821695909116939081906080820190565b9a918151615175575b50506150bf565b8784026151818a614a25565b60028a1461520c576060860151823b15610359576151d493600080948d604051978896879586937fa9a2340900000000000000000000000000000000000000000000000000000000855260048501614a81565b0393f180156151ff575b6151ec575b505b388061516e565b80610f486151f99261057b565b386151e3565b615207612183565b6151de565b6060860151823b156103595761525793600080948d604051978896879586937fa9a2340900000000000000000000000000000000000000000000000000000000855260048501614a81565b0393f19081615305575b50615300576001615270612d80565b6308c379a0146152ed575b156151e5576040517f220266b600000000000000000000000000000000000000000000000000000000815280610f21600482016080906000815260406020820152601260408201527f4141353020706f73744f7020726576657274000000000000000000000000000060608201520190565b6152f5612d9e565b80614db7575061527b565b6151e5565b80610f486153129261057b565b38615261565b60e060c082015191015180821461533c57480180821015615337575090565b905090565b5090565b6040519061534d8261058f565b60006040838281528260208201520152565b615367615340565b5065ffffffffffff808260a01c1680156153b3575b604051926153898461058f565b73ffffffffffffffffffffffffffffffffffffffff8116845260d01c602084015216604082015290565b508061537c565b6153cf6153d5916153c9615340565b5061535f565b9161535f565b9073ffffffffffffffffffffffffffffffffffffffff9182825116928315615461575b65ffffffffffff928391826040816020850151169301511693836040816020840151169201511690808410615459575b50808511615451575b506040519561543f8761058f565b16855216602084015216604082015290565b935038615431565b925038615428565b8151811693506153f8565b73ffffffffffffffffffffffffffffffffffffffff16600052600160205267ffffffffffffffff6154c88260401c60406000209077ffffffffffffffffffffffffffffffffffffffffffffffff16600052602052604060002090565b918254926154d584612491565b9055161490565b9073ffffffffffffffffffffffffffffffffffffffff6154fa612b50565b9216600052600060205263ffffffff600160406000206dffffffffffffffffffffffffffff815460781c1685520154166020830152565b61044d3361562b565b73ffffffffffffffffffffffffffffffffffffffff16600052600060205260406000206dffffffffffffffffffffffffffff8082541692830180931161561e575b8083116155c05761044d92166dffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffff0000000000000000000000000000825416179055565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f6465706f736974206f766572666c6f77000000000000000000000000000000006044820152fd5b615626612190565b61557b565b73ffffffffffffffffffffffffffffffffffffffff9061564b348261553a565b168060005260006020527f2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c460206dffffffffffffffffffffffffffff60406000205416604051908152a2565b1561569e57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f6d757374207370656369667920756e7374616b652064656c61790000000000006044820152fd5b1561570357565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f63616e6e6f7420646563726561736520756e7374616b652074696d65000000006044820152fd5b1561576857565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f6e6f207374616b652073706563696669656400000000000000000000000000006044820152fd5b156157cd57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f7374616b65206f766572666c6f770000000000000000000000000000000000006044820152fd5b9065ffffffffffff6080600161044d9461588b6dffffffffffffffffffffffffffff86511682906dffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffff0000000000000000000000000000825416179055565b602085015115156eff000000000000000000000000000082549160701b16807fffffffffffffffffffffffffffffffffff00ffffffffffffffffffffffffffff83161783557fffffff000000000000000000000000000000ffffffffffffffffffffffffffff7cffffffffffffffffffffffffffff000000000000000000000000000000604089015160781b16921617178155019263ffffffff6060820151167fffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000008554161784550151167fffffffffffffffffffffffffffffffffffffffffffff000000000000ffffffff69ffffffffffff0000000083549260201b169116179055565b1561599657565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f616c726561647920756e7374616b696e670000000000000000000000000000006044820152fd5b91909165ffffffffffff808094169116019182116121cd57565b15615a1557565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f207374616b6520746f2077697468647261770000000000000000000000006044820152fd5b15615a7a57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f6d7573742063616c6c20756e6c6f636b5374616b6528292066697273740000006044820152fd5b15615adf57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f5374616b65207769746864726177616c206973206e6f742064756500000000006044820152fd5b15615b4457565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f6661696c656420746f207769746864726177207374616b6500000000000000006044820152fd5b15615ba957565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f6661696c656420746f20776974686472617700000000000000000000000000006044820152fd5b816040519182372090565b9060009283809360208451940192f190565b3d610800808211615c4b575b50604051906020818301016040528082526000602083013e90565b905038615c3056fea2646970667358221220a706d8b02d7086d80e9330811f5af84b2614abdc5e9a1f2260126070a31d7cee64736f6c634300081100336080806040523461001657610210908161001c8239f35b600080fdfe6080604052600436101561001257600080fd5b6000803560e01c63570e1a361461002857600080fd5b346100c95760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100c95760043567ffffffffffffffff918282116100c957366023830112156100c95781600401359283116100c95736602484840101116100c9576100c561009e84602485016100fc565b60405173ffffffffffffffffffffffffffffffffffffffff90911681529081906020820190565b0390f35b80fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b90806014116101bb5767ffffffffffffffff917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec82018381116101cd575b604051937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f81600b8701160116850190858210908211176101c0575b604052808452602084019036848401116101bb576020946000600c819682946014880187378301015251923560601c5af19060005191156101b557565b60009150565b600080fd5b6101c86100cc565b610178565b6101d56100cc565b61013a56fea26469706673582212201927e80b76ab9b71c952137dd676621a9fdf520c25928815636594036eb1c40364736f6c63430008110033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var EntryPoint__factory = (
      /** @class */
      function(_super) {
        __extends(EntryPoint__factory2, _super);
        function EntryPoint__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        EntryPoint__factory2.prototype.deploy = function(overrides) {
          return _super.prototype.deploy.call(this, overrides || {});
        };
        EntryPoint__factory2.prototype.getDeployTransaction = function(overrides) {
          return _super.prototype.getDeployTransaction.call(this, overrides || {});
        };
        EntryPoint__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        EntryPoint__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        EntryPoint__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        EntryPoint__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        EntryPoint__factory2.bytecode = _bytecode;
        EntryPoint__factory2.abi = _abi;
        return EntryPoint__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.EntryPoint__factory = EntryPoint__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/IAccount__factory.js
var require_IAccount_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/IAccount__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.IAccount__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "missingAccountFunds",
            type: "uint256"
          }
        ],
        name: "validateUserOp",
        outputs: [
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var IAccount__factory = (
      /** @class */
      function() {
        function IAccount__factory2() {
        }
        IAccount__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        IAccount__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        IAccount__factory2.abi = _abi;
        return IAccount__factory2;
      }()
    );
    exports2.IAccount__factory = IAccount__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/IAggregator__factory.js
var require_IAggregator_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/IAggregator__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.IAggregator__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation[]",
            name: "userOps",
            type: "tuple[]"
          }
        ],
        name: "aggregateSignatures",
        outputs: [
          {
            internalType: "bytes",
            name: "aggregatedSignature",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation[]",
            name: "userOps",
            type: "tuple[]"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        name: "validateSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          }
        ],
        name: "validateUserOpSignature",
        outputs: [
          {
            internalType: "bytes",
            name: "sigForUserOp",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var IAggregator__factory = (
      /** @class */
      function() {
        function IAggregator__factory2() {
        }
        IAggregator__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        IAggregator__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        IAggregator__factory2.abi = _abi;
        return IAggregator__factory2;
      }()
    );
    exports2.IAggregator__factory = IAggregator__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/IEntryPoint__factory.js
var require_IEntryPoint_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/IEntryPoint__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.IEntryPoint__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "uint256",
            name: "preOpGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "paid",
            type: "uint256"
          },
          {
            internalType: "uint48",
            name: "validAfter",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "validUntil",
            type: "uint48"
          },
          {
            internalType: "bool",
            name: "targetSuccess",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "targetResult",
            type: "bytes"
          }
        ],
        name: "ExecutionResult",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "opIndex",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "reason",
            type: "string"
          }
        ],
        name: "FailedOp",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "SenderAddressResult",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "aggregator",
            type: "address"
          }
        ],
        name: "SignatureValidationFailed",
        type: "error"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "bool",
                name: "sigFailed",
                type: "bool"
              },
              {
                internalType: "uint48",
                name: "validAfter",
                type: "uint48"
              },
              {
                internalType: "uint48",
                name: "validUntil",
                type: "uint48"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          }
        ],
        name: "ValidationResult",
        type: "error"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "prefund",
                type: "uint256"
              },
              {
                internalType: "bool",
                name: "sigFailed",
                type: "bool"
              },
              {
                internalType: "uint48",
                name: "validAfter",
                type: "uint48"
              },
              {
                internalType: "uint48",
                name: "validUntil",
                type: "uint48"
              },
              {
                internalType: "bytes",
                name: "paymasterContext",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.ReturnInfo",
            name: "returnInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "senderInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "factoryInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "stake",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            internalType: "struct IStakeManager.StakeInfo",
            name: "paymasterInfo",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "aggregator",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "uint256",
                    name: "stake",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "unstakeDelaySec",
                    type: "uint256"
                  }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "stakeInfo",
                type: "tuple"
              }
            ],
            internalType: "struct IEntryPoint.AggregatorStakeInfo",
            name: "aggregatorInfo",
            type: "tuple"
          }
        ],
        name: "ValidationResultWithAggregation",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "factory",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "paymaster",
            type: "address"
          }
        ],
        name: "AccountDeployed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "BeforeExecution",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalDeposit",
            type: "uint256"
          }
        ],
        name: "Deposited",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "aggregator",
            type: "address"
          }
        ],
        name: "SignatureAggregatorChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalStaked",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        name: "StakeLocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "withdrawTime",
            type: "uint256"
          }
        ],
        name: "StakeUnlocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "StakeWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "paymaster",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "actualGasUsed",
            type: "uint256"
          }
        ],
        name: "UserOperationEvent",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "revertReason",
            type: "bytes"
          }
        ],
        name: "UserOperationRevertReason",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrawn",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "_unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "depositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getDepositInfo",
        outputs: [
          {
            components: [
              {
                internalType: "uint112",
                name: "deposit",
                type: "uint112"
              },
              {
                internalType: "bool",
                name: "staked",
                type: "bool"
              },
              {
                internalType: "uint112",
                name: "stake",
                type: "uint112"
              },
              {
                internalType: "uint32",
                name: "unstakeDelaySec",
                type: "uint32"
              },
              {
                internalType: "uint48",
                name: "withdrawTime",
                type: "uint48"
              }
            ],
            internalType: "struct IStakeManager.DepositInfo",
            name: "info",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          }
        ],
        name: "getSenderAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          }
        ],
        name: "getUserOpHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "sender",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "nonce",
                    type: "uint256"
                  },
                  {
                    internalType: "bytes",
                    name: "initCode",
                    type: "bytes"
                  },
                  {
                    internalType: "bytes",
                    name: "callData",
                    type: "bytes"
                  },
                  {
                    internalType: "uint256",
                    name: "callGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "verificationGasLimit",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "preVerificationGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "maxPriorityFeePerGas",
                    type: "uint256"
                  },
                  {
                    internalType: "bytes",
                    name: "paymasterAndData",
                    type: "bytes"
                  },
                  {
                    internalType: "bytes",
                    name: "signature",
                    type: "bytes"
                  }
                ],
                internalType: "struct UserOperation[]",
                name: "userOps",
                type: "tuple[]"
              },
              {
                internalType: "contract IAggregator",
                name: "aggregator",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
            name: "opsPerAggregator",
            type: "tuple[]"
          },
          {
            internalType: "address payable",
            name: "beneficiary",
            type: "address"
          }
        ],
        name: "handleAggregatedOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation[]",
            name: "ops",
            type: "tuple[]"
          },
          {
            internalType: "address payable",
            name: "beneficiary",
            type: "address"
          }
        ],
        name: "handleOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "incrementNonce",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "op",
            type: "tuple"
          },
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "targetCallData",
            type: "bytes"
          }
        ],
        name: "simulateHandleOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          }
        ],
        name: "simulateValidation",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "withdrawAmount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var IEntryPoint__factory = (
      /** @class */
      function() {
        function IEntryPoint__factory2() {
        }
        IEntryPoint__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        IEntryPoint__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        IEntryPoint__factory2.abi = _abi;
        return IEntryPoint__factory2;
      }()
    );
    exports2.IEntryPoint__factory = IEntryPoint__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/INonceManager__factory.js
var require_INonceManager_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/INonceManager__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.INonceManager__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "incrementNonce",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var INonceManager__factory = (
      /** @class */
      function() {
        function INonceManager__factory2() {
        }
        INonceManager__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        INonceManager__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        INonceManager__factory2.abi = _abi;
        return INonceManager__factory2;
      }()
    );
    exports2.INonceManager__factory = INonceManager__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/IPaymaster__factory.js
var require_IPaymaster_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/IPaymaster__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.IPaymaster__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "enum IPaymaster.PostOpMode",
            name: "mode",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          }
        ],
        name: "postOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "maxCost",
            type: "uint256"
          }
        ],
        name: "validatePaymasterUserOp",
        outputs: [
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var IPaymaster__factory = (
      /** @class */
      function() {
        function IPaymaster__factory2() {
        }
        IPaymaster__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        IPaymaster__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        IPaymaster__factory2.abi = _abi;
        return IPaymaster__factory2;
      }()
    );
    exports2.IPaymaster__factory = IPaymaster__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/IStakeManager__factory.js
var require_IStakeManager_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/IStakeManager__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.IStakeManager__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalDeposit",
            type: "uint256"
          }
        ],
        name: "Deposited",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalStaked",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        name: "StakeLocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "withdrawTime",
            type: "uint256"
          }
        ],
        name: "StakeUnlocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "StakeWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrawn",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "_unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "depositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getDepositInfo",
        outputs: [
          {
            components: [
              {
                internalType: "uint112",
                name: "deposit",
                type: "uint112"
              },
              {
                internalType: "bool",
                name: "staked",
                type: "bool"
              },
              {
                internalType: "uint112",
                name: "stake",
                type: "uint112"
              },
              {
                internalType: "uint32",
                name: "unstakeDelaySec",
                type: "uint32"
              },
              {
                internalType: "uint48",
                name: "withdrawTime",
                type: "uint48"
              }
            ],
            internalType: "struct IStakeManager.DepositInfo",
            name: "info",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "withdrawAmount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var IStakeManager__factory = (
      /** @class */
      function() {
        function IStakeManager__factory2() {
        }
        IStakeManager__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        IStakeManager__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        IStakeManager__factory2.abi = _abi;
        return IStakeManager__factory2;
      }()
    );
    exports2.IStakeManager__factory = IStakeManager__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/MaliciousAccount__factory.js
var require_MaliciousAccount_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/MaliciousAccount__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.MaliciousAccount__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "_ep",
            type: "address"
          }
        ],
        stateMutability: "payable",
        type: "constructor"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "missingAccountFunds",
            type: "uint256"
          }
        ],
        name: "validateUserOp",
        outputs: [
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x60806040526040516103ec3803806103ec83398101604081905261002291610047565b600080546001600160a01b0319166001600160a01b0392909216919091179055610077565b60006020828403121561005957600080fd5b81516001600160a01b038116811461007057600080fd5b9392505050565b610366806100866000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80633a871cdd14610030575b600080fd5b61004361003e3660046101be565b610055565b60405190815260200160405180910390f35b600080546040517fb760faf900000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff9091169063b760faf99084906024016000604051808303818588803b1580156100c257600080fd5b505af11580156100d6573d6000803e3d6000fd5b50505050506000848061014001906100ee9190610212565b8101906100fb919061027e565b9050600060c086013561011660a088013560808901356102c6565b61012091906102c6565b9050600061012e82866102de565b9050600061014161010089013583610319565b90508381146101b0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f5265766572742061667465722066697273742076616c69646174696f6e000000604482015260640160405180910390fd5b506000979650505050505050565b6000806000606084860312156101d357600080fd5b833567ffffffffffffffff8111156101ea57600080fd5b840161016081870312156101fd57600080fd5b95602085013595506040909401359392505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261024757600080fd5b83018035915067ffffffffffffffff82111561026257600080fd5b60200191503681900382131561027757600080fd5b9250929050565b60006020828403121561029057600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082198211156102d9576102d9610297565b500190565b600082610314577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60008282101561032b5761032b610297565b50039056fea26469706673582212207a8e78673a414e5633ca0da4ad76d63f65bd0d2c09da97ae1b26e837ad5870da64736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var MaliciousAccount__factory = (
      /** @class */
      function(_super) {
        __extends(MaliciousAccount__factory2, _super);
        function MaliciousAccount__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        MaliciousAccount__factory2.prototype.deploy = function(_ep, overrides) {
          return _super.prototype.deploy.call(this, _ep, overrides || {});
        };
        MaliciousAccount__factory2.prototype.getDeployTransaction = function(_ep, overrides) {
          return _super.prototype.getDeployTransaction.call(this, _ep, overrides || {});
        };
        MaliciousAccount__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        MaliciousAccount__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        MaliciousAccount__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        MaliciousAccount__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        MaliciousAccount__factory2.bytecode = _bytecode;
        MaliciousAccount__factory2.abi = _abi;
        return MaliciousAccount__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.MaliciousAccount__factory = MaliciousAccount__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/NonceManager__factory.js
var require_NonceManager_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/NonceManager__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.NonceManager__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint192",
            name: "key",
            type: "uint192"
          }
        ],
        name: "incrementNonce",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint192",
            name: "",
            type: "uint192"
          }
        ],
        name: "nonceSequenceNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var _bytecode = "0x608060405234801561001057600080fd5b50610291806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80630bd28e3b146100465780631b2e01b81461005b57806335567e1a14610095575b600080fd5b61005961005436600461018c565b610119565b005b6100836100693660046101ae565b600060208181529281526040808220909352908152205481565b60405190815260200160405180910390f35b6100836100a33660046101ae565b73ffffffffffffffffffffffffffffffffffffffff9190911660009081526020818152604080832077ffffffffffffffffffffffffffffffffffffffffffffffff85168452909152908190205491901b7fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000161790565b3360009081526020818152604080832077ffffffffffffffffffffffffffffffffffffffffffffffff851684529091528120805491610157836101fc565b919050555050565b803577ffffffffffffffffffffffffffffffffffffffffffffffff8116811461018757600080fd5b919050565b60006020828403121561019e57600080fd5b6101a78261015f565b9392505050565b600080604083850312156101c157600080fd5b823573ffffffffffffffffffffffffffffffffffffffff811681146101e557600080fd5b91506101f36020840161015f565b90509250929050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610254577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b506001019056fea2646970667358221220246a8c46e38a8c9811f06ac9a289595dfd8b2edbad85f35b8e177f24d26fe20664736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var NonceManager__factory = (
      /** @class */
      function(_super) {
        __extends(NonceManager__factory2, _super);
        function NonceManager__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        NonceManager__factory2.prototype.deploy = function(overrides) {
          return _super.prototype.deploy.call(this, overrides || {});
        };
        NonceManager__factory2.prototype.getDeployTransaction = function(overrides) {
          return _super.prototype.getDeployTransaction.call(this, overrides || {});
        };
        NonceManager__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        NonceManager__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        NonceManager__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        NonceManager__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        NonceManager__factory2.bytecode = _bytecode;
        NonceManager__factory2.abi = _abi;
        return NonceManager__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.NonceManager__factory = NonceManager__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/SenderCreator__factory.js
var require_SenderCreator_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/SenderCreator__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.SenderCreator__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          }
        ],
        name: "createSender",
        outputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x608060405234801561001057600080fd5b50610213806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063570e1a3614610030575b600080fd5b61004361003e3660046100f9565b61006c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b60008061007c601482858761016b565b61008591610195565b60601c90506000610099846014818861016b565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525084519495509360209350849250905082850182875af190506000519350806100f057600093505b50505092915050565b6000806020838503121561010c57600080fd5b823567ffffffffffffffff8082111561012457600080fd5b818501915085601f83011261013857600080fd5b81358181111561014757600080fd5b86602082850101111561015957600080fd5b60209290920196919550909350505050565b6000808585111561017b57600080fd5b8386111561018857600080fd5b5050820193919092039150565b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000081358181169160148510156101d55780818660140360031b1b83161692505b50509291505056fea2646970667358221220d5d7cb55b3123d86b2710028be2074a469cca162ad2a26c50fb1cfdce4424b9464736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var SenderCreator__factory = (
      /** @class */
      function(_super) {
        __extends(SenderCreator__factory2, _super);
        function SenderCreator__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        SenderCreator__factory2.prototype.deploy = function(overrides) {
          return _super.prototype.deploy.call(this, overrides || {});
        };
        SenderCreator__factory2.prototype.getDeployTransaction = function(overrides) {
          return _super.prototype.getDeployTransaction.call(this, overrides || {});
        };
        SenderCreator__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        SenderCreator__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        SenderCreator__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        SenderCreator__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        SenderCreator__factory2.bytecode = _bytecode;
        SenderCreator__factory2.abi = _abi;
        return SenderCreator__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.SenderCreator__factory = SenderCreator__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/SimpleAccount__factory.js
var require_SimpleAccount_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/SimpleAccount__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.SimpleAccount__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "anEntryPoint",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "previousAdmin",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "newAdmin",
            type: "address"
          }
        ],
        name: "AdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "beacon",
            type: "address"
          }
        ],
        name: "BeaconUpgraded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "contract IEntryPoint",
            name: "entryPoint",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "SimpleAccountInitialized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        name: "Upgraded",
        type: "event"
      },
      {
        inputs: [],
        name: "addDeposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "dest",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "func",
            type: "bytes"
          }
        ],
        name: "execute",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "dest",
            type: "address[]"
          },
          {
            internalType: "bytes[]",
            name: "func",
            type: "bytes[]"
          }
        ],
        name: "executeBatch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "anOwner",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "proxiableUUID",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newImplementation",
            type: "address"
          }
        ],
        name: "upgradeTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newImplementation",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "upgradeToAndCall",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "missingAccountFunds",
            type: "uint256"
          }
        ],
        name: "validateUserOp",
        outputs: [
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawDepositTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var _bytecode = "0x60c0346200016857601f6200229938819003918201601f19168301916001600160401b038311848410176200016d578084926020946040528339810103126200016857516001600160a01b038116810362000168573060805260a05260005460ff8160081c16620001135760ff80821610620000d7575b60405161211590816200018482396080518181816105e301528181610c290152610e06015260a051818181610802015281816108fb015281816109e401528181610f7d01528181611174015281816113c001528181611c040152611c630152f35b60ff90811916176000557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160ff8152a13862000076565b60405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b6064820152608490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe6080604052600436101561001b575b361561001957600080fd5b005b60003560e01c806223de291461018257806301ffc9a714610179578063150b7a021461017057806318dfb3c7146101675780633659cfe61461015e5780633a871cdd146101555780634a58db191461014c5780634d44560d146101435780634f1ef2861461013a57806352d1902d146101315780638da5cb5b14610128578063b0d691fe1461011f578063b61d27f614610116578063bc197c811461010d578063c399ec8814610104578063c4d66de8146100fb578063d087d288146100f25763f23a6e610361000e576100ed61142e565b61000e565b506100ed61133d565b506100ed6111d9565b506100ed6110fa565b506100ed611032565b506100ed610fa1565b506100ed610f31565b506100ed610edb565b506100ed610dbf565b506100ed610ba7565b506100ed610985565b506100ed6108b8565b506100ed61079a565b506100ed61058e565b506100ed61041c565b506100ed610359565b506100ed610268565b506100ed6101dc565b73ffffffffffffffffffffffffffffffffffffffff8116036101a957565b600080fd5b9181601f840112156101a95782359167ffffffffffffffff83116101a957602083818601950101116101a957565b50346101a95760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a95761021760043561018b565b61022260243561018b565b61022d60443561018b565b67ffffffffffffffff6084358181116101a95761024e9036906004016101ae565b505060a4359081116101a9576100199036906004016101ae565b50346101a95760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a9576004357fffffffff0000000000000000000000000000000000000000000000000000000081168091036101a957807f150b7a02000000000000000000000000000000000000000000000000000000006020921490811561032f575b8115610305575b506040519015158152f35b7f01ffc9a700000000000000000000000000000000000000000000000000000000915014386102fa565b7f4e2312e000000000000000000000000000000000000000000000000000000000811491506102f3565b50346101a95760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a95761039460043561018b565b61039f60243561018b565b60643567ffffffffffffffff81116101a9576103bf9036906004016101ae565b505060206040517f150b7a02000000000000000000000000000000000000000000000000000000008152f35b9181601f840112156101a95782359167ffffffffffffffff83116101a9576020808501948460051b0101116101a957565b50346101a95760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a95767ffffffffffffffff600480358281116101a95761046d90369083016103eb565b60249291929384359081116101a95761048990369084016103eb565b610491611c4b565b8083036105315760005b8381106104a457005b6104d56104ba6104b583878a611a71565b611a8f565b6104cf6104c8848688611aea565b3691610b70565b9061202c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146105045760010161049b565b866011867f4e487b7100000000000000000000000000000000000000000000000000000000600052526000fd5b6064846013886020604051937f08c379a00000000000000000000000000000000000000000000000000000000085528401528201527f77726f6e67206172726179206c656e67746873000000000000000000000000006044820152fd5b50346101a95760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a9576004356105ca8161018b565b73ffffffffffffffffffffffffffffffffffffffff90817f00000000000000000000000000000000000000000000000000000000000000001691610610833014156114c0565b61063f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc93828554161461154b565b61064761204c565b6040519061065482610aae565b600082527f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff161561068e575050610019915061167d565b6020600491604094939451928380927f52d1902d00000000000000000000000000000000000000000000000000000000825286165afa6000918161076a575b50610757576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201527f6f6e206973206e6f7420555550530000000000000000000000000000000000006064820152608490fd5b6100199361076591146115f2565b611769565b61078c91925060203d8111610793575b6107848183610ae6565b8101906115d6565b90386106cd565b503d61077a565b50346101a9577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc6060813601126101a9576004359067ffffffffffffffff82116101a9576101609082360301126101a95773ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016330361085a5761083b6108569160243590600401611d04565b610846604435611a07565b6040519081529081906020820190565b0390f35b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6163636f756e743a206e6f742066726f6d20456e747279506f696e74000000006044820152fd5b506000807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126109825773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001681813b1561098257602491604051928380927fb760faf900000000000000000000000000000000000000000000000000000000825230600483015234905af18015610975575b610969575080f35b61097290610a8d565b80f35b61097d6115e5565b610961565b80fd5b50346101a957600060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610982576004356109c38161018b565b6109cb61204c565b8173ffffffffffffffffffffffffffffffffffffffff807f00000000000000000000000000000000000000000000000000000000000000001692833b15610a59576044908360405195869485937f205c287800000000000000000000000000000000000000000000000000000000855216600484015260243560248401525af1801561097557610969575080f35b8280fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff8111610aa157604052565b610aa9610a5d565b604052565b6020810190811067ffffffffffffffff821117610aa157604052565b6060810190811067ffffffffffffffff821117610aa157604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610aa157604052565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209267ffffffffffffffff8111610b63575b01160190565b610b6b610a5d565b610b5d565b929192610b7c82610b27565b91610b8a6040519384610ae6565b8294818452818301116101a9578281602093846000960137010152565b5060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a957600435610bde8161018b565b60243567ffffffffffffffff81116101a957366023820112156101a957610c0f903690602481600401359101610b70565b9073ffffffffffffffffffffffffffffffffffffffff91827f00000000000000000000000000000000000000000000000000000000000000001692610c56843014156114c0565b610c857f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc94828654161461154b565b610c8d61204c565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615610cc3575050610019915061167d565b6020600491604094939451928380927f52d1902d00000000000000000000000000000000000000000000000000000000825286165afa60009181610d9f575b50610d8c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201527f6f6e206973206e6f7420555550530000000000000000000000000000000000006064820152608490fd5b61001993610d9a91146115f2565b611848565b610db891925060203d8111610793576107848183610ae6565b9038610d02565b50346101a95760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a95773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610e57576040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152602090f35b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c00000000000000006064820152fd5b50346101a95760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a957602073ffffffffffffffffffffffffffffffffffffffff60005460101c16604051908152f35b50346101a95760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a957602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346101a95760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a957600435610fdd8161018b565b60443567ffffffffffffffff81116101a95760009161100c611004849336906004016101ae565b6104c8611c4b565b9060208251920190602435905af16110226118a8565b901561102a57005b602081519101fd5b50346101a95760a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a95761106d60043561018b565b61107860243561018b565b67ffffffffffffffff6044358181116101a9576110999036906004016103eb565b50506064358181116101a9576110b39036906004016103eb565b50506084359081116101a9576110cd9036906004016101ae565b50506040517fbc197c81000000000000000000000000000000000000000000000000000000008152602090f35b50346101a95760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a95760206040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152818160248173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa9081156111cc575b6000916111af575b50604051908152f35b6111c69150823d8111610793576107848183610ae6565b386111a6565b6111d46115e5565b61119e565b50346101a95760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a9576004356112158161018b565b6112776000549161123d60ff8460081c16158094819561132f575b811561130f575b50611b14565b8261126e60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff006000541617600055565b6112d957611b9f565b61127d57005b6112aa7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff60005416600055565b604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a1005b61130a6101007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff6000541617600055565b611b9f565b303b15915081611321575b5038611237565b6001915060ff16143861131a565b600160ff8216109150611230565b50346101a95760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a9576108566040517f35567e1a0000000000000000000000000000000000000000000000000000000081523060048201526000602482015260208160448173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa908115611421575b600091611403575b506040519081529081906020820190565b61141b915060203d8111610793576107848183610ae6565b386113f2565b6114296115e5565b6113ea565b50346101a95760a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a95761146960043561018b565b61147460243561018b565b60843567ffffffffffffffff81116101a9576114949036906004016101ae565b505060206040517ff23a6e61000000000000000000000000000000000000000000000000000000008152f35b156114c757565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152fd5b1561155257565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f787900000000000000000000000000000000000000006064820152fd5b908160209103126101a9575190565b506040513d6000823e3d90fd5b156115f957565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f7860448201527f6961626c655555494400000000000000000000000000000000000000000000006064820152fd5b803b156116e55773ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc91167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152fd5b906117738261167d565b73ffffffffffffffffffffffffffffffffffffffff82167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a2805115801590611840575b6117c2575050565b61183d91600080604051936117d685610aca565b602785527f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c60208601527f206661696c6564000000000000000000000000000000000000000000000000006040860152602081519101845af46118376118a8565b9161193d565b50565b5060006117ba565b906118528261167d565b73ffffffffffffffffffffffffffffffffffffffff82167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a28051158015906118a0576117c2575050565b5060016117ba565b3d156118d3573d906118b982610b27565b916118c76040519384610ae6565b82523d6000602084013e565b606090565b156118df57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152fd5b919290156119605750815115611951575090565b61195d903b15156118d8565b90565b8251909150156119735750805190602001fd5b604051907f08c379a000000000000000000000000000000000000000000000000000000000825281602080600483015282519283602484015260005b8481106119f0575050507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f836000604480968601015201168101030190fd5b8181018301518682016044015285935082016119af565b80611a0f5750565b600080808093337ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff15061183d6118a8565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9190811015611a82575b60051b0190565b611a8a611a41565b611a7b565b3561195d8161018b565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1813603018212156101a9570180359067ffffffffffffffff82116101a9576020019181360383136101a957565b9091611b0392811015611b07575b60051b810190611a99565b9091565b611b0f611a41565b611af8565b15611b1b57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152fd5b7fffffffffffffffffffff0000000000000000000000000000000000000000ffff75ffffffffffffffffffffffffffffffffffffffff00006000549260101b169116178060005573ffffffffffffffffffffffffffffffffffffffff809160101c16907f0000000000000000000000000000000000000000000000000000000000000000167f47e55c76e7a6f1fd8996a1da8008c1ea29699cca35e7bcd057f2dec313b6e5de600080a3565b73ffffffffffffffffffffffffffffffffffffffff807f0000000000000000000000000000000000000000000000000000000000000000163314908115611cf3575b5015611c9557565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602060248201527f6163636f756e743a206e6f74204f776e6572206f7220456e747279506f696e746044820152fd5b905060005460101c16331438611c8d565b9060405160208101917f19457468657265756d205369676e6564204d6573736167653a0a3332000000008352603c820152603c8152611d4281610aca565b519020611d89611d8173ffffffffffffffffffffffffffffffffffffffff92611d7b6104c88560005460101c1696610140810190611a99565b90611f5b565b919091611dd2565b1603611d9457600090565b600190565b60051115611da357565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b611ddb81611d99565b80611de35750565b611dec81611d99565b60018103611e53576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606490fd5b611e5c81611d99565b60028103611ec3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606490fd5b80611ecf600392611d99565b14611ed657565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c60448201527f75650000000000000000000000000000000000000000000000000000000000006064820152608490fd5b906041815114600014611f8557611b03916020820151906060604084015193015160001a90611f8f565b5050600090600290565b9291907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083116120205791608094939160ff602094604051948552168484015260408301526060820152600093849182805260015afa15612013575b815173ffffffffffffffffffffffffffffffffffffffff81161561200d579190565b50600190565b61201b6115e5565b611feb565b50505050600090600390565b600091829182602083519301915af16120436118a8565b901561102a5750565b73ffffffffffffffffffffffffffffffffffffffff60005460101c16331480156120d6575b1561207857565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c79206f776e6572000000000000000000000000000000000000000000006044820152fd5b5030331461207156fea264697066735822122064340709e2302b7c389d4fa9f6710ad98eef5d24fb994c389ec27f1e3195d44564736f6c63430008110033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var SimpleAccount__factory = (
      /** @class */
      function(_super) {
        __extends(SimpleAccount__factory2, _super);
        function SimpleAccount__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        SimpleAccount__factory2.prototype.deploy = function(anEntryPoint, overrides) {
          return _super.prototype.deploy.call(this, anEntryPoint, overrides || {});
        };
        SimpleAccount__factory2.prototype.getDeployTransaction = function(anEntryPoint, overrides) {
          return _super.prototype.getDeployTransaction.call(this, anEntryPoint, overrides || {});
        };
        SimpleAccount__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        SimpleAccount__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        SimpleAccount__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        SimpleAccount__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        SimpleAccount__factory2.bytecode = _bytecode;
        SimpleAccount__factory2.abi = _abi;
        return SimpleAccount__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.SimpleAccount__factory = SimpleAccount__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/SimpleAccountFactory__factory.js
var require_SimpleAccountFactory_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/SimpleAccountFactory__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.SimpleAccountFactory__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "_entryPoint",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "accountImplementation",
        outputs: [
          {
            internalType: "contract SimpleAccount",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "salt",
            type: "uint256"
          }
        ],
        name: "createAccount",
        outputs: [
          {
            internalType: "contract SimpleAccount",
            name: "ret",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "salt",
            type: "uint256"
          }
        ],
        name: "getAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var _bytecode = "0x60a060405234801561001057600080fd5b5060405161336238038061336283398101604081905261002f91610088565b8060405161003c9061007b565b6001600160a01b039091168152602001604051809103906000f080158015610068573d6000803e3d6000fd5b506001600160a01b0316608052506100b8565b6125dc80610d8683390190565b60006020828403121561009a57600080fd5b81516001600160a01b03811681146100b157600080fd5b9392505050565b608051610ca66100e060003960008181604b0152818161011401526102580152610ca66000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806311464fbe146100465780635fbfb9cf146100965780638cb84e18146100a9575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61006d6100a436600461039d565b6100bc565b61006d6100b736600461039d565b6101ee565b6000806100c984846101ee565b905073ffffffffffffffffffffffffffffffffffffffff81163b80156100f1575090506101e8565b60405173ffffffffffffffffffffffffffffffffffffffff8616602482015284907f000000000000000000000000000000000000000000000000000000000000000090604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc4d66de800000000000000000000000000000000000000000000000000000000179052516101b790610390565b6101c2929190610412565b8190604051809103906000f59050801580156101e2573d6000803e3d6000fd5b50925050505b92915050565b60006103578260001b6040518060200161020790610390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082820381018352601f90910116604081905273ffffffffffffffffffffffffffffffffffffffff871660248201527f000000000000000000000000000000000000000000000000000000000000000090604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc4d66de800000000000000000000000000000000000000000000000000000000179052905161030093929101610412565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261033c9291602001610480565b6040516020818303038152906040528051906020012061035e565b9392505050565b60006103578383306000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b6107c1806104b083390190565b600080604083850312156103b057600080fd5b823573ffffffffffffffffffffffffffffffffffffffff811681146103d457600080fd5b946020939093013593505050565b60005b838110156103fd5781810151838201526020016103e5565b8381111561040c576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000825180604084015261044d8160608501602087016103e2565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b600083516104928184602088016103e2565b8351908301906104a68183602088016103e2565b0194935050505056fe60806040526040516107c13803806107c183398101604081905261002291610321565b61002e82826000610035565b505061043e565b61003e8361006b565b60008251118061004b5750805b156100665761006483836100ab60201b6100291760201c565b505b505050565b610074816100d7565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606100d0838360405180606001604052806027815260200161079a602791396101a9565b9392505050565b6100ea8161022260201b6100551760201c565b6101515760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084015b60405180910390fd5b806101887f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61023160201b6100711760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6060600080856001600160a01b0316856040516101c691906103ef565b600060405180830381855af49150503d8060008114610201576040519150601f19603f3d011682016040523d82523d6000602084013e610206565b606091505b50909250905061021886838387610234565b9695505050505050565b6001600160a01b03163b151590565b90565b606083156102a357825160000361029c576001600160a01b0385163b61029c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610148565b50816102ad565b6102ad83836102b5565b949350505050565b8151156102c55781518083602001fd5b8060405162461bcd60e51b8152600401610148919061040b565b634e487b7160e01b600052604160045260246000fd5b60005b838110156103105781810151838201526020016102f8565b838111156100645750506000910152565b6000806040838503121561033457600080fd5b82516001600160a01b038116811461034b57600080fd5b60208401519092506001600160401b038082111561036857600080fd5b818501915085601f83011261037c57600080fd5b81518181111561038e5761038e6102df565b604051601f8201601f19908116603f011681019083821181831017156103b6576103b66102df565b816040528281528860208487010111156103cf57600080fd5b6103e08360208301602088016102f5565b80955050505050509250929050565b600082516104018184602087016102f5565b9190910192915050565b602081526000825180602084015261042a8160408501602087016102f5565b601f01601f19169190910160400192915050565b61034d8061044d6000396000f3fe60806040523661001357610011610017565b005b6100115b610027610022610074565b6100b9565b565b606061004e83836040518060600160405280602781526020016102f1602791396100dd565b9392505050565b73ffffffffffffffffffffffffffffffffffffffff163b151590565b90565b60006100b47f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b905090565b3660008037600080366000845af43d6000803e8080156100d8573d6000f35b3d6000fd5b60606000808573ffffffffffffffffffffffffffffffffffffffff16856040516101079190610283565b600060405180830381855af49150503d8060008114610142576040519150601f19603f3d011682016040523d82523d6000602084013e610147565b606091505b509150915061015886838387610162565b9695505050505050565b606083156101fd5782516000036101f65773ffffffffffffffffffffffffffffffffffffffff85163b6101f6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b5081610207565b610207838361020f565b949350505050565b81511561021f5781518083602001fd5b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101ed919061029f565b60005b8381101561026e578181015183820152602001610256565b8381111561027d576000848401525b50505050565b60008251610295818460208701610253565b9190910192915050565b60208152600082518060208401526102be816040850160208701610253565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212201cd78ab6a31213989661cff2d7d05fc9b9c38b1a848e8249e2e398659a9eb7e364736f6c634300080f0033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a264697066735822122070aa03035a81441673770173c347020a4af1bf8f651ceebc066752c059bdbac764736f6c634300080f003360c0604052306080523480156200001557600080fd5b50604051620025dc380380620025dc833981016040819052620000389162000118565b6001600160a01b03811660a0526200004f62000056565b506200014a565b600054610100900460ff1615620000c35760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff908116101562000116576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b6000602082840312156200012b57600080fd5b81516001600160a01b03811681146200014357600080fd5b9392505050565b60805160a05161241f620001bd6000396000818161032f015281816108810152818161092801528181610d4c01528181610f9d01528181610fe40152818161133601526115f501526000818161066b0152818161071b015281816109ec01528181610a9c0152610be5015261241f6000f3fe60806040526004361061012c5760003560e01c806352d1902d116100a5578063bc197c8111610074578063c4d66de811610059578063c4d66de8146103d0578063d087d288146103f0578063f23a6e611461040557600080fd5b8063bc197c8114610373578063c399ec88146103bb57600080fd5b806352d1902d146102b35780638da5cb5b146102c8578063b0d691fe14610320578063b61d27f61461035357600080fd5b80633659cfe6116100fc5780634a58db19116100e15780634a58db19146102785780634d44560d146102805780634f1ef286146102a057600080fd5b80633659cfe61461022a5780633a871cdd1461024a57600080fd5b806223de291461013857806301ffc9a71461015f578063150b7a021461019457806318dfb3c71461020a57600080fd5b3661013357005b600080fd5b34801561014457600080fd5b5061015d610153366004611cbf565b5050505050505050565b005b34801561016b57600080fd5b5061017f61017a366004611d70565b61044b565b60405190151581526020015b60405180910390f35b3480156101a057600080fd5b506101d96101af366004611db2565b7f150b7a020000000000000000000000000000000000000000000000000000000095945050505050565b6040517fffffffff00000000000000000000000000000000000000000000000000000000909116815260200161018b565b34801561021657600080fd5b5061015d610225366004611e6a565b610530565b34801561023657600080fd5b5061015d610245366004611ed6565b610654565b34801561025657600080fd5b5061026a610265366004611ef3565b610859565b60405190815260200161018b565b61015d61087f565b34801561028c57600080fd5b5061015d61029b366004611f47565b61091e565b61015d6102ae366004611fa2565b6109d5565b3480156102bf57600080fd5b5061026a610bcb565b3480156102d457600080fd5b506000546102fb9062010000900473ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161018b565b34801561032c57600080fd5b507f00000000000000000000000000000000000000000000000000000000000000006102fb565b34801561035f57600080fd5b5061015d61036e366004612084565b610cb7565b34801561037f57600080fd5b506101d961038e3660046120d4565b7fbc197c810000000000000000000000000000000000000000000000000000000098975050505050505050565b3480156103c757600080fd5b5061026a610d06565b3480156103dc57600080fd5b5061015d6103eb366004611ed6565b610dbd565b3480156103fc57600080fd5b5061026a610f50565b34801561041157600080fd5b506101d9610420366004612172565b7ff23a6e61000000000000000000000000000000000000000000000000000000009695505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f150b7a020000000000000000000000000000000000000000000000000000000014806104de57507fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e000000000000000000000000000000000000000000000000000000000145b8061052a57507fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a700000000000000000000000000000000000000000000000000000000145b92915050565b610538610fcc565b8281146105a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f77726f6e67206172726179206c656e677468730000000000000000000000000060448201526064015b60405180910390fd5b60005b8381101561064d5761063b8585838181106105c6576105c66121ee565b90506020020160208101906105db9190611ed6565b60008585858181106105ef576105ef6121ee565b9050602002810190610601919061221d565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061109592505050565b8061064581612282565b9150506105a9565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610719576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161059d565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661078e7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1614610831576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f78790000000000000000000000000000000000000000606482015260840161059d565b61083a81611112565b604080516000808252602082019092526108569183919061111a565b50565b600061086361131e565b61086d84846113bd565b9050610878826114a3565b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006040517fb760faf900000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff919091169063b760faf99034906024016000604051808303818588803b15801561090a57600080fd5b505af115801561064d573d6000803e3d6000fd5b61092661150e565b7f00000000000000000000000000000000000000000000000000000000000000006040517f205c287800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff848116600483015260248201849052919091169063205c287890604401600060405180830381600087803b1580156109b957600080fd5b505af11580156109cd573d6000803e3d6000fd5b505050505050565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610a9a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161059d565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16610b0f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1614610bb2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f78790000000000000000000000000000000000000000606482015260840161059d565b610bbb82611112565b610bc78282600161111a565b5050565b60003073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610c92576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c0000000000000000606482015260840161059d565b507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc90565b610cbf610fcc565b610d00848484848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061109592505050565b50505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906370a08231906024015b602060405180830381865afa158015610d94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db891906122e1565b905090565b600054610100900460ff1615808015610ddd5750600054600160ff909116105b80610df75750303b158015610df7575060005460ff166001145b610e83576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161059d565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558015610ee157600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b610eea8261159f565b8015610bc757600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b6040517f35567e1a0000000000000000000000000000000000000000000000000000000081523060048201526000602482018190529073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906335567e1a90604401610d77565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016148061102d575060005462010000900473ffffffffffffffffffffffffffffffffffffffff1633145b611093576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f6163636f756e743a206e6f74204f776e6572206f7220456e747279506f696e74604482015260640161059d565b565b6000808473ffffffffffffffffffffffffffffffffffffffff1684846040516110be9190612326565b60006040518083038185875af1925050503d80600081146110fb576040519150601f19603f3d011682016040523d82523d6000602084013e611100565b606091505b50915091508161064d57805160208201fd5b61085661150e565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff16156111525761114d8361163e565b505050565b8273ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156111d7575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526111d4918101906122e1565b60015b611263576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201527f6f6e206973206e6f742055555053000000000000000000000000000000000000606482015260840161059d565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8114611312576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f7860448201527f6961626c65555549440000000000000000000000000000000000000000000000606482015260840161059d565b5061114d838383611748565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614611093576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6163636f756e743a206e6f742066726f6d20456e747279506f696e7400000000604482015260640161059d565b600080611417836040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b905061146761142a61014086018661221d565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250859392505061176d9050565b60005462010000900473ffffffffffffffffffffffffffffffffffffffff90811691161461149957600191505061052a565b5060009392505050565b80156108565760405160009033907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90849084818181858888f193505050503d806000811461064d576040519150601f19603f3d011682016040523d82523d6000602084013e61064d565b60005462010000900473ffffffffffffffffffffffffffffffffffffffff1633148061153957503330145b611093576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c79206f776e657200000000000000000000000000000000000000000000604482015260640161059d565b600080547fffffffffffffffffffff0000000000000000000000000000000000000000ffff166201000073ffffffffffffffffffffffffffffffffffffffff8481168202929092178084556040519190048216927f0000000000000000000000000000000000000000000000000000000000000000909216917f47e55c76e7a6f1fd8996a1da8008c1ea29699cca35e7bcd057f2dec313b6e5de91a350565b73ffffffffffffffffffffffffffffffffffffffff81163b6116e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e747261637400000000000000000000000000000000000000606482015260840161059d565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b61175183611791565b60008251118061175e5750805b1561114d57610d0083836117de565b600080600061177c8585611803565b9150915061178981611848565b509392505050565b61179a8161163e565b60405173ffffffffffffffffffffffffffffffffffffffff8216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b606061087883836040518060600160405280602781526020016123c3602791396119fb565b60008082516041036118395760208301516040840151606085015160001a61182d87828585611a80565b94509450505050611841565b506000905060025b9250929050565b600081600481111561185c5761185c612342565b036118645750565b600181600481111561187857611878612342565b036118df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f45434453413a20696e76616c6964207369676e61747572650000000000000000604482015260640161059d565b60028160048111156118f3576118f3612342565b0361195a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e67746800604482015260640161059d565b600381600481111561196e5761196e612342565b03610856576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c60448201527f7565000000000000000000000000000000000000000000000000000000000000606482015260840161059d565b60606000808573ffffffffffffffffffffffffffffffffffffffff1685604051611a259190612326565b600060405180830381855af49150503d8060008114611a60576040519150601f19603f3d011682016040523d82523d6000602084013e611a65565b606091505b5091509150611a7686838387611b6f565b9695505050505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115611ab75750600090506003611b66565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015611b0b573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116611b5f57600060019250925050611b66565b9150600090505b94509492505050565b60608315611c05578251600003611bfe5773ffffffffffffffffffffffffffffffffffffffff85163b611bfe576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161059d565b5081611c0f565b611c0f8383611c17565b949350505050565b815115611c275781518083602001fd5b806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161059d9190612371565b73ffffffffffffffffffffffffffffffffffffffff8116811461085657600080fd5b60008083601f840112611c8f57600080fd5b50813567ffffffffffffffff811115611ca757600080fd5b60208301915083602082850101111561184157600080fd5b60008060008060008060008060c0898b031215611cdb57600080fd5b8835611ce681611c5b565b97506020890135611cf681611c5b565b96506040890135611d0681611c5b565b955060608901359450608089013567ffffffffffffffff80821115611d2a57600080fd5b611d368c838d01611c7d565b909650945060a08b0135915080821115611d4f57600080fd5b50611d5c8b828c01611c7d565b999c989b5096995094979396929594505050565b600060208284031215611d8257600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461087857600080fd5b600080600080600060808688031215611dca57600080fd5b8535611dd581611c5b565b94506020860135611de581611c5b565b935060408601359250606086013567ffffffffffffffff811115611e0857600080fd5b611e1488828901611c7d565b969995985093965092949392505050565b60008083601f840112611e3757600080fd5b50813567ffffffffffffffff811115611e4f57600080fd5b6020830191508360208260051b850101111561184157600080fd5b60008060008060408587031215611e8057600080fd5b843567ffffffffffffffff80821115611e9857600080fd5b611ea488838901611e25565b90965094506020870135915080821115611ebd57600080fd5b50611eca87828801611e25565b95989497509550505050565b600060208284031215611ee857600080fd5b813561087881611c5b565b600080600060608486031215611f0857600080fd5b833567ffffffffffffffff811115611f1f57600080fd5b84016101608187031215611f3257600080fd5b95602085013595506040909401359392505050565b60008060408385031215611f5a57600080fd5b8235611f6581611c5b565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060408385031215611fb557600080fd5b8235611fc081611c5b565b9150602083013567ffffffffffffffff80821115611fdd57600080fd5b818501915085601f830112611ff157600080fd5b81358181111561200357612003611f73565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561204957612049611f73565b8160405282815288602084870101111561206257600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b6000806000806060858703121561209a57600080fd5b84356120a581611c5b565b935060208501359250604085013567ffffffffffffffff8111156120c857600080fd5b611eca87828801611c7d565b60008060008060008060008060a0898b0312156120f057600080fd5b88356120fb81611c5b565b9750602089013561210b81611c5b565b9650604089013567ffffffffffffffff8082111561212857600080fd5b6121348c838d01611e25565b909850965060608b013591508082111561214d57600080fd5b6121598c838d01611e25565b909650945060808b0135915080821115611d4f57600080fd5b60008060008060008060a0878903121561218b57600080fd5b863561219681611c5b565b955060208701356121a681611c5b565b94506040870135935060608701359250608087013567ffffffffffffffff8111156121d057600080fd5b6121dc89828a01611c7d565b979a9699509497509295939492505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261225257600080fd5b83018035915067ffffffffffffffff82111561226d57600080fd5b60200191503681900382131561184157600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036122da577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b6000602082840312156122f357600080fd5b5051919050565b60005b838110156123155781810151838201526020016122fd565b83811115610d005750506000910152565b600082516123388184602087016122fa565b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60208152600082518060208401526123908160408501602087016122fa565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220e7edcd8c7b9333c2bbdd5f8fa69f1cd2cb0f5cbfa76648b9830bcf0cbfef288e64736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var SimpleAccountFactory__factory = (
      /** @class */
      function(_super) {
        __extends(SimpleAccountFactory__factory2, _super);
        function SimpleAccountFactory__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        SimpleAccountFactory__factory2.prototype.deploy = function(_entryPoint, overrides) {
          return _super.prototype.deploy.call(this, _entryPoint, overrides || {});
        };
        SimpleAccountFactory__factory2.prototype.getDeployTransaction = function(_entryPoint, overrides) {
          return _super.prototype.getDeployTransaction.call(this, _entryPoint, overrides || {});
        };
        SimpleAccountFactory__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        SimpleAccountFactory__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        SimpleAccountFactory__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        SimpleAccountFactory__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        SimpleAccountFactory__factory2.bytecode = _bytecode;
        SimpleAccountFactory__factory2.abi = _abi;
        return SimpleAccountFactory__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.SimpleAccountFactory__factory = SimpleAccountFactory__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/StakeManager__factory.js
var require_StakeManager_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/StakeManager__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.__esModule = true;
    exports2.StakeManager__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalDeposit",
            type: "uint256"
          }
        ],
        name: "Deposited",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalStaked",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "unstakeDelaySec",
            type: "uint256"
          }
        ],
        name: "StakeLocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "withdrawTime",
            type: "uint256"
          }
        ],
        name: "StakeUnlocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "StakeWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "withdrawAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrawn",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "depositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "deposits",
        outputs: [
          {
            internalType: "uint112",
            name: "deposit",
            type: "uint112"
          },
          {
            internalType: "bool",
            name: "staked",
            type: "bool"
          },
          {
            internalType: "uint112",
            name: "stake",
            type: "uint112"
          },
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          },
          {
            internalType: "uint48",
            name: "withdrawTime",
            type: "uint48"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getDepositInfo",
        outputs: [
          {
            components: [
              {
                internalType: "uint112",
                name: "deposit",
                type: "uint112"
              },
              {
                internalType: "bool",
                name: "staked",
                type: "bool"
              },
              {
                internalType: "uint112",
                name: "stake",
                type: "uint112"
              },
              {
                internalType: "uint32",
                name: "unstakeDelaySec",
                type: "uint32"
              },
              {
                internalType: "uint48",
                name: "withdrawTime",
                type: "uint48"
              }
            ],
            internalType: "struct IStakeManager.DepositInfo",
            name: "info",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "withdrawAmount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var StakeManager__factory = (
      /** @class */
      function() {
        function StakeManager__factory2() {
        }
        StakeManager__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        StakeManager__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        StakeManager__factory2.abi = _abi;
        return StakeManager__factory2;
      }()
    );
    exports2.StakeManager__factory = StakeManager__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/TokenCallbackHandler__factory.js
var require_TokenCallbackHandler_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/TokenCallbackHandler__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.TokenCallbackHandler__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var _bytecode = "0x608060405234801561001057600080fd5b506105d1806100206000396000f3fe608060405234801561001057600080fd5b50600436106100665760003560e01c8063150b7a0211610050578063150b7a02146100ad578063bc197c8114610116578063f23a6e611461015157600080fd5b806223de291461006b57806301ffc9a714610085575b600080fd5b6100836100793660046102e1565b5050505050505050565b005b61009861009336600461038c565b61018a565b60405190151581526020015b60405180910390f35b6100e56100bb3660046103d5565b7f150b7a020000000000000000000000000000000000000000000000000000000095945050505050565b6040517fffffffff0000000000000000000000000000000000000000000000000000000090911681526020016100a4565b6100e5610124366004610489565b7fbc197c810000000000000000000000000000000000000000000000000000000098975050505050505050565b6100e561015f366004610523565b7ff23a6e61000000000000000000000000000000000000000000000000000000009695505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f150b7a0200000000000000000000000000000000000000000000000000000000148061021d57507fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e000000000000000000000000000000000000000000000000000000000145b8061026957507fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a700000000000000000000000000000000000000000000000000000000145b92915050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461029357600080fd5b919050565b60008083601f8401126102aa57600080fd5b50813567ffffffffffffffff8111156102c257600080fd5b6020830191508360208285010111156102da57600080fd5b9250929050565b60008060008060008060008060c0898b0312156102fd57600080fd5b6103068961026f565b975061031460208a0161026f565b965061032260408a0161026f565b955060608901359450608089013567ffffffffffffffff8082111561034657600080fd5b6103528c838d01610298565b909650945060a08b013591508082111561036b57600080fd5b506103788b828c01610298565b999c989b5096995094979396929594505050565b60006020828403121561039e57600080fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146103ce57600080fd5b9392505050565b6000806000806000608086880312156103ed57600080fd5b6103f68661026f565b94506104046020870161026f565b935060408601359250606086013567ffffffffffffffff81111561042757600080fd5b61043388828901610298565b969995985093965092949392505050565b60008083601f84011261045657600080fd5b50813567ffffffffffffffff81111561046e57600080fd5b6020830191508360208260051b85010111156102da57600080fd5b60008060008060008060008060a0898b0312156104a557600080fd5b6104ae8961026f565b97506104bc60208a0161026f565b9650604089013567ffffffffffffffff808211156104d957600080fd5b6104e58c838d01610444565b909850965060608b01359150808211156104fe57600080fd5b61050a8c838d01610444565b909650945060808b013591508082111561036b57600080fd5b60008060008060008060a0878903121561053c57600080fd5b6105458761026f565b95506105536020880161026f565b94506040870135935060608701359250608087013567ffffffffffffffff81111561057d57600080fd5b61058989828a01610298565b979a969950949750929593949250505056fea264697066735822122030acf64c41b7bf1b77d9c21072e6997dd7ea3417f79c52629ba33d09d9681dda64736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var TokenCallbackHandler__factory = (
      /** @class */
      function(_super) {
        __extends(TokenCallbackHandler__factory2, _super);
        function TokenCallbackHandler__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        TokenCallbackHandler__factory2.prototype.deploy = function(overrides) {
          return _super.prototype.deploy.call(this, overrides || {});
        };
        TokenCallbackHandler__factory2.prototype.getDeployTransaction = function(overrides) {
          return _super.prototype.getDeployTransaction.call(this, overrides || {});
        };
        TokenCallbackHandler__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        TokenCallbackHandler__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        TokenCallbackHandler__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        TokenCallbackHandler__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        TokenCallbackHandler__factory2.bytecode = _bytecode;
        TokenCallbackHandler__factory2.abi = _abi;
        return TokenCallbackHandler__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.TokenCallbackHandler__factory = TokenCallbackHandler__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/TokenPaymaster__factory.js
var require_TokenPaymaster_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/TokenPaymaster__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.TokenPaymaster__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "accountFactory",
            type: "address"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "contract IEntryPoint",
            name: "_entryPoint",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "COST_OF_POST",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "subtractedValue",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "deposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "mintTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IPaymaster.PostOpMode",
            name: "mode",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          }
        ],
        name: "postOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "theFactory",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "maxCost",
            type: "uint256"
          }
        ],
        name: "validatePaymasterUserOp",
        outputs: [
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x60c06040523480156200001157600080fd5b506040516200224438038062002244833981016040819052620000349162000327565b8180826200004233620000a0565b6001600160a01b031660805260046200005c8382620004bc565b5060056200006b8282620004bc565b5050506001600160a01b03831660a05262000088306001620000f0565b620000973033600019620001b9565b505050620005af565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b0382166200014c5760405162461bcd60e51b815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f20616464726573730060448201526064015b60405180910390fd5b806003600082825462000160919062000588565b90915550506001600160a01b0382166000818152600160209081526040808320805486019055518481527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef910160405180910390a35050565b6001600160a01b0383166200021d5760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b606482015260840162000143565b6001600160a01b038216620002805760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b606482015260840162000143565b6001600160a01b0383811660008181526002602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b505050565b6001600160a01b0381168114620002fc57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b80516200032281620002e6565b919050565b6000806000606084860312156200033d57600080fd5b83516200034a81620002e6565b602085810151919450906001600160401b03808211156200036a57600080fd5b818701915087601f8301126200037f57600080fd5b815181811115620003945762000394620002ff565b604051601f8201601f19908116603f01168101908382118183101715620003bf57620003bf620002ff565b816040528281528a86848701011115620003d857600080fd5b600093505b82841015620003fc5784840186015181850187015292850192620003dd565b828411156200040e5760008684830101525b809750505050505050620004256040850162000315565b90509250925092565b600181811c908216806200044357607f821691505b6020821081036200046457634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620002e157600081815260208120601f850160051c81016020861015620004935750805b601f850160051c820191505b81811015620004b4578281556001016200049f565b505050505050565b81516001600160401b03811115620004d857620004d8620002ff565b620004f081620004e984546200042e565b846200046a565b602080601f8311600181146200052857600084156200050f5750858301515b600019600386901b1c1916600185901b178555620004b4565b600085815260208120601f198616915b82811015620005595788860151825594840194600190910190840162000538565b5085821015620005785787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60008219821115620005aa57634e487b7160e01b600052601160045260246000fd5b500190565b60805160a051611c376200060d6000396000818161039201526116fa015260008181610426015281816105970152818161070b015281816108ea015281816109b101528181610a4101528181610af401526111f80152611c376000f3fe6080604052600436106101a15760003560e01c80639f5ca221116100e1578063c23a5cea1161008a578063dd62ed3e11610064578063dd62ed3e1461049a578063f0dda65c146104ed578063f2fde38b1461050d578063f465c77e1461052d57600080fd5b8063c23a5cea1461045d578063c399ec881461047d578063d0e30db01461049257600080fd5b8063a9a23409116100bb578063a9a23409146103f4578063b0d691fe14610414578063bb9fe6bf1461044857600080fd5b80639f5ca22114610380578063a457c2d7146103b4578063a9059cbb146103d457600080fd5b8063313ce5671161014e578063715018a611610128578063715018a6146102f4578063796d4371146103095780638da5cb5b1461031f57806395d89b411461036b57600080fd5b8063313ce56714610275578063395093511461029157806370a08231146102b157600080fd5b806318160ddd1161017f57806318160ddd14610216578063205c28781461023557806323b872dd1461025557600080fd5b80630396cb60146101a657806306fdde03146101bb578063095ea7b3146101e6575b600080fd5b6101b96101b43660046117a8565b61055b565b005b3480156101c757600080fd5b506101d061060d565b6040516101dd9190611840565b60405180910390f35b3480156101f257600080fd5b50610206610201366004611875565b61069f565b60405190151581526020016101dd565b34801561022257600080fd5b506003545b6040519081526020016101dd565b34801561024157600080fd5b506101b9610250366004611875565b6106b7565b34801561026157600080fd5b506102066102703660046118a1565b61074f565b34801561028157600080fd5b50604051601281526020016101dd565b34801561029d57600080fd5b506102066102ac366004611875565b610773565b3480156102bd57600080fd5b506102276102cc3660046118e2565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205490565b34801561030057600080fd5b506101b96107bf565b34801561031557600080fd5b50610227613a9881565b34801561032b57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101dd565b34801561037757600080fd5b506101d06107d3565b34801561038c57600080fd5b506103467f000000000000000000000000000000000000000000000000000000000000000081565b3480156103c057600080fd5b506102066103cf366004611875565b6107e2565b3480156103e057600080fd5b506102066103ef366004611875565b6108b8565b34801561040057600080fd5b506101b961040f3660046118ff565b6108c6565b34801561042057600080fd5b506103467f000000000000000000000000000000000000000000000000000000000000000081565b34801561045457600080fd5b506101b96108e0565b34801561046957600080fd5b506101b96104783660046118e2565b610964565b34801561048957600080fd5b50610227610a10565b6101b9610ac6565b3480156104a657600080fd5b506102276104b536600461198e565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260026020908152604080832093909416825291909152205490565b3480156104f957600080fd5b506101b9610508366004611875565b610b4e565b34801561051957600080fd5b506101b96105283660046118e2565b610b64565b34801561053957600080fd5b5061054d6105483660046119c7565b610bcd565b6040516101dd929190611a1b565b610563610bf0565b6040517f0396cb6000000000000000000000000000000000000000000000000000000000815263ffffffff821660048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690630396cb609034906024016000604051808303818588803b1580156105f157600080fd5b505af1158015610605573d6000803e3d6000fd5b505050505050565b60606004805461061c90611a3d565b80601f016020809104026020016040519081016040528092919081815260200182805461064890611a3d565b80156106955780601f1061066a57610100808354040283529160200191610695565b820191906000526020600020905b81548152906001019060200180831161067857829003601f168201915b5050505050905090565b6000336106ad818585610c71565b5060019392505050565b6106bf610bf0565b6040517f205c287800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063205c287890604401600060405180830381600087803b1580156105f157600080fd5b60003361075d858285610e24565b610768858585610ef5565b506001949350505050565b33600081815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff871684529091528120549091906106ad90829086906107ba908790611a90565b610c71565b6107c7610bf0565b6107d1600061116b565b565b60606005805461061c90611a3d565b33600081815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff87168452909152812054909190838110156108ab576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f00000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b6107688286868403610c71565b6000336106ad818585610ef5565b6108ce6111e0565b6108da8484848461127f565b50505050565b6108e8610bf0565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb9fe6bf6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561095057600080fd5b505af11580156108da573d6000803e3d6000fd5b61096c610bf0565b6040517fc23a5cea00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063c23a5cea90602401600060405180830381600087803b1580156109f557600080fd5b505af1158015610a09573d6000803e3d6000fd5b5050505050565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa158015610a9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac19190611acf565b905090565b6040517fb760faf90000000000000000000000000000000000000000000000000000000081523060048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b760faf99034906024016000604051808303818588803b1580156109f557600080fd5b610b56610bf0565b610b6082826112b2565b5050565b610b6c610bf0565b610b9630610b8f60005473ffffffffffffffffffffffffffffffffffffffff1690565b6000610c71565b610b9f816113a7565b610bca30827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff610c71565b50565b60606000610bd96111e0565b610be485858561145b565b91509150935093915050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146107d1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108a2565b73ffffffffffffffffffffffffffffffffffffffff8316610d13576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460448201527f726573730000000000000000000000000000000000000000000000000000000060648201526084016108a2565b73ffffffffffffffffffffffffffffffffffffffff8216610db6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f20616464726560448201527f737300000000000000000000000000000000000000000000000000000000000060648201526084016108a2565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526002602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b73ffffffffffffffffffffffffffffffffffffffff8381166000908152600260209081526040808320938616835292905220547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146108da5781811015610ee8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e636500000060448201526064016108a2565b6108da8484848403610c71565b73ffffffffffffffffffffffffffffffffffffffff8316610f98576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f647265737300000000000000000000000000000000000000000000000000000060648201526084016108a2565b73ffffffffffffffffffffffffffffffffffffffff821661103b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201527f657373000000000000000000000000000000000000000000000000000000000060648201526084016108a2565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260016020526040902054818110156110f1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e6365000000000000000000000000000000000000000000000000000060648201526084016108a2565b73ffffffffffffffffffffffffffffffffffffffff80851660008181526001602052604080822086860390559286168082529083902080548601905591517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9061115e9086815260200190565b60405180910390a36108da565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146107d1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f53656e646572206e6f7420456e747279506f696e74000000000000000000000060448201526064016108a2565b600061128d838501856118e2565b905060006112a56112a0613a9885611a90565b6116a4565b9050610605823083610ef5565b73ffffffffffffffffffffffffffffffffffffffff821661132f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f20616464726573730060448201526064016108a2565b80600360008282546113419190611a90565b909155505073ffffffffffffffffffffffffffffffffffffffff82166000818152600160209081526040808320805486019055518481527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef910160405180910390a35050565b6113af610bf0565b73ffffffffffffffffffffffffffffffffffffffff8116611452576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016108a2565b610bca8161116b565b6060600080611469846116a4565b9050613a988660a0013511611500576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f546f6b656e5061796d61737465723a2067617320746f6f206c6f7720666f722060448201527f706f73744f70000000000000000000000000000000000000000000000000000060648201526084016108a2565b61150d6040870187611ae8565b1590506115c15761151d866116b7565b8061152e6102cc60208901896118e2565b10156115bc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f546f6b656e5061796d61737465723a206e6f2062616c616e636520287072652d60448201527f637265617465290000000000000000000000000000000000000000000000000060648201526084016108a2565b61163a565b806115d26102cc60208901896118e2565b101561163a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f546f6b656e5061796d61737465723a206e6f2062616c616e636500000000000060448201526064016108a2565b61164760208701876118e2565b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015201604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529660009650945050505050565b60006116b1606483611b54565b92915050565b60006116c66040830183611ae8565b6116d591601491600091611b8f565b6116de91611bb9565b60601c905073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168114610b60576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f546f6b656e5061796d61737465723a2077726f6e67206163636f756e7420666160448201527f63746f727900000000000000000000000000000000000000000000000000000060648201526084016108a2565b6000602082840312156117ba57600080fd5b813563ffffffff811681146117ce57600080fd5b9392505050565b6000815180845260005b818110156117fb576020818501810151868301820152016117df565b8181111561180d576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006117ce60208301846117d5565b73ffffffffffffffffffffffffffffffffffffffff81168114610bca57600080fd5b6000806040838503121561188857600080fd5b823561189381611853565b946020939093013593505050565b6000806000606084860312156118b657600080fd5b83356118c181611853565b925060208401356118d181611853565b929592945050506040919091013590565b6000602082840312156118f457600080fd5b81356117ce81611853565b6000806000806060858703121561191557600080fd5b84356003811061192457600080fd5b9350602085013567ffffffffffffffff8082111561194157600080fd5b818701915087601f83011261195557600080fd5b81358181111561196457600080fd5b88602082850101111561197657600080fd5b95986020929092019750949560400135945092505050565b600080604083850312156119a157600080fd5b82356119ac81611853565b915060208301356119bc81611853565b809150509250929050565b6000806000606084860312156119dc57600080fd5b833567ffffffffffffffff8111156119f357600080fd5b84016101608187031215611a0657600080fd5b95602085013595506040909401359392505050565b604081526000611a2e60408301856117d5565b90508260208301529392505050565b600181811c90821680611a5157607f821691505b602082108103611a8a577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008219821115611aca577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b500190565b600060208284031215611ae157600080fd5b5051919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112611b1d57600080fd5b83018035915067ffffffffffffffff821115611b3857600080fd5b602001915036819003821315611b4d57600080fd5b9250929050565b600082611b8a577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60008085851115611b9f57600080fd5b83861115611bac57600080fd5b5050820193919092039150565b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008135818116916014851015611bf95780818660140360031b1b83161692505b50509291505056fea2646970667358221220dfdc8beeba6f7bd348dd4714b66158c03f7be31ff6617424db8528c77a85ae7664736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var TokenPaymaster__factory = (
      /** @class */
      function(_super) {
        __extends(TokenPaymaster__factory2, _super);
        function TokenPaymaster__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        TokenPaymaster__factory2.prototype.deploy = function(accountFactory, _symbol, _entryPoint, overrides) {
          return _super.prototype.deploy.call(this, accountFactory, _symbol, _entryPoint, overrides || {});
        };
        TokenPaymaster__factory2.prototype.getDeployTransaction = function(accountFactory, _symbol, _entryPoint, overrides) {
          return _super.prototype.getDeployTransaction.call(this, accountFactory, _symbol, _entryPoint, overrides || {});
        };
        TokenPaymaster__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        TokenPaymaster__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        TokenPaymaster__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        TokenPaymaster__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        TokenPaymaster__factory2.bytecode = _bytecode;
        TokenPaymaster__factory2.abi = _abi;
        return TokenPaymaster__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.TokenPaymaster__factory = TokenPaymaster__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/VerifyingPaymaster__factory.js
var require_VerifyingPaymaster_factory = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/VerifyingPaymaster__factory.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports2.__esModule = true;
    exports2.VerifyingPaymaster__factory = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract IEntryPoint",
            name: "_entryPoint",
            type: "address"
          },
          {
            internalType: "address",
            name: "_verifyingSigner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "unstakeDelaySec",
            type: "uint32"
          }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "deposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "entryPoint",
        outputs: [
          {
            internalType: "contract IEntryPoint",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "uint48",
            name: "validUntil",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "validAfter",
            type: "uint48"
          }
        ],
        name: "getHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          }
        ],
        name: "parsePaymasterAndData",
        outputs: [
          {
            internalType: "uint48",
            name: "validUntil",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "validAfter",
            type: "uint48"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IPaymaster.PostOpMode",
            name: "mode",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "actualGasCost",
            type: "uint256"
          }
        ],
        name: "postOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "senderNonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              }
            ],
            internalType: "struct UserOperation",
            name: "userOp",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "userOpHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "maxCost",
            type: "uint256"
          }
        ],
        name: "validatePaymasterUserOp",
        outputs: [
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "validationData",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "verifyingSigner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "withdrawAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var _bytecode = "0x60c06040523480156200001157600080fd5b5060405162001723380380620017238339810160408190526200003491620000c2565b81620000403362000059565b6001600160a01b039081166080521660a0525062000101565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b0381168114620000bf57600080fd5b50565b60008060408385031215620000d657600080fd5b8251620000e381620000a9565b6020840151909250620000f681620000a9565b809150509250929050565b60805160a0516115c46200015f6000396000818161013f0152610ca20152600081816102880152818161038601528181610450015281816105730152818161063a015281816106ca0152818161077d0152610a0401526115c46000f3fe6080604052600436106100f35760003560e01c8063a9a234091161008a578063c399ec8811610059578063c399ec88146102df578063d0e30db0146102f4578063f2fde38b146102fc578063f465c77e1461031c57600080fd5b8063a9a2340914610256578063b0d691fe14610276578063bb9fe6bf146102aa578063c23a5cea146102bf57600080fd5b80638da5cb5b116100c65780638da5cb5b146101a057806394d4ad60146101cb57806394e1fc19146101fb5780639c90b4431461022957600080fd5b80630396cb60146100f8578063205c28781461010d57806323d9ac9b1461012d578063715018a61461018b575b600080fd5b61010b610106366004611075565b61034a565b005b34801561011957600080fd5b5061010b6101283660046110c4565b6103fc565b34801561013957600080fd5b506101617f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b34801561019757600080fd5b5061010b610494565b3480156101ac57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff16610161565b3480156101d757600080fd5b506101eb6101e6366004611132565b6104a8565b6040516101829493929190611174565b34801561020757600080fd5b5061021b610216366004611212565b6104e5565b604051908152602001610182565b34801561023557600080fd5b5061021b610244366004611270565b60016020526000908152604090205481565b34801561026257600080fd5b5061010b61027136600461128d565b61054f565b34801561028257600080fd5b506101617f000000000000000000000000000000000000000000000000000000000000000081565b3480156102b657600080fd5b5061010b610569565b3480156102cb57600080fd5b5061010b6102da366004611270565b6105ed565b3480156102eb57600080fd5b5061021b610699565b61010b61074f565b34801561030857600080fd5b5061010b610317366004611270565b6107d7565b34801561032857600080fd5b5061033c6103373660046112ed565b610893565b6040516101829291906113a6565b6103526108b7565b6040517f0396cb6000000000000000000000000000000000000000000000000000000000815263ffffffff821660048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690630396cb609034906024016000604051808303818588803b1580156103e057600080fd5b505af11580156103f4573d6000803e3d6000fd5b505050505050565b6104046108b7565b6040517f205c287800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063205c287890604401600060405180830381600087803b1580156103e057600080fd5b61049c6108b7565b6104a66000610938565b565b60008036816104bb6054601487896113c8565b8101906104c891906113f2565b90945092506104da85605481896113c8565b949793965094505050565b60006104f0846109ad565b73ffffffffffffffffffffffffffffffffffffffff8535166000908152600160209081526040918290205491516105309392469230928991899101611425565b6040516020818303038152906040528051906020012090509392505050565b6105576109ec565b61056384848484610a8b565b50505050565b6105716108b7565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb9fe6bf6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156105d957600080fd5b505af1158015610563573d6000803e3d6000fd5b6105f56108b7565b6040517fc23a5cea00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063c23a5cea90602401600060405180830381600087803b15801561067e57600080fd5b505af1158015610692573d6000803e3d6000fd5b5050505050565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa158015610726573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074a9190611482565b905090565b6040517fb760faf90000000000000000000000000000000000000000000000000000000081523060048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b760faf99034906024016000604051808303818588803b15801561067e57600080fd5b6107df6108b7565b73ffffffffffffffffffffffffffffffffffffffff8116610887576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b61089081610938565b50565b6060600061089f6109ec565b6108aa858585610aed565b915091505b935093915050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146104a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161087e565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60603660006109c061012085018561149b565b915091508360208184030360405194506020810185016040528085528082602087013750505050919050565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146104a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f53656e646572206e6f7420456e747279506f696e740000000000000000000000604482015260640161087e565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f6d757374206f7665727269646500000000000000000000000000000000000000604482015260640161087e565b6060600080803681610b066101e66101208b018b61149b565b929650909450925090506040811480610b1f5750604181145b610bad57604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f566572696679696e675061796d61737465723a20696e76616c6964207369676e60448201527f6174757265206c656e67746820696e207061796d6173746572416e6444617461606482015260840161087e565b6000610c10610bbd8b87876104e5565b6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b73ffffffffffffffffffffffffffffffffffffffff8b35166000908152600160205260408120805492935090610c4583611500565b9190505550610c8a8184848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610d3292505050565b73ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1614610d0757610ce860018686610d56565b60405180602001604052806000815250909650965050505050506108af565b610d1360008686610d56565b6040805160208101909152600081529b909a5098505050505050505050565b6000806000610d418585610d8e565b91509150610d4e81610dd3565b509392505050565b600060d08265ffffffffffff16901b60a08465ffffffffffff16901b85610d7e576000610d81565b60015b60ff161717949350505050565b6000808251604103610dc45760208301516040840151606085015160001a610db887828585610f86565b94509450505050610dcc565b506000905060025b9250929050565b6000816004811115610de757610de761155f565b03610def5750565b6001816004811115610e0357610e0361155f565b03610e6a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f45434453413a20696e76616c6964207369676e61747572650000000000000000604482015260640161087e565b6002816004811115610e7e57610e7e61155f565b03610ee5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e67746800604482015260640161087e565b6003816004811115610ef957610ef961155f565b03610890576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c60448201527f7565000000000000000000000000000000000000000000000000000000000000606482015260840161087e565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115610fbd575060009050600361106c565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015611011573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff81166110655760006001925092505061106c565b9150600090505b94509492505050565b60006020828403121561108757600080fd5b813563ffffffff8116811461109b57600080fd5b9392505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461089057600080fd5b600080604083850312156110d757600080fd5b82356110e2816110a2565b946020939093013593505050565b60008083601f84011261110257600080fd5b50813567ffffffffffffffff81111561111a57600080fd5b602083019150836020828501011115610dcc57600080fd5b6000806020838503121561114557600080fd5b823567ffffffffffffffff81111561115c57600080fd5b611168858286016110f0565b90969095509350505050565b600065ffffffffffff8087168352808616602084015250606060408301528260608301528284608084013760006080848401015260807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f850116830101905095945050505050565b600061016082840312156111f157600080fd5b50919050565b803565ffffffffffff8116811461120d57600080fd5b919050565b60008060006060848603121561122757600080fd5b833567ffffffffffffffff81111561123e57600080fd5b61124a868287016111de565b935050611259602085016111f7565b9150611267604085016111f7565b90509250925092565b60006020828403121561128257600080fd5b813561109b816110a2565b600080600080606085870312156112a357600080fd5b8435600381106112b257600080fd5b9350602085013567ffffffffffffffff8111156112ce57600080fd5b6112da878288016110f0565b9598909750949560400135949350505050565b60008060006060848603121561130257600080fd5b833567ffffffffffffffff81111561131957600080fd5b611325868287016111de565b9660208601359650604090950135949350505050565b6000815180845260005b8181101561136157602081850181015186830182015201611345565b81811115611373576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6040815260006113b9604083018561133b565b90508260208301529392505050565b600080858511156113d857600080fd5b838611156113e557600080fd5b5050820193919092039150565b6000806040838503121561140557600080fd5b61140e836111f7565b915061141c602084016111f7565b90509250929050565b60c08152600061143860c083018961133b565b60208301979097525073ffffffffffffffffffffffffffffffffffffffff949094166040850152606084019290925265ffffffffffff90811660808401521660a090910152919050565b60006020828403121561149457600080fd5b5051919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126114d057600080fd5b83018035915067ffffffffffffffff8211156114eb57600080fd5b602001915036819003821315610dcc57600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611558577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fdfea264697066735822122056694a0f8516f09e33000ee7cca7b7c7c726d389f6b102f7392626a3678c862d64736f6c634300080f0033";
    var isSuperArgs = function(xs) {
      return xs.length > 1;
    };
    var VerifyingPaymaster__factory = (
      /** @class */
      function(_super) {
        __extends(VerifyingPaymaster__factory2, _super);
        function VerifyingPaymaster__factory2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = this;
          if (isSuperArgs(args)) {
            _this = _super.apply(this, args) || this;
          } else {
            _this = _super.call(this, _abi, _bytecode, args[0]) || this;
          }
          return _this;
        }
        VerifyingPaymaster__factory2.prototype.deploy = function(_entryPoint, _verifyingSigner, overrides) {
          return _super.prototype.deploy.call(this, _entryPoint, _verifyingSigner, overrides || {});
        };
        VerifyingPaymaster__factory2.prototype.getDeployTransaction = function(_entryPoint, _verifyingSigner, overrides) {
          return _super.prototype.getDeployTransaction.call(this, _entryPoint, _verifyingSigner, overrides || {});
        };
        VerifyingPaymaster__factory2.prototype.attach = function(address) {
          return _super.prototype.attach.call(this, address);
        };
        VerifyingPaymaster__factory2.prototype.connect = function(signer) {
          return _super.prototype.connect.call(this, signer);
        };
        VerifyingPaymaster__factory2.createInterface = function() {
          return new ethers_1.utils.Interface(_abi);
        };
        VerifyingPaymaster__factory2.connect = function(address, signerOrProvider) {
          return new ethers_1.Contract(address, _abi, signerOrProvider);
        };
        VerifyingPaymaster__factory2.bytecode = _bytecode;
        VerifyingPaymaster__factory2.abi = _abi;
        return VerifyingPaymaster__factory2;
      }(ethers_1.ContractFactory)
    );
    exports2.VerifyingPaymaster__factory = VerifyingPaymaster__factory;
  }
});

// node_modules/@account-abstraction/contracts/dist/types/factories/index.js
var require_factories = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/factories/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    exports2.__esModule = true;
    exports2.VerifyingPaymaster__factory = exports2.TokenPaymaster__factory = exports2.TokenCallbackHandler__factory = exports2.StakeManager__factory = exports2.SimpleAccountFactory__factory = exports2.SimpleAccount__factory = exports2.SenderCreator__factory = exports2.NonceManager__factory = exports2.MaliciousAccount__factory = exports2.IStakeManager__factory = exports2.IPaymaster__factory = exports2.INonceManager__factory = exports2.IEntryPoint__factory = exports2.IAggregator__factory = exports2.IAccount__factory = exports2.EntryPoint__factory = exports2.DepositPaymaster__factory = exports2.BrokenBLSAccountFactory__factory = exports2.BrokenBLSAccount__factory = exports2.BasePaymaster__factory = exports2.BaseAccount__factory = void 0;
    var BaseAccount__factory_1 = require_BaseAccount_factory();
    __createBinding(exports2, BaseAccount__factory_1, "BaseAccount__factory");
    var BasePaymaster__factory_1 = require_BasePaymaster_factory();
    __createBinding(exports2, BasePaymaster__factory_1, "BasePaymaster__factory");
    var BrokenBLSAccount__factory_1 = require_BrokenBLSAccount_factory();
    __createBinding(exports2, BrokenBLSAccount__factory_1, "BrokenBLSAccount__factory");
    var BrokenBLSAccountFactory__factory_1 = require_BrokenBLSAccountFactory_factory();
    __createBinding(exports2, BrokenBLSAccountFactory__factory_1, "BrokenBLSAccountFactory__factory");
    var DepositPaymaster__factory_1 = require_DepositPaymaster_factory();
    __createBinding(exports2, DepositPaymaster__factory_1, "DepositPaymaster__factory");
    var EntryPoint__factory_1 = require_EntryPoint_factory();
    __createBinding(exports2, EntryPoint__factory_1, "EntryPoint__factory");
    var IAccount__factory_1 = require_IAccount_factory();
    __createBinding(exports2, IAccount__factory_1, "IAccount__factory");
    var IAggregator__factory_1 = require_IAggregator_factory();
    __createBinding(exports2, IAggregator__factory_1, "IAggregator__factory");
    var IEntryPoint__factory_1 = require_IEntryPoint_factory();
    __createBinding(exports2, IEntryPoint__factory_1, "IEntryPoint__factory");
    var INonceManager__factory_1 = require_INonceManager_factory();
    __createBinding(exports2, INonceManager__factory_1, "INonceManager__factory");
    var IPaymaster__factory_1 = require_IPaymaster_factory();
    __createBinding(exports2, IPaymaster__factory_1, "IPaymaster__factory");
    var IStakeManager__factory_1 = require_IStakeManager_factory();
    __createBinding(exports2, IStakeManager__factory_1, "IStakeManager__factory");
    var MaliciousAccount__factory_1 = require_MaliciousAccount_factory();
    __createBinding(exports2, MaliciousAccount__factory_1, "MaliciousAccount__factory");
    var NonceManager__factory_1 = require_NonceManager_factory();
    __createBinding(exports2, NonceManager__factory_1, "NonceManager__factory");
    var SenderCreator__factory_1 = require_SenderCreator_factory();
    __createBinding(exports2, SenderCreator__factory_1, "SenderCreator__factory");
    var SimpleAccount__factory_1 = require_SimpleAccount_factory();
    __createBinding(exports2, SimpleAccount__factory_1, "SimpleAccount__factory");
    var SimpleAccountFactory__factory_1 = require_SimpleAccountFactory_factory();
    __createBinding(exports2, SimpleAccountFactory__factory_1, "SimpleAccountFactory__factory");
    var StakeManager__factory_1 = require_StakeManager_factory();
    __createBinding(exports2, StakeManager__factory_1, "StakeManager__factory");
    var TokenCallbackHandler__factory_1 = require_TokenCallbackHandler_factory();
    __createBinding(exports2, TokenCallbackHandler__factory_1, "TokenCallbackHandler__factory");
    var TokenPaymaster__factory_1 = require_TokenPaymaster_factory();
    __createBinding(exports2, TokenPaymaster__factory_1, "TokenPaymaster__factory");
    var VerifyingPaymaster__factory_1 = require_VerifyingPaymaster_factory();
    __createBinding(exports2, VerifyingPaymaster__factory_1, "VerifyingPaymaster__factory");
  }
});

// node_modules/@account-abstraction/contracts/dist/types/index.js
var require_types2 = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/types/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    exports2.__esModule = true;
    exports2.VerifyingPaymaster__factory = exports2.TokenPaymaster__factory = exports2.TokenCallbackHandler__factory = exports2.StakeManager__factory = exports2.SimpleAccountFactory__factory = exports2.SimpleAccount__factory = exports2.SenderCreator__factory = exports2.NonceManager__factory = exports2.MaliciousAccount__factory = exports2.IStakeManager__factory = exports2.IPaymaster__factory = exports2.INonceManager__factory = exports2.IEntryPoint__factory = exports2.IAggregator__factory = exports2.IAccount__factory = exports2.EntryPoint__factory = exports2.DepositPaymaster__factory = exports2.BrokenBLSAccountFactory__factory = exports2.BrokenBLSAccount__factory = exports2.BasePaymaster__factory = exports2.BaseAccount__factory = exports2.factories = void 0;
    exports2.factories = require_factories();
    var BaseAccount__factory_1 = require_BaseAccount_factory();
    __createBinding(exports2, BaseAccount__factory_1, "BaseAccount__factory");
    var BasePaymaster__factory_1 = require_BasePaymaster_factory();
    __createBinding(exports2, BasePaymaster__factory_1, "BasePaymaster__factory");
    var BrokenBLSAccount__factory_1 = require_BrokenBLSAccount_factory();
    __createBinding(exports2, BrokenBLSAccount__factory_1, "BrokenBLSAccount__factory");
    var BrokenBLSAccountFactory__factory_1 = require_BrokenBLSAccountFactory_factory();
    __createBinding(exports2, BrokenBLSAccountFactory__factory_1, "BrokenBLSAccountFactory__factory");
    var DepositPaymaster__factory_1 = require_DepositPaymaster_factory();
    __createBinding(exports2, DepositPaymaster__factory_1, "DepositPaymaster__factory");
    var EntryPoint__factory_1 = require_EntryPoint_factory();
    __createBinding(exports2, EntryPoint__factory_1, "EntryPoint__factory");
    var IAccount__factory_1 = require_IAccount_factory();
    __createBinding(exports2, IAccount__factory_1, "IAccount__factory");
    var IAggregator__factory_1 = require_IAggregator_factory();
    __createBinding(exports2, IAggregator__factory_1, "IAggregator__factory");
    var IEntryPoint__factory_1 = require_IEntryPoint_factory();
    __createBinding(exports2, IEntryPoint__factory_1, "IEntryPoint__factory");
    var INonceManager__factory_1 = require_INonceManager_factory();
    __createBinding(exports2, INonceManager__factory_1, "INonceManager__factory");
    var IPaymaster__factory_1 = require_IPaymaster_factory();
    __createBinding(exports2, IPaymaster__factory_1, "IPaymaster__factory");
    var IStakeManager__factory_1 = require_IStakeManager_factory();
    __createBinding(exports2, IStakeManager__factory_1, "IStakeManager__factory");
    var MaliciousAccount__factory_1 = require_MaliciousAccount_factory();
    __createBinding(exports2, MaliciousAccount__factory_1, "MaliciousAccount__factory");
    var NonceManager__factory_1 = require_NonceManager_factory();
    __createBinding(exports2, NonceManager__factory_1, "NonceManager__factory");
    var SenderCreator__factory_1 = require_SenderCreator_factory();
    __createBinding(exports2, SenderCreator__factory_1, "SenderCreator__factory");
    var SimpleAccount__factory_1 = require_SimpleAccount_factory();
    __createBinding(exports2, SimpleAccount__factory_1, "SimpleAccount__factory");
    var SimpleAccountFactory__factory_1 = require_SimpleAccountFactory_factory();
    __createBinding(exports2, SimpleAccountFactory__factory_1, "SimpleAccountFactory__factory");
    var StakeManager__factory_1 = require_StakeManager_factory();
    __createBinding(exports2, StakeManager__factory_1, "StakeManager__factory");
    var TokenCallbackHandler__factory_1 = require_TokenCallbackHandler_factory();
    __createBinding(exports2, TokenCallbackHandler__factory_1, "TokenCallbackHandler__factory");
    var TokenPaymaster__factory_1 = require_TokenPaymaster_factory();
    __createBinding(exports2, TokenPaymaster__factory_1, "TokenPaymaster__factory");
    var VerifyingPaymaster__factory_1 = require_VerifyingPaymaster_factory();
    __createBinding(exports2, VerifyingPaymaster__factory_1, "VerifyingPaymaster__factory");
  }
});

// node_modules/@account-abstraction/contracts/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@account-abstraction/contracts/dist/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    exports2.__esModule = true;
    __exportStar(require_types2(), exports2);
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/ERC4337EthersSigner.js
var require_ERC4337EthersSigner = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/ERC4337EthersSigner.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERC4337EthersSigner = void 0;
    var properties_1 = (init_lib4(), __toCommonJS(lib_exports4));
    var abstract_signer_1 = (init_lib13(), __toCommonJS(lib_exports13));
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var ethers_2 = (init_lib26(), __toCommonJS(lib_exports26));
    var common_1 = require_src4();
    var gasless_messaging_sdk_1 = require_build();
    var isomorphic_ws_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var ERC4337EthersSigner = class extends abstract_signer_1.Signer {
      constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {
        super();
        this.config = config;
        this.originalSigner = originalSigner;
        this.erc4337provider = erc4337provider;
        this.httpRpcClient = httpRpcClient;
        this.smartAccountAPI = smartAccountAPI;
        (0, properties_1.defineReadOnly)(this, "provider", erc4337provider);
      }
      // This one is called by Contract. It signs the request and passes in to Provider to be sent.
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      async sendTransaction(transaction, walletDeployOnly = false, engine) {
        var _a, _b;
        const socketServerUrl = this.config.socketServerUrl;
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
          try {
            await clientMessenger.connect();
            common_1.Logger.log("socket connection success", { socketServerUrl });
          } catch (err) {
            common_1.Logger.error("socket connection failure", err);
          }
        }
        common_1.Logger.log("received transaction ", transaction);
        const customData = transaction.customData;
        common_1.Logger.log("customData", customData);
        if (customData && (customData.isBatchedToMultiSend || !customData.isDeployed)) {
          if (customData.appliedGasLimit) {
            transaction.gasLimit = customData.appliedGasLimit;
            common_1.Logger.log("gaslimit applied from custom data...", transaction.gasLimit);
          }
        }
        delete transaction.customData;
        let userOperation;
        if (walletDeployOnly === true) {
          userOperation = await this.smartAccountAPI.createSignedUserOp({
            target: [""],
            data: [""],
            value: [0],
            gasLimit: [21e3]
          });
        } else {
          this.verifyAllNecessaryFields(transaction);
          userOperation = await this.smartAccountAPI.createSignedUserOp({
            target: transaction.to ? [transaction.to] : [ethers_1.ethers.constants.AddressZero],
            data: ((_a = transaction.data) === null || _a === void 0 ? void 0 : _a.toString()) ? [(_b = transaction.data) === null || _b === void 0 ? void 0 : _b.toString()] : ["0x"],
            value: transaction.value ? [transaction.value] : [0],
            gasLimit: transaction.gasLimit
          });
        }
        common_1.Logger.log("signed userOp ", userOperation);
        let bundlerServiceResponse;
        try {
          bundlerServiceResponse = await this.httpRpcClient.sendUserOpToBundler(userOperation);
          common_1.Logger.log("bundlerServiceResponse", bundlerServiceResponse);
        } catch (error) {
          throw this.unwrapError(error);
        }
        if (clientMessenger && clientMessenger.socketClient.isConnected()) {
          clientMessenger.createTransactionNotifier(bundlerServiceResponse.transactionId, {
            onHashGenerated: async (tx) => {
              if (tx) {
                const txHash = tx.transactionHash;
                const txId = tx.transactionId;
                common_1.Logger.log("Tx Hash generated message received at client", {
                  transactionId: txId,
                  hash: txHash
                });
                engine && engine.emit("txHashGenerated", {
                  id: tx.transactionId,
                  hash: tx.transactionHash,
                  msg: "txn hash generated"
                });
              }
            },
            onHashChanged: async (tx) => {
              if (tx) {
                const txHash = tx.transactionHash;
                const txId = tx.transactionId;
                common_1.Logger.log("Tx Hash changed message received at client", {
                  transactionId: txId,
                  hash: txHash
                });
                engine && engine.emit("txHashChanged", {
                  id: tx.transactionId,
                  hash: tx.transactionHash,
                  msg: "txn hash changed"
                });
              }
            },
            onError: async (tx) => {
              if (tx) {
                common_1.Logger.error("Error message received at client", JSON.stringify(tx));
                const err = tx.error;
                const txId = tx.transactionId;
                clientMessenger.unsubscribe(txId);
                engine && engine.emit("error", {
                  id: tx.transactionId,
                  error: err,
                  msg: "txn hash generated"
                });
                throw new Error(err);
              }
            }
          });
        }
        const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation, bundlerServiceResponse.transactionId, engine);
        return transactionResponse;
      }
      async sendTransactionBatch(transactions, engine) {
        const socketServerUrl = this.config.socketServerUrl;
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
          try {
            await clientMessenger.connect();
            common_1.Logger.log("socket connection success", { socketServerUrl });
          } catch (err) {
            common_1.Logger.error("socket connection failure", err);
          }
        }
        common_1.Logger.log("received transaction ", transactions);
        transactions.map(this.verifyAllNecessaryFields);
        const target = transactions.map((element) => {
          var _a;
          return (_a = element.to) !== null && _a !== void 0 ? _a : ethers_1.ethers.constants.AddressZero;
        });
        const data = transactions.map((element) => {
          var _a;
          return (_a = element.data) !== null && _a !== void 0 ? _a : "0x";
        });
        const value = transactions.map((element) => {
          var _a;
          return (_a = element.value) !== null && _a !== void 0 ? _a : ethers_2.BigNumber.from(0);
        });
        const userOperation = await this.smartAccountAPI.createSignedUserOp({
          target,
          data,
          value
        });
        common_1.Logger.log("signed userOp ", userOperation);
        let bundlerServiceResponse;
        try {
          bundlerServiceResponse = await this.httpRpcClient.sendUserOpToBundler(userOperation);
          common_1.Logger.log("bundlerServiceResponse", bundlerServiceResponse);
        } catch (error) {
          throw this.unwrapError(error);
        }
        if (clientMessenger && clientMessenger.socketClient.isConnected()) {
          clientMessenger.createTransactionNotifier(bundlerServiceResponse.transactionId, {
            onHashGenerated: async (tx) => {
              if (tx) {
                const txHash = tx.transactionHash;
                const txId = tx.transactionId;
                common_1.Logger.log("Tx Hash generated message received at client", {
                  transactionId: txId,
                  hash: txHash
                });
                engine && engine.emit("txHashGenerated", {
                  id: tx.transactionId,
                  hash: tx.transactionHash,
                  msg: "txn hash generated"
                });
              }
            },
            onHashChanged: async (tx) => {
              if (tx) {
                const txHash = tx.transactionHash;
                const txId = tx.transactionId;
                common_1.Logger.log("Tx Hash changed message received at client", {
                  transactionId: txId,
                  hash: txHash
                });
                engine && engine.emit("txHashChanged", {
                  id: tx.transactionId,
                  hash: tx.transactionHash,
                  msg: "txn hash changed"
                });
              }
            },
            onError: async (tx) => {
              if (tx) {
                common_1.Logger.error("Error message received at client", JSON.stringify(tx));
                const err = tx.error;
                const txId = tx.transactionId;
                clientMessenger.unsubscribe(txId);
                engine && engine.emit("error", {
                  id: tx.transactionId,
                  error: err,
                  msg: "txn hash generated"
                });
                throw new Error(err);
              }
            }
          });
        }
        const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation, bundlerServiceResponse.transactionId, engine);
        return transactionResponse;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      unwrapError(errorIn) {
        var _a;
        if (errorIn.body != null) {
          const errorBody = JSON.parse(errorIn.body);
          let paymasterInfo = "";
          let failedOpMessage = (_a = errorBody === null || errorBody === void 0 ? void 0 : errorBody.error) === null || _a === void 0 ? void 0 : _a.message;
          if ((failedOpMessage === null || failedOpMessage === void 0 ? void 0 : failedOpMessage.includes("FailedOp")) === true) {
            const matched = failedOpMessage.match(/FailedOp\((.*)\)/);
            if (matched != null) {
              const split = matched[1].split(",");
              paymasterInfo = `(paymaster address: ${split[1]})`;
              failedOpMessage = split[2];
            }
          }
          const error = new Error(`The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo})`);
          error.stack = errorIn.stack;
          return error;
        }
        return errorIn;
      }
      verifyAllNecessaryFields(transactionRequest) {
        if (transactionRequest.to == null) {
          throw new Error("Missing call target");
        }
        if (transactionRequest.data == null && transactionRequest.value == null) {
          throw new Error("Missing call data or value");
        }
      }
      connect(provider) {
        common_1.Logger.log("changing providers connect called", provider);
        throw new Error("changing providers is not supported");
      }
      async getAddress() {
        if (this.address == null) {
          this.address = await this.erc4337provider.getSenderAccountAddress();
        }
        return this.address;
      }
      async signMessage(message) {
        return await this.originalSigner.signMessage(message);
      }
      async signTransaction(transaction) {
        common_1.Logger.log("signTransaction called", transaction);
        throw new Error("not implemented");
      }
      async signUserOperation(userOperation) {
        const message = await this.smartAccountAPI.getUserOpHash(userOperation);
        return await this.originalSigner.signMessage(message);
      }
    };
    exports2.ERC4337EthersSigner = ERC4337EthersSigner;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/UserOperationEventListener.js
var require_UserOperationEventListener = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/UserOperationEventListener.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserOperationEventListener = void 0;
    var utils_1 = require_utils();
    var debug_1 = __importDefault(require_browser3());
    var common_1 = require_src4();
    var debug = (0, debug_1.default)("aa.listener");
    var DEFAULT_TRANSACTION_TIMEOUT = 1e4;
    var UserOperationEventListener = class {
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      constructor(resolve, reject, entryPoint, sender, userOpHash, nonce, timeout) {
        var _a;
        this.resolve = resolve;
        this.reject = reject;
        this.entryPoint = entryPoint;
        this.sender = sender;
        this.userOpHash = userOpHash;
        this.nonce = nonce;
        this.timeout = timeout;
        this.resolved = false;
        this.boundLisener = this.listenerCallback.bind(this);
        setTimeout(() => {
          this.stop();
          this.reject(new Error("Timed out"));
        }, (_a = this.timeout) !== null && _a !== void 0 ? _a : DEFAULT_TRANSACTION_TIMEOUT);
      }
      start() {
        const filter = this.entryPoint.filters.UserOperationEvent(this.userOpHash);
        setTimeout(async () => {
          const res = await this.entryPoint.queryFilter(filter, "latest");
          if (res.length > 0) {
            void this.listenerCallback(res[0]);
          } else {
            this.entryPoint.once(filter, this.boundLisener);
          }
        }, 3e4);
      }
      stop() {
        this.entryPoint.off("UserOperationEvent", this.boundLisener);
      }
      async listenerCallback(...param) {
        var _a;
        common_1.Logger.log("listenerCallback", { param });
        const event = param[param.length - 1];
        if (event.args == null) {
          console.error("got event without args", event);
          return;
        }
        if (event.args.userOpHash !== this.userOpHash) {
          common_1.Logger.log(`== event with wrong userOpHash: sender/nonce: event.${event.args.sender}@${event.args.nonce.toString()}!= userOp.${this.sender}@${parseInt((_a = this.nonce) === null || _a === void 0 ? void 0 : _a.toString())}`);
          return;
        }
        const transactionReceipt = await event.getTransactionReceipt();
        transactionReceipt.transactionHash = this.userOpHash;
        debug("got event with status=", event.args.success, "gasUsed=", transactionReceipt.gasUsed);
        if (!event.args.success) {
          await this.extractFailureReason(transactionReceipt);
        }
        this.stop();
        this.resolve(transactionReceipt);
        this.resolved = true;
      }
      async extractFailureReason(receipt) {
        debug("mark tx as failed");
        receipt.status = 0;
        const revertReasonEvents = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash, this.sender), receipt.blockHash);
        if (revertReasonEvents[0] != null) {
          let message = revertReasonEvents[0].args.revertReason;
          if (message.startsWith("0x08c379a0")) {
            message = utils_1.defaultAbiCoder.decode(["string"], "0x" + message.substring(10)).toString();
          }
          debug(`rejecting with reason: ${message}`);
          this.reject(new Error(`UserOp failed with reason: ${message}`));
        }
      }
    };
    exports2.UserOperationEventListener = UserOperationEventListener;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/ERC4337EthersProvider.js
var require_ERC4337EthersProvider = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/ERC4337EthersProvider.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERC4337EthersProvider = void 0;
    var providers_1 = (init_lib23(), __toCommonJS(lib_exports23));
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var utils_1 = require_utils();
    var common_1 = require_src4();
    var ERC4337EthersSigner_1 = require_ERC4337EthersSigner();
    var UserOperationEventListener_1 = require_UserOperationEventListener();
    var gasless_messaging_sdk_1 = require_build();
    var isomorphic_ws_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var common_2 = require_src4();
    var ERC4337EthersProvider = class extends providers_1.BaseProvider {
      constructor(config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI) {
        super({
          name: "ERC-4337 Custom Network",
          chainId: config.chainId
        });
        this.config = config;
        this.originalSigner = originalSigner;
        this.originalProvider = originalProvider;
        this.httpRpcClient = httpRpcClient;
        this.entryPoint = entryPoint;
        this.smartAccountAPI = smartAccountAPI;
        this.signer = new ERC4337EthersSigner_1.ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);
      }
      async init() {
        this.initializedBlockNumber = await this.originalProvider.getBlockNumber();
        await this.smartAccountAPI.init();
        return this;
      }
      getSigner() {
        return this.signer;
      }
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      async perform(method, params) {
        if (method === "sendTransaction" || method === "getTransactionReceipt") {
          throw new Error("Should not get here. Investigate.");
        }
        return await this.originalProvider.perform(method, params);
      }
      async getTransaction(transactionHash) {
        return await super.getTransaction(transactionHash);
      }
      async getTransactionReceipt(transactionHash) {
        const userOpHash = await transactionHash;
        const sender = await this.getSenderAccountAddress();
        return await new Promise((resolve, reject) => {
          new UserOperationEventListener_1.UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();
        });
      }
      async getSenderAccountAddress() {
        return await this.smartAccountAPI.getAccountAddress();
      }
      async waitForTransaction(transactionHash, confirmations, timeout) {
        common_2.Logger.log("waitForTransaction", { transactionHash, confirmations, timeout });
        const sender = await this.getSenderAccountAddress();
        return await new Promise((resolve, reject) => {
          const listener = new UserOperationEventListener_1.UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, void 0, timeout);
          listener.start();
        });
      }
      // fabricate a response (using messaging SDK) in a format usable by ethers users...
      async constructUserOpTransactionResponse(userOp1, transactionId, engine) {
        const socketServerUrl = this.config.socketServerUrl;
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
          try {
            await clientMessenger.connect();
            common_2.Logger.log("socket connection success", { socketServerUrl });
          } catch (err) {
            common_2.Logger.error("socket connection failure", err);
          }
        }
        const userOp = await (0, utils_1.resolveProperties)(userOp1);
        const userOpHash = (0, common_1.getUserOpHash)(userOp, this.config.entryPointAddress, this.config.chainId);
        const waitPromise = new Promise((resolve, reject) => {
          if (clientMessenger && clientMessenger.socketClient.isConnected()) {
            clientMessenger.createTransactionNotifier(transactionId, {
              onMined: (tx) => {
                const txId = tx.transactionId;
                clientMessenger.unsubscribe(txId);
                common_2.Logger.log("Tx Hash mined message received at client", {
                  transactionId: txId,
                  hash: tx.transactionHash,
                  receipt: tx.receipt
                });
                const receipt = tx.receipt;
                engine && engine.emit("txMined", {
                  msg: "txn mined",
                  id: txId,
                  hash: tx.transactionHash,
                  receipt: tx.receipt
                });
                resolve(receipt);
              },
              onError: async (err) => {
                reject(err);
              }
            });
          }
        });
        return {
          hash: userOpHash,
          confirmations: 0,
          from: userOp.sender,
          nonce: ethers_1.BigNumber.from(userOp.nonce).toNumber(),
          gasLimit: ethers_1.BigNumber.from(userOp.callGasLimit),
          value: ethers_1.BigNumber.from(0),
          data: (0, utils_1.hexValue)(userOp.callData),
          chainId: this.config.chainId,
          wait: async (confirmations) => {
            common_2.Logger.log("wait confirmations", { confirmations });
            const transactionReceipt = waitPromise.then((receipt) => {
              return receipt;
            });
            if (userOp.initCode.length !== 0) {
              await this.smartAccountAPI.checkAccountDeployed();
            }
            return transactionReceipt;
          }
        };
      }
      async detectNetwork() {
        return this.originalProvider.detectNetwork();
      }
    };
    exports2.ERC4337EthersProvider = ERC4337EthersProvider;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/HttpRpcClient.js
var require_HttpRpcClient = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/HttpRpcClient.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpRpcClient = void 0;
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var utils_1 = require_utils();
    var httpRequests_1 = require_httpRequests();
    var debug_1 = __importDefault(require_browser3());
    var common_1 = require_src4();
    var debug = (0, debug_1.default)("aa.rpc");
    var HttpRpcClient = class {
      // initializing: Promise<void>
      constructor(bundlerUrl, entryPointAddress, chainId, dappAPIKey) {
        this.bundlerUrl = bundlerUrl;
        this.entryPointAddress = entryPointAddress;
        this.chainId = chainId;
        this.dappAPIKey = dappAPIKey;
        this.userOpJsonRpcProvider = new ethers_1.ethers.providers.JsonRpcProvider(this.bundlerUrl, {
          name: "Not actually connected to network, only talking to the Bundler!",
          chainId
        });
      }
      // review : bundler needs to support this
      async validateChainId() {
        const chain = await this.userOpJsonRpcProvider.send("eth_chainId", []);
        const bundlerChain = parseInt(chain);
        if (bundlerChain !== this.chainId) {
          throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);
        }
      }
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      async sendUserOpToBundler(userOp1) {
        const hexifiedUserOp = (0, common_1.deepHexlify)(await (0, utils_1.resolveProperties)(userOp1));
        let params;
        if (this.dappAPIKey && this.dappAPIKey !== "") {
          const metaData = {
            dappAPIKey: this.dappAPIKey
          };
          params = [hexifiedUserOp, this.entryPointAddress, this.chainId, metaData];
        } else {
          params = [hexifiedUserOp, this.entryPointAddress, this.chainId];
        }
        const response = await (0, httpRequests_1.sendRequest)({
          url: `${this.bundlerUrl}`,
          method: httpRequests_1.HttpMethod.Post,
          body: {
            method: "eth_sendUserOperation",
            params,
            id: 1234,
            jsonrpc: "2.0"
          }
        });
        common_1.Logger.log("rest relayer : response", response);
        if (response && response.data) {
          const transactionId = response.data.transactionId;
          const connectionUrl = response.data.connectionUrl;
          return {
            connectionUrl,
            transactionId
          };
        } else {
          return {
            error: response.error || "transaction failed"
          };
        }
      }
      async estimateUserOpGas(userOp1) {
        const hexifiedUserOp = (0, common_1.deepHexlify)(await (0, utils_1.resolveProperties)(userOp1));
        return await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas", [
          hexifiedUserOp,
          this.entryPointAddress
        ]);
      }
      async printUserOperation(method, [userOp1, entryPointAddress]) {
        const userOp = await (0, utils_1.resolveProperties)(userOp1);
        debug("sending", method, {
          ...userOp
          // initCode: (userOp.initCode ?? '').length,
          // callData: (userOp.callData ?? '').length
        }, entryPointAddress);
      }
    };
    exports2.HttpRpcClient = HttpRpcClient;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/Provider.js
var require_Provider = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/Provider.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newProvider = void 0;
    var contracts_1 = require_dist5();
    var SmartAccountAPI_1 = require_SmartAccountAPI();
    var ERC4337EthersProvider_1 = require_ERC4337EthersProvider();
    var HttpRpcClient_1 = require_HttpRpcClient();
    async function newProvider(originalProvider, config, originalSigner = originalProvider.getSigner(), walletAddress, implementationAddress, fallbackHandlerAddress, factoryAddress) {
      const entryPoint = contracts_1.EntryPoint__factory.connect(config.entryPointAddress, originalProvider);
      const smartWalletAPI = new SmartAccountAPI_1.SmartAccountAPI(originalProvider, entryPoint, config, walletAddress, implementationAddress, originalSigner, fallbackHandlerAddress, factoryAddress, 0);
      const httpRpcClient = new HttpRpcClient_1.HttpRpcClient(config.bundlerUrl, config.entryPointAddress, config.chainId, config.dappAPIKey);
      const ethProvider = await new ERC4337EthersProvider_1.ERC4337EthersProvider(config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartWalletAPI).init();
      return ethProvider;
    }
    exports2.newProvider = newProvider;
  }
});

// node_modules/@biconomy/account-abstraction/dist/src/index.js
var require_src10 = __commonJS({
  "node_modules/@biconomy/account-abstraction/dist/src/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERC4337EthersProvider = exports2.ERC4337EthersSigner = exports2.newProvider = exports2.FallbackGasTankAPI = exports2.BiconomyPaymasterAPI = exports2.BaseAccountAPI = exports2.SmartAccountAPI = void 0;
    var SmartAccountAPI_1 = require_SmartAccountAPI();
    Object.defineProperty(exports2, "SmartAccountAPI", { enumerable: true, get: function() {
      return SmartAccountAPI_1.SmartAccountAPI;
    } });
    var BaseAccountAPI_1 = require_BaseAccountAPI();
    Object.defineProperty(exports2, "BaseAccountAPI", { enumerable: true, get: function() {
      return BaseAccountAPI_1.BaseAccountAPI;
    } });
    var BiconomyPaymasterAPI_1 = require_BiconomyPaymasterAPI();
    Object.defineProperty(exports2, "BiconomyPaymasterAPI", { enumerable: true, get: function() {
      return BiconomyPaymasterAPI_1.BiconomyPaymasterAPI;
    } });
    var FallbackGasTankAPI_1 = require_FallbackGasTankAPI();
    Object.defineProperty(exports2, "FallbackGasTankAPI", { enumerable: true, get: function() {
      return FallbackGasTankAPI_1.FallbackGasTankAPI;
    } });
    var Provider_1 = require_Provider();
    Object.defineProperty(exports2, "newProvider", { enumerable: true, get: function() {
      return Provider_1.newProvider;
    } });
    var ERC4337EthersSigner_1 = require_ERC4337EthersSigner();
    Object.defineProperty(exports2, "ERC4337EthersSigner", { enumerable: true, get: function() {
      return ERC4337EthersSigner_1.ERC4337EthersSigner;
    } });
    var ERC4337EthersProvider_1 = require_ERC4337EthersProvider();
    Object.defineProperty(exports2, "ERC4337EthersProvider", { enumerable: true, get: function() {
      return ERC4337EthersProvider_1.ERC4337EthersProvider;
    } });
  }
});

// node_modules/@biconomy/smart-account/dist/src/SmartAccount.js
var require_SmartAccount = __commonJS({
  "node_modules/@biconomy/smart-account/dist/src/SmartAccount.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver2, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state.set(receiver2, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver2, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _SmartAccount_smartAccountConfig;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_types_1 = require_src3();
    var node_client_1 = __importDefault(require_src2());
    var providers_1 = (init_lib23(), __toCommonJS(lib_exports23));
    var relayer_1 = require_src5();
    var _ = __importStar(require_lodash());
    var transactions_1 = __importStar(require_src9());
    var events_1 = __importDefault(require_events());
    var SmartAccountSigner_1 = require_SmartAccountSigner();
    var config_1 = require_config2();
    var account_abstraction_1 = require_src10();
    var common_1 = require_src4();
    var ethers_1 = (init_lib26(), __toCommonJS(lib_exports26));
    var SmartAccount = class extends events_1.default {
      // WIP
      // Could expose recommended provider classes through the SDK
      /**
       * Constructor for the Smart Account. If config is not provided it makes Smart Account available using default configuration
       * If you wish to use your own backend server and relayer service, pass the URLs here
       */
      constructor(signerOrProvider, config) {
        var _a;
        super();
        this.DEFAULT_VERSION = "1.0.0";
        _SmartAccount_smartAccountConfig.set(this, void 0);
        const env2 = (_a = config === null || config === void 0 ? void 0 : config.environment) !== null && _a !== void 0 ? _a : core_types_1.Environments.PROD;
        if (!env2 || env2 === core_types_1.Environments.PROD) {
          common_1.Logger.log("Client connected to production environment");
          __classPrivateFieldSet(this, _SmartAccount_smartAccountConfig, { ...config_1.ProductionConfig }, "f");
        } else if (env2 && env2 === core_types_1.Environments.DEV) {
          common_1.Logger.log("Client connected to testing environment");
          __classPrivateFieldSet(this, _SmartAccount_smartAccountConfig, { ...config_1.DevelopmentConfig }, "f");
        } else {
          common_1.Logger.log("Client connected to STAGING");
          __classPrivateFieldSet(this, _SmartAccount_smartAccountConfig, { ...config_1.StagingConfig }, "f");
        }
        if (!__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId) {
          throw Error("active chain needs to be specified");
        }
        if (__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").supportedNetworksIds.length == 0)
          __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").supportedNetworksIds = [__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId];
        let networkConfig = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").networkConfig;
        if (config) {
          const customNetworkConfig = config.networkConfig || [];
          common_1.Logger.log("Custom network config", customNetworkConfig);
          if (customNetworkConfig.length !== 0) {
            const mergedNetworkConfig = _.merge(_.keyBy(customNetworkConfig, "chainId"), _.keyBy(networkConfig, "chainId"));
            networkConfig = _.values(mergedNetworkConfig);
          }
          common_1.Logger.log("Merged network config values", networkConfig);
          __classPrivateFieldSet(this, _SmartAccount_smartAccountConfig, { ...__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f"), ...config }, "f");
          __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").networkConfig = networkConfig;
        }
        this.supportedNetworkIds = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").supportedNetworksIds;
        if (ethers_1.Signer.isSigner(signerOrProvider)) {
          this.signer = signerOrProvider;
        } else if (providers_1.Provider.isProvider(signerOrProvider)) {
          this.signer = new SmartAccountSigner_1.SmartAccountSigner(signerOrProvider);
        } else {
          common_1.Logger.error("signer or provider is not valid");
        }
        this.nodeClient = new node_client_1.default({ txServiceUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").backendUrl });
        this.relayer = new relayer_1.RestRelayer({
          url: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").relayerUrl,
          socketServerUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").socketServerUrl
        });
        this.aaProvider = {};
        this.chainConfig = [];
      }
      getConfig() {
        return __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f");
      }
      // Changes if we make change in nature of smart account signer
      getsigner() {
        return this.signer;
      }
      getSmartAccountAPI(chainId) {
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const aaSigner = this.aaProvider[chainId].getSigner();
        return aaSigner.smartAccountAPI;
      }
      getProviderUrl(network) {
        var _a;
        common_1.Logger.log("after init smartAccountConfig.networkConfig", __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").networkConfig);
        const networkConfig = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").networkConfig;
        common_1.Logger.log(`networkConfig state is`, networkConfig);
        let providerUrl = ((_a = networkConfig.find((element) => element.chainId === network.chainId)) === null || _a === void 0 ? void 0 : _a.providerUrl) || "";
        common_1.Logger.log("provider url in unioned network config ", providerUrl);
        if (!providerUrl) {
          common_1.Logger.log("using rpc url from chain seed ", network.providerUrl);
          providerUrl = network.providerUrl;
        }
        return providerUrl;
      }
      async getNetworkConfigValues(chainId) {
        var _a;
        const networkConfigValues = await ((_a = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").networkConfig) === null || _a === void 0 ? void 0 : _a.find((element) => element.chainId === chainId));
        if (!networkConfigValues)
          throw new Error("Could not get network config values");
        return networkConfigValues;
      }
      async initializeAtChain(chainId) {
        let exist;
        try {
          exist = this.contractUtils.smartWalletContract[chainId][this.DEFAULT_VERSION].getContract();
        } catch (err) {
          common_1.Logger.log("Chain config contract not loaded ", chainId);
        }
        if (!exist) {
          const network = this.chainConfig.find((element) => element.chainId === chainId);
          if (!network)
            return;
          const providerUrl = this.getProviderUrl(network);
          common_1.Logger.log("init at chain", chainId);
          const walletInfo = await this.getAddress({
            index: 0,
            chainId: network.chainId,
            version: this.DEFAULT_VERSION
          });
          this.address = walletInfo.smartAccountAddress;
          common_1.Logger.log("smart wallet address is ", this.address);
          const readProvider = new ethers_1.ethers.providers.JsonRpcProvider(providerUrl);
          this.provider = readProvider;
          this.contractUtils.initializeContracts(this.signer, readProvider, walletInfo, network);
          const clientConfig = await this.getNetworkConfigValues(network.chainId);
          this.signingService = new account_abstraction_1.FallbackGasTankAPI(__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").biconomySigningServiceUrl || "", clientConfig.dappAPIKey || "");
          this.fallbackRelayer = new relayer_1.FallbackRelayer({
            dappAPIKey: clientConfig.dappAPIKey || "",
            url: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").relayerUrl,
            relayerServiceUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").socketServerUrl
          });
          this.aaProvider[network.chainId] = await (0, account_abstraction_1.newProvider)(new ethers_1.ethers.providers.JsonRpcProvider(providerUrl), {
            dappAPIKey: clientConfig.dappAPIKey || "",
            // Review: default false
            // could come from global set config or method level when we implement fee mode
            strictSponsorshipMode: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").strictSponsorshipMode || false,
            biconomySigningServiceUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").biconomySigningServiceUrl || "",
            socketServerUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").socketServerUrl || "",
            entryPointAddress: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").entryPointAddress ? __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").entryPointAddress : network.entryPoint[network.entryPoint.length - 1].address,
            bundlerUrl: clientConfig.bundlerUrl || __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").bundlerUrl || "",
            chainId: network.chainId,
            customPaymasterAPI: clientConfig.customPaymasterAPI,
            txServiceUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").backendUrl
          }, this.signer, this.address, network.wallet[network.wallet.length - 1].address, network.fallBackHandler[network.fallBackHandler.length - 1].address, network.walletFactory[network.walletFactory.length - 1].address);
        }
      }
      async init() {
        try {
          this.owner = await this.signer.getAddress();
        } catch (error) {
          throw new Error("Invalid Provider, cant get signer address");
        }
        this.setActiveChain(__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId);
        const chainConfig = (await this.nodeClient.getAllSupportedChains()).data;
        this.contractUtils = new transactions_1.ContractUtils(chainConfig);
        for (let index = 0; index < __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").supportedNetworksIds.length; index++) {
          const network = chainConfig.find((element) => element.chainId === __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").supportedNetworksIds[index]);
          if (network) {
            this.chainConfig.push(network);
          }
        }
        await this.initializeAtChain(__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId);
        this.transactionManager = new transactions_1.default(this.contractUtils.getSmartAccountState());
        await this.transactionManager.initialize(this.relayer, this.nodeClient, this.contractUtils);
        return this;
      }
      // WIP
      // Optional methods for connecting paymaster
      // Optional methods for connecting another bundler
      async sendFallbackTransaction(transactionDto) {
        var _a;
        let { version, chainId } = transactionDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        version = version ? version : this.DEFAULT_VERSION;
        await this.initializeAtChain(chainId);
        const transaction = await this.createTransaction(transactionDto);
        const walletContract = this.contractUtils.attachWalletContract(chainId, this.DEFAULT_VERSION, this.address);
        const signature = await this.signUserPaidTransaction({
          version: this.DEFAULT_VERSION,
          tx: transaction,
          chainId,
          signer: this.signer
        });
        const refundInfo = {
          baseGas: transaction.baseGas,
          gasPrice: transaction.gasPrice,
          tokenGasPriceFactor: transaction.tokenGasPriceFactor,
          gasToken: transaction.gasToken,
          refundReceiver: transaction.refundReceiver
        };
        const execTransactionData = await walletContract.interface.encodeFunctionData("execTransaction", [transaction, refundInfo, signature]);
        const fallbackGasTank = this.contractUtils.fallbackGasTankContract[chainId][version].getContract();
        const gasTankNonce = await fallbackGasTank.getNonce(this.address);
        const isDeployed = await this.contractUtils.isDeployed(chainId, this.address);
        const fallbackUserOp = {
          sender: this.address,
          target: this.address,
          nonce: gasTankNonce,
          callData: execTransactionData || "",
          callGasLimit: ethers_1.BigNumber.from(8e5),
          dappIdentifier: "",
          signature: ""
        };
        if (!isDeployed) {
          const network = this.chainConfig.find((element) => element.chainId === chainId);
          if (!network)
            throw new Error("No Network Found for given chainid");
          const { multiSendCall, walletFactory } = this.getSmartAccountContext(chainId);
          const deployWalletEncodedData = await (0, common_1.deployCounterFactualEncodedData)({
            chainId: (_a = await this.provider.getNetwork()) === null || _a === void 0 ? void 0 : _a.chainId,
            owner: await this.owner,
            txServiceUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").backendUrl,
            index: 0
          });
          const txs = [
            {
              to: walletFactory.getAddress(),
              value: 0,
              data: deployWalletEncodedData,
              operation: 0
            },
            {
              to: this.address,
              value: 0,
              data: execTransactionData || "",
              operation: 0
            }
          ];
          const txnData = multiSendCall.getInterface().encodeFunctionData("multiSend", [(0, transactions_1.encodeMultiSend)(txs)]);
          common_1.Logger.log("txnData", txnData);
          fallbackUserOp.target = multiSendCall.getAddress();
          fallbackUserOp.callData = txnData;
        }
        common_1.Logger.log("fallbackUserOp before", fallbackUserOp);
        const signingServiceResponse = await this.signingService.getDappIdentifierAndSign(fallbackUserOp);
        fallbackUserOp.dappIdentifier = signingServiceResponse.dappIdentifier;
        fallbackUserOp.signature = signingServiceResponse.signature;
        common_1.Logger.log("fallbackUserOp after", fallbackUserOp);
        const handleFallBackData = await fallbackGasTank.populateTransaction.handleFallbackUserOp(fallbackUserOp);
        const rawTrx = {
          to: fallbackGasTank.address,
          data: handleFallBackData.data,
          value: 0,
          chainId
        };
        const signedTx = {
          rawTx: rawTrx,
          tx: transaction
        };
        const state = await this.contractUtils.getSmartAccountState();
        const relayTrx = {
          signedTx,
          config: state,
          context: this.getSmartAccountContext(chainId)
        };
        const relayResponse = await this.fallbackRelayer.relay(relayTrx, this);
        return relayResponse;
      }
      /**
       * @description this function will make complete transaction data for updateImplementationTrx
       * @param chainId
       * @returns
       */
      async updateImplementationTrx(chainId) {
        const isWalletDeployed = await this.isDeployed(chainId);
        if (isWalletDeployed) {
          const chainInfo = this.chainConfig.find((element) => element.chainId === chainId);
          if (!chainInfo) {
            throw new Error("No ChainInfo Found");
          }
          const latestImpAddress = chainInfo.wallet[chainInfo.wallet.length - 1].address;
          const walletsImpAddress = await this.contractUtils.getSmartAccountState().implementationAddress;
          if (latestImpAddress !== walletsImpAddress) {
            const updateImplementationCallData = await (0, common_1.updateImplementationEncodedData)(latestImpAddress);
            return { to: this.address, value: ethers_1.BigNumber.from(0), data: updateImplementationCallData };
          }
        }
        return { to: this.address, value: 0, data: "0x" };
      }
      /**
       * @description this function will make complete transaction data for updateFallBackHandlerTrx
       * @param chainId
       * @returns
       */
      async updateFallBackHandlerTrx(chainId) {
        const isWalletDeployed = await this.isDeployed(chainId);
        if (isWalletDeployed) {
          const chainInfo = this.chainConfig.find((element) => element.chainId === chainId);
          if (!chainInfo) {
            throw new Error("No ChainInfo Found");
          }
          const latestfallBackHandlerAddress = chainInfo.fallBackHandler[chainInfo.fallBackHandler.length - 1].address;
          const walletInfo = await this.contractUtils.getSmartAccountState();
          const fallBackHandlerAddress = walletInfo.fallbackHandlerAddress;
          if (latestfallBackHandlerAddress !== fallBackHandlerAddress) {
            const fallbackHandlerCallData = await (0, common_1.fallbackHandlerEncodedData)(latestfallBackHandlerAddress);
            return { to: this.address, value: ethers_1.BigNumber.from(0), data: fallbackHandlerCallData };
          }
        }
        return { to: this.address, value: 0, data: "0x" };
      }
      /**
       * @description this function will let dapp to update Base wallet Implemenation to Latest
       * @returns
       */
      async updateFallbackHandler() {
        const chainId = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const fallbackHandlerTrx = await this.updateFallBackHandlerTrx(__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId);
        await this.initializeAtChain(chainId);
        const aaSigner = this.aaProvider[chainId].getSigner();
        const response = await aaSigner.sendTransaction(fallbackHandlerTrx, false);
        return response;
      }
      /**
       * @description this function will let dapp to update FallBackHandler to Latest
       * @returns
       */
      async updateImplementation() {
        const chainId = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const updateImplTrx = await this.updateImplementationTrx(__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId);
        await this.initializeAtChain(chainId);
        const aaSigner = this.aaProvider[chainId].getSigner();
        const response = await aaSigner.sendTransaction(updateImplTrx, false);
        return response;
      }
      // TODO: single method. can have types as aa-4337 and non-4337. can have fee modes based on types
      async sendTransaction(transactionDto) {
        let isFallbackEnabled = false;
        try {
          const { data } = await this.nodeClient.isFallbackEnabled();
          isFallbackEnabled = data.enable_fallback_flow;
          common_1.Logger.log("isFallbackEnabled", data.enable_fallback_flow);
        } catch (error) {
          console.error("isFallbackEnabled", error);
        }
        if (isFallbackEnabled) {
          return this.sendFallbackTransaction(transactionDto);
        }
        let { chainId } = transactionDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const aaSigner = this.aaProvider[chainId].getSigner();
        await this.initializeAtChain(chainId);
        const batchTrx = [];
        const updateImplTrx = await this.updateImplementationTrx(chainId);
        let response;
        if (updateImplTrx.data != "0x") {
          batchTrx.push(updateImplTrx, transactionDto.transaction);
          response = this.sendTransactionBatch({ transactions: batchTrx });
        } else {
          response = await aaSigner.sendTransaction(transactionDto.transaction, false);
        }
        return response;
      }
      async sendTransactionBatch(transactionBatchDto) {
        let { chainId } = transactionBatchDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const { transactions } = transactionBatchDto;
        const aaSigner = this.aaProvider[chainId].getSigner();
        const updateImplTrx = await this.updateImplementationTrx(chainId);
        if (updateImplTrx.data != "0x") {
          transactions.unshift(updateImplTrx);
        }
        const response = await aaSigner.sendTransactionBatch(transactions, false);
        return response;
      }
      // Only to deploy wallet using connected paymaster
      async deployWalletUsingPaymaster() {
        const aaSigner = this.aaProvider[__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId].getSigner();
        const transaction = {
          to: core_types_1.ZERO_ADDRESS,
          data: "0x"
        };
        const response = await aaSigner.sendTransaction(transaction, true);
        return response;
      }
      /**
       *
       * @param smartAccountVersion
       * @description // set wallet version to be able to interact with different deployed versions
       */
      async setSmartAccountVersion(smartAccountVersion) {
        this.DEFAULT_VERSION = smartAccountVersion;
        this.address = (await this.getAddress({
          index: 0,
          chainId: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId,
          version: this.DEFAULT_VERSION
        })).smartAccountAddress;
        return this;
      }
      async getAlltokenBalances(balancesDto) {
        return this.nodeClient.getAlltokenBalances(balancesDto);
      }
      async getTotalBalanceInUsd(balancesDto) {
        return this.nodeClient.getTotalBalanceInUsd(balancesDto);
      }
      async getSmartAccountsByOwner(smartAccountByOwnerDto) {
        return this.nodeClient.getSmartAccountsByOwner(smartAccountByOwnerDto);
      }
      async getTransactionByAddress(chainId, address) {
        return this.nodeClient.getTransactionByAddress(chainId, address);
      }
      async getTransactionByHash(txHash) {
        return this.nodeClient.getTransactionByHash(txHash);
      }
      // Assigns transaction relayer to this smart wallet instance
      /**
       * Assigns transaction relayer to this smart wallet instance
       * @notice Assumption is that relayer will accept calls for all supported chains
       * @param relayer Relayer client to be associated with this smart account
       * @returns this/self
       */
      async setRelayer(relayer) {
        if (relayer === void 0)
          return this;
        this.relayer = relayer;
        return this;
      }
      /**
       * Allows to change default active chain of the Smart Account
       * @param chainId
       * @returns self/this
       */
      async setActiveChain(chainId) {
        __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId = chainId;
        await this.initializeAtChain(__classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId);
        return this;
      }
      // TODO: single method. can have types as aa-4337 and non-4337. can have fee modes based on types
      /*async signTransaction() {
      
        }*/
      /**
       *
       * @notice personal sign is used currently (Signer should be able to use _typedSignData)
       * @param tx IWalletTransaction Smart Account Transaction object prepared
       * @param chainId optional chainId
       * @returns:string Signature
       */
      async signUserPaidTransaction(signUserPaidTransactionDto) {
        const { chainId = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId, tx } = signUserPaidTransactionDto;
        const signatureType = __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").signType;
        const walletContract = this.contractUtils.attachWalletContract(chainId, this.DEFAULT_VERSION, this.address);
        let signature = "0x";
        if (signatureType === core_types_1.SignTypeMethod.PERSONAL_SIGN) {
          const { data } = await (0, transactions_1.smartAccountSignMessage)(this.signer, walletContract, tx, chainId);
          signature += data.slice(2);
        } else {
          const { data } = await (0, transactions_1.smartAccountSignTypedData)(this.signer, walletContract, tx, chainId);
          signature += data.slice(2);
        }
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
          const correctV = potentiallyIncorrectV + 27;
          signature = signature.slice(0, -2) + correctV.toString(16);
        }
        common_1.Logger.log("non-4337 flow signature: ", signature);
        return signature;
      }
      // This would be a implementation on non-aa4337 provider
      /**
       * Prepares encoded wallet transaction, gets signature from the signer and dispatches to the blockchain using relayer
       * @param tx IWalletTransaction Smart Account Transaction object prepared
       * @param chainId optional chainId
       * @returns transactionId : transaction identifier
       */
      // Forward transaction // rename options: sendDirectTransactionWithFeeQuote
      async sendUserPaidTransaction(sendUserPaidTransactionDto) {
        let { chainId } = sendUserPaidTransactionDto;
        const { tx } = sendUserPaidTransactionDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const { gasLimit } = sendUserPaidTransactionDto;
        const isDeployed = await this.contractUtils.isDeployed(chainId, this.address);
        const rawTx = {
          to: tx.to,
          data: tx.data,
          chainId
        };
        const transaction = {
          to: tx.to,
          value: tx.value,
          data: tx.data,
          operation: tx.operation,
          targetTxGas: tx.targetTxGas
        };
        const refundInfo = {
          baseGas: tx.baseGas,
          gasPrice: tx.gasPrice,
          tokenGasPriceFactor: tx.tokenGasPriceFactor,
          gasToken: tx.gasToken,
          refundReceiver: tx.refundReceiver
        };
        const walletContract = this.contractUtils.attachWalletContract(chainId, this.DEFAULT_VERSION, this.address);
        const signature = await this.signUserPaidTransaction({
          version: this.DEFAULT_VERSION,
          tx,
          chainId,
          signer: this.signer
        });
        const execTransaction = await walletContract.populateTransaction.execTransaction(transaction, refundInfo, signature);
        rawTx.to = this.address;
        rawTx.data = execTransaction.data;
        const state = await this.contractUtils.getSmartAccountState();
        const signedTx = {
          rawTx,
          tx
        };
        const relayTrx = {
          signedTx,
          config: state,
          context: this.getSmartAccountContext(chainId)
        };
        if (gasLimit) {
          relayTrx.gasLimit = gasLimit;
        } else {
          relayTrx.gasLimit = {
            hex: "0xC3500",
            type: "hex"
          };
        }
        if (!isDeployed) {
          relayTrx.gasLimit = {
            hex: "0x1E8480",
            type: "hex"
          };
        }
        const relayResponse = await this.relayer.relay(relayTrx, this);
        if (relayResponse.transactionId) {
          return relayResponse.transactionId;
        }
        return "";
      }
      // TODO: single method. can have types as aa-4337 and non-4337. can have fee modes based on types
      /*async sendSignedTransaction() {
      
        }*/
      async sendSignedTransactionWithFeeQuote(sendUserPaidSignedTransactionDto) {
        let { chainId } = sendUserPaidSignedTransactionDto;
        const { tx, signature } = sendUserPaidSignedTransactionDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        let { gasLimit } = sendUserPaidSignedTransactionDto;
        const isDeployed = await this.contractUtils.isDeployed(chainId, this.address);
        const rawTx = {
          to: tx.to,
          data: tx.data,
          value: 0,
          chainId
        };
        const transaction = {
          to: tx.to,
          value: tx.value,
          data: tx.data,
          operation: tx.operation,
          targetTxGas: tx.targetTxGas
        };
        const refundInfo = {
          baseGas: tx.baseGas,
          gasPrice: tx.gasPrice,
          tokenGasPriceFactor: tx.tokenGasPriceFactor,
          gasToken: tx.gasToken,
          refundReceiver: tx.refundReceiver
        };
        const walletContract = this.contractUtils.attachWalletContract(chainId, this.DEFAULT_VERSION, this.address);
        const execTransaction = await walletContract.populateTransaction.execTransaction(transaction, refundInfo, signature);
        rawTx.to = this.address;
        rawTx.data = execTransaction.data;
        const state = await this.contractUtils.getSmartAccountState();
        const signedTx = {
          rawTx,
          tx
        };
        const relayTrx = {
          signedTx,
          config: state,
          context: this.getSmartAccountContext(chainId)
        };
        if (gasLimit) {
          relayTrx.gasLimit = gasLimit;
        }
        if (!isDeployed) {
          gasLimit = {
            hex: "0x1E8480",
            type: "hex"
          };
          relayTrx.gasLimit = gasLimit;
        }
        const relayResponse = await this.relayer.relay(relayTrx, this);
        common_1.Logger.log("relayResponse", relayResponse);
        if (relayResponse.transactionId) {
          return relayResponse.transactionId;
        }
        return "";
      }
      // Get Fee Options from relayer and make it available for display
      // We can also show list of transactions to be processed (decodeContractCall)
      /**
       *
       * @param getFeeQuotesDto
       */
      async getFeeQuotes(getFeeQuotesDto) {
        let { version, chainId } = getFeeQuotesDto;
        const { transaction } = getFeeQuotesDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        version = version ? version : this.DEFAULT_VERSION;
        return this.transactionManager.getFeeQuotes({
          chainId,
          version,
          transaction
        });
      }
      // Get Fee Options from relayer and make it available for display
      // We can also show list of transactions to be processed (decodeContractCall)
      /**
       *
       * @param getFeeQuotesForBatchDto
       */
      // TODO: rename to getFeeQuotes // can keep single method for batch and single tx
      async getFeeQuotesForBatch(getFeeQuotesForBatchDto) {
        let { version, chainId } = getFeeQuotesForBatchDto;
        const { transactions } = getFeeQuotesForBatchDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        version = version ? version : this.DEFAULT_VERSION;
        return this.transactionManager.getFeeQuotesForBatch({
          version,
          chainId,
          transactions
        });
      }
      // Other helpers go here for pre build (feeOptions and quotes from relayer) , build and execution of refund type transactions
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
       * @param createUserPaidTransactionDto
       * @returns
       */
      // options : createSCWTransactionWithFeeQuote / invokeAccountWithFeeQuote / createDirectSCWTransaction
      async createUserPaidTransaction(createUserPaidTransactionDto) {
        let { version, chainId } = createUserPaidTransactionDto;
        const { transaction, feeQuote } = createUserPaidTransactionDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        version = version ? version : this.DEFAULT_VERSION;
        return this.transactionManager.createUserPaidTransaction({
          version,
          transaction,
          chainId,
          feeQuote
        });
      }
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is without fee refund (gasless)
       * @param transactionDto
       * @returns
       */
      async createTransaction(transactionDto) {
        let { version, chainId } = transactionDto;
        const { transaction } = transactionDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        version = version ? version : this.DEFAULT_VERSION;
        return this.transactionManager.createTransaction({ chainId, version, transaction });
      }
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is without fee refund (gasless)
       * @param transaction
       * @param chainId
       * @returns
       */
      async createTransactionBatch(transactionBatchDto) {
        let { version, chainId } = transactionBatchDto;
        const { transactions } = transactionBatchDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        version = version ? version : this.DEFAULT_VERSION;
        return this.transactionManager.createTransactionBatch({
          version,
          transactions,
          chainId
        });
      }
      /**
       * Prepares compatible IWalletTransaction object based on Transaction Request
       * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
       * @param createUserPaidTransactionBatchDto
       * @returns
       */
      async createUserPaidTransactionBatch(createUserPaidTransactionBatchDto) {
        let { version, chainId } = createUserPaidTransactionBatchDto;
        const { transactions, feeQuote } = createUserPaidTransactionBatchDto;
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        version = version ? version : this.DEFAULT_VERSION;
        return this.transactionManager.createUserPaidTransactionBatch({
          version,
          transactions,
          chainId,
          feeQuote
        });
      }
      /**
       *
       * @param chainId optional chainId
       * @returns Smart Wallet Contract instance attached with current smart account address (proxy)
       */
      smartAccount(chainId) {
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const smartWallet = this.contractUtils.smartWalletContract[chainId][this.DEFAULT_VERSION];
        const address = this.address;
        smartWallet.getContract().attach(address);
        return smartWallet;
      }
      /**
       *
       * @param address EOA address
       * @param chainId optional chainId
       * @param index optional index for counterfactual address
       * @returns SmartAccount address for given EOA address
       */
      async getSmartAccountAddress(owner, chainId, index) {
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        index = index ? index : 0;
        const factoryAddr = this.contractUtils.smartWalletFactoryContract[chainId][this.DEFAULT_VERSION];
        return await factoryAddr.getAddressForCounterFactualAccount(owner, index);
      }
      /**
       *
       * @param chainId optional chainId
       * @returns Smart Wallet Factory instance for requested chainId
       */
      factory(chainId) {
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        return this.contractUtils.smartWalletFactoryContract[chainId][this.DEFAULT_VERSION];
      }
      multiSend(chainId) {
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        return this.contractUtils.multiSendContract[chainId][this.DEFAULT_VERSION];
      }
      // WIP
      // expose getMultiSend(), getMultiSendCall()
      async getAddress(addressForCounterFactualWalletDto) {
        const { index, chainId } = addressForCounterFactualWalletDto;
        const walletInfo = await (0, common_1.getWalletInfo)({
          chainId,
          owner: this.owner,
          txServiceUrl: __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").backendUrl,
          index
        });
        common_1.Logger.log("walletInfo ", walletInfo);
        this.address = walletInfo.smartAccountAddress;
        const smartAccountState = {
          chainId,
          version: walletInfo.version,
          address: walletInfo.smartAccountAddress,
          owner: this.owner,
          isDeployed: walletInfo.isDeployed,
          entryPointAddress: walletInfo.entryPointAddress,
          implementationAddress: walletInfo.implementationAddress,
          fallbackHandlerAddress: walletInfo.fallBackHandlerAddress,
          factoryAddress: walletInfo.factoryAddress
        };
        this.contractUtils.setSmartAccountState(smartAccountState);
        return walletInfo;
      }
      /**
       * Allows one to check if the smart account is already deployed on requested chainOd
       * @notice the check is made on Wallet Factory state with current address in Smart Account state
       * @param chainId optional chainId : Default is current active
       * @returns
       */
      async isDeployed(chainId) {
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        return await this.contractUtils.isDeployed(chainId, this.address);
      }
      /**
       * @param chainId requested chain : default is active chain
       * @returns object containing infromation (owner, relevant contract addresses, isDeployed) about Smart Account for requested chain
       */
      async getSmartAccountState() {
        return this.contractUtils.getSmartAccountState();
      }
      //
      /**
       * Serves smart contract instances associated with Smart Account for requested ChainId
       * Context is useful when relayer is deploying a wallet
       * @param chainId requested chain : default is active chain
       * @returns object containing relevant contract instances
       */
      getSmartAccountContext(chainId) {
        chainId = chainId ? chainId : __classPrivateFieldGet(this, _SmartAccount_smartAccountConfig, "f").activeNetworkId;
        const context = this.contractUtils.getSmartAccountContext(chainId, this.DEFAULT_VERSION);
        return context;
      }
    };
    _SmartAccount_smartAccountConfig = /* @__PURE__ */ new WeakMap();
    exports2.default = SmartAccount;
  }
});

// node_modules/@biconomy/smart-account/dist/src/index.js
var require_src11 = __commonJS({
  "node_modules/@biconomy/smart-account/dist/src/index.js"(exports2) {
    init_process();
    init_buffer();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var SmartAccount_1 = __importDefault(require_SmartAccount());
    exports2.default = SmartAccount_1.default;
  }
});
export default require_src11();
/*! Bundled license information:

amqplib/lib/defs.js:
  (** @preserve This file is generated by the script
   * ../bin/generate-defs.js, which is not in general included in a
   * distribution, but is available in the source repository e.g. at
   * https://github.com/squaremo/amqp.node/
   *)

bluebird/js/browser/bluebird.js:
  (* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2013-2018 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   *)

utf8/utf8.js:
  (*! https://mths.be/utf8js v3.0.0 by @mathias *)
*/
//# sourceMappingURL=@biconomy_smart-account.js.map
