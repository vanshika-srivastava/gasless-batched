import {
  WalletConnectProvider,
  init_ethereumProvider_esm
} from "./chunk-B2MYMUV7.js";
import {
  ADAPTER_CATEGORY,
  ADAPTER_EVENTS,
  ADAPTER_NAMESPACES,
  ADAPTER_STATUS,
  BaseAdapter,
  CHAIN_NAMESPACES,
  CommonPrivateKeyProvider,
  JRPCEngine,
  PostMessageStream,
  SafeEventEmitter,
  WALLET_ADAPTERS,
  WalletInitializationError,
  WalletLoginError,
  Web3AuthError,
  _assertThisInitialized,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _get,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _slicedToArray,
  _typeof,
  base64url,
  base_esm_exports,
  checkIfTokenIsExpired,
  clearToken,
  createIdRemapMiddleware,
  createStreamMiddleware,
  getChainConfig,
  getRpcPromiseCallback,
  getSavedToken,
  init_assertThisInitialized,
  init_asyncToGenerator,
  init_baseProvider_esm,
  init_base_esm,
  init_classCallCheck,
  init_createClass,
  init_defineProperty,
  init_get,
  init_getPrototypeOf,
  init_inherits,
  init_openloginJrpc_esm,
  init_openloginUtils_esm,
  init_possibleConstructorReturn,
  init_slicedToArray,
  init_typeof,
  jsonToBase64,
  keccak,
  log,
  randomId,
  require_lodash,
  require_loglevel,
  require_pump,
  require_regenerator,
  safeatob,
  saveToken,
  setupMultiplex,
  signChallenge,
  storageAvailable,
  verifySignedChallenge
} from "./chunk-FEAYSPVD.js";
import {
  require_client
} from "./chunk-IUTJYGP5.js";
import {
  require_react
} from "./chunk-DCWOWBMG.js";
import {
  require_src
} from "./chunk-UNGKAARR.js";
import "./chunk-SKIYUWIC.js";
import {
  require_base64_js,
  require_elliptic,
  require_ieee754
} from "./chunk-3CFYJ5LS.js";
import {
  require_crypto
} from "./chunk-EG7FL5OY.js";
import {
  init_lib26 as init_lib,
  lib_exports26 as lib_exports,
  require_sha3
} from "./chunk-YHT3EI6P.js";
import {
  require_buffer
} from "./chunk-PZEDZEUW.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __export,
  __reExport,
  __toCommonJS,
  __toESM,
  init_buffer,
  init_process,
  process
} from "./chunk-ARAA7IXG.js";

// node_modules/@web3auth/base-plugin/dist/basePlugin.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var PLUGIN_NAMESPACES;
var init_basePlugin_esm = __esm({
  "node_modules/@web3auth/base-plugin/dist/basePlugin.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    init_base_esm();
    PLUGIN_NAMESPACES = _objectSpread(_objectSpread({}, CHAIN_NAMESPACES), {}, {
      MULTICHAIN: "multichain"
    });
  }
});

// node_modules/@web3auth/core/dist/core.esm.js
var core_esm_exports = {};
__export(core_esm_exports, {
  Web3AuthCore: () => Web3AuthCore
});
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var import_regenerator, ADAPTER_CACHE_KEY, Web3AuthCore;
var init_core_esm = __esm({
  "node_modules/@web3auth/core/dist/core.esm.js"() {
    init_process();
    init_buffer();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_regenerator = __toESM(require_regenerator());
    init_openloginJrpc_esm();
    init_base_esm();
    init_basePlugin_esm();
    ADAPTER_CACHE_KEY = "Web3Auth-cachedAdapter";
    Web3AuthCore = function(_SafeEventEmitter) {
      _inherits(Web3AuthCore2, _SafeEventEmitter);
      var _super = _createSuper(Web3AuthCore2);
      function Web3AuthCore2(options) {
        var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;
        var _this;
        _classCallCheck(this, Web3AuthCore2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "coreOptions", void 0);
        _defineProperty(_assertThisInitialized(_this), "connectedAdapterName", null);
        _defineProperty(_assertThisInitialized(_this), "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(_assertThisInitialized(_this), "cachedAdapter", null);
        _defineProperty(_assertThisInitialized(_this), "walletAdapters", {});
        _defineProperty(_assertThisInitialized(_this), "plugins", {});
        _defineProperty(_assertThisInitialized(_this), "storage", "localStorage");
        if (!options.clientId)
          throw WalletInitializationError.invalidParams("Please provide a valid clientId in constructor");
        if (options.enableLogging)
          log.enableAll();
        else
          log.disableAll();
        if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace))
          throw WalletInitializationError.invalidParams("Please provide a valid chainNamespace in chainConfig");
        if (options.storageKey === "session")
          _this.storage = "sessionStorage";
        _this.cachedAdapter = storageAvailable(_this.storage) ? window[_this.storage].getItem(ADAPTER_CACHE_KEY) : null;
        _this.coreOptions = _objectSpread2(_objectSpread2({}, options), {}, {
          chainConfig: _objectSpread2(_objectSpread2({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)
        });
        _this.subscribeToAdapterEvents = _this.subscribeToAdapterEvents.bind(_assertThisInitialized(_this));
        return _this;
      }
      _createClass(Web3AuthCore2, [{
        key: "provider",
        get: function get2() {
          if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {
            var adapter = this.walletAdapters[this.connectedAdapterName];
            return adapter.provider;
          }
          return null;
        },
        set: function set(_4) {
          throw new Error("Not implemented");
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
            var _this2 = this;
            var initPromises;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    initPromises = Object.keys(this.walletAdapters).map(function(adapterName) {
                      _this2.subscribeToAdapterEvents(_this2.walletAdapters[adapterName]);
                      if (!_this2.walletAdapters[adapterName].chainConfigProxy) {
                        var providedChainConfig = _this2.coreOptions.chainConfig;
                        if (!providedChainConfig.chainNamespace)
                          throw WalletInitializationError.invalidParams("Please provide chainNamespace in chainConfig");
                        var chainConfig = _objectSpread2(_objectSpread2({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);
                        _this2.walletAdapters[adapterName].setChainConfig(chainConfig);
                      }
                      _this2.walletAdapters[adapterName].setAdapterSettings({
                        sessionTime: _this2.coreOptions.sessionTime,
                        clientId: _this2.coreOptions.clientId
                      });
                      return _this2.walletAdapters[adapterName].init({
                        autoConnect: _this2.cachedAdapter === adapterName
                      }).catch(function(e3) {
                        return log.error(e3);
                      });
                    });
                    this.status = ADAPTER_STATUS.READY;
                    _context.next = 4;
                    return Promise.all(initPromises);
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "configureAdapter",
        value: function configureAdapter(adapter) {
          this.checkInitRequirements();
          var providedChainConfig = this.coreOptions.chainConfig;
          if (!providedChainConfig.chainNamespace)
            throw WalletInitializationError.invalidParams("Please provide chainNamespace in chainConfig");
          var adapterAlreadyExists = this.walletAdapters[adapter.name];
          if (adapterAlreadyExists)
            throw WalletInitializationError.duplicateAdapterError("Wallet adapter for ".concat(adapter.name, " already exists"));
          if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace)
            throw WalletInitializationError.incompatibleChainNameSpace("This wallet adapter belongs to ".concat(adapter.adapterNamespace, " which is incompatible with currently used namespace: ").concat(providedChainConfig.chainNamespace));
          if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {
            adapter.setChainConfig(providedChainConfig);
          }
          this.walletAdapters[adapter.name] = adapter;
          return this;
        }
      }, {
        key: "clearCache",
        value: function clearCache() {
          if (!storageAvailable(this.storage))
            return;
          window[this.storage].removeItem(ADAPTER_CACHE_KEY);
          this.cachedAdapter = null;
        }
        /**
         * Connect to a specific wallet adapter
         * @param walletName - Key of the walletAdapter to use.
         */
      }, {
        key: "connectTo",
        value: function() {
          var _connectTo = _asyncToGenerator(import_regenerator.default.mark(function _callee2(walletName, loginParams) {
            var provider;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.walletAdapters[walletName]) {
                      _context2.next = 2;
                      break;
                    }
                    throw WalletInitializationError.notFound("Please add wallet adapter for ".concat(walletName, " wallet, before connecting"));
                  case 2:
                    _context2.next = 4;
                    return this.walletAdapters[walletName].connect(loginParams);
                  case 4:
                    provider = _context2.sent;
                    return _context2.abrupt("return", provider);
                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function connectTo(_x, _x2) {
            return _connectTo.apply(this, arguments);
          }
          return connectTo;
        }()
      }, {
        key: "logout",
        value: function() {
          var _logout = _asyncToGenerator(import_regenerator.default.mark(function _callee3() {
            var options, _args3 = arguments;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    options = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {
                      cleanup: false
                    };
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)) {
                      _context3.next = 3;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("No wallet is connected");
                  case 3:
                    _context3.next = 5;
                    return this.walletAdapters[this.connectedAdapterName].disconnect(options);
                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function logout() {
            return _logout.apply(this, arguments);
          }
          return logout;
        }()
      }, {
        key: "getUserInfo",
        value: function() {
          var _getUserInfo = _asyncToGenerator(import_regenerator.default.mark(function _callee4() {
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    log.debug("Getting user info", this.status, this.connectedAdapterName);
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)) {
                      _context4.next = 3;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("No wallet is connected");
                  case 3:
                    return _context4.abrupt("return", this.walletAdapters[this.connectedAdapterName].getUserInfo());
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function getUserInfo() {
            return _getUserInfo.apply(this, arguments);
          }
          return getUserInfo;
        }()
      }, {
        key: "authenticateUser",
        value: function() {
          var _authenticateUser = _asyncToGenerator(import_regenerator.default.mark(function _callee5() {
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)) {
                      _context5.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("No wallet is connected");
                  case 2:
                    return _context5.abrupt("return", this.walletAdapters[this.connectedAdapterName].authenticateUser());
                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function authenticateUser() {
            return _authenticateUser.apply(this, arguments);
          }
          return authenticateUser;
        }()
      }, {
        key: "addPlugin",
        value: function() {
          var _addPlugin = _asyncToGenerator(import_regenerator.default.mark(function _callee6(plugin) {
            return import_regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    if (!this.plugins[plugin.name]) {
                      _context6.next = 2;
                      break;
                    }
                    throw new Error("Plugin ".concat(plugin.name, " already exist"));
                  case 2:
                    if (!(plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace)) {
                      _context6.next = 4;
                      break;
                    }
                    throw new Error("This plugin belongs to ".concat(plugin.pluginNamespace, " namespace which is incompatible with currently used namespace: ").concat(this.coreOptions.chainConfig.chainNamespace));
                  case 4:
                    this.plugins[plugin.name] = plugin;
                    _context6.next = 7;
                    return plugin.initWithWeb3Auth(this);
                  case 7:
                    return _context6.abrupt("return", this);
                  case 8:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function addPlugin(_x3) {
            return _addPlugin.apply(this, arguments);
          }
          return addPlugin;
        }()
      }, {
        key: "subscribeToAdapterEvents",
        value: function subscribeToAdapterEvents(walletAdapter) {
          var _this3 = this;
          walletAdapter.on(ADAPTER_EVENTS.CONNECTED, function() {
            var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee7(data) {
              return import_regenerator.default.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      _this3.status = ADAPTER_STATUS.CONNECTED;
                      _this3.connectedAdapterName = data.adapter;
                      _this3.cacheWallet(data.adapter);
                      log.debug("connected", _this3.status, _this3.connectedAdapterName);
                      _context7.next = 6;
                      return Promise.all(Object.values(_this3.plugins).map(function(plugin) {
                        return plugin.connect().catch(function(error) {
                          if (error.code === 5211) {
                            return;
                          }
                          log.error(error);
                        });
                      }));
                    case 6:
                      _this3.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread2({}, data));
                    case 7:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7);
            }));
            return function(_x4) {
              return _ref.apply(this, arguments);
            };
          }());
          walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, function() {
            var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee8(data) {
              var cachedAdapter;
              return import_regenerator.default.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      _this3.status = ADAPTER_STATUS.READY;
                      if (storageAvailable(_this3.storage)) {
                        cachedAdapter = window[_this3.storage].getItem(ADAPTER_CACHE_KEY);
                        if (_this3.connectedAdapterName === cachedAdapter) {
                          _this3.clearCache();
                        }
                      }
                      log.debug("disconnected", _this3.status, _this3.connectedAdapterName);
                      _context8.next = 5;
                      return Promise.all(Object.values(_this3.plugins).map(function(plugin) {
                        return plugin.disconnect().catch(function(error) {
                          if (error.code === 5211) {
                            return;
                          }
                          log.error(error);
                        });
                      }));
                    case 5:
                      _this3.connectedAdapterName = null;
                      _this3.emit(ADAPTER_EVENTS.DISCONNECTED, data);
                    case 7:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8);
            }));
            return function(_x5) {
              return _ref2.apply(this, arguments);
            };
          }());
          walletAdapter.on(ADAPTER_EVENTS.CONNECTING, function(data) {
            _this3.status = ADAPTER_STATUS.CONNECTING;
            _this3.emit(ADAPTER_EVENTS.CONNECTING, data);
            log.debug("connecting", _this3.status, _this3.connectedAdapterName);
          });
          walletAdapter.on(ADAPTER_EVENTS.ERRORED, function(data) {
            _this3.status = ADAPTER_STATUS.ERRORED;
            _this3.clearCache();
            _this3.emit(ADAPTER_EVENTS.ERRORED, data);
            log.debug("errored", _this3.status, _this3.connectedAdapterName);
          });
          walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, function(data) {
            log.debug("adapter data updated", data);
            _this3.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);
          });
        }
      }, {
        key: "checkInitRequirements",
        value: function checkInitRequirements() {
          if (this.status === ADAPTER_STATUS.CONNECTING)
            throw WalletInitializationError.notReady("Already pending connection");
          if (this.status === ADAPTER_STATUS.CONNECTED)
            throw WalletInitializationError.notReady("Already connected");
          if (this.status === ADAPTER_STATUS.READY)
            throw WalletInitializationError.notReady("Adapter is already initialized");
        }
      }, {
        key: "cacheWallet",
        value: function cacheWallet(walletName) {
          if (!storageAvailable(this.storage))
            return;
          window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);
          this.cachedAdapter = walletName;
        }
      }]);
      return Web3AuthCore2;
    }(SafeEventEmitter);
  }
});

// node_modules/@toruslabs/eccrypto/browser.js
var require_browser = __commonJS({
  "node_modules/@toruslabs/eccrypto/browser.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var browserCrypto = globalThis.crypto || globalThis.msCrypto || {};
    var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    var nodeCrypto = require_crypto();
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var ZERO32 = Buffer.alloc(32, 0);
    function assert2(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failed");
      }
    }
    function isScalar(x3) {
      return Buffer.isBuffer(x3) && x3.length === 32;
    }
    function isValidPrivateKey(privateKey) {
      if (!isScalar(privateKey)) {
        return false;
      }
      return privateKey.compare(ZERO32) > 0 && // > 0
      privateKey.compare(EC_GROUP_ORDER) < 0;
    }
    function equalConstTime(b1, b2) {
      if (b1.length !== b2.length) {
        return false;
      }
      var res = 0;
      for (var i3 = 0; i3 < b1.length; i3++) {
        res |= b1[i3] ^ b2[i3];
      }
      return res === 0;
    }
    function randomBytes2(size) {
      var arr = new Uint8Array(size);
      if (typeof browserCrypto.getRandomValues === "undefined") {
        return Buffer.from(nodeCrypto.randomBytes(size));
      } else {
        browserCrypto.getRandomValues(arr);
      }
      return Buffer.from(arr);
    }
    function sha5122(msg) {
      return new Promise(function(resolve) {
        var hash = nodeCrypto.createHash("sha512");
        var result = hash.update(msg).digest();
        resolve(new Uint8Array(result));
      });
    }
    function getAes(op) {
      return function(iv, key, data) {
        return new Promise(function(resolve) {
          if (subtle) {
            var importAlgorithm = { name: "AES-CBC" };
            var keyp = subtle.importKey("raw", key, importAlgorithm, false, [op]);
            return keyp.then(function(cryptoKey) {
              var encAlgorithm = { name: "AES-CBC", iv };
              return subtle[op](encAlgorithm, cryptoKey, data);
            }).then(function(result) {
              resolve(Buffer.from(new Uint8Array(result)));
            });
          } else {
            if (op === "encrypt") {
              var cipher = nodeCrypto.createCipheriv("aes-256-cbc", key, iv);
              let firstChunk = cipher.update(data);
              let secondChunk = cipher.final();
              resolve(Buffer.concat([firstChunk, secondChunk]));
            } else if (op === "decrypt") {
              var decipher = nodeCrypto.createDecipheriv("aes-256-cbc", key, iv);
              let firstChunk = decipher.update(data);
              let secondChunk = decipher.final();
              resolve(Buffer.concat([firstChunk, secondChunk]));
            }
          }
        });
      };
    }
    var aesCbcEncrypt2 = getAes("encrypt");
    var aesCbcDecrypt2 = getAes("decrypt");
    function hmacSha256Sign2(key, msg) {
      return new Promise(function(resolve) {
        var hmac = nodeCrypto.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var result = hmac.digest();
        resolve(result);
      });
    }
    function hmacSha256Verify2(key, msg, sig) {
      return new Promise(function(resolve) {
        var hmac = nodeCrypto.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var expectedSig = hmac.digest();
        resolve(equalConstTime(expectedSig, sig));
      });
    }
    exports.generatePrivate = function() {
      var privateKey = randomBytes2(32);
      while (!isValidPrivateKey(privateKey)) {
        privateKey = randomBytes2(32);
      }
      return privateKey;
    };
    var getPublic2 = exports.getPublic = function(privateKey) {
      assert2(privateKey.length === 32, "Bad private key");
      assert2(isValidPrivateKey(privateKey), "Bad private key");
      return Buffer.from(ec.keyFromPrivate(privateKey).getPublic("arr"));
    };
    var getPublicCompressed = exports.getPublicCompressed = function(privateKey) {
      assert2(privateKey.length === 32, "Bad private key");
      assert2(isValidPrivateKey(privateKey), "Bad private key");
      let compressed = true;
      return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, "arr"));
    };
    exports.sign = function(privateKey, msg) {
      return new Promise(function(resolve) {
        assert2(privateKey.length === 32, "Bad private key");
        assert2(isValidPrivateKey(privateKey), "Bad private key");
        assert2(msg.length > 0, "Message should not be empty");
        assert2(msg.length <= 32, "Message is too long");
        resolve(Buffer.from(ec.sign(msg, privateKey, { canonical: true }).toDER()));
      });
    };
    exports.verify = function(publicKey, msg, sig) {
      return new Promise(function(resolve, reject) {
        assert2(publicKey.length === 65 || publicKey.length === 33, "Bad public key");
        if (publicKey.length === 65) {
          assert2(publicKey[0] === 4, "Bad public key");
        }
        if (publicKey.length === 33) {
          assert2(publicKey[0] === 2 || publicKey[0] === 3, "Bad public key");
        }
        assert2(msg.length > 0, "Message should not be empty");
        assert2(msg.length <= 32, "Message is too long");
        if (ec.verify(msg, sig, publicKey)) {
          resolve(null);
        } else {
          reject(new Error("Bad signature"));
        }
      });
    };
    var derive = exports.derive = function(privateKeyA, publicKeyB) {
      return new Promise(function(resolve) {
        assert2(Buffer.isBuffer(privateKeyA), "Bad private key");
        assert2(Buffer.isBuffer(publicKeyB), "Bad public key");
        assert2(privateKeyA.length === 32, "Bad private key");
        assert2(isValidPrivateKey(privateKeyA), "Bad private key");
        assert2(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
        if (publicKeyB.length === 65) {
          assert2(publicKeyB[0] === 4, "Bad public key");
        }
        if (publicKeyB.length === 33) {
          assert2(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
        }
        var keyA = ec.keyFromPrivate(privateKeyA);
        var keyB = ec.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic());
        resolve(Buffer.from(Px.toArray()));
      });
    };
    exports.encrypt = function(publicKeyTo, msg, opts) {
      opts = opts || {};
      var iv, ephemPublicKey, ciphertext, macKey;
      return new Promise(function(resolve) {
        var ephemPrivateKey = opts.ephemPrivateKey || randomBytes2(32);
        while (!isValidPrivateKey(ephemPrivateKey)) {
          ephemPrivateKey = opts.ephemPrivateKey || randomBytes2(32);
        }
        ephemPublicKey = getPublic2(ephemPrivateKey);
        resolve(derive(ephemPrivateKey, publicKeyTo));
      }).then(function(Px) {
        return sha5122(Px);
      }).then(function(hash) {
        iv = opts.iv || randomBytes2(16);
        var encryptionKey = hash.slice(0, 32);
        macKey = hash.slice(32);
        return aesCbcEncrypt2(iv, encryptionKey, msg);
      }).then(function(data) {
        ciphertext = data;
        var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
        return hmacSha256Sign2(macKey, dataToMac);
      }).then(function(mac) {
        return {
          iv,
          ephemPublicKey,
          ciphertext,
          mac
        };
      });
    };
    exports.decrypt = function(privateKey, opts) {
      var encryptionKey;
      return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
        return sha5122(Px);
      }).then(function(hash) {
        encryptionKey = hash.slice(0, 32);
        var macKey = hash.slice(32);
        var dataToMac = Buffer.concat([
          opts.iv,
          opts.ephemPublicKey,
          opts.ciphertext
        ]);
        return hmacSha256Verify2(macKey, dataToMac, opts.mac);
      }).then(function(macGood) {
        assert2(macGood, "Bad MAC");
        return aesCbcDecrypt2(opts.iv, encryptionKey, opts.ciphertext);
      }).then(function(msg) {
        return Buffer.from(new Uint8Array(msg));
      });
    };
  }
});

// node_modules/@toruslabs/openlogin/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
async function fetchAndTrace(url, init) {
  let _url = null;
  try {
    _url = new URL(url);
  } catch (error) {
  }
  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {
    const transaction = sentry.startTransaction({
      name: url
    });
    const span = transaction.startChild({
      op: "http"
    });
    const response = await fetch(url, init);
    span.finish();
    transaction.finish();
    return response;
  }
  return fetch(url, init);
}
function getApiKeyHeaders() {
  const headers = {};
  if (apiKey)
    headers[gatewayAuthHeader] = apiKey;
  if (embedHost)
    headers[gatewayEmbedHostHeader] = embedHost;
  return headers;
}
function debugLogResponse(response) {
  log2.info(`Response: ${response.status} ${response.statusText}`);
  log2.info(`Url: ${response.url}`);
}
var import_lodash, import_loglevel, log2, apiKey, embedHost, gatewayAuthHeader, gatewayEmbedHostHeader, sentry, tracingOrigins, tracingPaths, get;
var init_httpHelpers_esm = __esm({
  "node_modules/@toruslabs/openlogin/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    import_lodash = __toESM(require_lodash());
    import_loglevel = __toESM(require_loglevel());
    log2 = import_loglevel.default.getLogger("http-helpers");
    log2.setLevel(import_loglevel.levels.INFO);
    apiKey = "torus-default";
    embedHost = "";
    gatewayAuthHeader = "x-api-key";
    gatewayEmbedHostHeader = "x-embed-host";
    sentry = null;
    tracingOrigins = [];
    tracingPaths = [];
    get = async function(url) {
      let options_ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let customOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const defaultOptions = {
        mode: "cors",
        headers: {}
      };
      if (customOptions.useAPIKey) {
        defaultOptions.headers = _objectSpread3(_objectSpread3({}, defaultOptions.headers), getApiKeyHeaders());
      }
      const options = (0, import_lodash.default)(defaultOptions, options_, {
        method: "GET"
      });
      const response = await fetchAndTrace(url, options);
      if (response.ok) {
        return response.json();
      }
      debugLogResponse(response);
      throw response;
    };
  }
});

// node_modules/@toruslabs/openlogin/dist/openlogin.esm.js
function documentReady() {
  return _documentReady.apply(this, arguments);
}
function _documentReady() {
  _documentReady = _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
    return import_regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function(resolve) {
              if (document.readyState !== "loading") {
                resolve();
              } else {
                document.addEventListener("DOMContentLoaded", function() {
                  resolve();
                });
              }
            }));
          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _documentReady.apply(this, arguments);
}
function getHashQueryParams() {
  var replaceUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var result = {};
  var url = new URL(window.location.href);
  url.searchParams.forEach(function(value, key) {
    if (key !== "result") {
      result[key] = value;
    }
  });
  var queryResult = url.searchParams.get("result");
  if (queryResult) {
    try {
      var queryParams = JSON.parse(safeatob(queryResult));
      Object.keys(queryParams).forEach(function(key) {
        result[key] = queryParams[key];
      });
    } catch (error) {
      log3.error(error);
    }
  }
  var hash = url.hash.substring(1);
  var hashUrl = new URL("".concat(window.location.origin, "/?").concat(hash));
  hashUrl.searchParams.forEach(function(value, key) {
    if (key !== "result") {
      result[key] = value;
    }
  });
  var hashResult = hashUrl.searchParams.get("result");
  if (hashResult) {
    try {
      var hashParams = JSON.parse(safeatob(hashResult));
      Object.keys(hashParams).forEach(function(key) {
        result[key] = hashParams[key];
      });
    } catch (error) {
      log3.error(error);
    }
  }
  if (replaceUrl) {
    var cleanUrl = window.location.origin + window.location.pathname;
    window.history.replaceState(null, "", cleanUrl);
  }
  return result;
}
function awaitReq(id, windowRef) {
  return new Promise(function(resolve, reject) {
    if (!windowRef) {
      reject(new Error("Unable to open window"));
      return;
    }
    var closedByHandler = false;
    var closedMonitor = setInterval(function() {
      if (!closedByHandler && windowRef.closed) {
        clearInterval(closedMonitor);
        reject(new Error("user closed popup"));
      }
    }, 500);
    var handler = function handler2(ev) {
      var pid = ev.data.pid;
      if (id !== pid)
        return;
      window.removeEventListener("message", handler2);
      closedByHandler = true;
      clearInterval(closedMonitor);
      windowRef.close();
      if (ev.data.data && ev.data.data.error) {
        reject(new Error(ev.data.data.error));
      } else {
        resolve(ev.data.data);
      }
    };
    window.addEventListener("message", handler);
  });
}
function constructURL(params) {
  var baseURL = params.baseURL, query = params.query, hash = params.hash;
  var url = new URL(baseURL);
  if (query) {
    Object.keys(query).forEach(function(key) {
      url.searchParams.append(key, query[key]);
    });
  }
  if (hash) {
    var h3 = new URL(constructURL({
      baseURL,
      query: hash
    })).searchParams.toString();
    url.hash = h3;
  }
  return url.toString();
}
function storageAvailable2(type) {
  var storageExists = false;
  var storageLength = 0;
  var storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    var x3 = "__storage_test__";
    storage.setItem(x3, x3);
    storage.removeItem(x3);
    return true;
  } catch (error) {
    return error && // everything except Firefox
    (error.code === 22 || // Firefox
    error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    error.name === "QuotaExceededErro r" || // Firefox
    error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0;
  }
}
function preloadIframe(url) {
  try {
    if (typeof document === "undefined")
      return;
    var openloginIframeHtml = document.createElement("link");
    openloginIframeHtml.href = url;
    openloginIframeHtml.crossOrigin = "anonymous";
    openloginIframeHtml.type = "text/html";
    openloginIframeHtml.rel = "prefetch";
    if (openloginIframeHtml.relList && openloginIframeHtml.relList.supports) {
      if (openloginIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(openloginIframeHtml);
      }
    }
  } catch (error) {
    log3.error(error);
  }
}
function getPopupFeatures() {
  var dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX;
  var dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY;
  var w4 = 1200;
  var h3 = 700;
  var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  var systemZoom = 1;
  var left = Math.abs((width - w4) / 2 / systemZoom + dualScreenLeft);
  var top = Math.abs((height - h3) / 2 / systemZoom + dualScreenTop);
  var features = "titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=".concat(h3 / systemZoom, ",width=").concat(w4 / systemZoom, ",top=").concat(top, ",left=").concat(left);
  return features;
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_loglevel2, import_regenerator2, import_eccrypto, import_lodash2, import_pump, modalDOMElementID, storeKey, UX_MODE, OPENLOGIN_METHOD, ALLOWED_INTERACTIONS, OPENLOGIN_NETWORK, SUPPORTED_KEY_CURVES, log3, htmlToElement, sessionStorageAvailable, localStorageAvailable, handleStream, Modal, MemoryStore, OpenLoginStore, Provider, OpenLogin;
var init_openlogin_esm = __esm({
  "node_modules/@toruslabs/openlogin/dist/openlogin.esm.js"() {
    init_process();
    init_buffer();
    import_loglevel2 = __toESM(require_loglevel());
    init_typeof();
    init_slicedToArray();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    import_regenerator2 = __toESM(require_regenerator());
    import_eccrypto = __toESM(require_browser());
    init_httpHelpers_esm();
    init_openloginJrpc_esm();
    init_openloginUtils_esm();
    import_lodash2 = __toESM(require_lodash());
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    import_pump = __toESM(require_pump());
    modalDOMElementID = "openlogin-modal";
    storeKey = "openlogin_store";
    UX_MODE = {
      POPUP: "popup",
      REDIRECT: "redirect",
      SESSIONLESS_REDIRECT: "sessionless_redirect"
    };
    OPENLOGIN_METHOD = {
      LOGIN: "openlogin_login",
      LOGOUT: "openlogin_logout",
      CHECK_3PC_SUPPORT: "openlogin_check_3PC_support",
      SET_PID_DATA: "openlogin_set_pid_data",
      GET_DATA: "openlogin_get_data"
    };
    ALLOWED_INTERACTIONS = {
      POPUP: "popup",
      REDIRECT: "redirect",
      JRPC: "jrpc"
    };
    OPENLOGIN_NETWORK = {
      MAINNET: "mainnet",
      TESTNET: "testnet",
      CYAN: "cyan",
      DEVELOPMENT: "development",
      SK_TESTNET: "sk_testnet",
      CELESTE: "celeste",
      AQUA: "aqua"
    };
    SUPPORTED_KEY_CURVES = {
      SECP256K1: "secp256k1",
      ED25519: "ed25519"
    };
    import_loglevel2.default.setLevel("error");
    log3 = import_loglevel2.default.getLogger("openlogin");
    htmlToElement = function htmlToElement2(html) {
      var template = window.document.createElement("template");
      var trimmedHtml = html.trim();
      template.innerHTML = trimmedHtml;
      return template.content.firstChild;
    };
    sessionStorageAvailable = storageAvailable2("sessionStorage");
    localStorageAvailable = storageAvailable2("localStorage");
    handleStream = function handleStream2(handle, eventName, handler) {
      var handlerWrapper = function handlerWrapper2(chunk) {
        handler(chunk);
        handle.removeListener(eventName, handlerWrapper2);
      };
      handle.on(eventName, handlerWrapper);
    };
    Modal = function() {
      function Modal2(modalUrl) {
        _classCallCheck(this, Modal2);
        _defineProperty(this, "modalUrl", void 0);
        _defineProperty(this, "iframeElem", void 0);
        _defineProperty(this, "initialized", false);
        _defineProperty(this, "modalZIndex", 99999);
        _defineProperty(this, "mux", void 0);
        _defineProperty(this, "verifierStream", void 0);
        this.modalUrl = modalUrl;
      }
      _createClass(Modal2, [{
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
            return import_regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.initIFrame(this.modalUrl);
                  case 2:
                    this.setupStream();
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "setupStream",
        value: function setupStream() {
          if (this.iframeElem === null)
            throw new Error("iframe is null");
          this.mux = setupMultiplex(new PostMessageStream({
            name: "modal_iframe_rpc",
            target: "modal_rpc",
            targetWindow: this.iframeElem.contentWindow,
            targetOrigin: new URL(this.modalUrl).origin
          }));
          this.verifierStream = this.mux.createStream("verifier");
        }
      }, {
        key: "initIFrame",
        value: function() {
          var _initIFrame = _asyncToGenerator(import_regenerator2.default.mark(function _callee2(src) {
            var _this = this;
            var documentIFrameElem;
            return import_regenerator2.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return documentReady();
                  case 2:
                    documentIFrameElem = document.getElementById(modalDOMElementID);
                    if (documentIFrameElem) {
                      documentIFrameElem.remove();
                      log3.info("already initialized, removing previous modal iframe");
                    }
                    this.iframeElem = htmlToElement("<iframe\n        id=".concat(modalDOMElementID, '\n        class="torusIframe"\n        src="').concat(src, '"\n        style="display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ').concat(this.modalZIndex.toString(), '"\n      ></iframe>'));
                    this._hideModal();
                    document.body.appendChild(this.iframeElem);
                    return _context2.abrupt("return", new Promise(function(resolve) {
                      _this.iframeElem.onload = function() {
                        _this.initialized = true;
                        resolve();
                      };
                    }));
                  case 8:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function initIFrame(_x) {
            return _initIFrame.apply(this, arguments);
          }
          return initIFrame;
        }()
      }, {
        key: "_showModal",
        value: function _showModal() {
          var style = {};
          style.display = "block";
          style.position = "fixed";
          style.width = "100%";
          style.height = "100%";
          style.top = "0px";
          style.right = "0px";
          style.left = "0px";
          style.bottom = "0px";
          style.border = "0";
          style["z-index"] = this.modalZIndex;
          this.iframeElem.setAttribute("style", Object.entries(style).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), k3 = _ref2[0], v3 = _ref2[1];
            return "".concat(k3, ":").concat(v3);
          }).join(";"));
        }
      }, {
        key: "_hideModal",
        value: function _hideModal() {
          var style = {};
          style.display = "none";
          style.position = "fixed";
          style.width = "100%";
          style.height = "100%";
          style.top = "0px";
          style.right = "0px";
          style.left = "0px";
          style.bottom = "0px";
          style.border = "0";
          style["z-index"] = this.modalZIndex;
          this.iframeElem.setAttribute("style", Object.entries(style).map(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), k3 = _ref4[0], v3 = _ref4[1];
            return "".concat(k3, ":").concat(v3);
          }).join(";"));
        }
      }, {
        key: "_prompt",
        value: function() {
          var _prompt2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee3(clientId, whiteLabel, loginConfig, cb) {
            var _this2 = this;
            var modalHandler;
            return import_regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    this._showModal();
                    modalHandler = function modalHandler2(chunk) {
                      _this2._hideModal();
                      cb(chunk);
                    };
                    handleStream(this.verifierStream, "data", modalHandler);
                    this.verifierStream.write({
                      name: "prompt",
                      clientId,
                      whiteLabel,
                      loginConfig
                    });
                  case 4:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function _prompt(_x2, _x3, _x4, _x5) {
            return _prompt2.apply(this, arguments);
          }
          return _prompt;
        }()
      }, {
        key: "cleanup",
        value: function() {
          var _cleanup = _asyncToGenerator(import_regenerator2.default.mark(function _callee4() {
            var documentIFrameElem;
            return import_regenerator2.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return documentReady();
                  case 2:
                    documentIFrameElem = document.getElementById(modalDOMElementID);
                    if (documentIFrameElem) {
                      documentIFrameElem.remove();
                      this.iframeElem = null;
                    }
                    this.initialized = false;
                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function cleanup() {
            return _cleanup.apply(this, arguments);
          }
          return cleanup;
        }()
      }]);
      return Modal2;
    }();
    MemoryStore = function() {
      function MemoryStore2() {
        _classCallCheck(this, MemoryStore2);
        _defineProperty(this, "store", {});
      }
      _createClass(MemoryStore2, [{
        key: "getItem",
        value: function getItem(key) {
          return this.store[key] || null;
        }
      }, {
        key: "setItem",
        value: function setItem(key, value) {
          this.store[key] = value;
        }
      }]);
      return MemoryStore2;
    }();
    OpenLoginStore = function() {
      function OpenLoginStore2(storage, _storeKey) {
        _classCallCheck(this, OpenLoginStore2);
        _defineProperty(this, "_storeKey", storeKey);
        _defineProperty(this, "storage", void 0);
        this.storage = storage;
        this._storeKey = _storeKey || storeKey;
        try {
          if (!storage.getItem(_storeKey || storeKey)) {
            this.resetStore();
          }
        } catch (error) {
        }
      }
      _createClass(OpenLoginStore2, [{
        key: "toJSON",
        value: function toJSON() {
          return this.storage.getItem(this._storeKey);
        }
      }, {
        key: "resetStore",
        value: function resetStore() {
          var currStore = this.getStore();
          this.storage.setItem(this._storeKey, JSON.stringify({}));
          return currStore;
        }
      }, {
        key: "getStore",
        value: function getStore() {
          return JSON.parse(this.storage.getItem(this._storeKey));
        }
      }, {
        key: "get",
        value: function get2(key) {
          var store = JSON.parse(this.storage.getItem(this._storeKey));
          return store[key];
        }
      }, {
        key: "set",
        value: function set(key, value) {
          var store = JSON.parse(this.storage.getItem(this._storeKey));
          store[key] = value;
          this.storage.setItem(this._storeKey, JSON.stringify(store));
        }
      }], [{
        key: "getInstance",
        value: function getInstance(storeNamespace) {
          var storageKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
          if (!this.instance) {
            var storage = new MemoryStore();
            if (storageKey === "local" && localStorageAvailable) {
              storage = localStorage;
            }
            if (storageKey === "session" && sessionStorageAvailable) {
              storage = sessionStorage;
            }
            var finalStoreKey = storeNamespace ? "".concat(storeKey, "_").concat(storeNamespace) : storeKey;
            this.instance = new this(storage, finalStoreKey);
          }
          return this.instance;
        }
      }]);
      return OpenLoginStore2;
    }();
    _defineProperty(OpenLoginStore, "instance", void 0);
    Provider = function(_SafeEventEmitter) {
      _inherits(Provider2, _SafeEventEmitter);
      var _super = _createSuper2(Provider2);
      function Provider2() {
        var _this;
        _classCallCheck(this, Provider2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "iframeElem", null);
        _defineProperty(_assertThisInitialized(_this), "rpcStream", void 0);
        _defineProperty(_assertThisInitialized(_this), "iframeUrl", void 0);
        _defineProperty(_assertThisInitialized(_this), "rpcEngine", void 0);
        _defineProperty(_assertThisInitialized(_this), "initialized", void 0);
        _defineProperty(_assertThisInitialized(_this), "mux", void 0);
        return _this;
      }
      _createClass(Provider2, [{
        key: "init",
        value: function init(_ref) {
          var iframeElem = _ref.iframeElem, iframeUrl = _ref.iframeUrl;
          this.iframeElem = iframeElem;
          this.iframeUrl = iframeUrl;
          this.setupStream();
          this.initialized = true;
        }
      }, {
        key: "setupStream",
        value: function setupStream() {
          if (this.iframeElem === null)
            throw new Error("iframe is null");
          this.rpcStream = new PostMessageStream({
            name: "embed_rpc",
            target: "iframe_rpc",
            targetWindow: this.iframeElem.contentWindow,
            targetOrigin: new URL(this.iframeUrl).origin
          });
          this.mux = setupMultiplex(this.rpcStream);
          var JRPCConnection = createStreamMiddleware();
          (0, import_pump.default)(JRPCConnection.stream, this.mux.createStream("jrpc"), JRPCConnection.stream, function(error) {
            log3.error("JRPC connection broken", error);
          });
          var rpcEngine = new JRPCEngine();
          rpcEngine.push(createIdRemapMiddleware());
          rpcEngine.push(JRPCConnection.middleware);
          this.rpcEngine = rpcEngine;
        }
      }, {
        key: "cleanup",
        value: function cleanup() {
          this.iframeElem = null;
          this.initialized = false;
        }
      }, {
        key: "_rpcRequest",
        value: function _rpcRequest(payload, callback) {
          if (!payload.jsonrpc) {
            payload.jsonrpc = "2.0";
          }
          if (!payload.id) {
            payload.id = randomId();
          }
          this.rpcEngine.handle(payload, callback);
        }
      }]);
      return Provider2;
    }(SafeEventEmitter);
    preloadIframe("https://app.openlogin.com/sdk-modal");
    OpenLogin = function() {
      function OpenLogin2(options) {
        var _options$no3PC, _options$_startUrl, _options$_popupUrl, _options$redirectUrl, _options$uxMode, _options$replaceUrlOn, _options$originData, _options$whiteLabel, _options$loginConfig, _options$_storageServ, _options$_sessionName, _options$webauthnTran;
        _classCallCheck(this, OpenLogin2);
        _defineProperty(this, "provider", void 0);
        _defineProperty(this, "state", void 0);
        _defineProperty(this, "modal", void 0);
        this.provider = new Proxy(new Provider(), {
          deleteProperty: function deleteProperty() {
            return true;
          }
          // work around for web3
        });
        if (!options._iframeUrl) {
          if (options.network === OPENLOGIN_NETWORK.MAINNET) {
            options._iframeUrl = "https://app.openlogin.com";
          } else if (options.network === OPENLOGIN_NETWORK.CYAN) {
            options._iframeUrl = "https://cyan.openlogin.com";
          } else if (options.network === OPENLOGIN_NETWORK.TESTNET) {
            options._iframeUrl = "https://beta.openlogin.com";
          } else if (options.network === OPENLOGIN_NETWORK.SK_TESTNET) {
            options._iframeUrl = "https://beta-sk.openlogin.com";
          } else if (options.network === OPENLOGIN_NETWORK.CELESTE) {
            options._iframeUrl = "https://celeste.openlogin.com";
          } else if (options.network === OPENLOGIN_NETWORK.AQUA) {
            options._iframeUrl = "https://aqua.openlogin.com";
          } else if (options.network === OPENLOGIN_NETWORK.DEVELOPMENT) {
            options._iframeUrl = "http://localhost:3000";
          }
        }
        if (!options._iframeUrl) {
          throw new Error("unspecified network and iframeUrl");
        }
        this.modal = new Modal("".concat(options._iframeUrl, "/sdk-modal"));
        this.initState(_objectSpread4(_objectSpread4({}, options), {}, {
          no3PC: (_options$no3PC = options.no3PC) !== null && _options$no3PC !== void 0 ? _options$no3PC : false,
          _iframeUrl: options._iframeUrl,
          _startUrl: (_options$_startUrl = options._startUrl) !== null && _options$_startUrl !== void 0 ? _options$_startUrl : "".concat(options._iframeUrl, "/start"),
          _popupUrl: (_options$_popupUrl = options._popupUrl) !== null && _options$_popupUrl !== void 0 ? _options$_popupUrl : "".concat(options._iframeUrl, "/popup-window"),
          redirectUrl: (_options$redirectUrl = options.redirectUrl) !== null && _options$redirectUrl !== void 0 ? _options$redirectUrl : "".concat(window.location.protocol, "//").concat(window.location.host).concat(window.location.pathname),
          uxMode: (_options$uxMode = options.uxMode) !== null && _options$uxMode !== void 0 ? _options$uxMode : UX_MODE.REDIRECT,
          replaceUrlOnRedirect: (_options$replaceUrlOn = options.replaceUrlOnRedirect) !== null && _options$replaceUrlOn !== void 0 ? _options$replaceUrlOn : true,
          originData: (_options$originData = options.originData) !== null && _options$originData !== void 0 ? _options$originData : _defineProperty({}, window.location.origin, ""),
          whiteLabel: (_options$whiteLabel = options.whiteLabel) !== null && _options$whiteLabel !== void 0 ? _options$whiteLabel : {},
          loginConfig: (_options$loginConfig = options.loginConfig) !== null && _options$loginConfig !== void 0 ? _options$loginConfig : {},
          _storageServerUrl: (_options$_storageServ = options._storageServerUrl) !== null && _options$_storageServ !== void 0 ? _options$_storageServ : "https://broadcast-server.tor.us",
          storageKey: options.storageKey === "session" ? "session" : "local",
          _sessionNamespace: (_options$_sessionName = options._sessionNamespace) !== null && _options$_sessionName !== void 0 ? _options$_sessionName : "",
          webauthnTransports: (_options$webauthnTran = options.webauthnTransports) !== null && _options$webauthnTran !== void 0 ? _options$webauthnTran : ["internal"]
        }));
      }
      _createClass(OpenLogin2, [{
        key: "privKey",
        get: function get2() {
          return this.state.privKey ? this.state.privKey.padStart(64, "0") : "";
        }
      }, {
        key: "coreKitKey",
        get: function get2() {
          return this.state.coreKitKey ? this.state.coreKitKey.padStart(64, "0") : "";
        }
      }, {
        key: "initState",
        value: function initState(options) {
          this.state = {
            uxMode: options.uxMode,
            network: options.network,
            store: OpenLoginStore.getInstance(options._sessionNamespace, options.storageKey),
            iframeUrl: options._iframeUrl,
            startUrl: options._startUrl,
            popupUrl: options._popupUrl,
            clientId: options.clientId,
            redirectUrl: options.redirectUrl,
            replaceUrlOnRedirect: options.replaceUrlOnRedirect,
            originData: options.originData,
            loginConfig: options.loginConfig,
            support3PC: !options.no3PC,
            whiteLabel: options.whiteLabel,
            storageServerUrl: options._storageServerUrl,
            sessionNamespace: options._sessionNamespace,
            webauthnTransports: options.webauthnTransports
          };
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
            var params, res;
            return import_regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.state.network === OPENLOGIN_NETWORK.TESTNET) {
                      console.log("%c WARNING! You are on testnet. Please set network: 'mainnet' in production", "color: #FF0000");
                    }
                    if (!(this.state.uxMode === UX_MODE.SESSIONLESS_REDIRECT)) {
                      _context.next = 7;
                      break;
                    }
                    _context.next = 4;
                    return this.updateOriginData();
                  case 4:
                    this.state.support3PC = false;
                    _context.next = 10;
                    break;
                  case 7:
                    _context.next = 9;
                    return Promise.all([this.modal.init(), this.updateOriginData()]);
                  case 9:
                    this.provider.init({
                      iframeElem: this.modal.iframeElem,
                      iframeUrl: this.state.iframeUrl
                    });
                  case 10:
                    params = getHashQueryParams(this.state.replaceUrlOnRedirect);
                    if (params.sessionId) {
                      this.state.store.set("sessionId", params.sessionId);
                    }
                    if (!(this.state.uxMode === UX_MODE.SESSIONLESS_REDIRECT)) {
                      _context.next = 16;
                      break;
                    }
                    this._syncState(params);
                    _context.next = 21;
                    break;
                  case 16:
                    _context.t0 = this;
                    _context.next = 19;
                    return this._getData();
                  case 19:
                    _context.t1 = _context.sent;
                    _context.t0._syncState.call(_context.t0, _context.t1);
                  case 21:
                    if (!this.state.support3PC) {
                      _context.next = 26;
                      break;
                    }
                    _context.next = 24;
                    return this._check3PCSupport();
                  case 24:
                    res = _context.sent;
                    this.state.support3PC = !!res.support3PC;
                  case 26:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "updateOriginData",
        value: function() {
          var _updateOriginData = _asyncToGenerator(import_regenerator2.default.mark(function _callee2() {
            var filteredOriginData, _yield$Promise$all, _yield$Promise$all2, whitelist, whiteLabel;
            return import_regenerator2.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    filteredOriginData = JSON.parse(JSON.stringify(this.state.originData));
                    Object.keys(filteredOriginData).forEach(function(key) {
                      if (filteredOriginData[key] === "")
                        delete filteredOriginData[key];
                    });
                    _context2.next = 4;
                    return Promise.all([this.getWhitelist(), this.getWhiteLabel()]);
                  case 4:
                    _yield$Promise$all = _context2.sent;
                    _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                    whitelist = _yield$Promise$all2[0];
                    whiteLabel = _yield$Promise$all2[1];
                    this._syncState({
                      originData: _objectSpread4(_objectSpread4({}, whitelist), filteredOriginData),
                      whiteLabel: _objectSpread4(_objectSpread4({}, whiteLabel), this.state.whiteLabel)
                    });
                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function updateOriginData() {
            return _updateOriginData.apply(this, arguments);
          }
          return updateOriginData;
        }()
      }, {
        key: "getWhitelist",
        value: function() {
          var _getWhitelist = _asyncToGenerator(import_regenerator2.default.mark(function _callee3() {
            var clientId, url, res;
            return import_regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.prev = 0;
                    clientId = this.state.clientId;
                    if (clientId) {
                      _context3.next = 4;
                      break;
                    }
                    throw new Error("unspecified clientId");
                  case 4:
                    url = new URL("https://api.developer.tor.us/whitelist");
                    url.searchParams.append("project_id", this.state.clientId);
                    url.searchParams.append("network", this.state.network);
                    _context3.next = 9;
                    return get(url.href);
                  case 9:
                    res = _context3.sent;
                    return _context3.abrupt("return", res.signed_urls);
                  case 13:
                    _context3.prev = 13;
                    _context3.t0 = _context3["catch"](0);
                    return _context3.abrupt("return", {});
                  case 16:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[0, 13]]);
          }));
          function getWhitelist() {
            return _getWhitelist.apply(this, arguments);
          }
          return getWhitelist;
        }()
      }, {
        key: "getWhiteLabel",
        value: function() {
          var _getWhiteLabel = _asyncToGenerator(import_regenerator2.default.mark(function _callee4() {
            var clientId, url, res;
            return import_regenerator2.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.prev = 0;
                    clientId = this.state.clientId;
                    if (clientId) {
                      _context4.next = 4;
                      break;
                    }
                    throw new Error("unspecified clientId");
                  case 4:
                    url = new URL("https://api.developer.tor.us/whitelabel");
                    url.searchParams.append("project_id", this.state.clientId);
                    _context4.next = 8;
                    return get(url.href);
                  case 8:
                    res = _context4.sent;
                    return _context4.abrupt("return", res.whiteLabel);
                  case 12:
                    _context4.prev = 12;
                    _context4.t0 = _context4["catch"](0);
                    return _context4.abrupt("return", {});
                  case 15:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[0, 12]]);
          }));
          function getWhiteLabel() {
            return _getWhiteLabel.apply(this, arguments);
          }
          return getWhiteLabel;
        }()
      }, {
        key: "login",
        value: function() {
          var _login = _asyncToGenerator(import_regenerator2.default.mark(function _callee5(params) {
            return import_regenerator2.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(params !== null && params !== void 0 && params.loginProvider)) {
                      _context5.next = 2;
                      break;
                    }
                    return _context5.abrupt("return", this._selectedLogin(params));
                  case 2:
                    if (!(this.state.uxMode === UX_MODE.SESSIONLESS_REDIRECT)) {
                      _context5.next = 4;
                      break;
                    }
                    throw new Error("Please pass loginProvider in params while using ".concat(UX_MODE.SESSIONLESS_REDIRECT, " mode"));
                  case 4:
                    return _context5.abrupt("return", this._modal(params));
                  case 5:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function login(_x) {
            return _login.apply(this, arguments);
          }
          return login;
        }()
      }, {
        key: "_selectedLogin",
        value: function() {
          var _selectedLogin2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee6(params) {
            var defaultParams, loginParams, res;
            return import_regenerator2.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    defaultParams = {
                      redirectUrl: this.state.redirectUrl
                    };
                    loginParams = _objectSpread4(_objectSpread4({
                      loginProvider: params.loginProvider
                    }, defaultParams), params);
                    _context6.next = 4;
                    return this.request({
                      method: OPENLOGIN_METHOD.LOGIN,
                      allowedInteractions: [UX_MODE.REDIRECT, UX_MODE.POPUP],
                      startUrl: this.state.startUrl,
                      popupUrl: this.state.popupUrl,
                      params: [loginParams]
                    });
                  case 4:
                    res = _context6.sent;
                    this.state.privKey = res.privKey;
                    if (!res.store) {
                      _context6.next = 10;
                      break;
                    }
                    this._syncState(res);
                    _context6.next = 16;
                    break;
                  case 10:
                    if (!(this.state.privKey && this.state.support3PC)) {
                      _context6.next = 16;
                      break;
                    }
                    _context6.t0 = this;
                    _context6.next = 14;
                    return this._getData();
                  case 14:
                    _context6.t1 = _context6.sent;
                    _context6.t0._syncState.call(_context6.t0, _context6.t1);
                  case 16:
                    return _context6.abrupt("return", {
                      privKey: this.privKey
                    });
                  case 17:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function _selectedLogin(_x2) {
            return _selectedLogin2.apply(this, arguments);
          }
          return _selectedLogin;
        }()
      }, {
        key: "logout",
        value: function() {
          var _logout = _asyncToGenerator(import_regenerator2.default.mark(function _callee7() {
            var logoutParams, params, allowedInteractions, res, _args7 = arguments;
            return import_regenerator2.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    logoutParams = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {};
                    params = {};
                    params.redirectUrl = this.state.redirectUrl;
                    params._clientId = this.state.clientId;
                    params.sessionId = this.state.store.get("sessionId");
                    if (logoutParams.clientId) {
                      params._clientId = logoutParams.clientId;
                    }
                    if (logoutParams.redirectUrl !== void 0) {
                      params.redirectUrl = logoutParams.redirectUrl;
                    }
                    allowedInteractions = this.state.uxMode === UX_MODE.SESSIONLESS_REDIRECT ? [ALLOWED_INTERACTIONS.REDIRECT] : [ALLOWED_INTERACTIONS.JRPC];
                    _context7.next = 10;
                    return this.request({
                      method: OPENLOGIN_METHOD.LOGOUT,
                      params: [params],
                      startUrl: this.state.startUrl,
                      popupUrl: this.state.popupUrl,
                      allowedInteractions
                    });
                  case 10:
                    res = _context7.sent;
                    this._syncState({
                      privKey: "",
                      coreKitKey: "",
                      walletKey: "",
                      oAuthPrivateKey: "",
                      tKey: "",
                      store: {
                        name: "",
                        profileImage: "",
                        dappShare: "",
                        idToken: "",
                        oAuthIdToken: "",
                        oAuthAccessToken: "",
                        sessionId: "",
                        sessionNamespace: "",
                        appState: ""
                      }
                    });
                    return _context7.abrupt("return", res);
                  case 13:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function logout() {
            return _logout.apply(this, arguments);
          }
          return logout;
        }()
      }, {
        key: "request",
        value: function() {
          var _request = _asyncToGenerator(import_regenerator2.default.mark(function _callee8(args) {
            var _params$0$redirectUrl;
            var pid, params, session, startUrl, popupUrl, method, allowedInteractions, userData, sig, sessionId, u3, windowRef, _u, _windowRef;
            return import_regenerator2.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    pid = randomId();
                    params = args.params;
                    session = {};
                    if (!(params.length !== 1)) {
                      _context8.next = 5;
                      break;
                    }
                    throw new Error("request params array should have only one element");
                  case 5:
                    startUrl = args.startUrl, popupUrl = args.popupUrl, method = args.method, allowedInteractions = args.allowedInteractions;
                    if (!(allowedInteractions.length === 0)) {
                      _context8.next = 8;
                      break;
                    }
                    throw new Error("no allowed interactions");
                  case 8:
                    if (this.state.clientId) {
                      session._clientId = this.state.clientId;
                    }
                    if (this.state.sessionNamespace) {
                      session._sessionNamespace = this.state.sessionNamespace;
                    }
                    if (!this.privKey) {
                      _context8.next = 18;
                      break;
                    }
                    userData = {
                      clientId: session._clientId,
                      timestamp: Date.now().toString()
                    };
                    _context8.next = 14;
                    return (0, import_eccrypto.sign)(Buffer.from(this.privKey, "hex"), Buffer.from(keccak("keccak256").update(JSON.stringify(userData)).digest("hex"), "hex"));
                  case 14:
                    sig = _context8.sent;
                    session._user = (0, import_eccrypto.getPublic)(Buffer.from(this.privKey, "hex")).toString("hex");
                    session._userSig = base64url.encode(sig);
                    session._userData = userData;
                  case 18:
                    session._originData = this.state.originData;
                    session._whiteLabelData = this.state.whiteLabel;
                    session._loginConfig = this.state.loginConfig;
                    session._sessionId = this.state.store.get("sessionId");
                    session._webauthnTransports = this.state.webauthnTransports;
                    if (!session._sessionId) {
                      sessionId = randomId();
                      session._sessionId = sessionId;
                      this.state.store.set("sessionId", sessionId);
                    }
                    params = [_objectSpread4(_objectSpread4({}, session), params[0])];
                    if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.JRPC)) {
                      _context8.next = 27;
                      break;
                    }
                    return _context8.abrupt("return", this._jrpcRequest({
                      method,
                      params
                    }));
                  case 27:
                    params[0]._origin = new URL((_params$0$redirectUrl = params[0].redirectUrl) !== null && _params$0$redirectUrl !== void 0 ? _params$0$redirectUrl : this.state.redirectUrl).origin;
                    if (!this.state.support3PC) {
                      _context8.next = 32;
                      break;
                    }
                    _context8.next = 31;
                    return this._setPIDData(pid, params);
                  case 31:
                    params = [{}];
                  case 32:
                    if (!(!startUrl || !popupUrl)) {
                      _context8.next = 34;
                      break;
                    }
                    throw new Error("no url for redirect / popup flow");
                  case 34:
                    if (!(this.state.uxMode === UX_MODE.REDIRECT || this.state.uxMode === UX_MODE.SESSIONLESS_REDIRECT)) {
                      _context8.next = 44;
                      break;
                    }
                    if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {
                      _context8.next = 38;
                      break;
                    }
                    setTimeout(function() {
                      window.location.href = constructURL({
                        baseURL: startUrl,
                        hash: {
                          b64Params: jsonToBase64(params[0]),
                          _pid: pid,
                          _method: method
                        }
                      });
                    }, 50);
                    return _context8.abrupt("return", {});
                  case 38:
                    if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {
                      _context8.next = 42;
                      break;
                    }
                    u3 = new URL(constructURL({
                      baseURL: popupUrl,
                      hash: {
                        b64Params: jsonToBase64(params[0]),
                        _pid: pid,
                        _method: method
                      }
                    }));
                    windowRef = window.open(u3.toString(), "_blank", getPopupFeatures());
                    return _context8.abrupt("return", awaitReq(pid, windowRef));
                  case 42:
                    _context8.next = 51;
                    break;
                  case 44:
                    if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {
                      _context8.next = 48;
                      break;
                    }
                    _u = new URL(constructURL({
                      baseURL: popupUrl,
                      hash: {
                        b64Params: jsonToBase64(params[0]),
                        _pid: pid,
                        _method: method
                      }
                    }));
                    _windowRef = window.open(_u.toString(), "_blank", getPopupFeatures());
                    return _context8.abrupt("return", awaitReq(pid, _windowRef));
                  case 48:
                    if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {
                      _context8.next = 51;
                      break;
                    }
                    setTimeout(function() {
                      window.location.href = constructURL({
                        baseURL: startUrl,
                        hash: {
                          b64Params: jsonToBase64(params[0]),
                          _pid: pid,
                          _method: method
                        }
                      });
                    }, 50);
                    return _context8.abrupt("return", null);
                  case 51:
                    throw new Error("no matching allowed interactions");
                  case 52:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function request(_x3) {
            return _request.apply(this, arguments);
          }
          return request;
        }()
      }, {
        key: "_jrpcRequest",
        value: function() {
          var _jrpcRequest2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee9(args) {
            var _this = this;
            var method, params;
            return import_regenerator2.default.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    if (!(!args || _typeof(args) !== "object" || Array.isArray(args))) {
                      _context9.next = 2;
                      break;
                    }
                    throw new Error("invalid request args");
                  case 2:
                    method = args.method, params = args.params;
                    if (!(typeof method !== "string" || method.length === 0)) {
                      _context9.next = 5;
                      break;
                    }
                    throw new Error("invalid request method");
                  case 5:
                    if (!(params === void 0 || !Array.isArray(params))) {
                      _context9.next = 7;
                      break;
                    }
                    throw new Error("invalid request params");
                  case 7:
                    if (params.length === 0) {
                      params.push({});
                    }
                    return _context9.abrupt("return", new Promise(function(resolve, reject) {
                      _this.provider._rpcRequest({
                        method,
                        params
                      }, getRpcPromiseCallback(resolve, reject));
                    }));
                  case 9:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9);
          }));
          function _jrpcRequest(_x4) {
            return _jrpcRequest2.apply(this, arguments);
          }
          return _jrpcRequest;
        }()
      }, {
        key: "_check3PCSupport",
        value: function() {
          var _check3PCSupport2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee10() {
            return import_regenerator2.default.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    return _context10.abrupt("return", this._jrpcRequest({
                      method: OPENLOGIN_METHOD.CHECK_3PC_SUPPORT,
                      params: [{
                        _originData: this.state.originData
                      }]
                    }));
                  case 1:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function _check3PCSupport() {
            return _check3PCSupport2.apply(this, arguments);
          }
          return _check3PCSupport;
        }()
      }, {
        key: "_setPIDData",
        value: function() {
          var _setPIDData2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee11(pid, data) {
            return import_regenerator2.default.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this.request({
                      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],
                      method: OPENLOGIN_METHOD.SET_PID_DATA,
                      params: [{
                        pid,
                        data: data[0]
                      }]
                    });
                  case 2:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function _setPIDData(_x5, _x6) {
            return _setPIDData2.apply(this, arguments);
          }
          return _setPIDData;
        }()
      }, {
        key: "_getData",
        value: function() {
          var _getData2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee12() {
            return import_regenerator2.default.wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    if (!(this.state.uxMode === UX_MODE.SESSIONLESS_REDIRECT)) {
                      _context12.next = 2;
                      break;
                    }
                    return _context12.abrupt("return", {});
                  case 2:
                    return _context12.abrupt("return", this.request({
                      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],
                      method: OPENLOGIN_METHOD.GET_DATA,
                      params: [{}]
                    }));
                  case 3:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));
          function _getData() {
            return _getData2.apply(this, arguments);
          }
          return _getData;
        }()
      }, {
        key: "_syncState",
        value: function _syncState(newState) {
          var _this2 = this;
          if (newState.store) {
            if (_typeof(newState.store) !== "object") {
              throw new Error("expected store to be an object");
            }
            Object.keys(newState.store).forEach(function(key) {
              _this2.state.store.set(key, newState.store[key]);
            });
          }
          var store = this.state.store;
          this.state = _objectSpread4(_objectSpread4(_objectSpread4({}, this.state), newState), {}, {
            store
          });
        }
      }, {
        key: "_modal",
        value: function() {
          var _modal2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee14(params) {
            var _this3 = this;
            return import_regenerator2.default.wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    return _context14.abrupt("return", new Promise(function(resolve, reject) {
                      _this3.modal._prompt(_this3.state.clientId, _this3.state.whiteLabel, _this3.state.loginConfig, function() {
                        var _ref2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee13(chunk) {
                          var selectedLoginResponse;
                          return import_regenerator2.default.wrap(function _callee13$(_context13) {
                            while (1) {
                              switch (_context13.prev = _context13.next) {
                                case 0:
                                  if (!chunk.cancel) {
                                    _context13.next = 4;
                                    break;
                                  }
                                  reject(new Error("user canceled login"));
                                  _context13.next = 14;
                                  break;
                                case 4:
                                  _context13.prev = 4;
                                  _context13.next = 7;
                                  return _this3._selectedLogin((0, import_lodash2.default)(params, chunk));
                                case 7:
                                  selectedLoginResponse = _context13.sent;
                                  resolve(selectedLoginResponse);
                                  _context13.next = 14;
                                  break;
                                case 11:
                                  _context13.prev = 11;
                                  _context13.t0 = _context13["catch"](4);
                                  reject(_context13.t0);
                                case 14:
                                case "end":
                                  return _context13.stop();
                              }
                            }
                          }, _callee13, null, [[4, 11]]);
                        }));
                        return function(_x8) {
                          return _ref2.apply(this, arguments);
                        };
                      }());
                    }));
                  case 1:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14);
          }));
          function _modal(_x7) {
            return _modal2.apply(this, arguments);
          }
          return _modal;
        }()
      }, {
        key: "_cleanup",
        value: function() {
          var _cleanup2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee15() {
            return import_regenerator2.default.wrap(function _callee15$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.next = 2;
                    return this.modal.cleanup();
                  case 2:
                    this.provider.cleanup();
                  case 3:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee15, this);
          }));
          function _cleanup() {
            return _cleanup2.apply(this, arguments);
          }
          return _cleanup;
        }()
      }, {
        key: "encrypt",
        value: function() {
          var _encrypt2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee16(message, privateKey) {
            var privKey;
            return import_regenerator2.default.wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    privKey = privateKey;
                    if (!privKey) {
                      privKey = this.privKey;
                    }
                    if (/^[0-9a-fA-f]{64}$/.exec(privKey)) {
                      _context16.next = 8;
                      break;
                    }
                    if (!(privKey === "" || privKey === void 0)) {
                      _context16.next = 7;
                      break;
                    }
                    throw new Error("private key cannot be empty");
                  case 7:
                    throw new Error("invalid private key in encrypt");
                  case 8:
                    return _context16.abrupt("return", (0, import_eccrypto.encrypt)((0, import_eccrypto.getPublic)(Buffer.from(privKey, "hex")), message));
                  case 9:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16, this);
          }));
          function encrypt$1(_x9, _x10) {
            return _encrypt2.apply(this, arguments);
          }
          return encrypt$1;
        }()
      }, {
        key: "decrypt",
        value: function() {
          var _decrypt2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee17(ciphertext, privateKey) {
            var privKey;
            return import_regenerator2.default.wrap(function _callee17$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    privKey = privateKey;
                    if (!privKey) {
                      privKey = this.privKey;
                    }
                    if (/^[0-9a-fA-f]{64}$/.exec(privKey)) {
                      _context17.next = 8;
                      break;
                    }
                    if (!(privKey === "" || privKey === void 0)) {
                      _context17.next = 7;
                      break;
                    }
                    throw new Error("private key cannot be empty");
                  case 7:
                    throw new Error("invalid private key in decrypt");
                  case 8:
                    return _context17.abrupt("return", (0, import_eccrypto.decrypt)(Buffer.from(privKey, "hex"), ciphertext));
                  case 9:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee17, this);
          }));
          function decrypt$1(_x11, _x12) {
            return _decrypt2.apply(this, arguments);
          }
          return decrypt$1;
        }()
      }, {
        key: "getUserInfo",
        value: function() {
          var _getUserInfo = _asyncToGenerator(import_regenerator2.default.mark(function _callee18() {
            var storeData, userInfo;
            return import_regenerator2.default.wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    if (!this.privKey) {
                      _context18.next = 4;
                      break;
                    }
                    storeData = this.state.store.getStore();
                    userInfo = {
                      email: storeData.email || "",
                      name: storeData.name || "",
                      profileImage: storeData.profileImage || "",
                      aggregateVerifier: storeData.aggregateVerifier || "",
                      verifier: storeData.verifier || "",
                      verifierId: storeData.verifierId || "",
                      typeOfLogin: storeData.typeOfLogin || "",
                      dappShare: storeData.dappShare || "",
                      idToken: storeData.idToken || "",
                      oAuthIdToken: storeData.oAuthIdToken || "",
                      oAuthAccessToken: storeData.oAuthAccessToken || ""
                    };
                    return _context18.abrupt("return", userInfo);
                  case 4:
                    throw new Error("user should be logged in to fetch userInfo");
                  case 5:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18, this);
          }));
          function getUserInfo() {
            return _getUserInfo.apply(this, arguments);
          }
          return getUserInfo;
        }()
      }, {
        key: "getEncodedLoginUrl",
        value: function() {
          var _getEncodedLoginUrl = _asyncToGenerator(import_regenerator2.default.mark(function _callee19(loginParams) {
            var redirectUrl, clientId, dataObject, b64Params, hashParams;
            return import_regenerator2.default.wrap(function _callee19$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                    redirectUrl = loginParams.redirectUrl;
                    clientId = this.state.clientId;
                    if (this.state.originData[origin]) {
                      _context19.next = 5;
                      break;
                    }
                    _context19.next = 5;
                    return this.updateOriginData();
                  case 5:
                    dataObject = _objectSpread4({
                      _clientId: clientId,
                      _origin: new URL(redirectUrl).origin,
                      _originData: this.state.originData,
                      redirectUrl
                    }, loginParams);
                    b64Params = jsonToBase64(dataObject);
                    hashParams = {
                      b64Params,
                      _method: "openlogin_login"
                    };
                    return _context19.abrupt("return", constructURL({
                      baseURL: "".concat(this.state.iframeUrl, "/start"),
                      hash: hashParams
                    }));
                  case 9:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee19, this);
          }));
          function getEncodedLoginUrl(_x13) {
            return _getEncodedLoginUrl.apply(this, arguments);
          }
          return getEncodedLoginUrl;
        }()
      }]);
      return OpenLogin2;
    }();
  }
});

// node_modules/@web3auth/openlogin-adapter/dist/openloginAdapter.esm.js
var openloginAdapter_esm_exports = {};
__export(openloginAdapter_esm_exports, {
  OpenloginAdapter: () => OpenloginAdapter,
  getOpenloginDefaultOptions: () => getOpenloginDefaultOptions
});
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var import_regenerator3, import_lodash3, getOpenloginDefaultOptions, OpenloginAdapter;
var init_openloginAdapter_esm = __esm({
  "node_modules/@web3auth/openlogin-adapter/dist/openloginAdapter.esm.js"() {
    init_process();
    init_buffer();
    init_openlogin_esm();
    init_base_esm();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_regenerator3 = __toESM(require_regenerator());
    init_baseProvider_esm();
    import_lodash3 = __toESM(require_lodash());
    getOpenloginDefaultOptions = function getOpenloginDefaultOptions2(chainNamespace, chainId) {
      return {
        adapterSettings: {
          network: OPENLOGIN_NETWORK.MAINNET,
          clientId: "",
          uxMode: UX_MODE.POPUP
        },
        chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : null,
        loginSettings: {}
      };
    };
    OpenloginAdapter = function(_BaseAdapter) {
      _inherits(OpenloginAdapter2, _BaseAdapter);
      var _super = _createSuper3(OpenloginAdapter2);
      function OpenloginAdapter2(params) {
        var _params$chainConfig, _params$chainConfig2, _params$adapterSettin, _params$chainConfig3;
        var _this;
        _classCallCheck(this, OpenloginAdapter2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "name", WALLET_ADAPTERS.OPENLOGIN);
        _defineProperty(_assertThisInitialized(_this), "adapterNamespace", ADAPTER_NAMESPACES.MULTICHAIN);
        _defineProperty(_assertThisInitialized(_this), "type", ADAPTER_CATEGORY.IN_APP);
        _defineProperty(_assertThisInitialized(_this), "openloginInstance", null);
        _defineProperty(_assertThisInitialized(_this), "clientId", void 0);
        _defineProperty(_assertThisInitialized(_this), "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(_assertThisInitialized(_this), "currentChainNamespace", CHAIN_NAMESPACES.EIP155);
        _defineProperty(_assertThisInitialized(_this), "openloginOptions", void 0);
        _defineProperty(_assertThisInitialized(_this), "loginSettings", {});
        _defineProperty(_assertThisInitialized(_this), "privKeyProvider", null);
        log.debug("const openlogin adapter", params);
        var defaultOptions = getOpenloginDefaultOptions((_params$chainConfig = params.chainConfig) === null || _params$chainConfig === void 0 ? void 0 : _params$chainConfig.chainNamespace, (_params$chainConfig2 = params.chainConfig) === null || _params$chainConfig2 === void 0 ? void 0 : _params$chainConfig2.chainId);
        _this.openloginOptions = _objectSpread5(_objectSpread5({
          clientId: "",
          network: OPENLOGIN_NETWORK.MAINNET
        }, defaultOptions.adapterSettings), params.adapterSettings || {});
        _this.clientId = (_params$adapterSettin = params.adapterSettings) === null || _params$adapterSettin === void 0 ? void 0 : _params$adapterSettin.clientId;
        _this.loginSettings = _objectSpread5(_objectSpread5({}, defaultOptions.loginSettings), params.loginSettings);
        _this.sessionTime = _this.loginSettings.sessionTime || 86400;
        if ((_params$chainConfig3 = params.chainConfig) !== null && _params$chainConfig3 !== void 0 && _params$chainConfig3.chainNamespace) {
          var _params$chainConfig4;
          _this.currentChainNamespace = (_params$chainConfig4 = params.chainConfig) === null || _params$chainConfig4 === void 0 ? void 0 : _params$chainConfig4.chainNamespace;
          var defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};
          _this.chainConfig = _objectSpread5(_objectSpread5({}, defaultChainIdConfig), params === null || params === void 0 ? void 0 : params.chainConfig);
          log.debug("const openlogin chainConfig", _this.chainConfig);
          if (!_this.chainConfig.rpcTarget && params.chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {
            throw WalletInitializationError.invalidParams("rpcTarget is required in chainConfig");
          }
        }
        return _this;
      }
      _createClass(OpenloginAdapter2, [{
        key: "chainConfigProxy",
        get: function get2() {
          return this.chainConfig ? _objectSpread5({}, this.chainConfig) : null;
        }
      }, {
        key: "provider",
        get: function get2() {
          var _this$privKeyProvider;
          return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;
        },
        set: function set(_4) {
          throw new Error("Not implemented");
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator3.default.mark(function _callee(options) {
            var _this$openloginOption;
            var isRedirectResult, redirectResult;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _get(_getPrototypeOf(OpenloginAdapter2.prototype), "checkInitializationRequirements", this).call(this);
                    if ((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.clientId) {
                      _context.next = 3;
                      break;
                    }
                    throw WalletInitializationError.invalidParams("clientId is required before openlogin's initialization");
                  case 3:
                    if (this.chainConfig) {
                      _context.next = 5;
                      break;
                    }
                    throw WalletInitializationError.invalidParams("chainConfig is required before initialization");
                  case 5:
                    isRedirectResult = false;
                    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT) {
                      redirectResult = getHashQueryParams();
                      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {
                        isRedirectResult = true;
                      }
                    }
                    this.openloginOptions = _objectSpread5(_objectSpread5({}, this.openloginOptions), {}, {
                      replaceUrlOnRedirect: isRedirectResult
                    });
                    this.openloginInstance = new OpenLogin(this.openloginOptions);
                    log.debug("initializing openlogin adapter init");
                    _context.next = 12;
                    return this.openloginInstance.init();
                  case 12:
                    this.status = ADAPTER_STATUS.READY;
                    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);
                    _context.prev = 14;
                    log.debug("initializing openlogin adapter");
                    if (!(this.openloginInstance.privKey && (options.autoConnect || isRedirectResult))) {
                      _context.next = 19;
                      break;
                    }
                    _context.next = 19;
                    return this.connect();
                  case 19:
                    _context.next = 25;
                    break;
                  case 21:
                    _context.prev = 21;
                    _context.t0 = _context["catch"](14);
                    log.error("Failed to connect with cached openlogin provider", _context.t0);
                    this.emit("ERRORED", _context.t0);
                  case 25:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[14, 21]]);
          }));
          function init(_x) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "connect",
        value: function() {
          var _connect = _asyncToGenerator(import_regenerator3.default.mark(function _callee2(params) {
            return import_regenerator3.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _get(_getPrototypeOf(OpenloginAdapter2.prototype), "checkConnectionRequirements", this).call(this);
                    this.status = ADAPTER_STATUS.CONNECTING;
                    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread5(_objectSpread5({}, params), {}, {
                      adapter: WALLET_ADAPTERS.OPENLOGIN
                    }));
                    _context2.prev = 3;
                    _context2.next = 6;
                    return this.connectWithProvider(params);
                  case 6:
                    return _context2.abrupt("return", this.provider);
                  case 9:
                    _context2.prev = 9;
                    _context2.t0 = _context2["catch"](3);
                    log.error("Failed to connect with openlogin provider", _context2.t0);
                    this.status = ADAPTER_STATUS.READY;
                    this.emit(ADAPTER_EVENTS.ERRORED, _context2.t0);
                    if (!(_context2.t0 !== null && _context2.t0 !== void 0 && _context2.t0.message.includes("user closed popup"))) {
                      _context2.next = 16;
                      break;
                    }
                    throw WalletLoginError.popupClosed();
                  case 16:
                    throw WalletLoginError.connectionError("Failed to login with openlogin");
                  case 17:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[3, 9]]);
          }));
          function connect(_x2) {
            return _connect.apply(this, arguments);
          }
          return connect;
        }()
      }, {
        key: "disconnect",
        value: function() {
          var _disconnect = _asyncToGenerator(import_regenerator3.default.mark(function _callee3() {
            var options, _args3 = arguments;
            return import_regenerator3.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    options = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {
                      cleanup: false
                    };
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED)) {
                      _context3.next = 3;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet");
                  case 3:
                    if (this.openloginInstance) {
                      _context3.next = 5;
                      break;
                    }
                    throw WalletInitializationError.notReady("openloginInstance is not ready");
                  case 5:
                    _context3.next = 7;
                    return this.openloginInstance.logout();
                  case 7:
                    if (options.cleanup) {
                      this.status = ADAPTER_STATUS.NOT_READY;
                      this.openloginInstance = null;
                      this.privKeyProvider = null;
                    } else {
                      this.status = ADAPTER_STATUS.READY;
                    }
                    this.emit(ADAPTER_EVENTS.DISCONNECTED);
                  case 9:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function disconnect() {
            return _disconnect.apply(this, arguments);
          }
          return disconnect;
        }()
      }, {
        key: "authenticateUser",
        value: function() {
          var _authenticateUser = _asyncToGenerator(import_regenerator3.default.mark(function _callee4() {
            var userInfo;
            return import_regenerator3.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED)) {
                      _context4.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
                  case 2:
                    _context4.next = 4;
                    return this.getUserInfo();
                  case 4:
                    userInfo = _context4.sent;
                    return _context4.abrupt("return", {
                      idToken: userInfo.idToken
                    });
                  case 6:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function authenticateUser() {
            return _authenticateUser.apply(this, arguments);
          }
          return authenticateUser;
        }()
      }, {
        key: "getUserInfo",
        value: function() {
          var _getUserInfo = _asyncToGenerator(import_regenerator3.default.mark(function _callee5() {
            var userInfo;
            return import_regenerator3.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED)) {
                      _context5.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet");
                  case 2:
                    if (this.openloginInstance) {
                      _context5.next = 4;
                      break;
                    }
                    throw WalletInitializationError.notReady("openloginInstance is not ready");
                  case 4:
                    _context5.next = 6;
                    return this.openloginInstance.getUserInfo();
                  case 6:
                    userInfo = _context5.sent;
                    return _context5.abrupt("return", userInfo);
                  case 8:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getUserInfo() {
            return _getUserInfo.apply(this, arguments);
          }
          return getUserInfo;
        }()
        // should be called only before initialization.
      }, {
        key: "setAdapterSettings",
        value: function setAdapterSettings(adapterSettings) {
          if (this.status === ADAPTER_STATUS.READY)
            return;
          var defaultOptions = getOpenloginDefaultOptions();
          this.openloginOptions = _objectSpread5(_objectSpread5(_objectSpread5({}, defaultOptions.adapterSettings), this.openloginOptions || {}), adapterSettings);
          if (adapterSettings.sessionTime) {
            this.loginSettings = _objectSpread5(_objectSpread5({}, this.loginSettings), {}, {
              sessionTime: adapterSettings.sessionTime
            });
          }
          if (adapterSettings.clientId) {
            this.clientId = adapterSettings.clientId;
          }
        }
        // should be called only before initialization.
      }, {
        key: "setChainConfig",
        value: function setChainConfig(customChainConfig) {
          _get(_getPrototypeOf(OpenloginAdapter2.prototype), "setChainConfig", this).call(this, customChainConfig);
          this.currentChainNamespace = customChainConfig.chainNamespace;
        }
      }, {
        key: "connectWithProvider",
        value: function() {
          var _connectWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee6() {
            var params, _yield$import, SolanaPrivateKeyProvider, _yield$import2, EthereumPrivateKeyProvider, _params$extraLoginOpt, finalPrivKey, _yield$import3, getED25519Key, _args6 = arguments;
            return import_regenerator3.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    params = _args6.length > 0 && _args6[0] !== void 0 ? _args6[0] : {};
                    if (this.chainConfig) {
                      _context6.next = 3;
                      break;
                    }
                    throw WalletInitializationError.invalidParams("chainConfig is required before initialization");
                  case 3:
                    if (this.openloginInstance) {
                      _context6.next = 5;
                      break;
                    }
                    throw WalletInitializationError.notReady("openloginInstance is not ready");
                  case 5:
                    if (!(this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA)) {
                      _context6.next = 13;
                      break;
                    }
                    _context6.next = 8;
                    return import("./solanaProvider.esm-K2JPBDT6.js");
                  case 8:
                    _yield$import = _context6.sent;
                    SolanaPrivateKeyProvider = _yield$import.SolanaPrivateKeyProvider;
                    this.privKeyProvider = new SolanaPrivateKeyProvider({
                      config: {
                        chainConfig: this.chainConfig
                      }
                    });
                    _context6.next = 26;
                    break;
                  case 13:
                    if (!(this.currentChainNamespace === CHAIN_NAMESPACES.EIP155)) {
                      _context6.next = 21;
                      break;
                    }
                    _context6.next = 16;
                    return import("./ethereumProvider.esm-NFYZHZH6.js");
                  case 16:
                    _yield$import2 = _context6.sent;
                    EthereumPrivateKeyProvider = _yield$import2.EthereumPrivateKeyProvider;
                    this.privKeyProvider = new EthereumPrivateKeyProvider({
                      config: {
                        chainConfig: this.chainConfig
                      }
                    });
                    _context6.next = 26;
                    break;
                  case 21:
                    if (!(this.currentChainNamespace === CHAIN_NAMESPACES.OTHER)) {
                      _context6.next = 25;
                      break;
                    }
                    this.privKeyProvider = new CommonPrivateKeyProvider();
                    _context6.next = 26;
                    break;
                  case 25:
                    throw new Error("Invalid chainNamespace: ".concat(this.currentChainNamespace, " found while connecting to wallet"));
                  case 26:
                    if (this.openloginInstance.privKey) {
                      _context6.next = 30;
                      break;
                    }
                    if (!this.loginSettings.curve) {
                      this.loginSettings.curve = this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;
                    }
                    _context6.next = 30;
                    return this.openloginInstance.login((0, import_lodash3.default)(this.loginSettings, params, {
                      loginProvider: params.loginProvider
                    }, {
                      extraLoginOptions: _objectSpread5(_objectSpread5({}, params.extraLoginOptions || {}), {}, {
                        login_hint: params.login_hint || ((_params$extraLoginOpt = params.extraLoginOptions) === null || _params$extraLoginOpt === void 0 ? void 0 : _params$extraLoginOpt.login_hint)
                      })
                    }));
                  case 30:
                    finalPrivKey = this.openloginInstance.privKey;
                    if (!finalPrivKey) {
                      _context6.next = 42;
                      break;
                    }
                    if (!(this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA)) {
                      _context6.next = 38;
                      break;
                    }
                    _context6.next = 35;
                    return import("./openloginEd25519.esm-N52ZPJKD.js");
                  case 35:
                    _yield$import3 = _context6.sent;
                    getED25519Key = _yield$import3.getED25519Key;
                    finalPrivKey = getED25519Key(finalPrivKey).sk.toString("hex");
                  case 38:
                    _context6.next = 40;
                    return this.privKeyProvider.setupProvider(finalPrivKey);
                  case 40:
                    this.status = ADAPTER_STATUS.CONNECTED;
                    this.emit(ADAPTER_EVENTS.CONNECTED, {
                      adapter: WALLET_ADAPTERS.OPENLOGIN,
                      reconnected: !params
                    });
                  case 42:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function connectWithProvider() {
            return _connectWithProvider.apply(this, arguments);
          }
          return connectWithProvider;
        }()
      }]);
      return OpenloginAdapter2;
    }(BaseAdapter);
  }
});

// node_modules/@metamask/detect-provider/dist/index.js
var require_dist = __commonJS({
  "node_modules/@metamask/detect-provider/dist/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function detectEthereumProvider2({ mustBeMetaMask = false, silent = false, timeout = 3e3 } = {}) {
      _validateInputs();
      let handled = false;
      return new Promise((resolve) => {
        if (window.ethereum) {
          handleEthereum();
        } else {
          window.addEventListener("ethereum#initialized", handleEthereum, { once: true });
          setTimeout(() => {
            handleEthereum();
          }, timeout);
        }
        function handleEthereum() {
          if (handled) {
            return;
          }
          handled = true;
          window.removeEventListener("ethereum#initialized", handleEthereum);
          const { ethereum } = window;
          if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {
            resolve(ethereum);
          } else {
            const message = mustBeMetaMask && ethereum ? "Non-MetaMask window.ethereum detected." : "Unable to detect window.ethereum.";
            !silent && console.error("@metamask/detect-provider:", message);
            resolve(null);
          }
        }
      });
      function _validateInputs() {
        if (typeof mustBeMetaMask !== "boolean") {
          throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);
        }
        if (typeof silent !== "boolean") {
          throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);
        }
        if (typeof timeout !== "number") {
          throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);
        }
      }
    }
    module.exports = detectEthereumProvider2;
  }
});

// node_modules/@web3auth/base-evm-adapter/dist/baseEvmAdapter.esm.js
function _createSuper4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var import_regenerator4, BaseEvmAdapter;
var init_baseEvmAdapter_esm = __esm({
  "node_modules/@web3auth/base-evm-adapter/dist/baseEvmAdapter.esm.js"() {
    init_process();
    init_buffer();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_regenerator4 = __toESM(require_regenerator());
    init_base_esm();
    BaseEvmAdapter = function(_BaseAdapter) {
      _inherits(BaseEvmAdapter2, _BaseAdapter);
      var _super = _createSuper4(BaseEvmAdapter2);
      function BaseEvmAdapter2() {
        var _this;
        var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, BaseEvmAdapter2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "clientId", void 0);
        _this.clientId = params.clientId;
        return _this;
      }
      _createClass(BaseEvmAdapter2, [{
        key: "authenticateUser",
        value: function() {
          var _authenticateUser = _asyncToGenerator(import_regenerator4.default.mark(function _callee() {
            var _this$chainConfig;
            var _this$chainConfig2, chainNamespace, chainId, accounts, existingToken, isExpired, payload, challenge, signedMessage, idToken;
            return import_regenerator4.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId))) {
                      _context.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError();
                  case 2:
                    _this$chainConfig2 = this.chainConfig, chainNamespace = _this$chainConfig2.chainNamespace, chainId = _this$chainConfig2.chainId;
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED)) {
                      _context.next = 5;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
                  case 5:
                    _context.next = 7;
                    return this.provider.request({
                      method: "eth_accounts"
                    });
                  case 7:
                    accounts = _context.sent;
                    if (!(accounts && accounts.length > 0)) {
                      _context.next = 26;
                      break;
                    }
                    existingToken = getSavedToken(accounts[0], this.name);
                    if (!existingToken) {
                      _context.next = 14;
                      break;
                    }
                    isExpired = checkIfTokenIsExpired(existingToken);
                    if (isExpired) {
                      _context.next = 14;
                      break;
                    }
                    return _context.abrupt("return", {
                      idToken: existingToken
                    });
                  case 14:
                    payload = {
                      domain: window.location.origin,
                      uri: window.location.href,
                      address: accounts[0],
                      chainId: parseInt(chainId, 16),
                      version: "1",
                      nonce: Math.random().toString(36).slice(2),
                      issuedAt: (/* @__PURE__ */ new Date()).toISOString()
                    };
                    _context.next = 17;
                    return signChallenge(payload, chainNamespace);
                  case 17:
                    challenge = _context.sent;
                    _context.next = 20;
                    return this.provider.request({
                      method: "personal_sign",
                      params: [challenge, accounts[0]]
                    });
                  case 20:
                    signedMessage = _context.sent;
                    _context.next = 23;
                    return verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.sessionTime, this.clientId);
                  case 23:
                    idToken = _context.sent;
                    saveToken(accounts[0], this.name, idToken);
                    return _context.abrupt("return", {
                      idToken
                    });
                  case 26:
                    throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
                  case 27:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function authenticateUser() {
            return _authenticateUser.apply(this, arguments);
          }
          return authenticateUser;
        }()
      }, {
        key: "disconnect",
        value: function() {
          var _disconnect = _asyncToGenerator(import_regenerator4.default.mark(function _callee2() {
            var accounts;
            return import_regenerator4.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED)) {
                      _context2.next = 2;
                      break;
                    }
                    throw WalletLoginError.disconnectionError("Not connected with wallet");
                  case 2:
                    _context2.next = 4;
                    return this.provider.request({
                      method: "eth_accounts"
                    });
                  case 4:
                    accounts = _context2.sent;
                    if (accounts && accounts.length > 0) {
                      clearToken(accounts[0], this.name);
                    }
                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function disconnect() {
            return _disconnect.apply(this, arguments);
          }
          return disconnect;
        }()
      }]);
      return BaseEvmAdapter2;
    }(BaseAdapter);
  }
});

// node_modules/@web3auth/metamask-adapter/dist/metamaskAdapter.esm.js
var metamaskAdapter_esm_exports = {};
__export(metamaskAdapter_esm_exports, {
  MetamaskAdapter: () => MetamaskAdapter
});
function _createSuper5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var import_regenerator5, import_detect_provider, MetamaskAdapter;
var init_metamaskAdapter_esm = __esm({
  "node_modules/@web3auth/metamask-adapter/dist/metamaskAdapter.esm.js"() {
    init_process();
    init_buffer();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_regenerator5 = __toESM(require_regenerator());
    import_detect_provider = __toESM(require_dist());
    init_base_esm();
    init_baseEvmAdapter_esm();
    MetamaskAdapter = function(_BaseEvmAdapter) {
      _inherits(MetamaskAdapter2, _BaseEvmAdapter);
      var _super = _createSuper5(MetamaskAdapter2);
      function MetamaskAdapter2(adapterOptions) {
        var _this;
        _classCallCheck(this, MetamaskAdapter2);
        _this = _super.call(this, adapterOptions);
        _defineProperty(_assertThisInitialized(_this), "adapterNamespace", ADAPTER_NAMESPACES.EIP155);
        _defineProperty(_assertThisInitialized(_this), "currentChainNamespace", CHAIN_NAMESPACES.EIP155);
        _defineProperty(_assertThisInitialized(_this), "type", ADAPTER_CATEGORY.EXTERNAL);
        _defineProperty(_assertThisInitialized(_this), "name", WALLET_ADAPTERS.METAMASK);
        _defineProperty(_assertThisInitialized(_this), "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(_assertThisInitialized(_this), "rehydrated", false);
        _defineProperty(_assertThisInitialized(_this), "metamaskProvider", null);
        _this.chainConfig = (adapterOptions === null || adapterOptions === void 0 ? void 0 : adapterOptions.chainConfig) || null;
        _this.sessionTime = (adapterOptions === null || adapterOptions === void 0 ? void 0 : adapterOptions.sessionTime) || 86400;
        return _this;
      }
      _createClass(MetamaskAdapter2, [{
        key: "provider",
        get: function get2() {
          if (this.status === ADAPTER_STATUS.CONNECTED && this.metamaskProvider) {
            return this.metamaskProvider;
          }
          return null;
        },
        set: function set(_4) {
          throw new Error("Not implemented");
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator5.default.mark(function _callee(options) {
            return import_regenerator5.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _get(_getPrototypeOf(MetamaskAdapter2.prototype), "checkInitializationRequirements", this).call(this);
                    _context.next = 3;
                    return (0, import_detect_provider.default)({
                      mustBeMetaMask: true
                    });
                  case 3:
                    this.metamaskProvider = _context.sent;
                    if (this.metamaskProvider) {
                      _context.next = 6;
                      break;
                    }
                    throw WalletInitializationError.notInstalled("Metamask extension is not installed");
                  case 6:
                    this.status = ADAPTER_STATUS.READY;
                    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.METAMASK);
                    _context.prev = 8;
                    log.debug("initializing metamask adapter");
                    if (!options.autoConnect) {
                      _context.next = 14;
                      break;
                    }
                    this.rehydrated = true;
                    _context.next = 14;
                    return this.connect();
                  case 14:
                    _context.next = 19;
                    break;
                  case 16:
                    _context.prev = 16;
                    _context.t0 = _context["catch"](8);
                    this.emit(ADAPTER_EVENTS.ERRORED, _context.t0);
                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[8, 16]]);
          }));
          function init(_x) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "setAdapterSettings",
        value: function setAdapterSettings(options) {
          if (this.status === ADAPTER_STATUS.READY)
            return;
          if (options !== null && options !== void 0 && options.sessionTime) {
            this.sessionTime = options.sessionTime;
          }
          if (options !== null && options !== void 0 && options.clientId) {
            this.clientId = options.clientId;
          }
        }
      }, {
        key: "connect",
        value: function() {
          var _connect = _asyncToGenerator(import_regenerator5.default.mark(function _callee2() {
            var _this2 = this;
            var chainId;
            return import_regenerator5.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _get(_getPrototypeOf(MetamaskAdapter2.prototype), "checkConnectionRequirements", this).call(this);
                    if (!this.chainConfig)
                      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);
                    this.status = ADAPTER_STATUS.CONNECTING;
                    this.emit(ADAPTER_EVENTS.CONNECTING, {
                      adapter: WALLET_ADAPTERS.METAMASK
                    });
                    if (this.metamaskProvider) {
                      _context2.next = 6;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not able to connect with metamask");
                  case 6:
                    _context2.prev = 6;
                    _context2.next = 9;
                    return this.metamaskProvider.request({
                      method: "eth_requestAccounts"
                    });
                  case 9:
                    chainId = this.metamaskProvider.chainId;
                    if (!(chainId !== this.chainConfig.chainId)) {
                      _context2.next = 13;
                      break;
                    }
                    _context2.next = 13;
                    return this.switchChain(this.chainConfig);
                  case 13:
                    this.status = ADAPTER_STATUS.CONNECTED;
                    if (this.provider) {
                      _context2.next = 16;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Failed to connect with provider");
                  case 16:
                    this.provider.once("disconnect", function() {
                      _this2.disconnect();
                    });
                    this.emit(ADAPTER_EVENTS.CONNECTED, {
                      adapter: WALLET_ADAPTERS.METAMASK,
                      reconnected: this.rehydrated
                    });
                    return _context2.abrupt("return", this.provider);
                  case 21:
                    _context2.prev = 21;
                    _context2.t0 = _context2["catch"](6);
                    this.status = ADAPTER_STATUS.READY;
                    this.rehydrated = false;
                    this.emit(ADAPTER_EVENTS.ERRORED, _context2.t0);
                    throw WalletLoginError.connectionError("Failed to login with metamask wallet");
                  case 27:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[6, 21]]);
          }));
          function connect() {
            return _connect.apply(this, arguments);
          }
          return connect;
        }()
      }, {
        key: "disconnect",
        value: function() {
          var _disconnect = _asyncToGenerator(import_regenerator5.default.mark(function _callee3() {
            var _this$provider;
            var options, _args3 = arguments;
            return import_regenerator5.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    options = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {
                      cleanup: false
                    };
                    _context3.next = 3;
                    return _get(_getPrototypeOf(MetamaskAdapter2.prototype), "disconnect", this).call(this);
                  case 3:
                    (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.removeAllListeners();
                    if (options.cleanup) {
                      this.status = ADAPTER_STATUS.NOT_READY;
                      this.metamaskProvider = null;
                    } else {
                      this.status = ADAPTER_STATUS.READY;
                    }
                    this.rehydrated = false;
                    this.emit(ADAPTER_EVENTS.DISCONNECTED);
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function disconnect() {
            return _disconnect.apply(this, arguments);
          }
          return disconnect;
        }()
      }, {
        key: "getUserInfo",
        value: function() {
          var _getUserInfo = _asyncToGenerator(import_regenerator5.default.mark(function _callee4() {
            return import_regenerator5.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(this.status !== ADAPTER_STATUS.CONNECTED)) {
                      _context4.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
                  case 2:
                    return _context4.abrupt("return", {});
                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function getUserInfo() {
            return _getUserInfo.apply(this, arguments);
          }
          return getUserInfo;
        }()
      }, {
        key: "switchChain",
        value: function() {
          var _switchChain = _asyncToGenerator(import_regenerator5.default.mark(function _callee5(chainConfig) {
            return import_regenerator5.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (this.metamaskProvider) {
                      _context5.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet");
                  case 2:
                    _context5.prev = 2;
                    _context5.next = 5;
                    return this.metamaskProvider.request({
                      method: "wallet_switchEthereumChain",
                      params: [{
                        chainId: chainConfig.chainId
                      }]
                    });
                  case 5:
                    _context5.next = 15;
                    break;
                  case 7:
                    _context5.prev = 7;
                    _context5.t0 = _context5["catch"](2);
                    if (!(_context5.t0.code === 4902)) {
                      _context5.next = 14;
                      break;
                    }
                    _context5.next = 12;
                    return this.metamaskProvider.request({
                      method: "wallet_addEthereumChain",
                      params: [{
                        chainId: chainConfig.chainId,
                        chainName: chainConfig.displayName,
                        rpcUrls: [chainConfig.rpcTarget]
                      }]
                    });
                  case 12:
                    _context5.next = 15;
                    break;
                  case 14:
                    throw _context5.t0;
                  case 15:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this, [[2, 7]]);
          }));
          function switchChain(_x2) {
            return _switchChain.apply(this, arguments);
          }
          return switchChain;
        }()
      }]);
      return MetamaskAdapter2;
    }(BaseEvmAdapter);
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name) {
      const res = getFromWindow3(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e3) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i3 = 0; i3 < links.length; i3++) {
          const link = links[i3];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i3 = 0; i3 < metaTags.length; i3++) {
          const tag = metaTags[i3];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/detect-browser/es/index.js"() {
    init_process();
    init_buffer();
    __spreadArrays = function() {
      for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
        s3 += arguments[i3].length;
      for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
        for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
          r3[k3] = a3[j3];
      return r3;
    };
    BrowserInfo = /** @class */
    function() {
      function BrowserInfo2(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = /** @class */
    function() {
      function NodeInfo2(version) {
        this.version = version;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = /** @class */
    function() {
      function SearchBotDeviceInfo2(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = /** @class */
    function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = /** @class */
    function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env3 = detectEnv();
  return env3 && env3.os ? env3.os : void 0;
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env3 = detectEnv();
  const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_browser = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
    init_process();
    init_buffer();
    windowMetadata = __toESM(require_cjs2());
    windowGetters = __toESM(require_cjs());
    init_es();
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
var init_esm = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
    init_process();
    init_buffer();
    init_esm();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key);
  }
}
var init_local = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
    init_process();
    init_buffer();
    init_json();
    init_browser();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
  }
  return links;
}
var mobileLinkChoiceKey;
var init_mobile = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
    init_process();
    init_buffer();
    init_local();
    mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var API_URL;
var init_registry = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
    init_process();
    init_buffer();
    API_URL = "https://registry.walletconnect.com";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser,
  isIOS: () => isIOS,
  isMobile: () => isMobile,
  isNode: () => isNode,
  mobileLinkChoiceKey: () => mobileLinkChoiceKey,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_browser();
    init_json();
    init_local();
    init_mobile();
    init_registry();
  }
});

// node_modules/@walletconnect/utils/dist/esm/constants.js
var reservedEvents, signingMethods;
var init_constants = __esm({
  "node_modules/@walletconnect/utils/dist/esm/constants.js"() {
    init_process();
    init_buffer();
    reservedEvents = [
      "session_request",
      "session_update",
      "exchange_key",
      "connect",
      "disconnect",
      "display_uri",
      "modal_closed",
      "transport_open",
      "transport_close",
      "transport_error"
    ];
    signingMethods = [
      "eth_sendTransaction",
      "eth_signTransaction",
      "eth_sign",
      "eth_signTypedData",
      "eth_signTypedData_v1",
      "eth_signTypedData_v2",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "personal_sign",
      "wallet_addEthereumChain",
      "wallet_switchEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode"
    ];
  }
});

// node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_process();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer;
      try {
        Buffer = require_buffer().Buffer;
      } catch (e3) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j3, w4;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j3 = 0; i3 >= 0; i3 -= 3) {
            w4 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j3 = 0; i3 < number.length; i3 += 3) {
            w4 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r3 <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r3 |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r3 |= c3 - 17 + 10;
          } else {
            r3 |= c3 & 15;
          }
        }
        return r3;
      }
      BN2.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j3, w4;
        var off = 0;
        for (i3 = number.length - 6, j3 = 0; i3 >= start; i3 -= 6) {
          w4 = parseHex(number, i3, i3 + 6);
          this.words[j3] |= w4 << off & 67108863;
          this.words[j3 + 1] |= w4 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j3++;
          }
        }
        if (i3 + 6 !== start) {
          w4 = parseHex(number, start, i3 + 6);
          this.words[j3] |= w4 << off & 67108863;
          this.words[j3 + 1] |= w4 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r3 *= mul;
          if (c3 >= 49) {
            r3 += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r3 += c3 - 17 + 10;
          } else {
            r3 += c3;
          }
        }
        return r3;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r3 = new BN2(null);
        this.copy(r3);
        return r3;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w4 = this.words[i3];
            var word = ((w4 << off | carry) & 16777215).toString(16);
            carry = w4 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r3 = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
      };
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i3;
        var q3 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q3.isZero(); i3++) {
            b2 = q3.andln(255);
            q3.iushrn(8);
            res[reqLength - i3 - 1] = b2;
          }
        } else {
          for (i3 = 0; !q3.isZero(); i3++) {
            b2 = q3.andln(255);
            q3.iushrn(8);
            res[i3] = b2;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w4) {
          return 32 - Math.clz32(w4);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w4) {
          var t3 = w4;
          var r3 = 0;
          if (t3 >= 4096) {
            r3 += 13;
            t3 >>>= 13;
          }
          if (t3 >= 64) {
            r3 += 7;
            t3 >>>= 7;
          }
          if (t3 >= 8) {
            r3 += 4;
            t3 >>>= 4;
          }
          if (t3 >= 2) {
            r3 += 2;
            t3 >>>= 2;
          }
          return r3 + t3;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w4) {
        if (w4 === 0)
          return 26;
        var t3 = w4;
        var r3 = 0;
        if ((t3 & 8191) === 0) {
          r3 += 13;
          t3 >>>= 13;
        }
        if ((t3 & 127) === 0) {
          r3 += 7;
          t3 >>>= 7;
        }
        if ((t3 & 15) === 0) {
          r3 += 4;
          t3 >>>= 4;
        }
        if ((t3 & 3) === 0) {
          r3 += 2;
          t3 >>>= 2;
        }
        if ((t3 & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w4 = this.words[this.length - 1];
        var hi = this._countBits(w4);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w4 = new Array(num.bitLength());
        for (var bit = 0; bit < w4.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w4[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w4;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b2 = this._zeroBits(this.words[i3]);
          r3 += b2;
          if (b2 !== 26)
            break;
        }
        return r3;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i3 = 0; i3 < b2.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a3;
        var b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        for (var i3 = 0; i3 < b2.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b2.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a3, b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b2.length; i3++) {
          r3 = (a3.words[i3] | 0) + (b2.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b2;
        if (cmp > 0) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b2.length; i3++) {
          r3 = (a3.words[i3] | 0) - (b2.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r3 = a3 * b2;
        var lo = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
            var i3 = k3 - j3 | 0;
            a3 = self2.words[i3] | 0;
            b2 = num.words[j3] | 0;
            r3 = a3 * b2 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b2 = num.words;
        var o3 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w22;
        o3[3] = w32;
        o3[4] = w4;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c3 !== 0) {
          o3[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
            var i3 = k3 - j3;
            var a3 = self2.words[i3] | 0;
            var b2 = num.words[j3] | 0;
            var r3 = a3 * b2;
            var lo = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x3, y3) {
        this.x = x3;
        this.y = y3;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t3 = new Array(N3);
        var l3 = BN2.prototype._countBits(N3) - 1;
        for (var i3 = 0; i3 < N3; i3++) {
          t3[i3] = this.revBin(i3, l3, N3);
        }
        return t3;
      };
      FFTM.prototype.revBin = function revBin(x3, l3, N3) {
        if (x3 === 0 || x3 === N3 - 1)
          return x3;
        var rb = 0;
        for (var i3 = 0; i3 < l3; i3++) {
          rb |= (x3 & 1) << l3 - i3 - 1;
          x3 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i3 = 0; i3 < N3; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s3 = 1; s3 < N3; s3 <<= 1) {
          var l3 = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l3);
          var itwdf = Math.sin(2 * Math.PI / l3);
          for (var p3 = 0; p3 < N3; p3 += l3) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j3 = 0; j3 < s3; j3++) {
              var re = rtws[p3 + j3];
              var ie = itws[p3 + j3];
              var ro = rtws[p3 + j3 + s3];
              var io = itws[p3 + j3 + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p3 + j3] = re + ro;
              itws[p3 + j3] = ie + io;
              rtws[p3 + j3 + s3] = re - ro;
              itws[p3 + j3 + s3] = ie - io;
              if (j3 !== l3) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m3) {
        var N3 = Math.max(m3, n2) | 1;
        var odd = N3 & 1;
        var i3 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i3 = 0; i3 < N3 / 2; i3++) {
          var t3 = rws[i3];
          rws[i3] = rws[N3 - i3 - 1];
          rws[N3 - i3 - 1] = t3;
          t3 = iws[i3];
          iws[i3] = -iws[N3 - i3 - 1];
          iws[N3 - i3 - 1] = -t3;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
        var carry = 0;
        for (var i3 = 0; i3 < N3 / 2; i3++) {
          var w4 = Math.round(ws[2 * i3 + 1] / N3) * 8192 + Math.round(ws[2 * i3] / N3) + carry;
          ws[i3] = w4 & 67108863;
          if (w4 < 67108864) {
            carry = 0;
          } else {
            carry = w4 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N3) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N3; ++i3) {
          rws[i3] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i3 = 0; i3 < N3; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x3, y3, out) {
        var N3 = 2 * this.guessLen13b(x3.length, y3.length);
        var rbt = this.makeRBT(N3);
        var _4 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x3.words, x3.length, rws, N3);
        this.convert13b(y3.words, y3.length, nrws, N3);
        this.transform(rws, _4, rwst, iwst, N3, rbt);
        this.transform(nrws, _4, nrwst, niwst, N3, rbt);
        for (var i3 = 0; i3 < N3; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _4, N3, rbt);
        this.conjugate(rmws, _4, N3);
        this.normalize13b(rmws, N3);
        out.negative = x3.negative ^ y3.negative;
        out.length = x3.length + y3.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w4 = (this.words[i3] | 0) * num;
          var lo = (w4 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w4 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w4 = toBitArray(num);
        if (w4.length === 0)
          return new BN2(1);
        var res = this;
        for (var i3 = 0; i3 < w4.length; i3++, res = res.sqr()) {
          if (w4[i3] !== 0)
            break;
        }
        if (++i3 < w4.length) {
          for (var q3 = res.sqr(); i3 < w4.length; i3++, q3 = q3.sqr()) {
            if (w4[i3] === 0)
              continue;
            res = res.mul(q3);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i3;
        if (r3 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r3;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s3] = this.words[i3];
          }
          for (i3 = 0; i3 < s3; i3++) {
            this.words[i3] = 0;
          }
          this.length += s3;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r3 = bits % 26;
        var s3 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h3 -= s3;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i3 = 0; i3 < s3; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q3 = 1 << r3;
        if (this.length <= s3)
          return false;
        var w4 = this.words[s3];
        return !!(w4 & q3);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r3 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w4;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w4 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w4 -= right & 67108863;
          carry = (w4 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w4 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w4 = (this.words[i3 + shift] | 0) + carry;
          carry = w4 >> 26;
          this.words[i3 + shift] = w4 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w4 = -(this.words[i3] | 0) + carry;
          carry = w4 >> 26;
          this.words[i3] = w4 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a3.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m3 = a3.length - b2.length;
        var q3;
        if (mode !== "mod") {
          q3 = new BN2(null);
          q3.length = m3 + 1;
          q3.words = new Array(q3.length);
          for (var i3 = 0; i3 < q3.length; i3++) {
            q3.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b2, 1, m3);
        if (diff.negative === 0) {
          a3 = diff;
          if (q3) {
            q3.words[m3] = 1;
          }
        }
        for (var j3 = m3 - 1; j3 >= 0; j3--) {
          var qj = (a3.words[b2.length + j3] | 0) * 67108864 + (a3.words[b2.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b2, qj, j3);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b2, 1, j3);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q3) {
            q3.words[j3] = qj;
          }
        }
        if (q3) {
          q3.strip();
        }
        a3.strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q3 || null,
          mod: a3
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p3 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p3 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w4 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w4 / num | 0;
          carry = w4 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p3) {
        assert2(p3.negative === 0);
        assert2(!p3.isZero());
        var x3 = this;
        var y3 = p3.clone();
        if (x3.negative !== 0) {
          x3 = x3.umod(p3);
        } else {
          x3 = x3.clone();
        }
        var A4 = new BN2(1);
        var B2 = new BN2(0);
        var C3 = new BN2(0);
        var D3 = new BN2(1);
        var g3 = 0;
        while (x3.isEven() && y3.isEven()) {
          x3.iushrn(1);
          y3.iushrn(1);
          ++g3;
        }
        var yp = y3.clone();
        var xp = x3.clone();
        while (!x3.isZero()) {
          for (var i3 = 0, im = 1; (x3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x3.iushrn(i3);
            while (i3-- > 0) {
              if (A4.isOdd() || B2.isOdd()) {
                A4.iadd(yp);
                B2.isub(xp);
              }
              A4.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (y3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y3.iushrn(j3);
            while (j3-- > 0) {
              if (C3.isOdd() || D3.isOdd()) {
                C3.iadd(yp);
                D3.isub(xp);
              }
              C3.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x3.cmp(y3) >= 0) {
            x3.isub(y3);
            A4.isub(C3);
            B2.isub(D3);
          } else {
            y3.isub(x3);
            C3.isub(A4);
            D3.isub(B2);
          }
        }
        return {
          a: C3,
          b: D3,
          gcd: y3.iushln(g3)
        };
      };
      BN2.prototype._invmp = function _invmp(p3) {
        assert2(p3.negative === 0);
        assert2(!p3.isZero());
        var a3 = this;
        var b2 = p3.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p3);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b2.clone();
        while (a3.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (b2.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b2.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a3.cmp(b2) >= 0) {
            a3.isub(b2);
            x1.isub(x22);
          } else {
            b2.isub(a3);
            x22.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p3);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b2 = num.clone();
        a3.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a3.isEven() && b2.isEven(); shift++) {
          a3.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r3 = a3.cmp(b2);
          if (r3 < 0) {
            var t3 = a3;
            a3 = b2;
            b2 = t3;
          } else if (r3 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a3.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q3 = 1 << r3;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q3;
          return this;
        }
        var carry = q3;
        for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
          var w4 = this.words[i3] | 0;
          w4 += carry;
          carry = w4 >>> 26;
          w4 &= 67108863;
          this.words[i3] = w4;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w4 = this.words[0] | 0;
          res = w4 === num ? 0 : w4 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b2 = num.words[i3] | 0;
          if (a3 === b2)
            continue;
          if (a3 < b2) {
            res = -1;
          } else if (a3 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p3) {
        this.name = name;
        this.p = new BN2(p3, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          r3.strip();
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w4 = num.words[i3] | 0;
          lo += w4 * 977;
          num.words[i3] = lo & 67108863;
          lo = w4 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN2._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a3) {
        assert2(a3.negative === 0, "red works only with positives");
        assert2(a3.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a3, b2) {
        assert2((a3.negative | b2.negative) === 0, "red works only with positives");
        assert2(
          a3.red && a3.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        return a3.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      };
      Red.prototype.add = function add(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      };
      Red.prototype.imul = function imul(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.imul(b2));
      };
      Red.prototype.mul = function mul(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.mul(b2));
      };
      Red.prototype.isqr = function isqr(a3) {
        return this.imul(a3, a3.clone());
      };
      Red.prototype.sqr = function sqr(a3) {
        return this.mul(a3, a3);
      };
      Red.prototype.sqrt = function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q3 = this.m.subn(1);
        var s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0) {
          s3++;
          q3.iushrn(1);
        }
        assert2(!q3.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN2(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c3 = this.pow(z3, q3);
        var r3 = this.pow(a3, q3.addn(1).iushrn(1));
        var t3 = this.pow(a3, q3);
        var m3 = s3;
        while (t3.cmp(one) !== 0) {
          var tmp = t3;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert2(i3 < m3);
          var b2 = this.pow(c3, new BN2(1).iushln(m3 - i3 - 1));
          r3 = r3.redMul(b2);
          c3 = b2.redSqr();
          t3 = t3.redMul(c3);
          m3 = i3;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a3, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j3 = start - 1; j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a3, b2) {
        if (a3.isZero() || b2.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t3 = a3.imul(b2);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a3, b2) {
        if (a3.isZero() || b2.isZero())
          return new BN2(0)._forceRed(this);
        var t3 = a3.mul(b2);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    init_process();
    init_buffer();
    var isTypedArray2 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/@walletconnect/encoding/dist/esm/index.js
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function padString(str, length, left, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad = padding.repeat(diff);
    result = left ? pad + str : str + pad;
  }
  return result;
}
var import_is_typedarray, import_typedarray_to_buffer, ENC_HEX, ENC_UTF8, STRING_ZERO;
var init_esm3 = __esm({
  "node_modules/@walletconnect/encoding/dist/esm/index.js"() {
    init_process();
    init_buffer();
    import_is_typedarray = __toESM(require_is_typedarray());
    import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
    ENC_HEX = "hex";
    ENC_UTF8 = "utf8";
    STRING_ZERO = "0";
  }
});

// node_modules/@walletconnect/utils/dist/esm/encoding.js
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}
var import_bn;
var init_encoding = __esm({
  "node_modules/@walletconnect/utils/dist/esm/encoding.js"() {
    init_process();
    init_buffer();
    import_bn = __toESM(require_bn());
    init_esm3();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, INTERNAL_ERROR, SERVER_ERROR, RESERVED_ERROR_CODES, SERVER_ERROR_CODE_RANGE, STANDARD_ERROR_MAP, DEFAULT_ERROR;
var init_constants2 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js"() {
    init_process();
    init_buffer();
    PARSE_ERROR = "PARSE_ERROR";
    INVALID_REQUEST = "INVALID_REQUEST";
    METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    INVALID_PARAMS = "INVALID_PARAMS";
    INTERNAL_ERROR = "INTERNAL_ERROR";
    SERVER_ERROR = "SERVER_ERROR";
    RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    STANDARD_ERROR_MAP = {
      [PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
    DEFAULT_ERROR = SERVER_ERROR;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e3) => e3.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e3, url, type) {
  return e3.message.includes("getaddrinfo ENOTFOUND") || e3.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e3;
}
var init_error = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js"() {
    init_process();
    init_buffer();
    init_constants2();
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module) {
    init_process();
    init_buffer();
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays2;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v3) {
          return exports2[id] = previous ? previous(id, v3) : v3;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p3 in b2)
          if (b2.hasOwnProperty(p3))
            d3[p3] = b2[p3];
      };
      __extends = function(d3, b2) {
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p3 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p3))
              t3[p3] = s3[p3];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
            t3[p3] = s3[p3];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
            if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
              t3[p3[i3]] = s3[p3[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d3 = decorators[i3])
              r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _4 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y3, t3, g3;
        return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
          return this;
        }), g3;
        function verb(n2) {
          return function(v3) {
            return step([n2, v3]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_4)
            try {
              if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
                return t3;
              if (y3 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _4.label++;
                  return { value: op[1], done: false };
                case 5:
                  _4.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _4.ops.pop();
                  _4.trys.pop();
                  continue;
                default:
                  if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _4 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _4.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _4.label < t3[1]) {
                    _4.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _4.label < t3[2]) {
                    _4.label = t3[2];
                    _4.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _4.ops.pop();
                  _4.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _4);
            } catch (e3) {
              op = [6, e3];
              y3 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m3[k3];
      };
      __exportStar = function(m3, exports2) {
        for (var p3 in m3)
          if (p3 !== "default" && !exports2.hasOwnProperty(p3))
            exports2[p3] = m3[p3];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o3[s3], i3 = 0;
        if (m3)
          return m3.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m3 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m3)
          return o3;
        var i3 = m3.call(o3), r3, ar = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m3 = i3["return"]))
              m3.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
          ar = ar.concat(__read(arguments[i3]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
            r3[k3] = a3[j3];
        return r3;
      };
      __await = function(v3) {
        return this instanceof __await ? (this.v = v3, this) : new __await(v3);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g3 = generator.apply(thisArg, _arguments || []), i3, q3 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g3[n2])
            i3[n2] = function(v3) {
              return new Promise(function(a3, b2) {
                q3.push([n2, v3, a3, b2]) > 1 || resume(n2, v3);
              });
            };
        }
        function resume(n2, v3) {
          try {
            step(g3[n2](v3));
          } catch (e3) {
            settle(q3[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q3[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v3) {
          if (f3(v3), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p3;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v3) {
            return (p3 = !p3) ? { value: __await(o3[n2](v3)), done: n2 === "return" } : f3 ? f3(v3) : v3;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o3[Symbol.asyncIterator], i3;
        return m3 ? m3.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v3) {
            return new Promise(function(resolve, reject) {
              v3 = o3[n2](v3), settle(resolve, reject, v3.done, v3.value);
            });
          };
        }
        function settle(resolve, reject, d3, v3) {
          Promise.resolve(v3).then(function(v4) {
            resolve({ value: v4, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (Object.hasOwnProperty.call(mod, k3))
              result[k3] = mod[k3];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) || (globalThis === null || globalThis === void 0 ? void 0 : globalThis.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser2() {
      return !isReactNative() && !isNode3();
    }
    exports.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_crypto2(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment, isNodeJs;
var init_env = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js"() {
    init_process();
    init_buffer();
    import_environment = __toESM(require_cjs3());
    __reExport(env_exports, __toESM(require_cjs3()));
    isNodeJs = import_environment.isNode;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}
var init_format = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js"() {
    init_process();
    init_buffer();
    init_error();
    init_constants2();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}
var init_routing = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
var init_jsonrpc = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents;
var init_misc = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js"() {
    init_process();
    init_buffer();
    IEvents = class {
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection, IBaseJsonRpcProvider, IJsonRpcProvider;
var init_provider = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js"() {
    init_process();
    init_buffer();
    init_misc();
    IJsonRpcConnection = class extends IEvents {
      constructor(opts) {
        super();
      }
    };
    IBaseJsonRpcProvider = class extends IEvents {
      constructor() {
        super();
      }
    };
    IJsonRpcProvider = class extends IBaseJsonRpcProvider {
      constructor(connection) {
        super();
      }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
var init_validator = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
var init_esm4 = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_jsonrpc();
    init_misc();
    init_provider();
    init_validator();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
var init_types = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js"() {
    init_process();
    init_buffer();
    init_esm4();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}
var HTTP_REGEX, WS_REGEX;
var init_url = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js"() {
    init_process();
    init_buffer();
    HTTP_REGEX = "^https?:";
    WS_REGEX = "^wss?:";
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}
var init_validators = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
var init_esm5 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_constants2();
    init_error();
    init_env();
    __reExport(esm_exports4, env_exports);
    init_format();
    init_routing();
    init_types();
    init_url();
    init_validators();
  }
});

// node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
function uuid() {
  const result = ((a3, b2) => {
    for (b2 = a3 = ""; a3++ < 36; b2 += a3 * 51 & 52 ? (a3 ^ 15 ? 8 ^ Math.random() * (a3 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b2;
  })();
  return result;
}
var payloadId2;
var init_misc2 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/misc.js"() {
    init_process();
    init_buffer();
    init_esm3();
    init_esm5();
    init_constants();
    payloadId2 = payloadId;
  }
});

// node_modules/@walletconnect/utils/dist/esm/validators.js
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}
var init_validators2 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/validators.js"() {
    init_process();
    init_buffer();
    init_esm3();
    init_constants();
  }
});

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i3 = 0; i3 < address.length; i3++) {
    if (parseInt(hash[i3], 16) > 7) {
      checksum += address[i3].toUpperCase();
    } else {
      checksum += address[i3];
    }
  }
  return addHexPrefix(checksum);
}
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}
var import_js_sha3, isValidAddress;
var init_ethereum = __esm({
  "node_modules/@walletconnect/utils/dist/esm/ethereum.js"() {
    init_process();
    init_buffer();
    import_js_sha3 = __toESM(require_sha3());
    init_esm3();
    init_encoding();
    init_misc2();
    init_validators2();
    isValidAddress = (address) => {
      if (!address) {
        return false;
      } else if (address.toLowerCase().substring(0, 2) !== "0x") {
        return false;
      } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return address === toChecksumAddress(address);
      }
    };
  }
});

// node_modules/@walletconnect/utils/dist/esm/payload.js
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  if (error.data) {
    result.data = error.data;
  }
  return result;
}
var init_payload = __esm({
  "node_modules/@walletconnect/utils/dist/esm/payload.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/utils/node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i3 = 1; i3 < tokens.length; i3++) {
          input = decodeComponents(tokens, i3).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i3 = 0; i3 < entries.length; i3++) {
        var key = entries[i3];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode(key, options), "=", encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b2) => Number(a3) - Number(b2)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x3) => x3.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse2(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@walletconnect/utils/dist/esm/url.js
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}
var queryStringUtils;
var init_url2 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/url.js"() {
    init_process();
    init_buffer();
    queryStringUtils = __toESM(require_query_string());
  }
});

// node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}
var init_session = __esm({
  "node_modules/@walletconnect/utils/dist/esm/session.js"() {
    init_process();
    init_buffer();
    init_url2();
  }
});

// node_modules/@walletconnect/utils/dist/esm/index.js
var init_esm6 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_esm2();
    init_constants();
    init_encoding();
    init_ethereum();
    init_misc2();
    init_payload();
    init_session();
    init_url2();
    init_validators2();
  }
});

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
var NetworkMonitor, network_default;
var init_network = __esm({
  "node_modules/@walletconnect/socket-transport/dist/esm/network.js"() {
    init_process();
    init_buffer();
    NetworkMonitor = class {
      constructor() {
        this._eventEmitters = [];
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
          window.addEventListener("online", () => this.trigger("online"));
          window.addEventListener("offline", () => this.trigger("offline"));
        }
      }
      on(event, callback) {
        this._eventEmitters.push({
          event,
          callback
        });
      }
      trigger(event) {
        let eventEmitters = [];
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        eventEmitters.forEach((eventEmitter) => {
          eventEmitter.callback();
        });
      }
    };
    network_default = NetworkMonitor;
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
function getWebSocketUrl(_url, protocol, version) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version,
    env: "browser",
    host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var WS, SocketTransport, esm_default;
var init_esm7 = __esm({
  "node_modules/@walletconnect/socket-transport/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_esm6();
    init_network();
    WS = typeof globalThis.WebSocket !== "undefined" ? globalThis.WebSocket : require_browser2();
    SocketTransport = class {
      constructor(opts) {
        this.opts = opts;
        this._queue = [];
        this._events = [];
        this._subscriptions = [];
        this._protocol = opts.protocol;
        this._version = opts.version;
        this._url = "";
        this._netMonitor = null;
        this._socket = null;
        this._nextSocket = null;
        this._subscriptions = opts.subscriptions || [];
        this._netMonitor = opts.netMonitor || new network_default();
        if (!opts.url || typeof opts.url !== "string") {
          throw new Error("Missing or invalid WebSocket url");
        }
        this._url = opts.url;
        this._netMonitor.on("online", () => this._socketCreate());
      }
      set readyState(value) {
      }
      get readyState() {
        return this._socket ? this._socket.readyState : -1;
      }
      set connecting(value) {
      }
      get connecting() {
        return this.readyState === 0;
      }
      set connected(value) {
      }
      get connected() {
        return this.readyState === 1;
      }
      set closing(value) {
      }
      get closing() {
        return this.readyState === 2;
      }
      set closed(value) {
      }
      get closed() {
        return this.readyState === 3;
      }
      open() {
        this._socketCreate();
      }
      close() {
        this._socketClose();
      }
      send(message, topic, silent) {
        if (!topic || typeof topic !== "string") {
          throw new Error("Missing or invalid topic field");
        }
        this._socketSend({
          topic,
          type: "pub",
          payload: message,
          silent: !!silent
        });
      }
      subscribe(topic) {
        this._socketSend({
          topic,
          type: "sub",
          payload: "",
          silent: true
        });
      }
      on(event, callback) {
        this._events.push({ event, callback });
      }
      _socketCreate() {
        if (this._nextSocket) {
          return;
        }
        const url = getWebSocketUrl(this._url, this._protocol, this._version);
        this._nextSocket = new WS(url);
        if (!this._nextSocket) {
          throw new Error("Failed to create socket");
        }
        this._nextSocket.onmessage = (event) => this._socketReceive(event);
        this._nextSocket.onopen = () => this._socketOpen();
        this._nextSocket.onerror = (event) => this._socketError(event);
        this._nextSocket.onclose = () => {
          setTimeout(() => {
            this._nextSocket = null;
            this._socketCreate();
          }, 1e3);
        };
      }
      _socketOpen() {
        this._socketClose();
        this._socket = this._nextSocket;
        this._nextSocket = null;
        this._queueSubscriptions();
        this._pushQueue();
      }
      _socketClose() {
        if (this._socket) {
          this._socket.onclose = () => {
          };
          this._socket.close();
        }
      }
      _socketSend(socketMessage) {
        const message = JSON.stringify(socketMessage);
        if (this._socket && this._socket.readyState === 1) {
          this._socket.send(message);
        } else {
          this._setToQueue(socketMessage);
          this._socketCreate();
        }
      }
      async _socketReceive(event) {
        let socketMessage;
        try {
          socketMessage = JSON.parse(event.data);
        } catch (error) {
          return;
        }
        this._socketSend({
          topic: socketMessage.topic,
          type: "ack",
          payload: "",
          silent: true
        });
        if (this._socket && this._socket.readyState === 1) {
          const events = this._events.filter((event2) => event2.event === "message");
          if (events && events.length) {
            events.forEach((event2) => event2.callback(socketMessage));
          }
        }
      }
      _socketError(e3) {
        const events = this._events.filter((event) => event.event === "error");
        if (events && events.length) {
          events.forEach((event) => event.callback(e3));
        }
      }
      _queueSubscriptions() {
        const subscriptions = this._subscriptions;
        subscriptions.forEach((topic) => this._queue.push({
          topic,
          type: "sub",
          payload: "",
          silent: true
        }));
        this._subscriptions = this.opts.subscriptions || [];
      }
      _setToQueue(socketMessage) {
        this._queue.push(socketMessage);
      }
      _pushQueue() {
        const queue = this._queue;
        queue.forEach((socketMessage) => this._socketSend(socketMessage));
        this._queue = [];
      }
    };
    esm_default = SocketTransport;
  }
});

// node_modules/@walletconnect/core/dist/esm/errors.js
var ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_MISSING_REQUIRED, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED;
var init_errors = __esm({
  "node_modules/@walletconnect/core/dist/esm/errors.js"() {
    init_process();
    init_buffer();
    ERROR_SESSION_CONNECTED = "Session currently connected";
    ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
    ERROR_SESSION_REJECTED = "Session Rejected";
    ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
    ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
    ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
    ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
    ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
    ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
    ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
    ERROR_INVALID_URI = "URI format is invalid";
    ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
    ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
  }
});

// node_modules/@walletconnect/core/dist/esm/events.js
var EventManager, events_default;
var init_events = __esm({
  "node_modules/@walletconnect/core/dist/esm/events.js"() {
    init_process();
    init_buffer();
    init_esm6();
    EventManager = class {
      constructor() {
        this._eventEmitters = [];
      }
      subscribe(eventEmitter) {
        this._eventEmitters.push(eventEmitter);
      }
      unsubscribe(event) {
        this._eventEmitters = this._eventEmitters.filter((x3) => x3.event !== event);
      }
      trigger(payload) {
        let eventEmitters = [];
        let event;
        if (isJsonRpcRequest2(payload)) {
          event = payload.method;
        } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
          event = `response:${payload.id}`;
        } else if (isInternalEvent(payload)) {
          event = payload.event;
        } else {
          event = "";
        }
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
        }
        eventEmitters.forEach((eventEmitter) => {
          if (isJsonRpcResponseError(payload)) {
            const error = new Error(payload.error.message);
            eventEmitter.callback(error, null);
          } else {
            eventEmitter.callback(null, payload);
          }
        });
      }
    };
    events_default = EventManager;
  }
});

// node_modules/@walletconnect/core/dist/esm/storage.js
var SessionStorage, storage_default;
var init_storage = __esm({
  "node_modules/@walletconnect/core/dist/esm/storage.js"() {
    init_process();
    init_buffer();
    init_esm6();
    SessionStorage = class {
      constructor(storageId = "walletconnect") {
        this.storageId = storageId;
      }
      getSession() {
        let session = null;
        const json = getLocal(this.storageId);
        if (json && isWalletConnectSession(json)) {
          session = json;
        }
        return session;
      }
      setSession(session) {
        setLocal(this.storageId, session);
        return session;
      }
      removeSession() {
        removeLocal(this.storageId);
      }
    };
    storage_default = SessionStorage;
  }
});

// node_modules/@walletconnect/core/dist/esm/url.js
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}
var domain, alphanumerical, bridges;
var init_url3 = __esm({
  "node_modules/@walletconnect/core/dist/esm/url.js"() {
    init_process();
    init_buffer();
    domain = "walletconnect.org";
    alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
    bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
  }
});

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector, esm_default2;
var init_esm8 = __esm({
  "node_modules/@walletconnect/core/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_esm6();
    init_esm7();
    init_errors();
    init_events();
    init_storage();
    init_url3();
    Connector = class {
      constructor(opts) {
        this.protocol = "wc";
        this.version = 1;
        this._bridge = "";
        this._key = null;
        this._clientId = "";
        this._clientMeta = null;
        this._peerId = "";
        this._peerMeta = null;
        this._handshakeId = 0;
        this._handshakeTopic = "";
        this._connected = false;
        this._accounts = [];
        this._chainId = 0;
        this._networkId = 0;
        this._rpcUrl = "";
        this._eventManager = new events_default();
        this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
        this._cryptoLib = opts.cryptoLib;
        this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
        this._qrcodeModal = opts.connectorOpts.qrcodeModal;
        this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
        this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
        if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
          throw new Error(ERROR_MISSING_REQUIRED);
        }
        if (opts.connectorOpts.bridge) {
          this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
        }
        if (opts.connectorOpts.uri) {
          this.uri = opts.connectorOpts.uri;
        }
        const session = opts.connectorOpts.session || this._getStorageSession();
        if (session) {
          this.session = session;
        }
        if (this.handshakeId) {
          this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
        }
        this._transport = opts.transport || new esm_default({
          protocol: this.protocol,
          version: this.version,
          url: this.bridge,
          subscriptions: [this.clientId]
        });
        this._subscribeToInternalEvents();
        this._initTransport();
        if (opts.connectorOpts.uri) {
          this._subscribeToSessionRequest();
        }
        if (opts.pushServerOpts) {
          this._registerPushServer(opts.pushServerOpts);
        }
      }
      set bridge(value) {
        if (!value) {
          return;
        }
        this._bridge = value;
      }
      get bridge() {
        return this._bridge;
      }
      set key(value) {
        if (!value) {
          return;
        }
        const key = convertHexToArrayBuffer(value);
        this._key = key;
      }
      get key() {
        if (this._key) {
          const key = convertArrayBufferToHex(this._key, true);
          return key;
        }
        return "";
      }
      set clientId(value) {
        if (!value) {
          return;
        }
        this._clientId = value;
      }
      get clientId() {
        let clientId = this._clientId;
        if (!clientId) {
          clientId = this._clientId = uuid();
        }
        return this._clientId;
      }
      set peerId(value) {
        if (!value) {
          return;
        }
        this._peerId = value;
      }
      get peerId() {
        return this._peerId;
      }
      set clientMeta(value) {
      }
      get clientMeta() {
        let clientMeta = this._clientMeta;
        if (!clientMeta) {
          clientMeta = this._clientMeta = getClientMeta();
        }
        return clientMeta;
      }
      set peerMeta(value) {
        this._peerMeta = value;
      }
      get peerMeta() {
        const peerMeta = this._peerMeta;
        return peerMeta;
      }
      set handshakeTopic(value) {
        if (!value) {
          return;
        }
        this._handshakeTopic = value;
      }
      get handshakeTopic() {
        return this._handshakeTopic;
      }
      set handshakeId(value) {
        if (!value) {
          return;
        }
        this._handshakeId = value;
      }
      get handshakeId() {
        return this._handshakeId;
      }
      get uri() {
        const _uri = this._formatUri();
        return _uri;
      }
      set uri(value) {
        if (!value) {
          return;
        }
        const { handshakeTopic, bridge, key } = this._parseUri(value);
        this.handshakeTopic = handshakeTopic;
        this.bridge = bridge;
        this.key = key;
      }
      set chainId(value) {
        this._chainId = value;
      }
      get chainId() {
        const chainId = this._chainId;
        return chainId;
      }
      set networkId(value) {
        this._networkId = value;
      }
      get networkId() {
        const networkId = this._networkId;
        return networkId;
      }
      set accounts(value) {
        this._accounts = value;
      }
      get accounts() {
        const accounts = this._accounts;
        return accounts;
      }
      set rpcUrl(value) {
        this._rpcUrl = value;
      }
      get rpcUrl() {
        const rpcUrl = this._rpcUrl;
        return rpcUrl;
      }
      set connected(value) {
      }
      get connected() {
        return this._connected;
      }
      set pending(value) {
      }
      get pending() {
        return !!this._handshakeTopic;
      }
      get session() {
        return {
          connected: this.connected,
          accounts: this.accounts,
          chainId: this.chainId,
          bridge: this.bridge,
          key: this.key,
          clientId: this.clientId,
          clientMeta: this.clientMeta,
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          handshakeId: this.handshakeId,
          handshakeTopic: this.handshakeTopic
        };
      }
      set session(value) {
        if (!value) {
          return;
        }
        this._connected = value.connected;
        this.accounts = value.accounts;
        this.chainId = value.chainId;
        this.bridge = value.bridge;
        this.key = value.key;
        this.clientId = value.clientId;
        this.clientMeta = value.clientMeta;
        this.peerId = value.peerId;
        this.peerMeta = value.peerMeta;
        this.handshakeId = value.handshakeId;
        this.handshakeTopic = value.handshakeTopic;
      }
      on(event, callback) {
        const eventEmitter = {
          event,
          callback
        };
        this._eventManager.subscribe(eventEmitter);
      }
      off(event) {
        this._eventManager.unsubscribe(event);
      }
      async createInstantRequest(instantRequest) {
        this._key = await this._generateKey();
        const request = this._formatRequest({
          method: "wc_instantRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              request: this._formatRequest(instantRequest)
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
        this.on("modal_closed", () => {
          throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
        });
        const endInstantRequest = () => {
          this.killSession();
        };
        try {
          const result = await this._sendCallRequest(request);
          if (result) {
            endInstantRequest();
          }
          return result;
        } catch (error) {
          endInstantRequest();
          throw error;
        }
      }
      async connect(opts) {
        if (!this._qrcodeModal) {
          throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
        }
        if (this.connected) {
          return {
            chainId: this.chainId,
            accounts: this.accounts
          };
        }
        await this.createSession(opts);
        return new Promise(async (resolve, reject) => {
          this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
          this.on("connect", (error, payload) => {
            if (error) {
              return reject(error);
            }
            resolve(payload.params[0]);
          });
        });
      }
      async createSession(opts) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        if (this.pending) {
          return;
        }
        this._key = await this._generateKey();
        const request = this._formatRequest({
          method: "wc_sessionRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              chainId: opts && opts.chainId ? opts.chainId : null
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._sendSessionRequest(request, "Session update rejected", {
          topic: this.handshakeTopic
        });
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
      }
      approveSession(sessionStatus) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl,
          peerId: this.clientId,
          peerMeta: this.clientMeta
        };
        const response = {
          id: this.handshakeId,
          jsonrpc: "2.0",
          result: sessionParams
        };
        this._sendResponse(response);
        this._connected = true;
        this._setStorageSession();
        this._eventManager.trigger({
          event: "connect",
          params: [
            {
              peerId: this.peerId,
              peerMeta: this.peerMeta,
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
      }
      rejectSession(sessionError) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
        const response = this._formatResponse({
          id: this.handshakeId,
          error: { message }
        });
        this._sendResponse(response);
        this._connected = false;
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
      }
      updateSession(sessionStatus) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        this._sendSessionRequest(request, "Session update rejected");
        this._eventManager.trigger({
          event: "session_update",
          params: [
            {
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
        this._manageStorageSession();
      }
      async killSession(sessionError) {
        const message = sessionError ? sessionError.message : "Session Disconnected";
        const sessionParams = {
          approved: false,
          chainId: null,
          networkId: null,
          accounts: null
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        await this._sendRequest(request);
        this._handleSessionDisconnect(message);
      }
      async sendTransaction(tx) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = parseTransactionData(tx);
        const request = this._formatRequest({
          method: "eth_sendTransaction",
          params: [parsedTx]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signTransaction(tx) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = parseTransactionData(tx);
        const request = this._formatRequest({
          method: "eth_signTransaction",
          params: [parsedTx]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signMessage(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_sign",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signPersonalMessage(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        params = parsePersonalSign(params);
        const request = this._formatRequest({
          method: "personal_sign",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signTypedData(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_signTypedData",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async updateChain(chainParams) {
        if (!this._connected) {
          throw new Error("Session currently disconnected");
        }
        const request = this._formatRequest({
          method: "wallet_updateChain",
          params: [chainParams]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      unsafeSend(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(request.id, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (!payload) {
              throw new Error(ERROR_MISSING_JSON_RPC);
            }
            resolve(payload);
          });
        });
      }
      async sendCustomRequest(request, options) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        switch (request.method) {
          case "eth_accounts":
            return this.accounts;
          case "eth_chainId":
            return convertNumberToHex(this.chainId);
          case "eth_sendTransaction":
          case "eth_signTransaction":
            if (request.params) {
              request.params[0] = parseTransactionData(request.params[0]);
            }
            break;
          case "personal_sign":
            if (request.params) {
              request.params = parsePersonalSign(request.params);
            }
            break;
          default:
            break;
        }
        const formattedRequest = this._formatRequest(request);
        const result = await this._sendCallRequest(formattedRequest, options);
        return result;
      }
      approveRequest(response) {
        if (isJsonRpcResponseSuccess(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(ERROR_MISSING_RESULT);
        }
      }
      rejectRequest(response) {
        if (isJsonRpcResponseError(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(ERROR_MISSING_ERROR);
        }
      }
      transportClose() {
        this._transport.close();
      }
      async _sendRequest(request, options) {
        const callRequest = this._formatRequest(request);
        const encryptionPayload = await this._encrypt(callRequest);
        const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
        this._transport.send(payload, topic, silent);
      }
      async _sendResponse(response) {
        const encryptionPayload = await this._encrypt(response);
        const topic = this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = true;
        this._transport.send(payload, topic, silent);
      }
      async _sendSessionRequest(request, errorMsg, options) {
        this._sendRequest(request, options);
        this._subscribeToSessionResponse(request.id, errorMsg);
      }
      _sendCallRequest(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return this._subscribeToCallResponse(request.id);
      }
      _formatRequest(request) {
        if (typeof request.method === "undefined") {
          throw new Error(ERROR_MISSING_METHOD);
        }
        const formattedRequest = {
          id: typeof request.id === "undefined" ? payloadId2() : request.id,
          jsonrpc: "2.0",
          method: request.method,
          params: typeof request.params === "undefined" ? [] : request.params
        };
        return formattedRequest;
      }
      _formatResponse(response) {
        if (typeof response.id === "undefined") {
          throw new Error(ERROR_MISSING_ID);
        }
        const baseResponse = { id: response.id, jsonrpc: "2.0" };
        if (isJsonRpcResponseError(response)) {
          const error = formatRpcError(response.error);
          const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
          return errorResponse;
        } else if (isJsonRpcResponseSuccess(response)) {
          const successResponse = Object.assign(Object.assign({}, baseResponse), response);
          return successResponse;
        }
        throw new Error(ERROR_INVALID_RESPONSE);
      }
      _handleSessionDisconnect(errorMsg) {
        const message = errorMsg || "Session Disconnected";
        if (!this._connected) {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
          removeLocal(mobileLinkChoiceKey);
        }
        if (this._connected) {
          this._connected = false;
        }
        if (this._handshakeId) {
          this._handshakeId = 0;
        }
        if (this._handshakeTopic) {
          this._handshakeTopic = "";
        }
        if (this._peerId) {
          this._peerId = "";
        }
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
        this.transportClose();
      }
      _handleSessionResponse(errorMsg, sessionParams) {
        if (sessionParams) {
          if (sessionParams.approved) {
            if (!this._connected) {
              this._connected = true;
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              if (sessionParams.peerId && !this.peerId) {
                this.peerId = sessionParams.peerId;
              }
              if (sessionParams.peerMeta && !this.peerMeta) {
                this.peerMeta = sessionParams.peerMeta;
              }
              this._eventManager.trigger({
                event: "connect",
                params: [
                  {
                    peerId: this.peerId,
                    peerMeta: this.peerMeta,
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            } else {
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              this._eventManager.trigger({
                event: "session_update",
                params: [
                  {
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            }
            this._manageStorageSession();
          } else {
            this._handleSessionDisconnect(errorMsg);
          }
        } else {
          this._handleSessionDisconnect(errorMsg);
        }
      }
      async _handleIncomingMessages(socketMessage) {
        const activeTopics = [this.clientId, this.handshakeTopic];
        if (!activeTopics.includes(socketMessage.topic)) {
          return;
        }
        let encryptionPayload;
        try {
          encryptionPayload = JSON.parse(socketMessage.payload);
        } catch (error) {
          return;
        }
        const payload = await this._decrypt(encryptionPayload);
        if (payload) {
          this._eventManager.trigger(payload);
        }
      }
      _subscribeToSessionRequest() {
        this._transport.subscribe(this.handshakeTopic);
      }
      _subscribeToResponse(id, callback) {
        this.on(`response:${id}`, callback);
      }
      _subscribeToSessionResponse(id, errorMsg) {
        this._subscribeToResponse(id, (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
            return;
          }
          if (isJsonRpcResponseSuccess(payload)) {
            this._handleSessionResponse(errorMsg, payload.result);
          } else if (payload.error && payload.error.message) {
            this._handleSessionResponse(payload.error.message);
          } else {
            this._handleSessionResponse(errorMsg);
          }
        });
      }
      _subscribeToCallResponse(id) {
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(id, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (isJsonRpcResponseSuccess(payload)) {
              resolve(payload.result);
            } else if (payload.error && payload.error.message) {
              reject(payload.error);
            } else {
              reject(new Error(ERROR_INVALID_RESPONSE));
            }
          });
        });
      }
      _subscribeToInternalEvents() {
        this.on("display_uri", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.open(this.uri, () => {
              this._eventManager.trigger({
                event: "modal_closed",
                params: []
              });
            }, this._qrcodeModalOptions);
          }
        });
        this.on("connect", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
        });
        this.on("call_request_sent", (error, payload) => {
          const { request } = payload.params[0];
          if (isMobile() && this._signingMethods.includes(request.method)) {
            const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
            if (mobileLinkUrl) {
              window.location.href = mobileLinkUrl.href;
            }
          }
        });
        this.on("wc_sessionRequest", (error, payload) => {
          if (error) {
            this._eventManager.trigger({
              event: "error",
              params: [
                {
                  code: "SESSION_REQUEST_ERROR",
                  message: error.toString()
                }
              ]
            });
          }
          this.handshakeId = payload.id;
          this.peerId = payload.params[0].peerId;
          this.peerMeta = payload.params[0].peerMeta;
          const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
          this._eventManager.trigger(internalPayload);
        });
        this.on("wc_sessionUpdate", (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
          }
          this._handleSessionResponse("Session disconnected", payload.params[0]);
        });
      }
      _initTransport() {
        this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
        this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
        this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
        this._transport.on("error", () => this._eventManager.trigger({
          event: "transport_error",
          params: ["Websocket connection failed"]
        }));
        this._transport.open();
      }
      _formatUri() {
        const protocol = this.protocol;
        const handshakeTopic = this.handshakeTopic;
        const version = this.version;
        const bridge = encodeURIComponent(this.bridge);
        const key = this.key;
        const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
        return uri;
      }
      _parseUri(uri) {
        const result = parseWalletConnectUri(uri);
        if (result.protocol === this.protocol) {
          if (!result.handshakeTopic) {
            throw Error("Invalid or missing handshakeTopic parameter value");
          }
          const handshakeTopic = result.handshakeTopic;
          if (!result.bridge) {
            throw Error("Invalid or missing bridge url parameter value");
          }
          const bridge = decodeURIComponent(result.bridge);
          if (!result.key) {
            throw Error("Invalid or missing key parameter value");
          }
          const key = result.key;
          return { handshakeTopic, bridge, key };
        } else {
          throw new Error(ERROR_INVALID_URI);
        }
      }
      async _generateKey() {
        if (this._cryptoLib) {
          const result = await this._cryptoLib.generateKey();
          return result;
        }
        return null;
      }
      async _encrypt(data) {
        const key = this._key;
        if (this._cryptoLib && key) {
          const result = await this._cryptoLib.encrypt(data, key);
          return result;
        }
        return null;
      }
      async _decrypt(payload) {
        const key = this._key;
        if (this._cryptoLib && key) {
          const result = await this._cryptoLib.decrypt(payload, key);
          return result;
        }
        return null;
      }
      _getStorageSession() {
        let result = null;
        if (this._sessionStorage) {
          result = this._sessionStorage.getSession();
        }
        return result;
      }
      _setStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.setSession(this.session);
        }
      }
      _removeStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.removeSession();
        }
      }
      _manageStorageSession() {
        if (this._connected) {
          this._setStorageSession();
        } else {
          this._removeStorageSession();
        }
      }
      _registerPushServer(pushServerOpts) {
        if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
          throw Error("Invalid or missing pushServerOpts.url parameter value");
        }
        if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
          throw Error("Invalid or missing pushServerOpts.type parameter value");
        }
        if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
          throw Error("Invalid or missing pushServerOpts.token parameter value");
        }
        const pushSubscription = {
          bridge: this.bridge,
          topic: this.clientId,
          type: pushServerOpts.type,
          token: pushServerOpts.token,
          peerName: "",
          language: pushServerOpts.language || ""
        };
        this.on("connect", async (error, payload) => {
          if (error) {
            throw error;
          }
          if (pushServerOpts.peerMeta) {
            const peerName = payload.params[0].peerMeta.name;
            pushSubscription.peerName = peerName;
          }
          try {
            const response = await fetch(`${pushServerOpts.url}/new`, {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(pushSubscription)
            });
            const json = await response.json();
            if (!json.success) {
              throw Error("Failed to register in Push Server");
            }
          } catch (error2) {
            throw Error("Failed to register in Push Server");
          }
        });
      }
    };
    esm_default2 = Connector;
  }
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
function randomBytes(length) {
  const browserCrypto = env.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}
var env;
var init_browser2 = __esm({
  "node_modules/@walletconnect/randombytes/dist/esm/browser/index.js"() {
    init_process();
    init_buffer();
    env = __toESM(require_cjs3());
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0, LENGTH_1, LENGTH_16, LENGTH_32, LENGTH_64, LENGTH_128, LENGTH_256, LENGTH_512, LENGTH_1024;
var init_length = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/length.js"() {
    init_process();
    init_buffer();
    LENGTH_0 = 0;
    LENGTH_1 = 1;
    LENGTH_16 = 16;
    LENGTH_32 = 32;
    LENGTH_64 = 64;
    LENGTH_128 = 128;
    LENGTH_256 = 256;
    LENGTH_512 = 512;
    LENGTH_1024 = 1024;
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH, HMAC_LENGTH, AES_BROWSER_ALGO, HMAC_BROWSER_ALGO, HMAC_BROWSER, SHA256_BROWSER_ALGO, SHA512_BROWSER_ALGO, AES_NODE_ALGO, HMAC_NODE_ALGO, SHA256_NODE_ALGO, SHA512_NODE_ALGO, RIPEMD160_NODE_ALGO, PREFIX_LENGTH, KEY_LENGTH, IV_LENGTH, MAC_LENGTH;
var init_default = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/default.js"() {
    init_process();
    init_buffer();
    init_length();
    AES_LENGTH = LENGTH_256;
    HMAC_LENGTH = LENGTH_256;
    AES_BROWSER_ALGO = "AES-CBC";
    HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
    HMAC_BROWSER = "HMAC";
    SHA256_BROWSER_ALGO = "SHA-256";
    SHA512_BROWSER_ALGO = "SHA-512";
    AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
    HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
    SHA256_NODE_ALGO = "sha256";
    SHA512_NODE_ALGO = "sha512";
    RIPEMD160_NODE_ALGO = "ripemd160";
    PREFIX_LENGTH = LENGTH_1;
    KEY_LENGTH = LENGTH_32;
    IV_LENGTH = LENGTH_16;
    MAC_LENGTH = LENGTH_32;
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC, UTF8_ENC;
var init_encoding2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js"() {
    init_process();
    init_buffer();
    HEX_ENC = "hex";
    UTF8_ENC = "utf8";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC;
var init_error2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/error.js"() {
    init_process();
    init_buffer();
    ERROR_BAD_MAC = "Bad MAC";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP, DECRYPT_OP, SIGN_OP, VERIFY_OP;
var init_operations = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/operations.js"() {
    init_process();
    init_buffer();
    ENCRYPT_OP = "encrypt";
    DECRYPT_OP = "decrypt";
    SIGN_OP = "sign";
    VERIFY_OP = "verify";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/index.js
var init_constants3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/index.js"() {
    init_process();
    init_buffer();
    init_default();
    init_encoding2();
    init_error2();
    init_length();
    init_operations();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
  return env2.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserSha256(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
var env2;
var init_browser3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/lib/browser.js"() {
    init_process();
    init_buffer();
    env2 = __toESM(require_cjs3());
    init_constants3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key, data) {
  return browserAesEncrypt(iv, key, data);
}
function aesCbcDecrypt(iv, key, data) {
  return browserAesDecrypt(iv, key, data);
}
var init_aes = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/aes.js"() {
    init_process();
    init_buffer();
    init_browser3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
var init_env2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/env.js"() {
    init_process();
    init_buffer();
    __reExport(env_exports2, __toESM(require_cjs3()));
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING, pkcs7;
var init_pkcs7 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js"() {
    init_process();
    init_buffer();
    PADDING = [
      [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
      [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
      [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
      [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
      [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
      [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
      [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
      [9, 9, 9, 9, 9, 9, 9, 9, 9],
      [8, 8, 8, 8, 8, 8, 8, 8],
      [7, 7, 7, 7, 7, 7, 7],
      [6, 6, 6, 6, 6, 6],
      [5, 5, 5, 5, 5],
      [4, 4, 4, 4],
      [3, 3, 3],
      [2, 2],
      [1]
    ];
    pkcs7 = {
      pad(plaintext) {
        const padding = PADDING[plaintext.byteLength % 16 || 0];
        const result = new Uint8Array(plaintext.byteLength + padding.length);
        result.set(plaintext);
        result.set(padding, plaintext.byteLength);
        return result;
      },
      unpad(padded) {
        return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
      }
    };
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/types.js
var init_types2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/types.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i3 = 0; i3 < arr1.length; i3++) {
    res |= arr1[i3] ^ arr2[i3];
  }
  return res === 0;
}
var init_validators3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});
var init_helpers = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/index.js"() {
    init_process();
    init_buffer();
    init_env2();
    __reExport(helpers_exports, env_exports2);
    init_pkcs7();
    init_types2();
    init_validators3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key, msg) {
  const result = await browserHmacSha512Sign(key, msg);
  return result;
}
async function hmacSha512Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
var init_hmac = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js"() {
    init_process();
    init_buffer();
    init_browser3();
    init_helpers();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha256(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha512(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd160(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}
var init_sha2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js"() {
    init_process();
    init_buffer();
    init_browser3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
var init_browser4 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/index.js"() {
    init_process();
    init_buffer();
    init_browser2();
    init_aes();
    init_hmac();
    init_sha2();
    init_helpers();
    __reExport(browser_exports, helpers_exports);
    init_constants3();
  }
});

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt2(data, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt2(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}
var init_esm9 = __esm({
  "node_modules/@walletconnect/iso-crypto/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_browser4();
    init_esm3();
    init_esm6();
  }
});

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect, esm_default3;
var init_esm10 = __esm({
  "node_modules/@walletconnect/client/dist/esm/index.js"() {
    init_process();
    init_buffer();
    init_esm8();
    init_esm9();
    WalletConnect = class extends esm_default2 {
      constructor(connectorOpts, pushServerOpts) {
        super({
          cryptoLib: esm_exports5,
          connectorOpts,
          pushServerOpts
        });
      }
    };
    esm_default3 = WalletConnect;
  }
});

// node_modules/@web3auth/wallet-connect-v1-adapter/dist/walletConnectV1Adapter.esm.js
var walletConnectV1Adapter_esm_exports = {};
__export(walletConnectV1Adapter_esm_exports, {
  WalletConnectV1Adapter: () => WalletConnectV1Adapter
});
function ownKeys6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys6(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var import_regenerator6, WALLET_CONNECT_EXTENSION_ADAPTERS, WalletConnectV1Adapter;
var init_walletConnectV1Adapter_esm = __esm({
  "node_modules/@web3auth/wallet-connect-v1-adapter/dist/walletConnectV1Adapter.esm.js"() {
    init_process();
    init_buffer();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_regenerator6 = __toESM(require_regenerator());
    init_esm10();
    init_base_esm();
    init_baseEvmAdapter_esm();
    init_ethereumProvider_esm();
    WALLET_CONNECT_EXTENSION_ADAPTERS = [{
      name: "Rainbow",
      chains: [CHAIN_NAMESPACES.EIP155],
      logo: "https://images.web3auth.io/login-rainbow.svg",
      mobile: {
        native: "rainbow:",
        universal: "https://rnbwapp.com"
      },
      desktop: {
        native: "",
        universal: ""
      }
    }, {
      name: "MetaMask",
      chains: [CHAIN_NAMESPACES.EIP155],
      logo: "https://images.web3auth.io/login-metamask.svg",
      mobile: {
        native: "metamask:",
        universal: "https://metamask.app.link"
      },
      desktop: {
        native: "",
        universal: ""
      }
    }];
    WalletConnectV1Adapter = function(_BaseEvmAdapter) {
      _inherits(WalletConnectV1Adapter2, _BaseEvmAdapter);
      var _super = _createSuper6(WalletConnectV1Adapter2);
      function WalletConnectV1Adapter2(options) {
        var _this;
        _classCallCheck(this, WalletConnectV1Adapter2);
        _this = _super.call(this, options);
        _defineProperty(_assertThisInitialized(_this), "name", WALLET_ADAPTERS.WALLET_CONNECT_V1);
        _defineProperty(_assertThisInitialized(_this), "adapterNamespace", ADAPTER_NAMESPACES.EIP155);
        _defineProperty(_assertThisInitialized(_this), "currentChainNamespace", CHAIN_NAMESPACES.EIP155);
        _defineProperty(_assertThisInitialized(_this), "type", ADAPTER_CATEGORY.EXTERNAL);
        _defineProperty(_assertThisInitialized(_this), "adapterOptions", void 0);
        _defineProperty(_assertThisInitialized(_this), "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(_assertThisInitialized(_this), "adapterData", {
          uri: "",
          extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS
        });
        _defineProperty(_assertThisInitialized(_this), "connector", null);
        _defineProperty(_assertThisInitialized(_this), "wcProvider", null);
        _defineProperty(_assertThisInitialized(_this), "rehydrated", false);
        _this.adapterOptions = _objectSpread6({}, options);
        _this.chainConfig = options.chainConfig || null;
        _this.sessionTime = options.sessionTime || 86400;
        return _this;
      }
      _createClass(WalletConnectV1Adapter2, [{
        key: "connected",
        get: function get2() {
          var _this$connector;
          return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);
        }
      }, {
        key: "provider",
        get: function get2() {
          var _this$wcProvider;
          return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;
        },
        set: function set(_4) {
          throw new Error("Not implemented");
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator6.default.mark(function _callee() {
            return import_regenerator6.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _get(_getPrototypeOf(WalletConnectV1Adapter2.prototype), "checkInitializationRequirements", this).call(this);
                    if (!this.chainConfig) {
                      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);
                    }
                    this.connector = this.getWalletConnectInstance();
                    this.wcProvider = new WalletConnectProvider({
                      config: {
                        chainConfig: this.chainConfig
                      },
                      connector: this.connector
                    });
                    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);
                    this.status = ADAPTER_STATUS.READY;
                    log.debug("initializing wallet connect v1 adapter");
                    if (!this.connector.connected) {
                      _context.next = 11;
                      break;
                    }
                    this.rehydrated = true;
                    _context.next = 11;
                    return this.onConnectHandler({
                      accounts: this.connector.accounts,
                      chainId: this.connector.chainId
                    });
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "connect",
        value: function() {
          var _connect = _asyncToGenerator(import_regenerator6.default.mark(function _callee4() {
            var _this2 = this;
            var _this$adapterOptions$, _this$adapterOptions$2;
            return import_regenerator6.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _get(_getPrototypeOf(WalletConnectV1Adapter2.prototype), "checkConnectionRequirements", this).call(this);
                    if (this.connector) {
                      _context4.next = 3;
                      break;
                    }
                    throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
                  case 3:
                    if (!this.connected) {
                      _context4.next = 7;
                      break;
                    }
                    _context4.next = 6;
                    return this.onConnectHandler({
                      accounts: this.connector.accounts,
                      chainId: this.connector.chainId
                    });
                  case 6:
                    return _context4.abrupt("return", this.provider);
                  case 7:
                    if (!(this.status !== ADAPTER_STATUS.CONNECTING)) {
                      _context4.next = 13;
                      break;
                    }
                    if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {
                      this.connector = this.getWalletConnectInstance();
                      this.wcProvider = new WalletConnectProvider({
                        config: {
                          chainConfig: this.chainConfig,
                          // network switching can be skipped with custom ui
                          skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching
                        },
                        connector: this.connector
                      });
                    }
                    _context4.next = 11;
                    return this.createNewSession();
                  case 11:
                    this.status = ADAPTER_STATUS.CONNECTING;
                    this.emit(ADAPTER_EVENTS.CONNECTING, {
                      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1
                    });
                  case 13:
                    return _context4.abrupt("return", new Promise(function(resolve, reject) {
                      if (!_this2.connector) {
                        reject(WalletInitializationError.notReady("Wallet adapter is not ready yet"));
                        return;
                      }
                      _this2.connector.on("modal_closed", _asyncToGenerator(import_regenerator6.default.mark(function _callee2() {
                        return import_regenerator6.default.wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                _this2.status = ADAPTER_STATUS.READY;
                                _this2.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);
                                return _context2.abrupt("return", reject(new Error("User closed modal")));
                              case 3:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2);
                      })));
                      try {
                        _this2.connector.on("connect", function() {
                          var _ref2 = _asyncToGenerator(import_regenerator6.default.mark(function _callee3(error, payload) {
                            return import_regenerator6.default.wrap(function _callee3$(_context3) {
                              while (1) {
                                switch (_context3.prev = _context3.next) {
                                  case 0:
                                    if (error) {
                                      _this2.emit(ADAPTER_EVENTS.ERRORED, error);
                                    }
                                    log.debug("connected event emitted by web3auth");
                                    _context3.next = 4;
                                    return _this2.onConnectHandler(payload.params[0]);
                                  case 4:
                                    return _context3.abrupt("return", resolve(_this2.provider));
                                  case 5:
                                  case "end":
                                    return _context3.stop();
                                }
                              }
                            }, _callee3);
                          }));
                          return function(_x, _x2) {
                            return _ref2.apply(this, arguments);
                          };
                        }());
                      } catch (error) {
                        log.error("Wallet connect v1 adapter error while connecting", error);
                        _this2.status = ADAPTER_STATUS.READY;
                        _this2.rehydrated = true;
                        _this2.emit(ADAPTER_EVENTS.ERRORED, error);
                        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError("Failed to login with wallet connect: ".concat((error === null || error === void 0 ? void 0 : error.message) || "")));
                      }
                    }));
                  case 14:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function connect() {
            return _connect.apply(this, arguments);
          }
          return connect;
        }()
      }, {
        key: "setAdapterSettings",
        value: function setAdapterSettings(options) {
          if (this.status === ADAPTER_STATUS.READY)
            return;
          if (options !== null && options !== void 0 && options.sessionTime) {
            this.sessionTime = options.sessionTime;
          }
          if (options !== null && options !== void 0 && options.clientId) {
            this.clientId = options.clientId;
          }
        }
      }, {
        key: "getUserInfo",
        value: function() {
          var _getUserInfo = _asyncToGenerator(import_regenerator6.default.mark(function _callee5() {
            return import_regenerator6.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (this.connected) {
                      _context5.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
                  case 2:
                    return _context5.abrupt("return", {});
                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getUserInfo() {
            return _getUserInfo.apply(this, arguments);
          }
          return getUserInfo;
        }()
      }, {
        key: "disconnect",
        value: function() {
          var _disconnect = _asyncToGenerator(import_regenerator6.default.mark(function _callee6() {
            var options, cleanup, _args6 = arguments;
            return import_regenerator6.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    options = _args6.length > 0 && _args6[0] !== void 0 ? _args6[0] : {
                      cleanup: false
                    };
                    cleanup = options.cleanup;
                    if (!(!this.connector || !this.connected)) {
                      _context6.next = 4;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Not connected with wallet");
                  case 4:
                    _context6.next = 6;
                    return _get(_getPrototypeOf(WalletConnectV1Adapter2.prototype), "disconnect", this).call(this);
                  case 6:
                    _context6.next = 8;
                    return this.connector.killSession();
                  case 8:
                    this.rehydrated = false;
                    if (cleanup) {
                      this.connector = null;
                      this.status = ADAPTER_STATUS.NOT_READY;
                      this.wcProvider = null;
                    } else {
                      this.status = ADAPTER_STATUS.READY;
                    }
                    this.emit(ADAPTER_EVENTS.DISCONNECTED);
                  case 11:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function disconnect() {
            return _disconnect.apply(this, arguments);
          }
          return disconnect;
        }()
      }, {
        key: "addChain",
        value: function() {
          var _addChain = _asyncToGenerator(import_regenerator6.default.mark(function _callee7(chainConfig) {
            var _this$adapterOptions$3, networkSwitch;
            return import_regenerator6.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.prev = 0;
                    if (this.wcProvider) {
                      _context7.next = 3;
                      break;
                    }
                    throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
                  case 3:
                    networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;
                    if (!networkSwitch) {
                      _context7.next = 7;
                      break;
                    }
                    _context7.next = 7;
                    return networkSwitch.addNetwork({
                      chainConfig,
                      appOrigin: window.location.hostname
                    });
                  case 7:
                    _context7.next = 9;
                    return this.wcProvider.addChain(chainConfig);
                  case 9:
                    _context7.next = 14;
                    break;
                  case 11:
                    _context7.prev = 11;
                    _context7.t0 = _context7["catch"](0);
                    log.error(_context7.t0);
                  case 14:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this, [[0, 11]]);
          }));
          function addChain(_x3) {
            return _addChain.apply(this, arguments);
          }
          return addChain;
        }()
      }, {
        key: "switchChain",
        value: function() {
          var _switchChain = _asyncToGenerator(import_regenerator6.default.mark(function _callee8(connectedChainConfig, chainConfig) {
            var _this$adapterOptions$4;
            var networkSwitch;
            return import_regenerator6.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    if (this.wcProvider) {
                      _context8.next = 2;
                      break;
                    }
                    throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
                  case 2:
                    networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;
                    if (!networkSwitch) {
                      _context8.next = 6;
                      break;
                    }
                    _context8.next = 6;
                    return networkSwitch.switchNetwork({
                      currentChainConfig: chainConfig,
                      newChainConfig: connectedChainConfig,
                      appOrigin: window.location.hostname
                    });
                  case 6:
                    _context8.next = 8;
                    return this.wcProvider.switchChain({
                      chainId: chainConfig.chainId,
                      lookup: false,
                      addChain: false
                    });
                  case 8:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function switchChain(_x4, _x5) {
            return _switchChain.apply(this, arguments);
          }
          return switchChain;
        }()
      }, {
        key: "createNewSession",
        value: function() {
          var _createNewSession = _asyncToGenerator(import_regenerator6.default.mark(function _callee10() {
            var _this$adapterOptions, _this$adapterOptions$5, _this3 = this;
            var opts, _this$chainConfig, _args10 = arguments;
            return import_regenerator6.default.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    opts = _args10.length > 0 && _args10[0] !== void 0 ? _args10[0] : {
                      forceNewSession: false
                    };
                    if (this.connector) {
                      _context10.next = 3;
                      break;
                    }
                    throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
                  case 3:
                    if (!(opts.forceNewSession && this.connector.pending)) {
                      _context10.next = 6;
                      break;
                    }
                    _context10.next = 6;
                    return this.connector.killSession();
                  case 6:
                    if (!((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal)) {
                      _context10.next = 10;
                      break;
                    }
                    _context10.next = 9;
                    return this.connector.createSession({
                      chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || "0x1", 16)
                    });
                  case 9:
                    return _context10.abrupt("return");
                  case 10:
                    return _context10.abrupt("return", new Promise(function(resolve, reject) {
                      var _this3$chainConfig;
                      if (!_this3.connector) {
                        reject(WalletInitializationError.notReady("Wallet adapter is not ready yet"));
                        return;
                      }
                      log.debug("creating new session for web3auth wallet connect");
                      _this3.connector.on("display_uri", function() {
                        var _ref3 = _asyncToGenerator(import_regenerator6.default.mark(function _callee9(err, payload) {
                          var _this3$connector;
                          var uri;
                          return import_regenerator6.default.wrap(function _callee9$(_context9) {
                            while (1) {
                              switch (_context9.prev = _context9.next) {
                                case 0:
                                  if (!err) {
                                    _context9.next = 3;
                                    break;
                                  }
                                  _this3.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError("Failed to display wallet connect qr code"));
                                  return _context9.abrupt("return", reject(err));
                                case 3:
                                  uri = payload.params[0];
                                  _this3.updateAdapterData({
                                    uri,
                                    extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS
                                  });
                                  (_this3$connector = _this3.connector) === null || _this3$connector === void 0 ? void 0 : _this3$connector.off("display_uri");
                                  return _context9.abrupt("return", resolve());
                                case 7:
                                case "end":
                                  return _context9.stop();
                              }
                            }
                          }, _callee9);
                        }));
                        return function(_x6, _x7) {
                          return _ref3.apply(this, arguments);
                        };
                      }());
                      _this3.connector.createSession({
                        chainId: parseInt(((_this3$chainConfig = _this3.chainConfig) === null || _this3$chainConfig === void 0 ? void 0 : _this3$chainConfig.chainId) || "0x1", 16)
                      }).catch(function(error) {
                        log.error("error while creating new wallet connect session", error);
                        _this3.emit(ADAPTER_EVENTS.ERRORED, error);
                        return reject(error);
                      });
                    }));
                  case 11:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function createNewSession() {
            return _createNewSession.apply(this, arguments);
          }
          return createNewSession;
        }()
      }, {
        key: "onConnectHandler",
        value: function() {
          var _onConnectHandler = _asyncToGenerator(import_regenerator6.default.mark(function _callee11(params) {
            var chainId, _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3, connectedChainConfig, isCustomUi;
            return import_regenerator6.default.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    if (!(!this.connector || !this.wcProvider)) {
                      _context11.next = 2;
                      break;
                    }
                    throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
                  case 2:
                    if (this.chainConfig) {
                      _context11.next = 4;
                      break;
                    }
                    throw WalletInitializationError.invalidParams("Chain config is not set");
                  case 4:
                    chainId = params.chainId;
                    log.debug("connected chainId in hex");
                    if (!(chainId !== parseInt(this.chainConfig.chainId, 16))) {
                      _context11.next = 27;
                      break;
                    }
                    connectedChainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, chainId) || {
                      chainId: "0x".concat(chainId.toString(16)),
                      displayName: "Unknown Network"
                    };
                    isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal;
                    if (!(!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching))) {
                      _context11.next = 27;
                      break;
                    }
                    _context11.prev = 10;
                    _context11.next = 13;
                    return this.addChain(this.chainConfig);
                  case 13:
                    _context11.next = 15;
                    return this.switchChain(connectedChainConfig, this.chainConfig);
                  case 15:
                    this.connector = this.getWalletConnectInstance();
                    _context11.next = 27;
                    break;
                  case 18:
                    _context11.prev = 18;
                    _context11.t0 = _context11["catch"](10);
                    log.error("error while chain switching", _context11.t0);
                    _context11.next = 23;
                    return this.createNewSession({
                      forceNewSession: true
                    });
                  case 23:
                    this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5e3, "Not connected to correct network. Expected: ".concat(this.chainConfig.displayName, ", Current: ").concat((connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId, ", Please switch to correct network from wallet")));
                    this.status = ADAPTER_STATUS.READY;
                    this.rehydrated = true;
                    return _context11.abrupt("return");
                  case 27:
                    _context11.next = 29;
                    return this.wcProvider.setupProvider(this.connector);
                  case 29:
                    this.subscribeEvents(this.connector);
                    this.status = ADAPTER_STATUS.CONNECTED;
                    this.emit(ADAPTER_EVENTS.CONNECTED, {
                      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,
                      reconnected: this.rehydrated
                    });
                  case 32:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this, [[10, 18]]);
          }));
          function onConnectHandler(_x8) {
            return _onConnectHandler.apply(this, arguments);
          }
          return onConnectHandler;
        }()
      }, {
        key: "subscribeEvents",
        value: function subscribeEvents(connector) {
          var _this4 = this;
          connector.on("session_update", function() {
            var _ref4 = _asyncToGenerator(import_regenerator6.default.mark(function _callee12(error) {
              return import_regenerator6.default.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      if (error) {
                        _this4.emit(ADAPTER_EVENTS.ERRORED, error);
                      }
                    case 1:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12);
            }));
            return function(_x9) {
              return _ref4.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "getWalletConnectInstance",
        value: function getWalletConnectInstance() {
          var walletConnectOptions = this.adapterOptions.adapterSettings || {};
          walletConnectOptions.bridge = walletConnectOptions.bridge || "https://bridge.walletconnect.org";
          return new esm_default3(walletConnectOptions);
        }
      }]);
      return WalletConnectV1Adapter2;
    }(BaseEvmAdapter);
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/qrcode/node_modules/isarray/index.js"(exports, module) {
    init_process();
    init_buffer();
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/qrcode/lib/utils/typedarray-buffer.js
var require_typedarray_buffer = __commonJS({
  "node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var isArray = require_isarray();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    var K_MAX_LENGTH = Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    function Buffer(arg, offset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, offset, length);
      }
      if (typeof arg === "number") {
        return allocUnsafe(this, arg);
      }
      return from(this, arg, offset, length);
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function isnan(val) {
      return val !== val;
    }
    function createBuffer(that, length) {
      var buf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        buf = new Uint8Array(length);
        buf.__proto__ = Buffer.prototype;
      } else {
        buf = that;
        if (buf === null) {
          buf = new Buffer(length);
        }
        buf.length = length;
      }
      return buf;
    }
    function allocUnsafe(that, size) {
      var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i3 = 0; i3 < size; ++i3) {
          buf[i3] = 0;
        }
      }
      return buf;
    }
    function fromString(that, string) {
      var length = byteLength(string) | 0;
      var buf = createBuffer(that, length);
      var actual = buf.write(string);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(that, length);
      for (var i3 = 0; i3 < length; i3 += 1) {
        buf[i3] = array[i3] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(that, array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        buf.__proto__ = Buffer.prototype;
      } else {
        buf = fromArrayLike(that, buf);
      }
      return buf;
    }
    function fromObject(that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(that, len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i3 = 0; i3 < length; ++i3) {
        codePoint = string.charCodeAt(i3);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i3 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function byteLength(string) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        string = "" + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      return utf8ToBytes(string).length;
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i3 = 0; i3 < length; ++i3) {
        if (i3 + offset >= dst.length || i3 >= src.length)
          break;
        dst[i3 + offset] = src[i3];
      }
      return i3;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function from(that, value, offset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, offset, length);
      }
      if (typeof value === "string") {
        return fromString(that, value, offset);
      }
      return fromObject(that, value);
    }
    Buffer.prototype.write = function write(string, offset, length) {
      if (offset === void 0) {
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
        } else {
          length = void 0;
        }
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      return utf8Write(this, string, offset, length);
    };
    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, void 0);
        for (var i3 = 0; i3 < sliceLen; ++i3) {
          newBuf[i3] = this[i3 + start];
        }
      }
      return newBuf;
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i3;
      if (this === target && start < targetStart && targetStart < end) {
        for (i3 = len - 1; i3 >= 0; --i3) {
          target[i3 + targetStart] = this[i3 + start];
        }
      } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
        for (i3 = 0; i3 < len; ++i3) {
          target[i3 + targetStart] = this[i3 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i3;
      if (typeof val === "number") {
        for (i3 = start; i3 < end; ++i3) {
          this[i3] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : new Buffer(val);
        var len = bytes.length;
        for (i3 = 0; i3 < end - start; ++i3) {
          this[i3 + start] = bytes[i3 % len];
        }
      }
      return this;
    };
    Buffer.concat = function concat(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return createBuffer(null, 0);
      }
      var i3;
      if (length === void 0) {
        length = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          length += list[i3].length;
        }
      }
      var buffer = allocUnsafe(null, length);
      var pos = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        var buf = list[i3];
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer.byteLength = byteLength;
    Buffer.prototype._isBuffer = true;
    Buffer.isBuffer = function isBuffer2(b2) {
      return !!(b2 != null && b2._isBuffer);
    };
    module.exports.alloc = function(size) {
      var buffer = new Buffer(size);
      buffer.fill(0);
      return buffer;
    };
    module.exports.from = function(data) {
      return new Buffer(data);
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    init_process();
    init_buffer();
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version) {
      if (!version)
        throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f3) {
      if (typeof f3 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f3;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    init_process();
    init_buffer();
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e3) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    init_process();
    init_buffer();
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (var i3 = 0; i3 < length; i3++) {
          this.putBit((num >>> length - i3 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    init_process();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      var index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    init_process();
    init_buffer();
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1)
        return [];
      var posCount = Math.floor(version / 7) + 2;
      var size = getSymbolSize(version);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i3 = 1; i3 < posCount - 1; i3++) {
        positions[i3] = positions[i3 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version) {
      var coords = [];
      var pos = exports.getRowColCoords(version);
      var posLength = pos.length;
      for (var i3 = 0; i3 < posLength; i3++) {
        for (var j3 = 0; j3 < posLength; j3++) {
          if (i3 === 0 && j3 === 0 || // top-left
          i3 === 0 && j3 === posLength - 1 || // bottom-left
          i3 === posLength - 1 && j3 === 0) {
            continue;
          }
          coords.push([pos[i3], pos[j3]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    init_process();
    init_buffer();
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version) {
      var size = getSymbolSize(version);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    init_process();
    init_buffer();
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i3 = 0; i3 < modulesCount; i3++)
        darkCount += data.data[i3];
      var k3 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k3 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i3, j3) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i3 + j3) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i3 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j3 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i3 + j3) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i3 / 2) + Math.floor(j3 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i3 * j3 % 2 + i3 * j3 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i3 * j3 % 2 + i3 * j3 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i3 * j3 % 3 + (i3 + j3) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p3 = 0; p3 < numPatterns; p3++) {
        setupFormatFunc(p3);
        exports.applyMask(p3, data);
        var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p3, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p3;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    init_process();
    init_buffer();
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    init_process();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x3 = 1;
      for (var i3 = 0; i3 < 255; i3++) {
        EXP_TABLE[i3] = x3;
        LOG_TABLE[x3] = i3;
        x3 <<= 1;
        if (x3 & 256) {
          x3 ^= 285;
        }
      }
      for (i3 = 255; i3 < 512; i3++) {
        EXP_TABLE[i3] = EXP_TABLE[i3 - 255];
      }
    })();
    exports.log = function log4(n2) {
      if (n2 < 1)
        throw new Error("log(" + n2 + ")");
      return LOG_TABLE[n2];
    };
    exports.exp = function exp(n2) {
      return EXP_TABLE[n2];
    };
    exports.mul = function mul(x3, y3) {
      if (x3 === 0 || y3 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x3] + LOG_TABLE[y3]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    init_process();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var GF = require_galois_field();
    exports.mul = function mul(p1, p22) {
      var coeff = BufferUtil.alloc(p1.length + p22.length - 1);
      for (var i3 = 0; i3 < p1.length; i3++) {
        for (var j3 = 0; j3 < p22.length; j3++) {
          coeff[i3 + j3] ^= GF.mul(p1[i3], p22[j3]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i3 = 0; i3 < divisor.length; i3++) {
          result[i3] ^= GF.mul(divisor[i3], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i3 = 0; i3 < degree; i3++) {
        poly = exports.mul(poly, [1, GF.exp(i3)]);
      }
      return poly;
    };
  }
});

// node_modules/qrcode/node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/qrcode/node_modules/buffer/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }
      var b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i3 = 0; i3 < length; i3 += 1) {
        buf[i3] = array[i3] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer2(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer.prototype;
    };
    Buffer.compare = function compare(a3, b2) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer.from(b2, b2.offset, b2.byteLength);
      if (!Buffer.isBuffer(a3) || !Buffer.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a3 === b2)
        return 0;
      var x3 = a3.length;
      var y3 = b2.length;
      for (var i3 = 0, len = Math.min(x3, y3); i3 < len; ++i3) {
        if (a3[i3] !== b2[i3]) {
          x3 = a3[i3];
          y3 = b2[i3];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      var i3;
      if (length === void 0) {
        length = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          length += list[i3].length;
        }
      }
      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        var buf = list[i3];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b2, n2, m3) {
      var i3 = b2[n2];
      b2[n2] = b2[m3];
      b2[m3] = i3;
    }
    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i3 = 0; i3 < len; i3 += 2) {
        swap(this, i3, i3 + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i3 = 0; i3 < len; i3 += 4) {
        swap(this, i3, i3 + 3);
        swap(this, i3 + 1, i3 + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i3 = 0; i3 < len; i3 += 8) {
        swap(this, i3, i3 + 7);
        swap(this, i3 + 1, i3 + 6);
        swap(this, i3 + 2, i3 + 5);
        swap(this, i3 + 3, i3 + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    Buffer.prototype.equals = function equals(b2) {
      if (!Buffer.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer.compare(this, b2) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }
    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x3 = thisEnd - thisStart;
      var y3 = end - start;
      var len = Math.min(x3, y3);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i3 = 0; i3 < len; ++i3) {
        if (thisCopy[i3] !== targetCopy[i3]) {
          x3 = thisCopy[i3];
          y3 = targetCopy[i3];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i4) {
        if (indexSize === 1) {
          return buf[i4];
        } else {
          return buf.readUInt16BE(i4 * indexSize);
        }
      }
      var i3;
      if (dir) {
        var foundIndex = -1;
        for (i3 = byteOffset; i3 < arrLength; i3++) {
          if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i3;
            if (i3 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i3 -= i3 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i3 = byteOffset; i3 >= 0; i3--) {
          var found = true;
          for (var j3 = 0; j3 < valLength; j3++) {
            if (read(arr, i3 + j3) !== read(val, j3)) {
              found = false;
              break;
            }
          }
          if (found)
            return i3;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i3 = 0; i3 < length; ++i3) {
        var parsed = parseInt(string.substr(i3 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i3;
        buf[offset + i3] = parsed;
      }
      return i3;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i3 = start;
      while (i3 < end) {
        var firstByte = buf[i3];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i3 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i3 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i3 + 1];
              thirdByte = buf[i3 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i3 + 1];
              thirdByte = buf[i3 + 2];
              fourthByte = buf[i3 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i3 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i3 = 0;
      while (i3 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i3 = start; i3 < end; ++i3) {
        ret += String.fromCharCode(buf[i3] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i3 = start; i3 < end; ++i3) {
        ret += String.fromCharCode(buf[i3]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i3 = start; i3 < end; ++i3) {
        out += hexSliceLookupTable[buf[i3]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i3 = 0; i3 < bytes.length - 1; i3 += 2) {
        res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i3 = 0;
      while (++i3 < byteLength2 && (mul *= 256)) {
        val += this[offset + i3] * mul;
      }
      return val;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i3 = 0;
      while (++i3 < byteLength2 && (mul *= 256)) {
        val += this[offset + i3] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i3 = byteLength2;
      var mul = 1;
      var val = this[offset + --i3];
      while (i3 > 0 && (mul *= 256)) {
        val += this[offset + --i3] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i3 = 0;
      this[offset] = value & 255;
      while (++i3 < byteLength2 && (mul *= 256)) {
        this[offset + i3] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i3 = byteLength2 - 1;
      var mul = 1;
      this[offset + i3] = value & 255;
      while (--i3 >= 0 && (mul *= 256)) {
        this[offset + i3] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i3 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i3 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i3] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i3 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i3] = value & 255;
      while (--i3 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i3] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i3;
      if (typeof val === "number") {
        for (i3 = start; i3 < end; ++i3) {
          this[i3] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i3 = 0; i3 < end - start; ++i3) {
          this[i3 + start] = bytes[i3 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i3 = 0; i3 < length; ++i3) {
        codePoint = string.charCodeAt(i3);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i3 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i3 = 0; i3 < str.length; ++i3) {
        byteArray.push(str.charCodeAt(i3) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c3, hi, lo;
      var byteArray = [];
      for (var i3 = 0; i3 < str.length; ++i3) {
        if ((units -= 2) < 0)
          break;
        c3 = str.charCodeAt(i3);
        hi = c3 >> 8;
        lo = c3 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i3 = 0; i3 < length; ++i3) {
        if (i3 + offset >= dst.length || i3 >= src.length)
          break;
        dst[i3 + offset] = src[i3];
      }
      return i3;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i3 = 0; i3 < 16; ++i3) {
        var i16 = i3 * 16;
        for (var j3 = 0; j3 < 16; ++j3) {
          table[i16 + j3] = alphabet[i3] + alphabet[j3];
        }
      }
      return table;
    }();
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    init_process();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Polynomial = require_polynomial();
    var Buffer = require_buffer2().Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad = BufferUtil.alloc(this.degree);
      var paddedData = Buffer.concat([data, pad], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    init_process();
    init_buffer();
    exports.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    init_process();
    init_buffer();
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    init_process();
    init_buffer();
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10)
        return mode.ccBits[0];
      else if (version < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e3) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    init_process();
    init_buffer();
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d3 = version << 12;
      while (Utils.getBCHDigit(d3) - G18_BCH >= 0) {
        d3 ^= G18 << Utils.getBCHDigit(d3) - G18_BCH;
      }
      return version << 12 | d3;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    init_process();
    init_buffer();
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      var data = errorCorrectionLevel.bit << 3 | mask;
      var d3 = data << 10;
      while (Utils.getBCHDigit(d3) - G15_BCH >= 0) {
        d3 ^= G15 << Utils.getBCHDigit(d3) - G15_BCH;
      }
      return (data << 10 | d3) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    init_process();
    init_buffer();
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      var i3, group, value;
      for (i3 = 0; i3 + 3 <= this.data.length; i3 += 3) {
        group = this.data.substr(i3, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      var remainingNum = this.data.length - i3;
      if (remainingNum > 0) {
        group = this.data.substr(i3);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    init_process();
    init_buffer();
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      var i3;
      for (i3 = 0; i3 + 2 <= this.data.length; i3 += 2) {
        var value = ALPHA_NUM_CHARS.indexOf(this.data[i3]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i3 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i3]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    init_process();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i3 = 0, l3 = this.data.length; i3 < l3; i3++) {
        bitBuffer.put(this.data[i3], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    init_process();
    init_buffer();
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i3;
      for (i3 = 0; i3 < this.data.length; i3++) {
        var value = Utils.toSJIS(this.data[i3]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i3] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var dijkstra = {
      single_source_shortest_paths: function(graph, s3, d3) {
        var predecessors = {};
        var costs = {};
        costs[s3] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s3, 0);
        var closest, u3, v3, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u3 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u3] || {};
          for (v3 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v3)) {
              cost_of_e = adjacent_nodes[v3];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v3];
              first_visit = typeof costs[v3] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v3] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v3, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v3] = u3;
              }
            }
          }
        }
        if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
          var msg = ["Could not find a path from ", s3, " to ", d3, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d3) {
        var nodes = [];
        var u3 = d3;
        var predecessor;
        while (u3) {
          nodes.push(u3);
          predecessor = predecessors[u3];
          u3 = predecessors[u3];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s3, d3) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s3, d3);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d3
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T4 = dijkstra.PriorityQueue, t3 = {}, key;
          opts = opts || {};
          for (key in T4) {
            if (T4.hasOwnProperty(key)) {
              t3[key] = T4[key];
            }
          }
          t3.queue = [];
          t3.sorter = opts.sorter || T4.default_sorter;
          return t3;
        },
        default_sorter: function(a3, b2) {
          return a3.cost - b2.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    init_process();
    init_buffer();
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      var segments = [];
      var result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i3 = 0; i3 < segs.length; i3++) {
        var seg = segs[i3];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i3 = 0; i3 < nodes.length; i3++) {
        var nodeGroup = nodes[i3];
        var currentNodeIds = [];
        for (var j3 = 0; j3 < nodeGroup.length; j3++) {
          var node = nodeGroup[j3];
          var key = "" + i3 + j3;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (var n2 = 0; n2 < prevNodeIds.length; n2++) {
            var prevNodeId = prevNodeIds[n2];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n2 = 0; n2 < prevNodeIds.length; n2++) {
        graph[prevNodeIds[n2]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version);
      var path = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i3 = 1; i3 < path.length - 1; i3++) {
        optimizedSegs.push(graph.table[path[i3]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    init_process();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray = require_isarray();
    function setupFinderPattern(matrix, version) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version);
      for (var i3 = 0; i3 < pos.length; i3++) {
        var row = pos[i3][0];
        var col = pos[i3][1];
        for (var r3 = -1; r3 <= 7; r3++) {
          if (row + r3 <= -1 || size <= row + r3)
            continue;
          for (var c3 = -1; c3 <= 7; c3++) {
            if (col + c3 <= -1 || size <= col + c3)
              continue;
            if (r3 >= 0 && r3 <= 6 && (c3 === 0 || c3 === 6) || c3 >= 0 && c3 <= 6 && (r3 === 0 || r3 === 6) || r3 >= 2 && r3 <= 4 && c3 >= 2 && c3 <= 4) {
              matrix.set(row + r3, col + c3, true, true);
            } else {
              matrix.set(row + r3, col + c3, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r3 = 8; r3 < size - 8; r3++) {
        var value = r3 % 2 === 0;
        matrix.set(r3, 6, value, true);
        matrix.set(6, r3, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      var pos = AlignmentPattern.getPositions(version);
      for (var i3 = 0; i3 < pos.length; i3++) {
        var row = pos[i3][0];
        var col = pos[i3][1];
        for (var r3 = -2; r3 <= 2; r3++) {
          for (var c3 = -2; c3 <= 2; c3++) {
            if (r3 === -2 || r3 === 2 || c3 === -2 || c3 === 2 || r3 === 0 && c3 === 0) {
              matrix.set(row + r3, col + c3, true, true);
            } else {
              matrix.set(row + r3, col + c3, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version);
      var row, col, mod;
      for (var i3 = 0; i3 < 18; i3++) {
        row = Math.floor(i3 / 3);
        col = i3 % 3 + size - 8 - 3;
        mod = (bits >> i3 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i3, mod;
      for (i3 = 0; i3 < 15; i3++) {
        mod = (bits >> i3 & 1) === 1;
        if (i3 < 6) {
          matrix.set(i3, 8, mod, true);
        } else if (i3 < 8) {
          matrix.set(i3 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i3, 8, mod, true);
        }
        if (i3 < 8) {
          matrix.set(8, size - i3 - 1, mod, true);
        } else if (i3 < 9) {
          matrix.set(8, 15 - i3 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i3 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c3 = 0; c3 < 2; c3++) {
            if (!matrix.isReserved(row, col - c3)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c3, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      var buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (var i3 = 0; i3 < remainingByte; i3++) {
        buffer.put(i3 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs = new ReedSolomonEncoder(ecCount);
      var offset = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer = BufferUtil.from(bitBuffer.buffer);
      for (var b2 = 0; b2 < ecTotalBlocks; b2++) {
        var dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b2] = buffer.slice(offset, offset + dataSize);
        ecData[b2] = rs.encode(dcData[b2]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index = 0;
      var i3, r3;
      for (i3 = 0; i3 < maxDataSize; i3++) {
        for (r3 = 0; r3 < ecTotalBlocks; r3++) {
          if (i3 < dcData[r3].length) {
            data[index++] = dcData[r3][i3];
          }
        }
      }
      for (i3 = 0; i3 < ecCount; i3++) {
        for (r3 = 0; r3 < ecTotalBlocks; r3++) {
          data[index++] = ecData[r3][i3];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(
            rawSegments,
            errorCorrectionLevel
          );
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(
        segments,
        errorCorrectionLevel
      );
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      var dataBits = createData(version, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version;
      var mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    init_process();
    init_buffer();
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c3) {
          return [c3, c3];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i3 = 0; i3 < symbolSize; i3++) {
        for (var j3 = 0; j3 < symbolSize; j3++) {
          var posDst = (i3 * symbolSize + j3) * 4;
          var pxColor = opts.color.light;
          if (i3 >= scaledMargin && j3 >= scaledMargin && i3 < symbolSize - scaledMargin && j3 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i3 - scaledMargin) / scale);
            var jSrc = Math.floor((j3 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    init_process();
    init_buffer();
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e3) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports.render(qrData, canvas, opts);
      var type = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    init_process();
    init_buffer();
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x3, y3) {
      var str = cmd + x3;
      if (typeof y3 !== "undefined")
        str += " " + y3;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i3 = 0; i3 < data.length; i3++) {
        var col = Math.floor(i3 % size);
        var row = Math.floor(i3 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i3]) {
          lineLength++;
          if (!(i3 > 0 && col > 0 && data[i3 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i3 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    init_process();
    init_buffer();
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e3) {
            reject(e3);
          }
        });
      }
      try {
        var data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e3) {
        cb(e3);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _4, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i3 = 0; i3 < selection.rangeCount; i3++) {
        ranges.push(selection.getRangeAt(i3));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e3) {
          e3.stopPropagation();
          if (options.format) {
            e3.preventDefault();
            if (typeof e3.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e3.clipboardData.clearData();
              e3.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e3.preventDefault();
            options.onCopy(e3.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/preact/dist/preact.module.js
function a(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function v(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function h(n2, l3, u3) {
  var i3, t3 = arguments, r3 = {};
  for (i3 in l3)
    "key" !== i3 && "ref" !== i3 && (r3[i3] = l3[i3]);
  if (arguments.length > 3)
    for (u3 = [u3], i3 = 3; i3 < arguments.length; i3++)
      u3.push(t3[i3]);
  if (null != u3 && (r3.children = u3), "function" == typeof n2 && null != n2.defaultProps)
    for (i3 in n2.defaultProps)
      void 0 === r3[i3] && (r3[i3] = n2.defaultProps[i3]);
  return p(n2, r3, l3 && l3.key, l3 && l3.ref, null);
}
function p(l3, u3, i3, t3, r3) {
  var o3 = { type: l3, props: u3, key: i3, ref: t3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r3 };
  return null == r3 && (o3.__v = o3), n.vnode && n.vnode(o3), o3;
}
function y() {
  return {};
}
function d(n2) {
  return n2.children;
}
function m(n2, l3) {
  this.props = n2, this.context = l3;
}
function w(n2, l3) {
  if (null == l3)
    return n2.__ ? w(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n2.type ? w(n2) : null;
}
function k(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return k(n2);
  }
}
function g(l3) {
  (!l3.__d && (l3.__d = true) && u.push(l3) && !i++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || t)(_);
}
function _() {
  for (var n2; i = u.length; )
    n2 = u.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }), u = [], n2.some(function(n3) {
      var l3, u3, i3, t3, r3, o3, f3;
      n3.__d && (o3 = (r3 = (l3 = n3).__v).__e, (f3 = l3.__P) && (u3 = [], (i3 = a({}, r3)).__v = i3, t3 = A(f3, r3, i3, l3.__n, void 0 !== f3.ownerSVGElement, null, u3, null == o3 ? w(r3) : o3), T(u3, r3), t3 != o3 && k(r3)));
    });
}
function b(n2, l3, u3, i3, t3, r3, o3, f3, s3) {
  var a3, h3, p3, y3, d3, m3, k3, g3 = u3 && u3.__k || c, _4 = g3.length;
  if (f3 == e && (f3 = null != r3 ? r3[0] : _4 ? w(u3, 0) : null), a3 = 0, l3.__k = x(l3.__k, function(u4) {
    if (null != u4) {
      if (u4.__ = l3, u4.__b = l3.__b + 1, null === (p3 = g3[a3]) || p3 && u4.key == p3.key && u4.type === p3.type)
        g3[a3] = void 0;
      else
        for (h3 = 0; h3 < _4; h3++) {
          if ((p3 = g3[h3]) && u4.key == p3.key && u4.type === p3.type) {
            g3[h3] = void 0;
            break;
          }
          p3 = null;
        }
      if (y3 = A(n2, u4, p3 = p3 || e, i3, t3, r3, o3, f3, s3), (h3 = u4.ref) && p3.ref != h3 && (k3 || (k3 = []), p3.ref && k3.push(p3.ref, null, u4), k3.push(h3, u4.__c || y3, u4)), null != y3) {
        var c3;
        if (null == m3 && (m3 = y3), void 0 !== u4.__d)
          c3 = u4.__d, u4.__d = void 0;
        else if (r3 == p3 || y3 != f3 || null == y3.parentNode) {
          n:
            if (null == f3 || f3.parentNode !== n2)
              n2.appendChild(y3), c3 = null;
            else {
              for (d3 = f3, h3 = 0; (d3 = d3.nextSibling) && h3 < _4; h3 += 2)
                if (d3 == y3)
                  break n;
              n2.insertBefore(y3, f3), c3 = f3;
            }
          "option" == l3.type && (n2.value = "");
        }
        f3 = void 0 !== c3 ? c3 : y3.nextSibling, "function" == typeof l3.type && (l3.__d = f3);
      } else
        f3 && p3.__e == f3 && f3.parentNode != n2 && (f3 = w(p3));
    }
    return a3++, u4;
  }), l3.__e = m3, null != r3 && "function" != typeof l3.type)
    for (a3 = r3.length; a3--; )
      null != r3[a3] && v(r3[a3]);
  for (a3 = _4; a3--; )
    null != g3[a3] && D(g3[a3], g3[a3]);
  if (k3)
    for (a3 = 0; a3 < k3.length; a3++)
      j(k3[a3], k3[++a3], k3[++a3]);
}
function x(n2, l3, u3) {
  if (null == u3 && (u3 = []), null == n2 || "boolean" == typeof n2)
    l3 && u3.push(l3(null));
  else if (Array.isArray(n2))
    for (var i3 = 0; i3 < n2.length; i3++)
      x(n2[i3], l3, u3);
  else
    u3.push(l3 ? l3("string" == typeof n2 || "number" == typeof n2 ? p(null, n2, null, null, n2) : null != n2.__e || null != n2.__c ? p(n2.type, n2.props, n2.key, null, n2.__v) : n2) : n2);
  return u3;
}
function P(n2, l3, u3, i3, t3) {
  var r3;
  for (r3 in u3)
    "children" === r3 || "key" === r3 || r3 in l3 || N(n2, r3, null, u3[r3], i3);
  for (r3 in l3)
    t3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u3[r3] === l3[r3] || N(n2, r3, l3[r3], u3[r3], i3);
}
function C(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, u3) : n2[l3] = "number" == typeof u3 && false === s.test(l3) ? u3 + "px" : null == u3 ? "" : u3;
}
function N(n2, l3, u3, i3, t3) {
  var r3, o3, f3, e3, c3;
  if (t3 ? "className" === l3 && (l3 = "class") : "class" === l3 && (l3 = "className"), "style" === l3)
    if (r3 = n2.style, "string" == typeof u3)
      r3.cssText = u3;
    else {
      if ("string" == typeof i3 && (r3.cssText = "", i3 = null), i3)
        for (e3 in i3)
          u3 && e3 in u3 || C(r3, e3, "");
      if (u3)
        for (c3 in u3)
          i3 && u3[c3] === i3[c3] || C(r3, c3, u3[c3]);
    }
  else
    "o" === l3[0] && "n" === l3[1] ? (o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), f3 = l3.toLowerCase(), l3 = (f3 in n2 ? f3 : l3).slice(2), u3 ? (i3 || n2.addEventListener(l3, z, o3), (n2.l || (n2.l = {}))[l3] = u3) : n2.removeEventListener(l3, z, o3)) : "list" !== l3 && "tagName" !== l3 && "form" !== l3 && "type" !== l3 && "size" !== l3 && !t3 && l3 in n2 ? n2[l3] = null == u3 ? "" : u3 : "function" != typeof u3 && "dangerouslySetInnerHTML" !== l3 && (l3 !== (l3 = l3.replace(/^xlink:?/, "")) ? null == u3 || false === u3 ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l3.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l3.toLowerCase(), u3) : null == u3 || false === u3 && !/^ar/.test(l3) ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
}
function z(l3) {
  this.l[l3.type](n.event ? n.event(l3) : l3);
}
function A(l3, u3, i3, t3, r3, o3, f3, e3, c3) {
  var s3, v3, h3, p3, y3, w4, k3, g3, _4, x3, P3 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  (s3 = n.__b) && s3(u3);
  try {
    n:
      if ("function" == typeof P3) {
        if (g3 = u3.props, _4 = (s3 = P3.contextType) && t3[s3.__c], x3 = s3 ? _4 ? _4.props.value : s3.__ : t3, i3.__c ? k3 = (v3 = u3.__c = i3.__c).__ = v3.__E : ("prototype" in P3 && P3.prototype.render ? u3.__c = v3 = new P3(g3, x3) : (u3.__c = v3 = new m(g3, x3), v3.constructor = P3, v3.render = E), _4 && _4.sub(v3), v3.props = g3, v3.state || (v3.state = {}), v3.context = x3, v3.__n = t3, h3 = v3.__d = true, v3.__h = []), null == v3.__s && (v3.__s = v3.state), null != P3.getDerivedStateFromProps && (v3.__s == v3.state && (v3.__s = a({}, v3.__s)), a(v3.__s, P3.getDerivedStateFromProps(g3, v3.__s))), p3 = v3.props, y3 = v3.state, h3)
          null == P3.getDerivedStateFromProps && null != v3.componentWillMount && v3.componentWillMount(), null != v3.componentDidMount && v3.__h.push(v3.componentDidMount);
        else {
          if (null == P3.getDerivedStateFromProps && g3 !== p3 && null != v3.componentWillReceiveProps && v3.componentWillReceiveProps(g3, x3), !v3.__e && null != v3.shouldComponentUpdate && false === v3.shouldComponentUpdate(g3, v3.__s, x3) || u3.__v === i3.__v && !v3.__) {
            for (v3.props = g3, v3.state = v3.__s, u3.__v !== i3.__v && (v3.__d = false), v3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, v3.__h.length && f3.push(v3), s3 = 0; s3 < u3.__k.length; s3++)
              u3.__k[s3] && (u3.__k[s3].__ = u3);
            break n;
          }
          null != v3.componentWillUpdate && v3.componentWillUpdate(g3, v3.__s, x3), null != v3.componentDidUpdate && v3.__h.push(function() {
            v3.componentDidUpdate(p3, y3, w4);
          });
        }
        v3.context = x3, v3.props = g3, v3.state = v3.__s, (s3 = n.__r) && s3(u3), v3.__d = false, v3.__v = u3, v3.__P = l3, s3 = v3.render(v3.props, v3.state, v3.context), u3.__k = null != s3 && s3.type == d && null == s3.key ? s3.props.children : Array.isArray(s3) ? s3 : [s3], null != v3.getChildContext && (t3 = a(a({}, t3), v3.getChildContext())), h3 || null == v3.getSnapshotBeforeUpdate || (w4 = v3.getSnapshotBeforeUpdate(p3, y3)), b(l3, u3, i3, t3, r3, o3, f3, e3, c3), v3.base = u3.__e, v3.__h.length && f3.push(v3), k3 && (v3.__E = v3.__ = null), v3.__e = false;
      } else
        null == o3 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = $(i3.__e, u3, i3, t3, r3, o3, f3, c3);
    (s3 = n.diffed) && s3(u3);
  } catch (l4) {
    u3.__v = null, n.__e(l4, u3, i3);
  }
  return u3.__e;
}
function T(l3, u3) {
  n.__c && n.__c(u3, l3), l3.some(function(u4) {
    try {
      l3 = u4.__h, u4.__h = [], l3.some(function(n2) {
        n2.call(u4);
      });
    } catch (l4) {
      n.__e(l4, u4.__v);
    }
  });
}
function $(n2, l3, u3, i3, t3, r3, o3, f3) {
  var s3, a3, v3, h3, p3, y3 = u3.props, d3 = l3.props;
  if (t3 = "svg" === l3.type || t3, null != r3) {
    for (s3 = 0; s3 < r3.length; s3++)
      if (null != (a3 = r3[s3]) && ((null === l3.type ? 3 === a3.nodeType : a3.localName === l3.type) || n2 == a3)) {
        n2 = a3, r3[s3] = null;
        break;
      }
  }
  if (null == n2) {
    if (null === l3.type)
      return document.createTextNode(d3);
    n2 = t3 ? document.createElementNS("http://www.w3.org/2000/svg", l3.type) : document.createElement(l3.type, d3.is && { is: d3.is }), r3 = null, f3 = false;
  }
  if (null === l3.type)
    y3 !== d3 && n2.data != d3 && (n2.data = d3);
  else {
    if (null != r3 && (r3 = c.slice.call(n2.childNodes)), v3 = (y3 = u3.props || e).dangerouslySetInnerHTML, h3 = d3.dangerouslySetInnerHTML, !f3) {
      if (y3 === e)
        for (y3 = {}, p3 = 0; p3 < n2.attributes.length; p3++)
          y3[n2.attributes[p3].name] = n2.attributes[p3].value;
      (h3 || v3) && (h3 && v3 && h3.__html == v3.__html || (n2.innerHTML = h3 && h3.__html || ""));
    }
    P(n2, d3, y3, t3, f3), h3 ? l3.__k = [] : (l3.__k = l3.props.children, b(n2, l3, u3, i3, "foreignObject" !== l3.type && t3, r3, o3, e, f3)), f3 || ("value" in d3 && void 0 !== (s3 = d3.value) && s3 !== n2.value && N(n2, "value", s3, y3.value, false), "checked" in d3 && void 0 !== (s3 = d3.checked) && s3 !== n2.checked && N(n2, "checked", s3, y3.checked, false));
  }
  return n2;
}
function j(l3, u3, i3) {
  try {
    "function" == typeof l3 ? l3(u3) : l3.current = u3;
  } catch (l4) {
    n.__e(l4, i3);
  }
}
function D(l3, u3, i3) {
  var t3, r3, o3;
  if (n.unmount && n.unmount(l3), (t3 = l3.ref) && (t3.current && t3.current !== l3.__e || j(t3, null, u3)), i3 || "function" == typeof l3.type || (i3 = null != (r3 = l3.__e)), l3.__e = l3.__d = void 0, null != (t3 = l3.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (l4) {
        n.__e(l4, u3);
      }
    t3.base = t3.__P = null;
  }
  if (t3 = l3.__k)
    for (o3 = 0; o3 < t3.length; o3++)
      t3[o3] && D(t3[o3], u3, i3);
  null != r3 && v(r3);
}
function E(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function H(l3, u3, i3) {
  var t3, r3, f3;
  n.__ && n.__(l3, u3), r3 = (t3 = i3 === o) ? null : i3 && i3.__k || u3.__k, l3 = h(d, null, [l3]), f3 = [], A(u3, (t3 ? u3 : i3 || u3).__k = l3, r3 || e, e, void 0 !== u3.ownerSVGElement, i3 && !t3 ? [i3] : r3 ? null : c.slice.call(u3.childNodes), f3, i3 || e, t3), T(f3, l3);
}
function I(n2, l3) {
  H(n2, l3, o);
}
function L(n2, l3) {
  var u3, i3;
  for (i3 in l3 = a(a({}, n2.props), l3), arguments.length > 2 && (l3.children = c.slice.call(arguments, 2)), u3 = {}, l3)
    "key" !== i3 && "ref" !== i3 && (u3[i3] = l3[i3]);
  return p(n2.type, u3, l3.key || n2.key, l3.ref || n2.ref, null);
}
function M(n2) {
  var l3 = {}, u3 = { __c: "__cC" + f++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var i3, t3 = this;
    return this.getChildContext || (i3 = [], this.getChildContext = function() {
      return l3[u3.__c] = t3, l3;
    }, this.shouldComponentUpdate = function(n4) {
      t3.props.value !== n4.value && i3.some(function(l4) {
        l4.context = n4.value, g(l4);
      });
    }, this.sub = function(n4) {
      i3.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        i3.splice(i3.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Consumer.contextType = u3, u3.Provider.__ = u3, u3;
}
var n, l, u, i, t, r, o, f, e, c, s;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    init_process();
    init_buffer();
    e = {};
    c = [];
    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    n = { __e: function(n2, l3) {
      for (var u3, i3; l3 = l3.__; )
        if ((u3 = l3.__c) && !u3.__)
          try {
            if (u3.constructor && null != u3.constructor.getDerivedStateFromError && (i3 = true, u3.setState(u3.constructor.getDerivedStateFromError(n2))), null != u3.componentDidCatch && (i3 = true, u3.componentDidCatch(n2)), i3)
              return g(u3.__E = u3);
          } catch (l4) {
            n2 = l4;
          }
      throw n2;
    } }, l = function(n2) {
      return null != n2 && void 0 === n2.constructor;
    }, m.prototype.setState = function(n2, l3) {
      var u3;
      u3 = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n2 && (n2 = n2(u3, this.props)), n2 && a(u3, n2), null != n2 && this.__v && (l3 && this.__h.push(l3), g(this));
    }, m.prototype.forceUpdate = function(n2) {
      this.__v && (this.__e = true, n2 && this.__h.push(n2), g(this));
    }, m.prototype.render = d, u = [], i = 0, t = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
function v2(t3, r3) {
  n.__h && n.__h(u2, t3, i2 || r3), i2 = 0;
  var o3 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t3 >= o3.__.length && o3.__.push({}), o3.__[t3];
}
function m2(n2) {
  return i2 = 1, p2(E2, n2);
}
function p2(n2, r3, i3) {
  var o3 = v2(t2++, 2);
  return o3.__c || (o3.__c = u2, o3.__ = [i3 ? i3(r3) : E2(void 0, r3), function(t3) {
    var u3 = n2(o3.__[0], t3);
    o3.__[0] !== u3 && (o3.__[0] = u3, o3.__c.setState({}));
  }]), o3.__;
}
function l2(r3, i3) {
  var o3 = v2(t2++, 3);
  !n.__s && x2(o3.__H, i3) && (o3.__ = r3, o3.__H = i3, u2.__H.__h.push(o3));
}
function y2(r3, i3) {
  var o3 = v2(t2++, 4);
  !n.__s && x2(o3.__H, i3) && (o3.__ = r3, o3.__H = i3, u2.__h.push(o3));
}
function d2(n2) {
  return i2 = 5, h2(function() {
    return { current: n2 };
  }, []);
}
function s2(n2, t3, u3) {
  i2 = 6, y2(function() {
    "function" == typeof n2 ? n2(t3()) : n2 && (n2.current = t3());
  }, null == u3 ? u3 : u3.concat(n2));
}
function h2(n2, u3) {
  var r3 = v2(t2++, 7);
  return x2(r3.__H, u3) ? (r3.__H = u3, r3.__h = n2, r3.__ = n2()) : r3.__;
}
function T2(n2, t3) {
  return i2 = 8, h2(function() {
    return n2;
  }, t3);
}
function w2(n2) {
  var r3 = u2.context[n2.__c], i3 = v2(t2++, 9);
  return i3.__c = n2, r3 ? (null == i3.__ && (i3.__ = true, r3.sub(u2)), r3.props.value) : n2.__;
}
function A2(t3, u3) {
  n.useDebugValue && n.useDebugValue(u3 ? u3(t3) : t3);
}
function F(n2) {
  var r3 = v2(t2++, 10), i3 = m2();
  return r3.__ = n2, u2.componentDidCatch || (u2.componentDidCatch = function(n3) {
    r3.__ && r3.__(n3), i3[1](n3);
  }), [i3[0], function() {
    i3[1](void 0);
  }];
}
function _2() {
  o2.some(function(t3) {
    if (t3.__P)
      try {
        t3.__H.__h.forEach(g2), t3.__H.__h.forEach(q), t3.__H.__h = [];
      } catch (u3) {
        return t3.__H.__h = [], n.__e(u3, t3.__v), true;
      }
  }), o2 = [];
}
function g2(n2) {
  n2.t && n2.t();
}
function q(n2) {
  var t3 = n2.__();
  "function" == typeof t3 && (n2.t = t3);
}
function x2(n2, t3) {
  return !n2 || t3.some(function(t4, u3) {
    return t4 !== n2[u3];
  });
}
function E2(n2, t3) {
  return "function" == typeof t3 ? t3(n2) : t3;
}
var t2, u2, r2, i2, o2, c2, f2, e2, a2;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_process();
    init_buffer();
    init_preact_module();
    i2 = 0;
    o2 = [];
    c2 = n.__r;
    f2 = n.diffed;
    e2 = n.__c;
    a2 = n.unmount;
    n.__r = function(n2) {
      c2 && c2(n2), t2 = 0, (u2 = n2.__c).__H && (u2.__H.__h.forEach(g2), u2.__H.__h.forEach(q), u2.__H.__h = []);
    }, n.diffed = function(t3) {
      f2 && f2(t3);
      var u3 = t3.__c;
      if (u3) {
        var i3 = u3.__H;
        i3 && i3.__h.length && (1 !== o2.push(u3) && r2 === n.requestAnimationFrame || ((r2 = n.requestAnimationFrame) || function(n2) {
          var t4, u4 = function() {
            clearTimeout(r3), cancelAnimationFrame(t4), setTimeout(n2);
          }, r3 = setTimeout(u4, 100);
          "undefined" != typeof window && (t4 = requestAnimationFrame(u4));
        })(_2));
      }
    }, n.__c = function(t3, u3) {
      u3.some(function(t4) {
        try {
          t4.__h.forEach(g2), t4.__h = t4.__h.filter(function(n2) {
            return !n2.__ || q(n2);
          });
        } catch (r3) {
          u3.some(function(n2) {
            n2.__h && (n2.__h = []);
          }), u3 = [], n.__e(r3, t4.__v);
        }
      }), e2 && e2(t3, u3);
    }, n.unmount = function(t3) {
      a2 && a2(t3);
      var u3 = t3.__c;
      if (u3) {
        var r3 = u3.__H;
        if (r3)
          try {
            r3.__.forEach(function(n2) {
              return n2.t && n2.t();
            });
          } catch (t4) {
            n.__e(t4, u3.__v);
          }
      }
    };
  }
});

// node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => R,
  Component: () => m,
  Fragment: () => d,
  PureComponent: () => C2,
  Suspense: () => U,
  SuspenseList: () => O,
  cloneElement: () => K,
  createContext: () => M,
  createElement: () => h,
  createFactory: () => G,
  createPortal: () => z2,
  createRef: () => y,
  default: () => compat_module_default,
  findDOMNode: () => X,
  forwardRef: () => S,
  hydrate: () => V,
  isValidElement: () => J,
  lazy: () => L2,
  memo: () => _3,
  render: () => T3,
  unmountComponentAtNode: () => Q,
  unstable_batchedUpdates: () => Y,
  useCallback: () => T2,
  useContext: () => w2,
  useDebugValue: () => A2,
  useEffect: () => l2,
  useErrorBoundary: () => F,
  useImperativeHandle: () => s2,
  useLayoutEffect: () => y2,
  useMemo: () => h2,
  useReducer: () => p2,
  useRef: () => d2,
  useState: () => m2,
  version: () => B
});
function E3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function w3(n2, t3) {
  for (var e3 in n2)
    if ("__source" !== e3 && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if ("__source" !== r3 && n2[r3] !== t3[r3])
      return true;
  return false;
}
function _3(n2, t3) {
  function e3(n3) {
    var e4 = this.props.ref, r4 = e4 == n3.ref;
    return !r4 && e4 && (e4.call ? e4(null) : e4.current = null), t3 ? !t3(this.props, n3) || !r4 : w3(this.props, n3);
  }
  function r3(t4) {
    return this.shouldComponentUpdate = e3, h(n2, E3({}, t4));
  }
  return r3.prototype.isReactComponent = true, r3.displayName = "Memo(" + (n2.displayName || n2.name) + ")", r3.t = true, r3;
}
function S(n2) {
  function t3(t4) {
    var e3 = E3({}, t4);
    return delete e3.ref, n2(e3, t4.ref);
  }
  return t3.prototype.isReactComponent = t3.t = true, t3.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t3;
}
function N2(n2) {
  return n2 && ((n2 = E3({}, n2)).__c = null, n2.__k = n2.__k && n2.__k.map(N2)), n2;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M2(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.u && t3.u(n2);
}
function L2(n2) {
  var t3, e3, r3;
  function o3(o4) {
    if (t3 || (t3 = n2()).then(function(n3) {
      e3 = n3.default || n3;
    }, function(n3) {
      r3 = n3;
    }), r3)
      throw r3;
    if (!e3)
      throw t3;
    return h(e3, o4);
  }
  return o3.displayName = "Lazy", o3.t = true, o3;
}
function O() {
  this.i = null, this.l = null;
}
function j2(n2) {
  var t3 = this, e3 = n2.container, r3 = h(W, { context: t3.context }, n2.vnode);
  return t3.s && t3.s !== e3 && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h), t3.p = false), n2.vnode ? t3.p ? (e3.__k = t3.__k, H(r3, e3), t3.__k = e3.__k) : (t3.v = document.createTextNode(""), I("", e3), e3.appendChild(t3.v), t3.p = true, t3.s = e3, H(r3, e3, t3.v), t3.__k = t3.v.__k) : t3.p && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h)), t3.h = r3, t3.componentWillUnmount = function() {
    t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h);
  }, null;
}
function z2(n2, t3) {
  return h(j2, { vnode: n2, container: t3 });
}
function T3(n2, t3, e3) {
  if (null == t3.__k)
    for (; t3.firstChild; )
      t3.removeChild(t3.firstChild);
  return H(n2, t3), "function" == typeof e3 && e3(), n2 ? n2.__c : null;
}
function V(n2, t3, e3) {
  return I(n2, t3), "function" == typeof e3 && e3(), n2 ? n2.__c : null;
}
function I2(n2, t3) {
  n2["UNSAFE_" + t3] && !n2[t3] && Object.defineProperty(n2, t3, { configurable: false, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n3) {
    this["UNSAFE_" + t3] = n3;
  } });
}
function G(n2) {
  return h.bind(null, n2);
}
function J(n2) {
  return !!n2 && n2.$$typeof === H2;
}
function K(n2) {
  return J(n2) ? L.apply(null, arguments) : n2;
}
function Q(n2) {
  return !!n2.__k && (H(null, n2), true);
}
function X(n2) {
  return n2 && (n2.base || 1 === n2.nodeType && n2) || null;
}
var C2, A3, k2, R, F2, P2, W, D2, H2, Z, $2, q2, B, Y, compat_module_default;
var init_compat_module = __esm({
  "node_modules/preact/compat/dist/compat.module.js"() {
    init_process();
    init_buffer();
    init_hooks_module();
    init_hooks_module();
    init_preact_module();
    init_preact_module();
    C2 = function(n2) {
      var t3, e3;
      function r3(t4) {
        var e4;
        return (e4 = n2.call(this, t4) || this).isPureReactComponent = true, e4;
      }
      return e3 = n2, (t3 = r3).prototype = Object.create(e3.prototype), t3.prototype.constructor = t3, t3.__proto__ = e3, r3.prototype.shouldComponentUpdate = function(n3, t4) {
        return w3(this.props, n3) || w3(this.state, t4);
      }, r3;
    }(m);
    A3 = n.__b;
    n.__b = function(n2) {
      n2.type && n2.type.t && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), A3 && A3(n2);
    };
    k2 = function(n2, t3) {
      return n2 ? x(n2).reduce(function(n3, e3, r3) {
        return n3.concat(t3(e3, r3));
      }, []) : null;
    };
    R = { map: k2, forEach: k2, count: function(n2) {
      return n2 ? x(n2).length : 0;
    }, only: function(n2) {
      if (1 !== (n2 = x(n2)).length)
        throw new Error("Children.only() expects only one child.");
      return n2[0];
    }, toArray: x };
    F2 = n.__e;
    n.__e = function(n2, t3, e3) {
      if (n2.then) {
        for (var r3, o3 = t3; o3 = o3.__; )
          if ((r3 = o3.__c) && r3.__c)
            return r3.__c(n2, t3.__c);
      }
      F2(n2, t3, e3);
    }, (U.prototype = new m()).__c = function(n2, t3) {
      var e3 = this;
      null == e3.o && (e3.o = []), e3.o.push(t3);
      var r3 = M2(e3.__v), o3 = false, u3 = function() {
        o3 || (o3 = true, r3 ? r3(i3) : i3());
      };
      t3.__c = t3.componentWillUnmount, t3.componentWillUnmount = function() {
        u3(), t3.__c && t3.__c();
      };
      var i3 = function() {
        var n3;
        if (!--e3.__u)
          for (e3.__v.__k[0] = e3.state.u, e3.setState({ u: e3.__b = null }); n3 = e3.o.pop(); )
            n3.forceUpdate();
      };
      e3.__u++ || e3.setState({ u: e3.__b = e3.__v.__k[0] }), n2.then(u3, u3);
    }, U.prototype.render = function(n2, t3) {
      return this.__b && (this.__v.__k[0] = N2(this.__b), this.__b = null), [h(m, null, t3.u ? null : n2.children), t3.u && n2.fallback];
    };
    P2 = function(n2, t3, e3) {
      if (++e3[1] === e3[0] && n2.l.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.l.size))
        for (e3 = n2.i; e3; ) {
          for (; e3.length > 3; )
            e3.pop()();
          if (e3[1] < e3[0])
            break;
          n2.i = e3 = e3[2];
        }
    };
    (O.prototype = new m()).u = function(n2) {
      var t3 = this, e3 = M2(t3.__v), r3 = t3.l.get(n2);
      return r3[0]++, function(o3) {
        var u3 = function() {
          t3.props.revealOrder ? (r3.push(o3), P2(t3, n2, r3)) : o3();
        };
        e3 ? e3(u3) : u3();
      };
    }, O.prototype.render = function(n2) {
      this.i = null, this.l = /* @__PURE__ */ new Map();
      var t3 = x(n2.children);
      n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
      for (var e3 = t3.length; e3--; )
        this.l.set(t3[e3], this.i = [1, 0, this.i]);
      return n2.children;
    }, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function() {
      var n2 = this;
      n2.l.forEach(function(t3, e3) {
        P2(n2, e3, t3);
      });
    };
    W = function() {
      function n2() {
      }
      var t3 = n2.prototype;
      return t3.getChildContext = function() {
        return this.props.context;
      }, t3.render = function(n3) {
        return n3.children;
      }, n2;
    }();
    D2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    m.prototype.isReactComponent = {};
    H2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    Z = n.event;
    n.event = function(n2) {
      Z && (n2 = Z(n2)), n2.persist = function() {
      };
      var t3 = false, e3 = false, r3 = n2.stopPropagation;
      n2.stopPropagation = function() {
        r3.call(n2), t3 = true;
      };
      var o3 = n2.preventDefault;
      return n2.preventDefault = function() {
        o3.call(n2), e3 = true;
      }, n2.isPropagationStopped = function() {
        return t3;
      }, n2.isDefaultPrevented = function() {
        return e3;
      }, n2.nativeEvent = n2;
    };
    $2 = { configurable: true, get: function() {
      return this.class;
    } };
    q2 = n.vnode;
    n.vnode = function(n2) {
      n2.$$typeof = H2;
      var t3 = n2.type, e3 = n2.props;
      if (t3) {
        if (e3.class != e3.className && ($2.enumerable = "className" in e3, null != e3.className && (e3.class = e3.className), Object.defineProperty(e3, "className", $2)), "function" != typeof t3) {
          var r3, o3, u3;
          for (u3 in e3.defaultValue && void 0 !== e3.value && (e3.value || 0 === e3.value || (e3.value = e3.defaultValue), delete e3.defaultValue), Array.isArray(e3.value) && e3.multiple && "select" === t3 && (x(e3.children).forEach(function(n3) {
            -1 != e3.value.indexOf(n3.props.value) && (n3.props.selected = true);
          }), delete e3.value), e3)
            if (r3 = D2.test(u3))
              break;
          if (r3)
            for (u3 in o3 = n2.props = {}, e3)
              o3[D2.test(u3) ? u3.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u3] = e3[u3];
        }
        !function(t4) {
          var e4 = n2.type, r4 = n2.props;
          if (r4 && "string" == typeof e4) {
            var o4 = {};
            for (var u4 in r4)
              /^on(Ani|Tra|Tou)/.test(u4) && (r4[u4.toLowerCase()] = r4[u4], delete r4[u4]), o4[u4.toLowerCase()] = u4;
            if (o4.ondoubleclick && (r4.ondblclick = r4[o4.ondoubleclick], delete r4[o4.ondoubleclick]), o4.onbeforeinput && (r4.onbeforeinput = r4[o4.onbeforeinput], delete r4[o4.onbeforeinput]), o4.onchange && ("textarea" === e4 || "input" === e4.toLowerCase() && !/^fil|che|ra/i.test(r4.type))) {
              var i3 = o4.oninput || "oninput";
              r4[i3] || (r4[i3] = r4[o4.onchange], delete r4[o4.onchange]);
            }
          }
        }(), "function" == typeof t3 && !t3.m && t3.prototype && (I2(t3.prototype, "componentWillMount"), I2(t3.prototype, "componentWillReceiveProps"), I2(t3.prototype, "componentWillUpdate"), t3.m = true);
      }
      q2 && q2(n2);
    };
    B = "16.8.0";
    Y = function(n2, t3) {
      return n2(t3);
    };
    compat_module_default = { useState: m2, useReducer: p2, useEffect: l2, useLayoutEffect: y2, useRef: d2, useImperativeHandle: s2, useMemo: h2, useCallback: T2, useContext: w2, useDebugValue: A2, version: "16.8.0", Children: R, render: T3, hydrate: T3, unmountComponentAtNode: Q, createPortal: z2, createElement: h, createContext: M, createFactory: G, cloneElement: K, createRef: y, Fragment: d, isValidElement: J, findDOMNode: X, Component: m, PureComponent: C2, memo: _3, forwardRef: S, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O, lazy: L2 };
  }
});

// node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js"(exports, module) {
    init_process();
    init_buffer();
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var browserUtils = (init_esm2(), __toCommonJS(esm_exports2));
    var QRCode = _interopDefault(require_browser3());
    var copy = _interopDefault(require_copy_to_clipboard());
    var React = (init_compat_module(), __toCommonJS(compat_module_exports));
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
    function _catch(body, recover) {
      try {
        var result = body();
      } catch (e3) {
        return recover(e3);
      }
      if (result && result.then) {
        return result.then(void 0, recover);
      }
      return result;
    }
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props) {
      return React.createElement("div", {
        className: "walletconnect-modal__header"
      }, React.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props.onClose
      }, React.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props) {
      return React.createElement("a", {
        className: "walletconnect-connect__button",
        href: props.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
        onClick: props.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props.color
        },
        target: "_blank"
      }, props.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
    function WalletButton(props) {
      var color = props.color;
      var href = props.href;
      var name = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      return React.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name), React.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props) {
      var color = props.color;
      var href = props.href;
      var name = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      var fontSize = window.innerWidth < 768 ? (name.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props) {
      var android = browserUtils.isAndroid();
      var ref = React.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React.useState("");
      var filter = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter ? props.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter.toLowerCase());
      }) : props.links;
      var errorMessage = props.errorMessage;
      var grid = filter || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_4, index2) {
        return index2 + 1 >= range[0] && index2 + 1 <= range[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e3) {
        setInput(e3.target.value);
        clearTimeout(filterTimeout);
        if (e3.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e3.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = browserUtils.formatIOSMobile(props.uri, entry);
        var handleClickIOS = React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name,
            href
          });
        }, [pageLinks]);
        return !grid ? React.createElement(WalletButton, {
          color,
          href,
          name,
          logo,
          onClick: handleClickIOS
        }) : React.createElement(WalletIcon, {
          color,
          href,
          name: shortName || name,
          logo,
          onClick: handleClickIOS
        });
      }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
        name: props.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props.uri,
        onClick: React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props.uri
          });
        }, [])
      })), hasPaging && React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_4, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification(props) {
      var show = !!props.message.trim();
      return React.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props.message);
    }
    var formatQRCodeImage = function(data) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e3) {
        return Promise.reject(e3);
      }
    };
    function QRCodeDisplay(props) {
      var ref = React.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e3) {
          Promise.reject(e3);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy(props.uri);
        if (success) {
          setNotification(props.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React.createElement("a", {
        onClick: copyToClipboard
      }, props.text.copy_to_clipboard)), React.createElement(Notification, {
        message: notification
      }));
    }
    function Modal2(props) {
      var android = browserUtils.isAndroid();
      var mobile = browserUtils.isMobile();
      var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props.text,
        uri: props.uri,
        qrcodeModalOptions: props.qrcodeModalOptions
      };
      var ref$3 = React.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              var _temp = _catch(function() {
                var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
                return Promise.resolve(fetch(url)).then(function(registryResponse) {
                  return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                    var registry = _registryResponse$jso.listings;
                    var platform = mobile ? "mobile" : "desktop";
                    var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
                    setLoading(false);
                    setFetched(true);
                    setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                    setLinks(_links);
                    var hasSingleLink2 = _links.length === 1;
                    if (hasSingleLink2) {
                      setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                      setDisplayQRCode(true);
                    }
                    setHasSingleLink(hasSingleLink2);
                  });
                });
              }, function(e3) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props.text.something_went_wrong);
                console.error(e3);
              });
              return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
              }) : void 0);
            } catch (e3) {
              return Promise.reject(e3);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React.createElement("div", {
        className: "walletconnect-modal__base"
      }, React.createElement(Header, {
        onClose: props.onClose
      }), hasSingleLink && displayQRCode ? React.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React.createElement("a", {
        onClick: function() {
          return browserUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " ›")) : android || loading || !loading && links.length ? React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.mobile), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign(
        {},
        displayProps,
        {
          links,
          errorMessage
        }
      )))));
    }
    var de = {
      choose_preferred_wallet: "Wähle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterstützten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera móvil",
      scan_qrcode_with_wallet: "Escanea el código QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "Código QR",
      mobile: "Móvil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo salió mal",
      no_supported_wallets: "Todavía no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr = {
      choose_preferred_wallet: "Choisissez votre portefeuille préféré",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copié!",
      connect_with: "Connectez-vous à l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourné",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouvé"
    };
    var ko = {
      choose_preferred_wallet: "원하는 지갑을 선택하세요",
      connect_mobile_wallet: "모바일 지갑과 연결",
      scan_qrcode_with_wallet: "WalletConnect 지원 지갑에서 QR코드를 스캔하세요",
      connect: "연결",
      qrcode: "QR 코드",
      mobile: "모바일",
      desktop: "데스크탑",
      copy_to_clipboard: "클립보드에 복사",
      copied_to_clipboard: "클립보드에 복사되었습니다!",
      connect_with: "와 연결하다",
      loading: "로드 중...",
      something_went_wrong: "문제가 발생했습니다.",
      no_supported_wallets: "아직 지원되는 지갑이 없습니다",
      no_wallets_found: "지갑을 찾을 수 없습니다"
    };
    var pt = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se à carteira móvel",
      scan_qrcode_with_wallet: "Ler o código QR com uma carteira compatível com WalletConnect",
      connect: "Conectar",
      qrcode: "Código QR",
      mobile: "Móvel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda não há carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "选择你的钱包",
      connect_mobile_wallet: "连接至移动端钱包",
      scan_qrcode_with_wallet: "使用兼容 WalletConnect 的钱包扫描二维码",
      connect: "连接",
      qrcode: "二维码",
      mobile: "移动",
      desktop: "桌面",
      copy_to_clipboard: "复制到剪贴板",
      copied_to_clipboard: "复制到剪贴板成功！",
      connect_with: "通过以下方式连接",
      loading: "正在加载...",
      something_went_wrong: "出了问题",
      no_supported_wallets: "目前还没有支持的钱包",
      no_wallets_found: "没有找到钱包"
    };
    var fa = {
      choose_preferred_wallet: "کیف پول مورد نظر خود را انتخاب کنید",
      connect_mobile_wallet: "به کیف پول موبایل وصل شوید",
      scan_qrcode_with_wallet: "کد QR را با یک کیف پول سازگار با WalletConnect اسکن کنید",
      connect: "اتصال",
      qrcode: "کد QR",
      mobile: "سیار",
      desktop: "دسکتاپ",
      copy_to_clipboard: "کپی به کلیپ بورد",
      copied_to_clipboard: "در کلیپ بورد کپی شد!",
      connect_with: "ارتباط با",
      loading: "...بارگذاری",
      something_went_wrong: "مشکلی پیش آمد",
      no_supported_wallets: "هنوز هیچ کیف پول پشتیبانی شده ای وجود ندارد",
      no_wallets_found: "هیچ کیف پولی پیدا نشد"
    };
    var languages = {
      de,
      en,
      es,
      fr,
      ko,
      pt,
      zh,
      fa
    };
    function injectStyleSheet() {
      var doc = browserUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style = doc.createElement("style");
      style.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style);
    }
    function renderWrapper() {
      var doc = browserUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = browserUtils.getDocumentOrThrow();
      var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal) {
        modal.className = modal.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React.render(React.createElement(Modal2, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode3 = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode3()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode3())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module.exports = index;
  }
});

// node_modules/@biconomy/web3-auth/dist/src/UI.js
var require_UI = __commonJS({
  "node_modules/@biconomy/web3-auth/dist/src/UI.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m3, k3);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k3];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var container = {
      position: "fixed",
      float: "left",
      left: "50%",
      top: "50%",
      width: "min(90vw, 375px)",
      transform: "translate(-50%, -50%)",
      transition: "opacity 400ms ease-in",
      border: "1px solid #181818",
      borderRadius: 10,
      background: "black",
      overflow: "hidden"
    };
    var UI = ({ socialLogin }) => {
      const [email, setEmail] = (0, react_1.useState)("");
      function handleEmailSubmit(event) {
        event.preventDefault();
        socialLogin.emailLogin(email);
      }
      function handleEmailChange(event) {
        setEmail(event.currentTarget.value);
      }
      return react_1.default.createElement(
        "div",
        { style: container },
        react_1.default.createElement(
          "div",
          { className: "w3a-modal__header" },
          react_1.default.createElement(
            "div",
            { className: "w3a-header" },
            react_1.default.createElement("img", { className: "w3a-header__logo", src: socialLogin.whiteLabel.logo, alt: "logo" }),
            react_1.default.createElement(
              "div",
              null,
              react_1.default.createElement("div", { className: "w3a-header__title" }, "Sign in"),
              react_1.default.createElement("p", { className: "w3a-header__subtitle" }, "Select one of the following to continue")
            )
          ),
          react_1.default.createElement(
            "button",
            { onClick: () => socialLogin.hideWallet(), style: { position: "absolute", top: 20, right: 26, cursor: "pointer" } },
            react_1.default.createElement(
              "svg",
              { width: "24", height: "24", fill: "none", viewBox: "0 0 24 24" },
              react_1.default.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "M17.25 6.75L6.75 17.25" }),
              react_1.default.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "M6.75 6.75L17.25 17.25" })
            )
          )
        ),
        react_1.default.createElement(
          "div",
          { className: "w3a-modal__content" },
          react_1.default.createElement(
            "div",
            { className: "w3ajs-social-logins w3a-group" },
            react_1.default.createElement("div", { className: "w3a-group__title" }, "CONTINUE WITH"),
            react_1.default.createElement(
              "ul",
              { className: "w3a-adapter-list" },
              react_1.default.createElement(
                "li",
                { className: "w3a-adapter-item" },
                react_1.default.createElement(
                  "button",
                  { type: "button", className: "w3a-button w3a-button--icon", onClick: () => socialLogin.socialLogin("google") },
                  react_1.default.createElement("img", { src: "https://images.web3auth.io/login-google.svg", height: "auto", width: "auto", alt: "login-google" })
                )
              ),
              react_1.default.createElement(
                "li",
                { className: "w3a-adapter-item" },
                react_1.default.createElement(
                  "button",
                  { type: "button", className: "w3a-button w3a-button--icon", onClick: () => socialLogin.socialLogin("facebook") },
                  react_1.default.createElement("img", { src: "https://images.web3auth.io/login-facebook.svg", height: "auto", width: "auto", alt: "login-facebook" })
                )
              )
            )
          ),
          react_1.default.createElement(
            "div",
            { className: "w3ajs-email-passwordless w3a-group w3a-group--email" },
            react_1.default.createElement("div", { className: "w3a-group__title" }, "EMAIL"),
            react_1.default.createElement(
              "form",
              { className: "w3ajs-email-passwordless-form", onSubmit: handleEmailSubmit },
              react_1.default.createElement("input", { className: "w3a-text-field", type: "email", name: "email", placeholder: "Email", value: email, onChange: handleEmailChange }),
              react_1.default.createElement("button", { className: "w3a-button", type: "submit" }, "Continue with Email")
            )
          ),
          react_1.default.createElement(
            "div",
            { className: "w3ajs-external-wallet" },
            react_1.default.createElement(
              "div",
              { className: "w3a-external-toggle" },
              react_1.default.createElement("div", { className: "w3a-group__title" }, "EXTERNAL WALLET"),
              react_1.default.createElement("button", { type: "button", className: "w3a-button w3ajs-external-toggle__button", onClick: () => socialLogin.metamaskLogin() }, "Connect using MetaMask"),
              react_1.default.createElement("button", { type: "button", className: "w3a-button w3ajs-external-toggle__button", onClick: () => socialLogin.walletConnectLogin() }, "Use Wallet Connect")
            )
          )
        ),
        react_1.default.createElement(
          "div",
          { className: "w3a-modal__footer" },
          react_1.default.createElement(
            "div",
            { className: "w3a-footer" },
            react_1.default.createElement(
              "div",
              null,
              react_1.default.createElement(
                "div",
                { className: "w3a-footer__links" },
                "Powered by ",
                react_1.default.createElement("a", { href: "https://biconomy.io" }, "Biconomy")
              )
            )
          )
        )
      );
    };
    exports.default = UI;
  }
});

// node_modules/@biconomy/web3-auth/dist/src/SocialLogin.js
var require_SocialLogin = __commonJS({
  "node_modules/@biconomy/web3-auth/dist/src/SocialLogin.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSocialLoginSDK = exports.socialLoginSDK = void 0;
    var react_1 = __importDefault(require_react());
    var client_1 = require_client();
    var ethers_1 = (init_lib(), __toCommonJS(lib_exports));
    var core_1 = (init_core_esm(), __toCommonJS(core_esm_exports));
    var base_1 = (init_base_esm(), __toCommonJS(base_esm_exports));
    var openlogin_adapter_1 = (init_openloginAdapter_esm(), __toCommonJS(openloginAdapter_esm_exports));
    var metamask_adapter_1 = (init_metamaskAdapter_esm(), __toCommonJS(metamaskAdapter_esm_exports));
    var wallet_connect_v1_adapter_1 = (init_walletConnectV1Adapter_esm(), __toCommonJS(walletConnectV1Adapter_esm_exports));
    var qrcode_modal_1 = __importDefault(require_cjs4());
    var node_client_1 = __importDefault(require_src());
    var UI_1 = __importDefault(require_UI());
    function createLoginModal(socialLogin) {
      const root = (0, client_1.createRoot)(document.getElementById("w3a-modal"));
      root.render(react_1.default.createElement(UI_1.default, { socialLogin }));
    }
    var SocialLogin = class {
      constructor(backendUrl = defaultSocialLoginConfig.backendUrl) {
        this.iWin = false;
        this.iframeInitialized = false;
        this.isInit = false;
        this.userInfo = null;
        this.web3auth = null;
        this.provider = null;
        this.createWalletDiv();
        this.isInit = false;
        this.web3auth = null;
        this.provider = null;
        this.clientId = "BDtxlmCXNAWQFGiiaiVY3Qb1aN-d7DQ82OhT6B-RBr5j_rGnrKAqbIkvLJlf-ofYlJRiNSHbnkeHlsh8j3ueuYY";
        this.backendUrl = backendUrl;
        this.nodeClient = new node_client_1.default({ txServiceUrl: this.backendUrl });
        this.whiteLabel = {
          name: "Biconomy SDK",
          logo: "https://s2.coinmarketcap.com/static/img/coins/64x64/9543.png"
        };
      }
      async whitelistUrl(origin2) {
        const whiteListUrlResponse = await this.nodeClient.whitelistUrl(origin2);
        console.log(whiteListUrlResponse.data);
        return whiteListUrlResponse.data;
      }
      async init(socialLoginDTO) {
        const finalDTO = {
          chainId: "0x1",
          whitelistUrls: {},
          network: "mainnet",
          whteLableData: this.whiteLabel
        };
        if (socialLoginDTO) {
          if (socialLoginDTO.chainId)
            finalDTO.chainId = socialLoginDTO.chainId;
          if (socialLoginDTO.network)
            finalDTO.network = socialLoginDTO.network;
          if (socialLoginDTO.whitelistUrls)
            finalDTO.whitelistUrls = socialLoginDTO.whitelistUrls;
          if (socialLoginDTO.whteLableData)
            this.whiteLabel = socialLoginDTO.whteLableData;
        }
        try {
          console.log("SocialLogin init");
          const web3AuthCore = new core_1.Web3AuthCore({
            clientId: this.clientId,
            chainConfig: {
              chainNamespace: base_1.CHAIN_NAMESPACES.EIP155,
              chainId: finalDTO.chainId
            }
          });
          const openloginAdapter = new openlogin_adapter_1.OpenloginAdapter({
            adapterSettings: {
              clientId: this.clientId,
              network: finalDTO.network,
              uxMode: "popup",
              whiteLabel: {
                name: this.whiteLabel.name,
                logoLight: this.whiteLabel.logo,
                logoDark: this.whiteLabel.logo,
                defaultLanguage: "en",
                dark: true
              },
              originData: finalDTO.whitelistUrls
            }
          });
          const metamaskAdapter = new metamask_adapter_1.MetamaskAdapter({
            clientId: this.clientId
          });
          const wcAdapter = new wallet_connect_v1_adapter_1.WalletConnectV1Adapter({
            adapterSettings: {
              qrcodeModal: qrcode_modal_1.default
            }
          });
          web3AuthCore.configureAdapter(openloginAdapter);
          web3AuthCore.configureAdapter(metamaskAdapter);
          web3AuthCore.configureAdapter(wcAdapter);
          await web3AuthCore.init();
          this.web3auth = web3AuthCore;
          if (web3AuthCore && web3AuthCore.provider) {
            this.provider = web3AuthCore.provider;
          }
          createLoginModal(this);
          this.isInit = true;
        } catch (error) {
          console.error(error);
        }
      }
      getProvider() {
        return this.provider;
      }
      /* eslint-disable  @typescript-eslint/no-explicit-any */
      _createIframe(iframeContainerDiv) {
        this.walletIframe = document.createElement("iframe");
        this.walletIframe.style.display = "none";
        this.walletIframe.style.display = "relative";
        this.walletIframe.onload = () => {
          this.iWin = this.walletIframe.contentWindow || this.walletIframe;
          this.iframeInitialized = true;
        };
        iframeContainerDiv.appendChild(this.walletIframe);
      }
      createWalletDiv() {
        const walletDiv = document.createElement("div");
        walletDiv.id = "w3a-modal";
        walletDiv.className = "w3a-modal w3a-modal--light";
        walletDiv.style.display = "none";
        walletDiv.style.position = "fixed";
        walletDiv.style.top = "0";
        walletDiv.style.right = "0";
        walletDiv.style.height = "100%";
        walletDiv.style.width = "100%";
        walletDiv.style.background = "rgba(33, 33, 33, 0.75)";
        walletDiv.style.zIndex = "100";
        this.walletDiv = walletDiv;
        document.body.insertBefore(walletDiv, document.body.firstChild);
        this._createIframe(walletDiv);
      }
      showWallet() {
        this.walletDiv.style.display = "block";
        this.walletIframe.style.display = "block";
        this.walletIframe.style.height = "600px";
        this.walletIframe.style.width = "341px";
        this.walletIframe.style.border = "0px";
        this.walletIframe.style.borderRadius = "3%";
        const el = document.getElementById("w3a-modal");
        el === null || el === void 0 ? void 0 : el.dispatchEvent(new Event("show-modal"));
      }
      hideWallet() {
        console.log("hide wallet");
        this.walletDiv.style.display = "none";
        this.walletIframe.style.display = "none";
      }
      async getUserInfo() {
        if (this.web3auth) {
          const userInfo = await this.web3auth.getUserInfo();
          this.userInfo = userInfo;
          return userInfo;
        }
        return null;
      }
      async getPrivateKey() {
        if (this.web3auth && this.web3auth.provider) {
          const privateKey = await this.web3auth.provider.request({
            method: "eth_private_key"
          });
          return privateKey;
        }
        return null;
      }
      async socialLogin(loginProvider) {
        if (!this.web3auth) {
          console.info("web3auth not initialized yet");
          return;
        }
        try {
          const web3authProvider = await this.web3auth.connectTo(base_1.WALLET_ADAPTERS.OPENLOGIN, {
            loginProvider
          });
          if (!web3authProvider) {
            console.error("web3authProvider is null");
            return null;
          }
          const web3Provider = new ethers_1.ethers.providers.Web3Provider(web3authProvider);
          const signer = web3Provider.getSigner();
          const gotAccount = await signer.getAddress();
          const network = await web3Provider.getNetwork();
          console.info(`EOA Address ${gotAccount}
Network: ${network}`);
          this.provider = web3authProvider;
          return web3authProvider;
        } catch (error) {
          console.error(error);
          return error;
        }
      }
      async emailLogin(email) {
        if (!this.web3auth) {
          console.info("web3auth not initialized yet");
          return;
        }
        try {
          const web3authProvider = await this.web3auth.connectTo(base_1.WALLET_ADAPTERS.OPENLOGIN, {
            loginProvider: "email_passwordless",
            login_hint: email
          });
          if (!web3authProvider) {
            console.error("web3authProvider is null");
            return null;
          }
          const web3Provider = new ethers_1.ethers.providers.Web3Provider(web3authProvider);
          const signer = web3Provider.getSigner();
          const gotAccount = await signer.getAddress();
          const network = await web3Provider.getNetwork();
          console.info(`EOA Address ${gotAccount}
Network: ${network}`);
          this.provider = web3authProvider;
          return web3authProvider;
        } catch (error) {
          console.error(error);
          return error;
        }
      }
      async metamaskLogin() {
        if (!this.web3auth) {
          console.log("web3auth not initialized yet");
          return;
        }
        try {
          const web3authProvider = await this.web3auth.connectTo(base_1.WALLET_ADAPTERS.METAMASK);
          if (!web3authProvider) {
            console.log("web3authProvider is null");
            return null;
          }
          const web3Provider = new ethers_1.ethers.providers.Web3Provider(web3authProvider);
          const signer = web3Provider.getSigner();
          const gotAccount = await signer.getAddress();
          const network = await web3Provider.getNetwork();
          console.info(`EOA Address ${gotAccount}
Network: ${network}`);
          this.provider = web3authProvider;
          return web3authProvider;
        } catch (error) {
          console.error(error);
          return error;
        }
      }
      async walletConnectLogin() {
        if (!this.web3auth) {
          console.log("web3auth not initialized yet");
          return;
        }
        try {
          const web3authProvider = await this.web3auth.connectTo(base_1.WALLET_ADAPTERS.WALLET_CONNECT_V1);
          if (!web3authProvider) {
            console.log("web3authProvider is null");
            return null;
          }
          const web3Provider = new ethers_1.ethers.providers.Web3Provider(web3authProvider);
          const signer = web3Provider.getSigner();
          const gotAccount = await signer.getAddress();
          const network = await web3Provider.getNetwork();
          console.info(`EOA Address ${gotAccount}
Network: ${network}`);
          this.provider = web3authProvider;
          return web3authProvider;
        } catch (error) {
          console.error(error);
          return error;
        }
      }
      async logout() {
        if (!this.web3auth) {
          console.log("web3auth not initialized yet");
          return;
        }
        await this.web3auth.logout();
        this.web3auth.clearCache();
        this.provider = null;
      }
    };
    var defaultSocialLoginConfig = {
      backendUrl: "https://sdk-backend.prod.biconomy.io/v1"
    };
    exports.default = SocialLogin;
    var initializedSocialLogin = null;
    var getSocialLoginSDK = async (socialLoginDTO) => {
      if (initializedSocialLogin) {
        return initializedSocialLogin;
      }
      await socialLoginSDK.init(socialLoginDTO);
      initializedSocialLogin = socialLoginSDK;
      return socialLoginSDK;
    };
    exports.getSocialLoginSDK = getSocialLoginSDK;
    var socialLoginSDK = new SocialLogin();
    exports.socialLoginSDK = socialLoginSDK;
    window.socialLoginSDK = socialLoginSDK;
  }
});

// node_modules/@biconomy/web3-auth/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/@biconomy/web3-auth/dist/src/index.js"(exports) {
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m3, k3);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k3];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSocialLoginSDK = exports.socialLoginSDK = void 0;
    var SocialLogin_1 = __importStar(require_SocialLogin());
    Object.defineProperty(exports, "socialLoginSDK", { enumerable: true, get: function() {
      return SocialLogin_1.socialLoginSDK;
    } });
    Object.defineProperty(exports, "getSocialLoginSDK", { enumerable: true, get: function() {
      return SocialLogin_1.getSocialLoginSDK;
    } });
    exports.default = SocialLogin_1.default;
  }
});
export default require_src2();
/*! Bundled license information:

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=@biconomy_web3-auth.js.map
