import {
  BaseProvider,
  BigNumber,
  CHAIN_NAMESPACES,
  JRPCEngine,
  WalletInitializationError,
  WalletLoginError,
  _assertThisInitialized,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _get,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _typeof,
  bignumber_default,
  createAsyncMiddleware,
  createFetchMiddleware,
  createScaffoldMiddleware,
  getChainConfig,
  init_assertThisInitialized,
  init_asyncToGenerator,
  init_baseControllers_esm,
  init_baseProvider_esm,
  init_base_esm,
  init_bignumber,
  init_classCallCheck,
  init_createClass,
  init_defineProperty,
  init_get,
  init_getPrototypeOf,
  init_inherits,
  init_openloginJrpc_esm,
  init_possibleConstructorReturn,
  init_typeof,
  isHexStrict,
  log,
  mergeMiddleware,
  providerFromEngine,
  require_dist,
  require_dist2,
  require_fast_safe_stringify,
  require_lodash,
  require_loglevel,
  require_regenerator,
  require_url,
  signMessage
} from "./chunk-FEAYSPVD.js";
import {
  require_assert,
  require_src,
  require_src2
} from "./chunk-SKIYUWIC.js";
import {
  require_events
} from "./chunk-3CFYJ5LS.js";
import {
  require_crypto
} from "./chunk-EG7FL5OY.js";
import {
  require_bn,
  require_buffer
} from "./chunk-PZEDZEUW.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __require,
  __toESM,
  init_buffer,
  init_process
} from "./chunk-ARAA7IXG.js";

// node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert2 = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    exports.default = assert2;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, l, s) => h >>> s;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H = (h, l) => l;
    var rotr32L = (h, l) => h;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u64 = {
      fromBig,
      split,
      toBig: exports.toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto2();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex3 = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex3 += hexes[uint8a[i]];
      }
      return hex3;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex3) {
      if (typeof hex3 !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex3);
      }
      if (hex3.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex3.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex3.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils2();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.number(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/ethereum-cryptography/utils.js
var require_utils3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    var _assert_1 = __importDefault(require_assert2());
    var utils_1 = require_utils2();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils2();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    exports.bytesToUtf8 = bytesToUtf8;
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    exports.hexToBytes = hexToBytes;
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports.equalsBytes = equalsBytes;
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.wrapHash = wrapHash;
    exports.crypto = (() => {
      const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/ethereum-cryptography/keccak.js
var require_keccak = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils3();
    exports.keccak224 = (0, utils_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "node_modules/crc-32/crc32.js"(exports) {
    init_process();
    init_buffer();
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/goerli.json
var require_goerli = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/goerli.json"(exports, module) {
    module.exports = {
      name: "goerli",
      chainId: 5,
      networkId: 5,
      defaultHardfork: "merge",
      consensus: {
        type: "poa",
        algorithm: "clique",
        clique: {
          period: 15,
          epoch: 3e4
        }
      },
      comment: "Cross-client PoA test network",
      url: "https://github.com/goerli/testnet",
      genesis: {
        timestamp: "0x5c51a607",
        gasLimit: 10485760,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "istanbul",
          block: 1561651,
          forkHash: "0xc25efa5c"
        },
        {
          name: "berlin",
          block: 4460644,
          forkHash: "0x757a1c47"
        },
        {
          name: "london",
          block: 5062605,
          forkHash: "0xb8c6299d"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
          name: "merge",
          ttd: "10790000",
          block: 7382819,
          forkHash: "0xb8c6299d"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1678832736",
          forkHash: "0xf9843abf"
        }
      ],
      bootstrapNodes: [
        {
          ip: "51.141.78.53",
          port: 30303,
          id: "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
          location: "",
          comment: "Upstream bootnode 1"
        },
        {
          ip: "13.93.54.137",
          port: 30303,
          id: "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
          location: "",
          comment: "Upstream bootnode 2"
        },
        {
          ip: "94.237.54.114",
          port: 30313,
          id: "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
          location: "",
          comment: "Upstream bootnode 3"
        },
        {
          ip: "18.218.250.66",
          port: 30313,
          id: "b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",
          location: "",
          comment: "Upstream bootnode 4"
        },
        {
          ip: "3.11.147.67",
          port: 30303,
          id: "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
          location: "",
          comment: "Ethereum Foundation bootnode"
        },
        {
          ip: "51.15.116.226",
          port: 30303,
          id: "a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 30303,
          id: "807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 40303,
          id: "a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",
          location: "",
          comment: "Goerli Initiative bootnode"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
      ]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/mainnet.json
var require_mainnet = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/mainnet.json"(exports, module) {
    module.exports = {
      name: "mainnet",
      chainId: 1,
      networkId: 1,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "The Ethereum main chain",
      url: "https://ethstats.net/",
      genesis: {
        gasLimit: 5e3,
        difficulty: 17179869184,
        nonce: "0x0000000000000042",
        extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfc64ec04"
        },
        {
          name: "homestead",
          block: 115e4,
          forkHash: "0x97c2c34c"
        },
        {
          name: "dao",
          block: 192e4,
          forkHash: "0x91d1f948"
        },
        {
          name: "tangerineWhistle",
          block: 2463e3,
          forkHash: "0x7a64da13"
        },
        {
          name: "spuriousDragon",
          block: 2675e3,
          forkHash: "0x3edd5b10"
        },
        {
          name: "byzantium",
          block: 437e4,
          forkHash: "0xa00bc324"
        },
        {
          name: "constantinople",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "petersburg",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "istanbul",
          block: 9069e3,
          forkHash: "0x879d6e30"
        },
        {
          name: "muirGlacier",
          block: 92e5,
          forkHash: "0xe029e991"
        },
        {
          name: "berlin",
          block: 12244e3,
          forkHash: "0x0eb440f6"
        },
        {
          name: "london",
          block: 12965e3,
          forkHash: "0xb715077d"
        },
        {
          name: "arrowGlacier",
          block: 13773e3,
          forkHash: "0x20c327fc"
        },
        {
          name: "grayGlacier",
          block: 1505e4,
          forkHash: "0xf0afd0e3"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
          name: "merge",
          ttd: "58750000000000000000000",
          block: 15537394,
          forkHash: "0xf0afd0e3"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1681338455",
          forkHash: "0xdce96c2d"
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.138.108.67",
          port: 30303,
          id: "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
          location: "ap-southeast-1-001",
          comment: "bootnode-aws-ap-southeast-1-001"
        },
        {
          ip: "3.209.45.79",
          port: 30303,
          id: "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
          location: "us-east-1-001",
          comment: "bootnode-aws-us-east-1-001"
        },
        {
          ip: "65.108.70.101",
          port: 30303,
          id: "2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc",
          location: "eu-west-1-001",
          comment: "bootnode-hetzner-hel"
        },
        {
          ip: "157.90.35.166",
          port: 30303,
          id: "4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052",
          location: "eu-central-1-001",
          comment: "bootnode-hetzner-fsn"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
      ]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/rinkeby.json
var require_rinkeby = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/rinkeby.json"(exports, module) {
    module.exports = {
      name: "rinkeby",
      chainId: 4,
      networkId: 4,
      defaultHardfork: "london",
      consensus: {
        type: "poa",
        algorithm: "clique",
        clique: {
          period: 15,
          epoch: 3e4
        }
      },
      comment: "PoA test network",
      url: "https://www.rinkeby.io",
      genesis: {
        timestamp: "0x58ee40ba",
        gasLimit: 47e5,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0x3b8e0691"
        },
        {
          name: "homestead",
          block: 1,
          forkHash: "0x60949295"
        },
        {
          name: "tangerineWhistle",
          block: 2,
          forkHash: "0x8bde40dd"
        },
        {
          name: "spuriousDragon",
          block: 3,
          forkHash: "0xcb3a64bb"
        },
        {
          name: "byzantium",
          block: 1035301,
          forkHash: "0x8d748b57"
        },
        {
          name: "constantinople",
          block: 3660663,
          forkHash: "0xe49cab14"
        },
        {
          name: "petersburg",
          block: 4321234,
          forkHash: "0xafec6b27"
        },
        {
          name: "istanbul",
          block: 5435345,
          forkHash: "0xcbdb8838"
        },
        {
          name: "berlin",
          block: 8290928,
          forkHash: "0x6910c8bd"
        },
        {
          name: "london",
          block: 8897988,
          forkHash: "0x8e29f2f3"
        },
        {
          name: "merge",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "52.169.42.101",
          port: 30303,
          id: "a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",
          location: "",
          comment: "IE"
        },
        {
          ip: "52.3.158.184",
          port: 30303,
          id: "343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",
          location: "",
          comment: "INFURA"
        },
        {
          ip: "159.89.28.211",
          port: 30303,
          id: "b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",
          location: "",
          comment: "AKASHA"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"
      ]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/ropsten.json
var require_ropsten = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/ropsten.json"(exports, module) {
    module.exports = {
      name: "ropsten",
      chainId: 3,
      networkId: 3,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "PoW test network",
      url: "https://github.com/ethereum/ropsten",
      genesis: {
        gasLimit: 16777216,
        difficulty: 1048576,
        nonce: "0x0000000000000042",
        extraData: "0x3535353535353535353535353535353535353535353535353535353535353535"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "spuriousDragon",
          block: 10,
          forkHash: "0x63760190"
        },
        {
          name: "byzantium",
          block: 17e5,
          forkHash: "0x3ea159c7"
        },
        {
          name: "constantinople",
          block: 423e4,
          forkHash: "0x97b544f3"
        },
        {
          name: "petersburg",
          block: 4939394,
          forkHash: "0xd6e2149b"
        },
        {
          name: "istanbul",
          block: 6485846,
          forkHash: "0x4bc66396"
        },
        {
          name: "muirGlacier",
          block: 7117117,
          forkHash: "0x6727ef90"
        },
        {
          name: "berlin",
          block: 9812189,
          forkHash: "0xa157d377"
        },
        {
          name: "london",
          block: 10499401,
          forkHash: "0x7119b6b3"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
          name: "merge",
          ttd: "50000000000000000",
          block: null,
          forkHash: "0x7119b6b3"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "52.176.7.10",
          port: 30303,
          id: "30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",
          location: "",
          comment: "US-Azure geth"
        },
        {
          ip: "52.176.100.77",
          port: 30303,
          id: "865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",
          location: "",
          comment: "US-Azure parity"
        },
        {
          ip: "52.232.243.152",
          port: 30303,
          id: "6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",
          location: "",
          comment: "Parity"
        },
        {
          ip: "192.81.208.223",
          port: 30303,
          id: "94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",
          location: "",
          comment: "@gpip"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"
      ]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/sepolia.json
var require_sepolia = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/chains/sepolia.json"(exports, module) {
    module.exports = {
      name: "sepolia",
      chainId: 11155111,
      networkId: 11155111,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "PoW test network to replace Ropsten",
      url: "https://github.com/ethereum/go-ethereum/pull/23730",
      genesis: {
        timestamp: "0x6159af19",
        gasLimit: 3e7,
        difficulty: 131072,
        nonce: "0x0000000000000000",
        extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "istanbul",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "muirGlacier",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "berlin",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "london",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
          name: "merge",
          ttd: "17000000000000000",
          block: 1450409,
          forkHash: "0xfe3366e7"
        },
        {
          name: "mergeForkIdTransition",
          block: 1735371,
          forkHash: "0xb96cbd13"
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1677557088",
          forkHash: "0xf7f9bc08"
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.168.182.86",
          port: 30303,
          id: "9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",
          location: "",
          comment: "geth"
        },
        {
          ip: "52.14.151.177",
          port: 30303,
          id: "ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",
          location: "",
          comment: "besu"
        },
        {
          ip: "165.22.196.173",
          port: 30303,
          id: "ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",
          location: "",
          comment: "EF"
        },
        {
          ip: "65.108.95.67",
          port: 30303,
          id: "075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",
          location: "",
          comment: "lodestar"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
      ]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/1153.json
var require__ = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/1153.json"(exports, module) {
    module.exports = {
      name: "EIP-1153",
      number: 1153,
      comment: "Transient Storage",
      url: "https://eips.ethereum.org/EIPS/eip-1153",
      status: "Review",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        tstore: {
          v: 100,
          d: "Base fee of the TSTORE opcode"
        },
        tload: {
          v: 100,
          d: "Base fee of the TLOAD opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/1559.json
var require__2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/1559.json"(exports, module) {
    module.exports = {
      name: "EIP-1559",
      number: 1559,
      comment: "Fee market change for ETH 1.0 chain",
      url: "https://eips.ethereum.org/EIPS/eip-1559",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [2930],
      gasConfig: {
        baseFeeMaxChangeDenominator: {
          v: 8,
          d: "Maximum base fee change denominator"
        },
        elasticityMultiplier: {
          v: 2,
          d: "Maximum block gas target elasticity"
        },
        initialBaseFee: {
          v: 1e9,
          d: "Initial base fee on first EIP1559 block"
        }
      },
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2315.json
var require__3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2315.json"(exports, module) {
    module.exports = {
      name: "EIP-2315",
      number: 2315,
      comment: "Simple subroutines for the EVM",
      url: "https://eips.ethereum.org/EIPS/eip-2315",
      status: "Draft",
      minimumHardfork: "istanbul",
      gasConfig: {},
      gasPrices: {
        beginsub: {
          v: 2,
          d: "Base fee of the BEGINSUB opcode"
        },
        returnsub: {
          v: 5,
          d: "Base fee of the RETURNSUB opcode"
        },
        jumpsub: {
          v: 10,
          d: "Base fee of the JUMPSUB opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2537.json
var require__4 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2537.json"(exports, module) {
    module.exports = {
      name: "EIP-2537",
      number: 2537,
      comment: "BLS12-381 precompiles",
      url: "https://eips.ethereum.org/EIPS/eip-2537",
      status: "Draft",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {
        Bls12381G1AddGas: {
          v: 600,
          d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
        },
        Bls12381G1MulGas: {
          v: 12e3,
          d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
        },
        Bls12381G2AddGas: {
          v: 4500,
          d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
        },
        Bls12381G2MulGas: {
          v: 55e3,
          d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
        },
        Bls12381PairingBaseGas: {
          v: 115e3,
          d: "Base gas cost of BLS12-381 pairing check"
        },
        Bls12381PairingPerPairGas: {
          v: 23e3,
          d: "Per-pair gas cost of BLS12-381 pairing check"
        },
        Bls12381MapG1Gas: {
          v: 5500,
          d: "Gas cost of BLS12-381 map field element to G1"
        },
        Bls12381MapG2Gas: {
          v: 11e4,
          d: "Gas cost of BLS12-381 map field element to G2"
        },
        Bls12381MultiExpGasDiscount: {
          v: [
            [1, 1200],
            [2, 888],
            [3, 764],
            [4, 641],
            [5, 594],
            [6, 547],
            [7, 500],
            [8, 453],
            [9, 438],
            [10, 423],
            [11, 408],
            [12, 394],
            [13, 379],
            [14, 364],
            [15, 349],
            [16, 334],
            [17, 330],
            [18, 326],
            [19, 322],
            [20, 318],
            [21, 314],
            [22, 310],
            [23, 306],
            [24, 302],
            [25, 298],
            [26, 294],
            [27, 289],
            [28, 285],
            [29, 281],
            [30, 277],
            [31, 273],
            [32, 269],
            [33, 268],
            [34, 266],
            [35, 265],
            [36, 263],
            [37, 262],
            [38, 260],
            [39, 259],
            [40, 257],
            [41, 256],
            [42, 254],
            [43, 253],
            [44, 251],
            [45, 250],
            [46, 248],
            [47, 247],
            [48, 245],
            [49, 244],
            [50, 242],
            [51, 241],
            [52, 239],
            [53, 238],
            [54, 236],
            [55, 235],
            [56, 233],
            [57, 232],
            [58, 231],
            [59, 229],
            [60, 228],
            [61, 226],
            [62, 225],
            [63, 223],
            [64, 222],
            [65, 221],
            [66, 220],
            [67, 219],
            [68, 219],
            [69, 218],
            [70, 217],
            [71, 216],
            [72, 216],
            [73, 215],
            [74, 214],
            [75, 213],
            [76, 213],
            [77, 212],
            [78, 211],
            [79, 211],
            [80, 210],
            [81, 209],
            [82, 208],
            [83, 208],
            [84, 207],
            [85, 206],
            [86, 205],
            [87, 205],
            [88, 204],
            [89, 203],
            [90, 202],
            [91, 202],
            [92, 201],
            [93, 200],
            [94, 199],
            [95, 199],
            [96, 198],
            [97, 197],
            [98, 196],
            [99, 196],
            [100, 195],
            [101, 194],
            [102, 193],
            [103, 193],
            [104, 192],
            [105, 191],
            [106, 191],
            [107, 190],
            [108, 189],
            [109, 188],
            [110, 188],
            [111, 187],
            [112, 186],
            [113, 185],
            [114, 185],
            [115, 184],
            [116, 183],
            [117, 182],
            [118, 182],
            [119, 181],
            [120, 180],
            [121, 179],
            [122, 179],
            [123, 178],
            [124, 177],
            [125, 176],
            [126, 176],
            [127, 175],
            [128, 174]
          ],
          d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2565.json
var require__5 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2565.json"(exports, module) {
    module.exports = {
      name: "EIP-2565",
      number: 2565,
      comment: "ModExp gas cost",
      url: "https://eips.ethereum.org/EIPS/eip-2565",
      status: "Final",
      minimumHardfork: "byzantium",
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 3,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2718.json
var require__6 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2718.json"(exports, module) {
    module.exports = {
      name: "EIP-2718",
      comment: "Typed Transaction Envelope",
      url: "https://eips.ethereum.org/EIPS/eip-2718",
      status: "Final",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2929.json
var require__7 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2929.json"(exports, module) {
    module.exports = {
      name: "EIP-2929",
      comment: "Gas cost increases for state access opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-2929",
      status: "Final",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {
        coldsload: {
          v: 2100,
          d: "Gas cost of the first read of storage from a given location (per transaction)"
        },
        coldaccountaccess: {
          v: 2600,
          d: "Gas cost of the first read of a given address (per transaction)"
        },
        warmstorageread: {
          v: 100,
          d: "Gas cost of reading storage locations which have already loaded 'cold'"
        },
        sstoreCleanGasEIP2200: {
          v: 2900,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreNoopGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitRefundEIP2200: {
          v: 19900,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanRefundEIP2200: {
          v: 4900,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        call: {
          v: 0,
          d: "Base fee of the CALL opcode"
        },
        callcode: {
          v: 0,
          d: "Base fee of the CALLCODE opcode"
        },
        delegatecall: {
          v: 0,
          d: "Base fee of the DELEGATECALL opcode"
        },
        staticcall: {
          v: 0,
          d: "Base fee of the STATICCALL opcode"
        },
        balance: {
          v: 0,
          d: "Base fee of the BALANCE opcode"
        },
        extcodesize: {
          v: 0,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 0,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        extcodehash: {
          v: 0,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        sload: {
          v: 0,
          d: "Base fee of the SLOAD opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2930.json
var require__8 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/2930.json"(exports, module) {
    module.exports = {
      name: "EIP-2930",
      comment: "Optional access lists",
      url: "https://eips.ethereum.org/EIPS/eip-2930",
      status: "Final",
      minimumHardfork: "istanbul",
      requiredEIPs: [2718, 2929],
      gasConfig: {},
      gasPrices: {
        accessListStorageKeyCost: {
          v: 1900,
          d: "Gas cost per storage key in an Access List transaction"
        },
        accessListAddressCost: {
          v: 2400,
          d: "Gas cost per storage key in an Access List transaction"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3074.json
var require__9 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3074.json"(exports, module) {
    module.exports = {
      name: "EIP-3074",
      number: 3074,
      comment: "AUTH and AUTHCALL opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-3074",
      status: "Review",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {
        auth: {
          v: 3100,
          d: "Gas cost of the AUTH opcode"
        },
        authcall: {
          v: 0,
          d: "Gas cost of the AUTHCALL opcode"
        },
        authcallValueTransfer: {
          v: 6700,
          d: "Paid for CALL when the value transfer is non-zero"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3198.json
var require__10 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3198.json"(exports, module) {
    module.exports = {
      name: "EIP-3198",
      number: 3198,
      comment: "BASEFEE opcode",
      url: "https://eips.ethereum.org/EIPS/eip-3198",
      status: "Final",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {
        basefee: {
          v: 2,
          d: "Gas cost of the BASEFEE opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3529.json
var require__11 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3529.json"(exports, module) {
    module.exports = {
      name: "EIP-3529",
      comment: "Reduction in refunds",
      url: "https://eips.ethereum.org/EIPS/eip-3529",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [2929],
      gasConfig: {
        maxRefundQuotient: {
          v: 5,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        selfdestructRefund: {
          v: 0,
          d: "Refunded following a selfdestruct operation"
        },
        sstoreClearRefundEIP2200: {
          v: 4800,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3540.json
var require__12 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3540.json"(exports, module) {
    module.exports = {
      name: "EIP-3540",
      number: 3540,
      comment: "EVM Object Format (EOF) v1",
      url: "https://eips.ethereum.org/EIPS/eip-3540",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [3541],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3541.json
var require__13 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3541.json"(exports, module) {
    module.exports = {
      name: "EIP-3541",
      comment: "Reject new contracts starting with the 0xEF byte",
      url: "https://eips.ethereum.org/EIPS/eip-3541",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3554.json
var require__14 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3554.json"(exports, module) {
    module.exports = {
      name: "EIP-3554",
      comment: "Reduction in refunds",
      url: "Difficulty Bomb Delay to December 1st 2021",
      status: "Final",
      minimumHardfork: "muirGlacier",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 95e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3607.json
var require__15 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3607.json"(exports, module) {
    module.exports = {
      name: "EIP-3607",
      number: 3607,
      comment: "Reject transactions from senders with deployed code",
      url: "https://eips.ethereum.org/EIPS/eip-3607",
      status: "Final",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3651.json
var require__16 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3651.json"(exports, module) {
    module.exports = {
      name: "EIP-3651",
      number: 3198,
      comment: "Warm COINBASE",
      url: "https://eips.ethereum.org/EIPS/eip-3651",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [2929],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3670.json
var require__17 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3670.json"(exports, module) {
    module.exports = {
      name: "EIP-3670",
      number: 3670,
      comment: "EOF - Code Validation",
      url: "https://eips.ethereum.org/EIPS/eip-3670",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [3540],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3675.json
var require__18 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3675.json"(exports, module) {
    module.exports = {
      name: "EIP-3675",
      number: 3675,
      comment: "Upgrade consensus to Proof-of-Stake",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: "Final",
      minimumHardfork: "london",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3855.json
var require__19 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3855.json"(exports, module) {
    module.exports = {
      name: "EIP-3855",
      number: 3855,
      comment: "PUSH0 instruction",
      url: "https://eips.ethereum.org/EIPS/eip-3855",
      status: "Review",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        push0: {
          v: 2,
          d: "Base fee of the PUSH0 opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3860.json
var require__20 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/3860.json"(exports, module) {
    module.exports = {
      name: "EIP-3860",
      number: 3860,
      comment: "Limit and meter initcode",
      url: "https://eips.ethereum.org/EIPS/eip-3860",
      status: "Review",
      minimumHardfork: "spuriousDragon",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        initCodeWordCost: {
          v: 2,
          d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
        }
      },
      vm: {
        maxInitCodeSize: {
          v: 49152,
          d: "Maximum length of initialization code when creating a contract"
        }
      },
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4345.json
var require__21 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4345.json"(exports, module) {
    module.exports = {
      name: "EIP-4345",
      number: 4345,
      comment: "Difficulty Bomb Delay to June 2022",
      url: "https://eips.ethereum.org/EIPS/eip-4345",
      status: "Final",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 107e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4399.json
var require__22 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4399.json"(exports, module) {
    module.exports = {
      name: "EIP-4399",
      number: 4399,
      comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
      url: "https://eips.ethereum.org/EIPS/eip-4399",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4844.json
var require__23 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4844.json"(exports, module) {
    module.exports = {
      name: "EIP-4844",
      number: 4844,
      comment: "Shard Blob Transactions",
      url: "https://eips.ethereum.org/EIPS/eip-4844",
      status: "Draft",
      minimumHardfork: "merge",
      requiredEIPs: [1559, 2718, 2930, 4895],
      gasConfig: {
        dataGasPerBlob: {
          v: 131072,
          d: "The base fee for data gas per blob"
        },
        targetDataGasPerBlock: {
          v: 262144,
          d: "The target data gas consumed per block"
        },
        maxDataGasPerBlock: {
          v: 524288,
          d: "The max data gas allowable per block"
        },
        dataGasPriceUpdateFraction: {
          v: 2225652,
          d: "The denominator used in the exponential when calculating a data gas price"
        }
      },
      gasPrices: {
        simpleGasPerBlob: {
          v: 12e3,
          d: "The basic gas fee for each blob"
        },
        minDataGasPrice: {
          v: 1,
          d: "The minimum fee per data gas"
        },
        kzgPointEvaluationGasPrecompilePrice: {
          v: 5e4,
          d: "The fee associated with the point evaluation precompile"
        },
        datahash: {
          v: 3,
          d: "Base fee of the DATAHASH opcode"
        }
      },
      sharding: {
        blobCommitmentVersionKzg: {
          v: 1,
          d: "The number indicated a versioned hash is a KZG commitment"
        },
        fieldElementsPerBlob: {
          v: 4096,
          d: "The number of field elements allowed per blob"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4895.json
var require__24 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/4895.json"(exports, module) {
    module.exports = {
      name: "EIP-4895",
      number: 4895,
      comment: "Beacon chain push withdrawals as operations",
      url: "https://eips.ethereum.org/EIPS/eip-4895",
      status: "Review",
      minimumHardfork: "merge",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/5133.json
var require__25 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/5133.json"(exports, module) {
    module.exports = {
      name: "EIP-5133",
      number: 5133,
      comment: "Delaying Difficulty Bomb to mid-September 2022",
      url: "https://eips.ethereum.org/EIPS/eip-5133",
      status: "Draft",
      minimumHardfork: "grayGlacier",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 114e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/index.js
var require_eips = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/eips/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EIPs = void 0;
    exports.EIPs = {
      1153: require__(),
      1559: require__2(),
      2315: require__3(),
      2537: require__4(),
      2565: require__5(),
      2718: require__6(),
      2929: require__7(),
      2930: require__8(),
      3074: require__9(),
      3198: require__10(),
      3529: require__11(),
      3540: require__12(),
      3541: require__13(),
      3554: require__14(),
      3607: require__15(),
      3651: require__16(),
      3670: require__17(),
      3675: require__18(),
      3855: require__19(),
      3860: require__20(),
      4345: require__21(),
      4399: require__22(),
      4844: require__23(),
      4895: require__24(),
      5133: require__25()
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/enums.js
var require_enums = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/enums.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomChain = exports.ConsensusAlgorithm = exports.ConsensusType = exports.Hardfork = exports.Chain = void 0;
    var Chain;
    (function(Chain2) {
      Chain2[Chain2["Mainnet"] = 1] = "Mainnet";
      Chain2[Chain2["Ropsten"] = 3] = "Ropsten";
      Chain2[Chain2["Rinkeby"] = 4] = "Rinkeby";
      Chain2[Chain2["Goerli"] = 5] = "Goerli";
      Chain2[Chain2["Sepolia"] = 11155111] = "Sepolia";
    })(Chain = exports.Chain || (exports.Chain = {}));
    var Hardfork2;
    (function(Hardfork3) {
      Hardfork3["Chainstart"] = "chainstart";
      Hardfork3["Homestead"] = "homestead";
      Hardfork3["Dao"] = "dao";
      Hardfork3["TangerineWhistle"] = "tangerineWhistle";
      Hardfork3["SpuriousDragon"] = "spuriousDragon";
      Hardfork3["Byzantium"] = "byzantium";
      Hardfork3["Constantinople"] = "constantinople";
      Hardfork3["Petersburg"] = "petersburg";
      Hardfork3["Istanbul"] = "istanbul";
      Hardfork3["MuirGlacier"] = "muirGlacier";
      Hardfork3["Berlin"] = "berlin";
      Hardfork3["London"] = "london";
      Hardfork3["ArrowGlacier"] = "arrowGlacier";
      Hardfork3["GrayGlacier"] = "grayGlacier";
      Hardfork3["MergeForkIdTransition"] = "mergeForkIdTransition";
      Hardfork3["Merge"] = "merge";
      Hardfork3["Shanghai"] = "shanghai";
      Hardfork3["ShardingForkDev"] = "shardingFork";
    })(Hardfork2 = exports.Hardfork || (exports.Hardfork = {}));
    var ConsensusType;
    (function(ConsensusType2) {
      ConsensusType2["ProofOfStake"] = "pos";
      ConsensusType2["ProofOfWork"] = "pow";
      ConsensusType2["ProofOfAuthority"] = "poa";
    })(ConsensusType = exports.ConsensusType || (exports.ConsensusType = {}));
    var ConsensusAlgorithm;
    (function(ConsensusAlgorithm2) {
      ConsensusAlgorithm2["Ethash"] = "ethash";
      ConsensusAlgorithm2["Clique"] = "clique";
      ConsensusAlgorithm2["Casper"] = "casper";
    })(ConsensusAlgorithm = exports.ConsensusAlgorithm || (exports.ConsensusAlgorithm = {}));
    var CustomChain;
    (function(CustomChain2) {
      CustomChain2["PolygonMainnet"] = "polygon-mainnet";
      CustomChain2["PolygonMumbai"] = "polygon-mumbai";
      CustomChain2["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
      CustomChain2["ArbitrumOne"] = "arbitrum-one";
      CustomChain2["xDaiChain"] = "x-dai-chain";
      CustomChain2["OptimisticKovan"] = "optimistic-kovan";
      CustomChain2["OptimisticEthereum"] = "optimistic-ethereum";
    })(CustomChain = exports.CustomChain || (exports.CustomChain = {}));
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/chainstart.json
var require_chainstart = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/chainstart.json"(exports, module) {
    module.exports = {
      name: "chainstart",
      comment: "Start of the Ethereum main chain",
      url: "",
      status: "",
      gasConfig: {
        minGasLimit: {
          v: 5e3,
          d: "Minimum the gas limit may ever be"
        },
        gasLimitBoundDivisor: {
          v: 1024,
          d: "The bound divisor of the gas limit, used in update calculations"
        },
        maxRefundQuotient: {
          v: 2,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        base: {
          v: 2,
          d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
        },
        tierStep: {
          v: [0, 2, 3, 5, 8, 10, 20],
          d: "Once per operation, for a selection of them"
        },
        exp: {
          v: 10,
          d: "Base fee of the EXP opcode"
        },
        expByte: {
          v: 10,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        },
        sha3: {
          v: 30,
          d: "Base fee of the SHA3 opcode"
        },
        sha3Word: {
          v: 6,
          d: "Once per word of the SHA3 operation's data"
        },
        sload: {
          v: 50,
          d: "Base fee of the SLOAD opcode"
        },
        sstoreSet: {
          v: 2e4,
          d: "Once per SSTORE operation if the zeroness changes from zero"
        },
        sstoreReset: {
          v: 5e3,
          d: "Once per SSTORE operation if the zeroness does not change from zero"
        },
        sstoreRefund: {
          v: 15e3,
          d: "Once per SSTORE operation if the zeroness changes to zero"
        },
        jumpdest: {
          v: 1,
          d: "Base fee of the JUMPDEST opcode"
        },
        log: {
          v: 375,
          d: "Base fee of the LOG opcode"
        },
        logData: {
          v: 8,
          d: "Per byte in a LOG* operation's data"
        },
        logTopic: {
          v: 375,
          d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
        },
        create: {
          v: 32e3,
          d: "Base fee of the CREATE opcode"
        },
        call: {
          v: 40,
          d: "Base fee of the CALL opcode"
        },
        callStipend: {
          v: 2300,
          d: "Free gas given at beginning of call"
        },
        callValueTransfer: {
          v: 9e3,
          d: "Paid for CALL when the value transfor is non-zero"
        },
        callNewAccount: {
          v: 25e3,
          d: "Paid for CALL when the destination address didn't exist prior"
        },
        selfdestructRefund: {
          v: 24e3,
          d: "Refunded following a selfdestruct operation"
        },
        memory: {
          v: 3,
          d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
        },
        quadCoeffDiv: {
          v: 512,
          d: "Divisor for the quadratic particle of the memory cost equation"
        },
        createData: {
          v: 200,
          d: ""
        },
        tx: {
          v: 21e3,
          d: "Per transaction. NOTE: Not payable on data of calls between transactions"
        },
        txCreation: {
          v: 32e3,
          d: "The cost of creating a contract via tx"
        },
        txDataZero: {
          v: 4,
          d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
        },
        txDataNonZero: {
          v: 68,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        copy: {
          v: 3,
          d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
        },
        ecRecover: {
          v: 3e3,
          d: ""
        },
        sha256: {
          v: 60,
          d: ""
        },
        sha256Word: {
          v: 12,
          d: ""
        },
        ripemd160: {
          v: 600,
          d: ""
        },
        ripemd160Word: {
          v: 120,
          d: ""
        },
        identity: {
          v: 15,
          d: ""
        },
        identityWord: {
          v: 3,
          d: ""
        },
        stop: {
          v: 0,
          d: "Base fee of the STOP opcode"
        },
        add: {
          v: 3,
          d: "Base fee of the ADD opcode"
        },
        mul: {
          v: 5,
          d: "Base fee of the MUL opcode"
        },
        sub: {
          v: 3,
          d: "Base fee of the SUB opcode"
        },
        div: {
          v: 5,
          d: "Base fee of the DIV opcode"
        },
        sdiv: {
          v: 5,
          d: "Base fee of the SDIV opcode"
        },
        mod: {
          v: 5,
          d: "Base fee of the MOD opcode"
        },
        smod: {
          v: 5,
          d: "Base fee of the SMOD opcode"
        },
        addmod: {
          v: 8,
          d: "Base fee of the ADDMOD opcode"
        },
        mulmod: {
          v: 8,
          d: "Base fee of the MULMOD opcode"
        },
        signextend: {
          v: 5,
          d: "Base fee of the SIGNEXTEND opcode"
        },
        lt: {
          v: 3,
          d: "Base fee of the LT opcode"
        },
        gt: {
          v: 3,
          d: "Base fee of the GT opcode"
        },
        slt: {
          v: 3,
          d: "Base fee of the SLT opcode"
        },
        sgt: {
          v: 3,
          d: "Base fee of the SGT opcode"
        },
        eq: {
          v: 3,
          d: "Base fee of the EQ opcode"
        },
        iszero: {
          v: 3,
          d: "Base fee of the ISZERO opcode"
        },
        and: {
          v: 3,
          d: "Base fee of the AND opcode"
        },
        or: {
          v: 3,
          d: "Base fee of the OR opcode"
        },
        xor: {
          v: 3,
          d: "Base fee of the XOR opcode"
        },
        not: {
          v: 3,
          d: "Base fee of the NOT opcode"
        },
        byte: {
          v: 3,
          d: "Base fee of the BYTE opcode"
        },
        address: {
          v: 2,
          d: "Base fee of the ADDRESS opcode"
        },
        balance: {
          v: 20,
          d: "Base fee of the BALANCE opcode"
        },
        origin: {
          v: 2,
          d: "Base fee of the ORIGIN opcode"
        },
        caller: {
          v: 2,
          d: "Base fee of the CALLER opcode"
        },
        callvalue: {
          v: 2,
          d: "Base fee of the CALLVALUE opcode"
        },
        calldataload: {
          v: 3,
          d: "Base fee of the CALLDATALOAD opcode"
        },
        calldatasize: {
          v: 2,
          d: "Base fee of the CALLDATASIZE opcode"
        },
        calldatacopy: {
          v: 3,
          d: "Base fee of the CALLDATACOPY opcode"
        },
        codesize: {
          v: 2,
          d: "Base fee of the CODESIZE opcode"
        },
        codecopy: {
          v: 3,
          d: "Base fee of the CODECOPY opcode"
        },
        gasprice: {
          v: 2,
          d: "Base fee of the GASPRICE opcode"
        },
        extcodesize: {
          v: 20,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 20,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        blockhash: {
          v: 20,
          d: "Base fee of the BLOCKHASH opcode"
        },
        coinbase: {
          v: 2,
          d: "Base fee of the COINBASE opcode"
        },
        timestamp: {
          v: 2,
          d: "Base fee of the TIMESTAMP opcode"
        },
        number: {
          v: 2,
          d: "Base fee of the NUMBER opcode"
        },
        difficulty: {
          v: 2,
          d: "Base fee of the DIFFICULTY opcode"
        },
        gaslimit: {
          v: 2,
          d: "Base fee of the GASLIMIT opcode"
        },
        pop: {
          v: 2,
          d: "Base fee of the POP opcode"
        },
        mload: {
          v: 3,
          d: "Base fee of the MLOAD opcode"
        },
        mstore: {
          v: 3,
          d: "Base fee of the MSTORE opcode"
        },
        mstore8: {
          v: 3,
          d: "Base fee of the MSTORE8 opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        },
        jump: {
          v: 8,
          d: "Base fee of the JUMP opcode"
        },
        jumpi: {
          v: 10,
          d: "Base fee of the JUMPI opcode"
        },
        pc: {
          v: 2,
          d: "Base fee of the PC opcode"
        },
        msize: {
          v: 2,
          d: "Base fee of the MSIZE opcode"
        },
        gas: {
          v: 2,
          d: "Base fee of the GAS opcode"
        },
        push: {
          v: 3,
          d: "Base fee of the PUSH opcode"
        },
        dup: {
          v: 3,
          d: "Base fee of the DUP opcode"
        },
        swap: {
          v: 3,
          d: "Base fee of the SWAP opcode"
        },
        callcode: {
          v: 40,
          d: "Base fee of the CALLCODE opcode"
        },
        return: {
          v: 0,
          d: "Base fee of the RETURN opcode"
        },
        invalid: {
          v: 0,
          d: "Base fee of the INVALID opcode"
        },
        selfdestruct: {
          v: 0,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      },
      vm: {
        stackLimit: {
          v: 1024,
          d: "Maximum size of VM stack allowed"
        },
        callCreateDepth: {
          v: 1024,
          d: "Maximum depth of call/create stack"
        },
        maxExtraDataSize: {
          v: 32,
          d: "Maximum size extra data may be after Genesis"
        }
      },
      pow: {
        minimumDifficulty: {
          v: 131072,
          d: "The minimum that the difficulty may ever be"
        },
        difficultyBoundDivisor: {
          v: 2048,
          d: "The bound divisor of the difficulty, used in the update calculations"
        },
        durationLimit: {
          v: 13,
          d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
        },
        epochDuration: {
          v: 3e4,
          d: "Duration between proof-of-work epochs"
        },
        timebombPeriod: {
          v: 1e5,
          d: "Exponential difficulty timebomb period"
        },
        minerReward: {
          v: "5000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 0,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/homestead.json
var require_homestead = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/homestead.json"(exports, module) {
    module.exports = {
      name: "homestead",
      comment: "Homestead hardfork with protocol and network changes",
      url: "https://eips.ethereum.org/EIPS/eip-606",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        delegatecall: {
          v: 40,
          d: "Base fee of the DELEGATECALL opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/dao.json
var require_dao = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/dao.json"(exports, module) {
    module.exports = {
      name: "dao",
      comment: "DAO rescue hardfork",
      url: "https://eips.ethereum.org/EIPS/eip-779",
      status: "Final",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/tangerineWhistle.json
var require_tangerineWhistle = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/tangerineWhistle.json"(exports, module) {
    module.exports = {
      name: "tangerineWhistle",
      comment: "Hardfork with gas cost changes for IO-heavy operations",
      url: "https://eips.ethereum.org/EIPS/eip-608",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        sload: {
          v: 200,
          d: "Once per SLOAD operation"
        },
        call: {
          v: 700,
          d: "Once per CALL operation & message call transaction"
        },
        extcodesize: {
          v: 700,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 700,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        balance: {
          v: 400,
          d: "Base fee of the BALANCE opcode"
        },
        delegatecall: {
          v: 700,
          d: "Base fee of the DELEGATECALL opcode"
        },
        callcode: {
          v: 700,
          d: "Base fee of the CALLCODE opcode"
        },
        selfdestruct: {
          v: 5e3,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/spuriousDragon.json
var require_spuriousDragon = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/spuriousDragon.json"(exports, module) {
    module.exports = {
      name: "spuriousDragon",
      comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
      url: "https://eips.ethereum.org/EIPS/eip-607",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        expByte: {
          v: 50,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        }
      },
      vm: {
        maxCodeSize: {
          v: 24576,
          d: "Maximum length of contract code"
        }
      },
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/byzantium.json
var require_byzantium = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/byzantium.json"(exports, module) {
    module.exports = {
      name: "byzantium",
      comment: "Hardfork with new precompiles, instructions and other protocol changes",
      url: "https://eips.ethereum.org/EIPS/eip-609",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 20,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        },
        ecAdd: {
          v: 500,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 4e4,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 1e5,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 8e4,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        revert: {
          v: 0,
          d: "Base fee of the REVERT opcode"
        },
        staticcall: {
          v: 700,
          d: "Base fee of the STATICCALL opcode"
        },
        returndatasize: {
          v: 2,
          d: "Base fee of the RETURNDATASIZE opcode"
        },
        returndatacopy: {
          v: 3,
          d: "Base fee of the RETURNDATACOPY opcode"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "3000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 3e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/constantinople.json
var require_constantinople = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/constantinople.json"(exports, module) {
    module.exports = {
      name: "constantinople",
      comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
      url: "https://eips.ethereum.org/EIPS/eip-1013",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: 200,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        netSstoreInitGas: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero"
        },
        netSstoreCleanGas: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero"
        },
        netSstoreDirtyGas: {
          v: 200,
          d: "Once per SSTORE operation from dirty"
        },
        netSstoreClearRefund: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        netSstoreResetRefund: {
          v: 4800,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        netSstoreResetClearRefund: {
          v: 19800,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        shl: {
          v: 3,
          d: "Base fee of the SHL opcode"
        },
        shr: {
          v: 3,
          d: "Base fee of the SHR opcode"
        },
        sar: {
          v: 3,
          d: "Base fee of the SAR opcode"
        },
        extcodehash: {
          v: 400,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        create2: {
          v: 32e3,
          d: "Base fee of the CREATE2 opcode"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "2000000000000000000",
          d: "The amount a miner gets rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 5e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/petersburg.json
var require_petersburg = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/petersburg.json"(exports, module) {
    module.exports = {
      name: "petersburg",
      comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
      url: "https://eips.ethereum.org/EIPS/eip-1716",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreInitGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreCleanGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreDirtyGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/istanbul.json
var require_istanbul = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/istanbul.json"(exports, module) {
    module.exports = {
      name: "istanbul",
      comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
      url: "https://eips.ethereum.org/EIPS/eip-1679",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        blake2Round: {
          v: 1,
          d: "Gas cost per round for the Blake2 F precompile"
        },
        ecAdd: {
          v: 150,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 6e3,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 45e3,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 34e3,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        txDataNonZero: {
          v: 16,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        sstoreSentryGasEIP2200: {
          v: 2300,
          d: "Minimum gas required to be present for an SSTORE call, not consumed"
        },
        sstoreNoopGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitGasEIP2200: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero to non-zero"
        },
        sstoreInitRefundEIP2200: {
          v: 19200,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanGasEIP2200: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreCleanRefundEIP2200: {
          v: 4200,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        sstoreClearRefundEIP2200: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        balance: {
          v: 700,
          d: "Base fee of the BALANCE opcode"
        },
        extcodehash: {
          v: 700,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        chainid: {
          v: 2,
          d: "Base fee of the CHAINID opcode"
        },
        selfbalance: {
          v: 5,
          d: "Base fee of the SELFBALANCE opcode"
        },
        sload: {
          v: 800,
          d: "Base fee of the SLOAD opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/muirGlacier.json
var require_muirGlacier = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/muirGlacier.json"(exports, module) {
    module.exports = {
      name: "muirGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://eips.ethereum.org/EIPS/eip-2384",
      status: "Final",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 9e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/berlin.json
var require_berlin = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/berlin.json"(exports, module) {
    module.exports = {
      name: "berlin",
      comment: "HF targeted for July 2020 following the Muir Glacier HF",
      url: "https://eips.ethereum.org/EIPS/eip-2070",
      status: "Final",
      eips: [2565, 2929, 2718, 2930]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/london.json
var require_london = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/london.json"(exports, module) {
    module.exports = {
      name: "london",
      comment: "HF targeted for July 2021 following the Berlin fork",
      url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
      status: "Final",
      eips: [1559, 3198, 3529, 3541]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/shanghai.json
var require_shanghai = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/shanghai.json"(exports, module) {
    module.exports = {
      name: "shanghai",
      comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
      status: "Final",
      eips: [3651, 3855, 3860, 4895]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/arrowGlacier.json
var require_arrowGlacier = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/arrowGlacier.json"(exports, module) {
    module.exports = {
      name: "arrowGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
      status: "Final",
      eips: [4345],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/grayGlacier.json
var require_grayGlacier = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/grayGlacier.json"(exports, module) {
    module.exports = {
      name: "grayGlacier",
      comment: "Delaying the difficulty bomb to Mid September 2022",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
      status: "Draft",
      eips: [5133],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/mergeForkIdTransition.json
var require_mergeForkIdTransition = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/mergeForkIdTransition.json"(exports, module) {
    module.exports = {
      name: "mergeForkIdTransition",
      comment: "Pre-merge hardfork to fork off non-upgraded clients",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: "Draft",
      eips: []
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/merge.json
var require_merge = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/merge.json"(exports, module) {
    module.exports = {
      name: "merge",
      comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
      status: "Final",
      consensus: {
        type: "pos",
        algorithm: "casper",
        casper: {}
      },
      eips: [3675, 4399]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/sharding.json
var require_sharding = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/sharding.json"(exports, module) {
    module.exports = {
      name: "shardingFork",
      comment: "Internal hardfork to test proto-danksharding (do not use in production)",
      url: "https://eips.ethereum.org/EIPS/eip-4844",
      status: "Experimental",
      eips: [4844]
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/index.js
var require_hardforks = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/hardforks/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hardforks = void 0;
    exports.hardforks = {
      chainstart: require_chainstart(),
      homestead: require_homestead(),
      dao: require_dao(),
      tangerineWhistle: require_tangerineWhistle(),
      spuriousDragon: require_spuriousDragon(),
      byzantium: require_byzantium(),
      constantinople: require_constantinople(),
      petersburg: require_petersburg(),
      istanbul: require_istanbul(),
      muirGlacier: require_muirGlacier(),
      berlin: require_berlin(),
      london: require_london(),
      shanghai: require_shanghai(),
      arrowGlacier: require_arrowGlacier(),
      grayGlacier: require_grayGlacier(),
      mergeForkIdTransition: require_mergeForkIdTransition(),
      merge: require_merge(),
      shardingFork: require_sharding()
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/utils.js
var require_utils4 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGethGenesis = void 0;
    var util_1 = require_dist2();
    var enums_1 = require_enums();
    function formatNonce(nonce) {
      if (!nonce || nonce === "0x0") {
        return "0x0000000000000000";
      }
      if ((0, util_1.isHexPrefixed)(nonce)) {
        return "0x" + (0, util_1.stripHexPrefix)(nonce).padStart(16, "0");
      }
      return "0x" + nonce.padStart(16, "0");
    }
    function parseGethParams(json, mergeForkIdPostMerge = true) {
      const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas } = json;
      let { extraData, timestamp, nonce } = json;
      const genesisTimestamp = Number(timestamp);
      const { chainId } = config;
      if (extraData === "") {
        extraData = "0x";
      }
      if (!(0, util_1.isHexPrefixed)(timestamp)) {
        timestamp = (0, util_1.intToHex)(parseInt(timestamp));
      }
      if (nonce.length !== 18) {
        nonce = formatNonce(nonce);
      }
      if (config.eip155Block !== config.eip158Block) {
        throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
      }
      const params = {
        name,
        chainId,
        networkId: chainId,
        genesis: {
          timestamp,
          gasLimit: parseInt(gasLimit),
          difficulty: parseInt(difficulty),
          nonce,
          extraData,
          mixHash,
          coinbase,
          baseFeePerGas
        },
        hardfork: void 0,
        hardforks: [],
        bootstrapNodes: [],
        consensus: config.clique !== void 0 ? {
          type: "poa",
          algorithm: "clique",
          clique: {
            // The recent geth genesis seems to be using blockperiodseconds
            // and epochlength for clique specification
            // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ
            period: config.clique.period ?? config.clique.blockperiodseconds,
            epoch: config.clique.epoch ?? config.clique.epochlength
          }
        } : {
          type: "pow",
          algorithm: "ethash",
          ethash: {}
        }
      };
      const forkMap = {
        [enums_1.Hardfork.Homestead]: { name: "homesteadBlock" },
        [enums_1.Hardfork.Dao]: { name: "daoForkBlock" },
        [enums_1.Hardfork.TangerineWhistle]: { name: "eip150Block" },
        [enums_1.Hardfork.SpuriousDragon]: { name: "eip155Block" },
        [enums_1.Hardfork.Byzantium]: { name: "byzantiumBlock" },
        [enums_1.Hardfork.Constantinople]: { name: "constantinopleBlock" },
        [enums_1.Hardfork.Petersburg]: { name: "petersburgBlock" },
        [enums_1.Hardfork.Istanbul]: { name: "istanbulBlock" },
        [enums_1.Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
        [enums_1.Hardfork.Berlin]: { name: "berlinBlock" },
        [enums_1.Hardfork.London]: { name: "londonBlock" },
        [enums_1.Hardfork.MergeForkIdTransition]: { name: "mergeForkBlock", postMerge: mergeForkIdPostMerge },
        [enums_1.Hardfork.Shanghai]: { name: "shanghaiTime", postMerge: true, isTimestamp: true },
        [enums_1.Hardfork.ShardingForkDev]: { name: "shardingForkTime", postMerge: true, isTimestamp: true }
      };
      const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
        acc[forkMap[elem].name] = elem;
        return acc;
      }, {});
      const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== void 0 && config[key] !== void 0 && config[key] !== null);
      params.hardforks = configHardforkNames.map((nameBlock) => ({
        name: forkMapRev[nameBlock],
        block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== "number" ? null : config[nameBlock],
        timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === "number" ? config[nameBlock] : void 0
      })).filter((fork) => fork.block !== null || fork.timestamp !== void 0);
      params.hardforks.sort(function(a, b) {
        return (a.block ?? Infinity) - (b.block ?? Infinity);
      });
      params.hardforks.sort(function(a, b) {
        return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);
      });
      if (config.terminalTotalDifficulty !== void 0) {
        const mergeConfig = {
          name: enums_1.Hardfork.Merge,
          ttd: config.terminalTotalDifficulty,
          block: null
        };
        const postMergeIndex = params.hardforks.findIndex((hf) => {
          var _a;
          return ((_a = forkMap[hf.name]) == null ? void 0 : _a.postMerge) === true;
        });
        if (postMergeIndex !== -1) {
          params.hardforks.splice(postMergeIndex, 0, mergeConfig);
        } else {
          params.hardforks.push(mergeConfig);
        }
      }
      const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : void 0;
      params.hardfork = latestHardfork == null ? void 0 : latestHardfork.name;
      params.hardforks.unshift({ name: enums_1.Hardfork.Chainstart, block: 0 });
      return params;
    }
    function parseGethGenesis(json, name, mergeForkIdPostMerge) {
      try {
        if (["config", "difficulty", "gasLimit", "alloc"].some((field) => !(field in json))) {
          throw new Error("Invalid format, expected geth genesis fields missing");
        }
        if (name !== void 0) {
          json.name = name;
        }
        return parseGethParams(json, mergeForkIdPostMerge);
      } catch (e) {
        throw new Error(`Error parsing parameters file: ${e.message}`);
      }
    }
    exports.parseGethGenesis = parseGethGenesis;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/common.js
var require_common = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/common.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Common = void 0;
    var util_1 = require_dist2();
    var crc_32_1 = require_crc32();
    var events_1 = require_events();
    var goerli = require_goerli();
    var mainnet = require_mainnet();
    var rinkeby = require_rinkeby();
    var ropsten = require_ropsten();
    var sepolia = require_sepolia();
    var eips_1 = require_eips();
    var enums_1 = require_enums();
    var hardforks_1 = require_hardforks();
    var utils_1 = require_utils4();
    var Common2 = class extends events_1.EventEmitter {
      constructor(opts) {
        super();
        this._eips = [];
        this._customChains = opts.customChains ?? [];
        this._chainParams = this.setChain(opts.chain);
        this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;
        this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
          hf.name,
          hardforks_1.hardforks[hf.name]
        ]);
        this._hardfork = this.DEFAULT_HARDFORK;
        if (opts.hardfork !== void 0) {
          this.setHardfork(opts.hardfork);
        }
        if (opts.eips) {
          this.setEIPs(opts.eips);
        }
      }
      /**
       * Creates a {@link Common} object for a custom chain, based on a standard one.
       *
       * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden
       * in a provided {@link chainParamsOrName} dictionary. Some usage example:
       *
       * ```javascript
       * Common.custom({chainId: 123})
       * ```
       *
       * There are also selected supported custom chains which can be initialized by using one of the
       * {@link CustomChains} for {@link chainParamsOrName}, e.g.:
       *
       * ```javascript
       * Common.custom(CustomChains.MaticMumbai)
       * ```
       *
       * Note that these supported custom chains only provide some base parameters (usually the chain and
       * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with
       * the `@ethereumjs/tx` library to a Layer-2 chain).
       *
       * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain
       * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others
       */
      static custom(chainParamsOrName, opts = {}) {
        const baseChain = opts.baseChain ?? "mainnet";
        const standardChainParams = { ...Common2._getChainParams(baseChain) };
        standardChainParams["name"] = "custom-chain";
        if (typeof chainParamsOrName !== "string") {
          return new Common2({
            chain: {
              ...standardChainParams,
              ...chainParamsOrName
            },
            ...opts
          });
        } else {
          if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {
            return Common2.custom({
              name: enums_1.CustomChain.PolygonMainnet,
              chainId: 137,
              networkId: 137
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {
            return Common2.custom({
              name: enums_1.CustomChain.PolygonMumbai,
              chainId: 80001,
              networkId: 80001
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {
            return Common2.custom({
              name: enums_1.CustomChain.ArbitrumRinkebyTestnet,
              chainId: 421611,
              networkId: 421611
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {
            return Common2.custom({
              name: enums_1.CustomChain.ArbitrumOne,
              chainId: 42161,
              networkId: 42161
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {
            return Common2.custom({
              name: enums_1.CustomChain.xDaiChain,
              chainId: 100,
              networkId: 100
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {
            return Common2.custom(
              {
                name: enums_1.CustomChain.OptimisticKovan,
                chainId: 69,
                networkId: 69
              },
              // Optimism has not implemented the London hardfork yet (targeting Q1.22)
              { hardfork: enums_1.Hardfork.Berlin, ...opts }
            );
          }
          if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {
            return Common2.custom(
              {
                name: enums_1.CustomChain.OptimisticEthereum,
                chainId: 10,
                networkId: 10
              },
              // Optimism has not implemented the London hardfork yet (targeting Q1.22)
              { hardfork: enums_1.Hardfork.Berlin, ...opts }
            );
          }
          throw new Error(`Custom chain ${chainParamsOrName} not supported`);
        }
      }
      /**
       * Static method to load and set common from a geth genesis json
       * @param genesisJson json of geth configuration
       * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance
       * @returns Common
       */
      static fromGethGenesis(genesisJson, { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }) {
        const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);
        const common = new Common2({
          chain: genesisParams.name ?? "custom",
          customChains: [genesisParams],
          eips,
          hardfork: hardfork ?? genesisParams.hardfork
        });
        if (genesisHash !== void 0) {
          common.setForkHashes(genesisHash);
        }
        return common;
      }
      /**
       * Static method to determine if a {@link chainId} is supported as a standard chain
       * @param chainId bigint id (`1`) of a standard chain
       * @returns boolean
       */
      static isSupportedChainId(chainId) {
        const initializedChains = this._getInitializedChains();
        return Boolean(initializedChains["names"][chainId.toString()]);
      }
      static _getChainParams(chain, customChains) {
        const initializedChains = this._getInitializedChains(customChains);
        if (typeof chain === "number" || typeof chain === "bigint") {
          chain = chain.toString();
          if (initializedChains["names"][chain]) {
            const name = initializedChains["names"][chain];
            return initializedChains[name];
          }
          throw new Error(`Chain with ID ${chain} not supported`);
        }
        if (initializedChains[chain] !== void 0) {
          return initializedChains[chain];
        }
        throw new Error(`Chain with name ${chain} not supported`);
      }
      /**
       * Sets the chain
       * @param chain String ('mainnet') or Number (1) chain representation.
       *              Or, a Dictionary of chain parameters for a private network.
       * @returns The dictionary with parameters set as chain
       */
      setChain(chain) {
        if (typeof chain === "number" || typeof chain === "bigint" || typeof chain === "string") {
          this._chainParams = Common2._getChainParams(chain, this._customChains);
        } else if (typeof chain === "object") {
          if (this._customChains.length > 0) {
            throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
          }
          const required = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
          for (const param of required) {
            if (!(param in chain)) {
              throw new Error(`Missing required chain parameter: ${param}`);
            }
          }
          this._chainParams = chain;
        } else {
          throw new Error("Wrong input format");
        }
        for (const hf of this.hardforks()) {
          if (hf.block === void 0) {
            throw new Error(`Hardfork cannot have undefined block number`);
          }
        }
        return this._chainParams;
      }
      /**
       * Sets the hardfork to get params for
       * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum
       */
      setHardfork(hardfork) {
        let existing = false;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if (hfChanges[0] === hardfork) {
            if (this._hardfork !== hardfork) {
              this._hardfork = hardfork;
              this.emit("hardforkChanged", hardfork);
            }
            existing = true;
          }
        }
        if (!existing) {
          throw new Error(`Hardfork with name ${hardfork} not supported`);
        }
      }
      /**
       * Returns the hardfork based on the block number or an optional
       * total difficulty (Merge HF) provided.
       *
       * An optional TD takes precedence in case the corresponding HF block
       * is set to `null` or otherwise needs to match (if not an error
       * will be thrown).
       *
       * @param blockNumber
       * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)
       * @param timestamp: timestamp in seconds at which block was/is to be minted
       * @returns The name of the HF
       */
      getHardforkByBlockNumber(blockNumber, td, timestamp) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);
        timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number);
        const hfs = this.hardforks().filter((hf) => hf.block !== null || hf.ttd !== null && hf.ttd !== void 0 || hf.timestamp !== void 0);
        const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
        const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
        if (doubleTTDHF >= 0) {
          throw Error(`More than one merge hardforks found with ttd specified`);
        }
        let hfIndex = hfs.findIndex((hf) => hf.block !== null && hf.block > blockNumber || timestamp !== void 0 && Number(hf.timestamp) > timestamp);
        if (hfIndex === -1) {
          hfIndex = hfs.length;
        } else if (hfIndex === 0) {
          throw Error("Must have at least one hardfork at block 0");
        }
        if (timestamp === void 0) {
          const stepBack = hfs.slice(0, hfIndex).reverse().findIndex((hf) => hf.block !== null || hf.ttd !== void 0);
          hfIndex = hfIndex - stepBack;
        }
        hfIndex = hfIndex - 1;
        if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === void 0) {
          if (td === void 0 || td === null || BigInt(hfs[hfIndex].ttd) > td) {
            hfIndex -= 1;
          }
        } else {
          if (mergeIndex >= 0 && td !== void 0 && td !== null) {
            if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
              throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
            } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
              throw Error("HF determined by block number is lower than the minimum total difficulty HF");
            }
          }
        }
        const hfStartIndex = hfIndex;
        for (; hfIndex < hfs.length - 1; hfIndex++) {
          if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
            break;
          }
        }
        if (timestamp) {
          const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => Math.max(Number(hf.timestamp ?? "0"), acc), 0);
          if (minTimeStamp > timestamp) {
            throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
          }
          const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);
          if (maxTimeStamp < timestamp) {
            throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
          }
        }
        const hardfork = hfs[hfIndex];
        return hardfork.name;
      }
      /**
       * Sets a new hardfork based on the block number or an optional
       * total difficulty (Merge HF) provided.
       *
       * An optional TD takes precedence in case the corresponding HF block
       * is set to `null` or otherwise needs to match (if not an error
       * will be thrown).
       *
       * @param blockNumber
       * @param td
       * @param timestamp
       * @returns The name of the HF set
       */
      setHardforkByBlockNumber(blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        this.setHardfork(hardfork);
        return hardfork;
      }
      /**
       * Internal helper function, returns the params for the given hardfork for the chain set
       * @param hardfork Hardfork name
       * @returns Dictionary with hardfork params or null if hardfork not on chain
       */
      _getHardfork(hardfork) {
        const hfs = this.hardforks();
        for (const hf of hfs) {
          if (hf["name"] === hardfork)
            return hf;
        }
        return null;
      }
      /**
       * Sets the active EIPs
       * @param eips
       */
      setEIPs(eips = []) {
        for (const eip of eips) {
          if (!(eip in eips_1.EIPs)) {
            throw new Error(`${eip} not supported`);
          }
          const minHF = this.gteHardfork(eips_1.EIPs[eip]["minimumHardfork"]);
          if (!minHF) {
            throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
          }
          if (eips_1.EIPs[eip].requiredEIPs !== void 0) {
            for (const elem of eips_1.EIPs[eip].requiredEIPs) {
              if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
                throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
              }
            }
          }
        }
        this._eips = eips;
      }
      /**
       * Returns a parameter for the current chain setup
       *
       * If the parameter is present in an EIP, the EIP always takes precedence.
       * Otherwise the parameter if taken from the latest applied HF with
       * a change on the respective parameter.
       *
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @returns The value requested or `BigInt(0)` if not found
       */
      param(topic, name) {
        let value;
        for (const eip of this._eips) {
          value = this.paramByEIP(topic, name, eip);
          if (value !== void 0)
            return value;
        }
        return this.paramByHardfork(topic, name, this._hardfork);
      }
      /**
       * Returns the parameter corresponding to a hardfork
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @param hardfork Hardfork name
       * @returns The value requested or `BigInt(0)` if not found
       */
      paramByHardfork(topic, name, hardfork) {
        let value = null;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("eips" in hfChanges[1]) {
            const hfEIPs = hfChanges[1]["eips"];
            for (const eip of hfEIPs) {
              const valueEIP = this.paramByEIP(topic, name, eip);
              value = typeof valueEIP === "bigint" ? valueEIP : value;
            }
          } else {
            if (hfChanges[1][topic] === void 0) {
              throw new Error(`Topic ${topic} not defined`);
            }
            if (hfChanges[1][topic][name] !== void 0) {
              value = hfChanges[1][topic][name].v;
            }
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return BigInt(value ?? 0);
      }
      /**
       * Returns a parameter corresponding to an EIP
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @param eip Number of the EIP
       * @returns The value requested or `undefined` if not found
       */
      paramByEIP(topic, name, eip) {
        if (!(eip in eips_1.EIPs)) {
          throw new Error(`${eip} not supported`);
        }
        const eipParams = eips_1.EIPs[eip];
        if (!(topic in eipParams)) {
          throw new Error(`Topic ${topic} not defined`);
        }
        if (eipParams[topic][name] === void 0) {
          return void 0;
        }
        const value = eipParams[topic][name].v;
        return BigInt(value);
      }
      /**
       * Returns a parameter for the hardfork active on block number or
       * optional provided total difficulty (Merge HF)
       * @param topic Parameter topic
       * @param name Parameter name
       * @param blockNumber Block number
       * @param td Total difficulty
       *    * @returns The value requested or `BigInt(0)` if not found
       */
      paramByBlock(topic, name, blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        return this.paramByHardfork(topic, name, hardfork);
      }
      /**
       * Checks if an EIP is activated by either being included in the EIPs
       * manually passed in with the {@link CommonOpts.eips} or in a
       * hardfork currently being active
       *
       * Note: this method only works for EIPs being supported
       * by the {@link CommonOpts.eips} constructor option
       * @param eip
       */
      isActivatedEIP(eip) {
        if (this.eips().includes(eip)) {
          return true;
        }
        for (const hfChanges of this.HARDFORK_CHANGES) {
          const hf = hfChanges[1];
          if (this.gteHardfork(hf["name"]) && "eips" in hf) {
            if (hf["eips"].includes(eip)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks if set or provided hardfork is active on block number
       * @param hardfork Hardfork name or null (for HF set)
       * @param blockNumber
       * @returns True if HF is active on block number
       */
      hardforkIsActiveOnBlock(hardfork, blockNumber) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const hfBlock = this.hardforkBlock(hardfork);
        if (typeof hfBlock === "bigint" && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
          return true;
        }
        return false;
      }
      /**
       * Alias to hardforkIsActiveOnBlock when hardfork is set
       * @param blockNumber
       * @returns True if HF is active on block number
       */
      activeOnBlock(blockNumber) {
        return this.hardforkIsActiveOnBlock(null, blockNumber);
      }
      /**
       * Sequence based check if given or set HF1 is greater than or equal HF2
       * @param hardfork1 Hardfork name or null (if set)
       * @param hardfork2 Hardfork name
       * @param opts Hardfork options
       * @returns True if HF1 gte HF2
       */
      hardforkGteHardfork(hardfork1, hardfork2) {
        hardfork1 = hardfork1 ?? this._hardfork;
        const hardforks = this.hardforks();
        let posHf1 = -1, posHf2 = -1;
        let index = 0;
        for (const hf of hardforks) {
          if (hf["name"] === hardfork1)
            posHf1 = index;
          if (hf["name"] === hardfork2)
            posHf2 = index;
          index += 1;
        }
        return posHf1 >= posHf2 && posHf2 !== -1;
      }
      /**
       * Alias to hardforkGteHardfork when hardfork is set
       * @param hardfork Hardfork name
       * @returns True if hardfork set is greater than hardfork provided
       */
      gteHardfork(hardfork) {
        return this.hardforkGteHardfork(null, hardfork);
      }
      /**
       * Returns the hardfork change block for hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block number or null if unscheduled
       */
      hardforkBlock(hardfork) {
        var _a;
        hardfork = hardfork ?? this._hardfork;
        const block = (_a = this._getHardfork(hardfork)) == null ? void 0 : _a["block"];
        if (block === void 0 || block === null) {
          return null;
        }
        return BigInt(block);
      }
      hardforkTimestamp(hardfork) {
        var _a;
        hardfork = hardfork ?? this._hardfork;
        const timestamp = (_a = this._getHardfork(hardfork)) == null ? void 0 : _a["timestamp"];
        if (timestamp === void 0 || timestamp === null) {
          return null;
        }
        return BigInt(timestamp);
      }
      /**
       * Returns the hardfork change block for eip
       * @param eip EIP number
       * @returns Block number or null if unscheduled
       */
      eipBlock(eip) {
        for (const hfChanges of this.HARDFORK_CHANGES) {
          const hf = hfChanges[1];
          if ("eips" in hf) {
            if (hf["eips"].includes(eip)) {
              return this.hardforkBlock(hfChanges[0]);
            }
          }
        }
        return null;
      }
      /**
       * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Total difficulty or null if no set
       */
      hardforkTTD(hardfork) {
        var _a;
        hardfork = hardfork ?? this._hardfork;
        const ttd = (_a = this._getHardfork(hardfork)) == null ? void 0 : _a["ttd"];
        if (ttd === void 0 || ttd === null) {
          return null;
        }
        return BigInt(ttd);
      }
      /**
       * True if block number provided is the hardfork (given or set) change block
       * @param blockNumber Number of the block to check
       * @param hardfork Hardfork name, optional if HF set
       * @returns True if blockNumber is HF block
       * @deprecated
       */
      isHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const block = this.hardforkBlock(hardfork);
        return typeof block === "bigint" && block !== BigInt(0) ? block === blockNumber : false;
      }
      /**
       * Returns the change block for the next hardfork after the hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block timestamp, number or null if not available
       */
      nextHardforkBlockOrTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const hfs = this.hardforks();
        let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
        if (hardfork === enums_1.Hardfork.Merge) {
          hfIndex -= 1;
        }
        if (hfIndex < 0) {
          return null;
        }
        let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;
        currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== void 0 ? Number(currHfTimeOrBlock) : null;
        const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
          let hfTimeOrBlock = hf.timestamp ?? hf.block;
          hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 ? Number(hfTimeOrBlock) : null;
          return hf.name !== enums_1.Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 && hfTimeOrBlock !== currHfTimeOrBlock;
        });
        if (nextHf === void 0) {
          return null;
        }
        const nextHfBlock = nextHf.timestamp ?? nextHf.block;
        if (nextHfBlock === null || nextHfBlock === void 0) {
          return null;
        }
        return BigInt(nextHfBlock);
      }
      /**
       * Returns the change block for the next hardfork after the hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block number or null if not available
       * @deprecated
       */
      nextHardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        let hfBlock = this.hardforkBlock(hardfork);
        if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {
          const hfs = this.hardforks();
          const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
          if (mergeIndex < 0) {
            throw Error(`Merge hardfork should have been found`);
          }
          hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
        }
        if (hfBlock === null) {
          return null;
        }
        const nextHfBlock = this.hardforks().reduce((acc, hf) => {
          const block = BigInt(hf.block === null || hf.ttd !== void 0 && hf.ttd !== null ? 0 : hf.block);
          return block > hfBlock && acc === null ? block : acc;
        }, null);
        return nextHfBlock;
      }
      /**
       * True if block number provided is the hardfork change block following the hardfork given or set
       * @param blockNumber Number of the block to check
       * @param hardfork Hardfork name, optional if HF set
       * @returns True if blockNumber is HF block
       * @deprecated
       */
      isNextHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const nextHardforkBlock = this.nextHardforkBlock(hardfork);
        return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
      }
      /**
       * Internal helper function to calculate a fork hash
       * @param hardfork Hardfork name
       * @param genesisHash Genesis block hash of the chain
       * @returns Fork hash as hex string
       */
      _calcForkHash(hardfork, genesisHash) {
        let hfBuffer = Buffer.alloc(0);
        let prevBlockOrTime = 0;
        for (const hf of this.hardforks()) {
          const { block, timestamp, name } = hf;
          let blockOrTime = timestamp ?? block;
          blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
          if (typeof blockOrTime === "number" && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== enums_1.Hardfork.Merge) {
            const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, "0"), "hex");
            hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);
            prevBlockOrTime = blockOrTime;
          }
          if (hf.name === hardfork)
            break;
        }
        const inputBuffer = Buffer.concat([genesisHash, hfBuffer]);
        const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString("hex");
        return `0x${forkhash}`;
      }
      /**
       * Returns an eth/64 compliant fork hash (EIP-2124)
       * @param hardfork Hardfork name, optional if HF set
       * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated
       */
      forkHash(hardfork, genesisHash) {
        hardfork = hardfork ?? this._hardfork;
        const data = this._getHardfork(hardfork);
        if (data === null || (data == null ? void 0 : data.block) === null && (data == null ? void 0 : data.timestamp) === void 0 && (data == null ? void 0 : data.ttd) === void 0) {
          const msg = "No fork hash calculation possible for future hardfork";
          throw new Error(msg);
        }
        if ((data == null ? void 0 : data.forkHash) !== null && (data == null ? void 0 : data.forkHash) !== void 0) {
          return data.forkHash;
        }
        if (!genesisHash)
          throw new Error("genesisHash required for forkHash calculation");
        return this._calcForkHash(hardfork, genesisHash);
      }
      /**
       *
       * @param forkHash Fork hash as a hex string
       * @returns Array with hardfork data (name, block, forkHash)
       */
      hardforkForForkHash(forkHash) {
        const resArray = this.hardforks().filter((hf) => {
          return hf.forkHash === forkHash;
        });
        return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
      }
      /**
       * Sets any missing forkHashes on the passed-in {@link Common} instance
       * @param common The {@link Common} to set the forkHashes for
       * @param genesisHash The genesis block hash
       */
      setForkHashes(genesisHash) {
        for (const hf of this.hardforks()) {
          const blockOrTime = hf.timestamp ?? hf.block;
          if ((hf.forkHash === null || hf.forkHash === void 0) && (blockOrTime !== null && blockOrTime !== void 0 || typeof hf.ttd !== "undefined")) {
            hf.forkHash = this.forkHash(hf.name, genesisHash);
          }
        }
      }
      /**
       * Returns the Genesis parameters of the current chain
       * @returns Genesis dictionary
       */
      genesis() {
        return this._chainParams.genesis;
      }
      /**
       * Returns the hardforks for current chain
       * @returns {Array} Array with arrays of hardforks
       */
      hardforks() {
        return this._chainParams.hardforks;
      }
      /**
       * Returns bootstrap nodes for the current chain
       * @returns {Dictionary} Dict with bootstrap nodes
       */
      bootstrapNodes() {
        return this._chainParams.bootstrapNodes;
      }
      /**
       * Returns DNS networks for the current chain
       * @returns {String[]} Array of DNS ENR urls
       */
      dnsNetworks() {
        return this._chainParams.dnsNetworks;
      }
      /**
       * Returns the hardfork set
       * @returns Hardfork name
       */
      hardfork() {
        return this._hardfork;
      }
      /**
       * Returns the Id of current chain
       * @returns chain Id
       */
      chainId() {
        return BigInt(this._chainParams.chainId);
      }
      /**
       * Returns the name of current chain
       * @returns chain name (lower case)
       */
      chainName() {
        return this._chainParams.name;
      }
      /**
       * Returns the Id of current network
       * @returns network Id
       */
      networkId() {
        return BigInt(this._chainParams.networkId);
      }
      /**
       * Returns the active EIPs
       * @returns List of EIPs
       */
      eips() {
        return this._eips;
      }
      /**
       * Returns the consensus type of the network
       * Possible values: "pow"|"poa"|"pos"
       *
       * Note: This value can update along a Hardfork.
       */
      consensusType() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"]["type"];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"]["type"];
      }
      /**
       * Returns the concrete consensus implementation
       * algorithm or protocol for the network
       * e.g. "ethash" for "pow" consensus type,
       * "clique" for "poa" consensus type or
       * "casper" for "pos" consensus type.
       *
       * Note: This value can update along a Hardfork.
       */
      consensusAlgorithm() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"]["algorithm"];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"]["algorithm"];
      }
      /**
       * Returns a dictionary with consensus configuration
       * parameters based on the consensus algorithm
       *
       * Expected returns (parameters must be present in
       * the respective chain json files):
       *
       * ethash: empty object
       * clique: period, epoch
       * casper: empty object
       *
       * Note: This value can update along a Hardfork.
       */
      consensusConfig() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"][hfChanges[1]["consensus"]["algorithm"]];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"][this.consensusAlgorithm()] ?? {};
      }
      /**
       * Returns a deep copy of this {@link Common} instance.
       */
      copy() {
        const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        copy.removeAllListeners();
        return copy;
      }
      static _getInitializedChains(customChains) {
        const names = {};
        for (const [name, id] of Object.entries(enums_1.Chain)) {
          names[id] = name.toLowerCase();
        }
        const chains = { mainnet, ropsten, rinkeby, goerli, sepolia };
        if (customChains) {
          for (const chain of customChains) {
            const { name } = chain;
            names[chain.chainId.toString()] = name;
            chains[name] = chain;
          }
        }
        chains.names = names;
        return chains;
      }
    };
    exports.Common = Common2;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/types.js
var require_types = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/common/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_common(), exports);
    __exportStar(require_enums(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_utils4(), exports);
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/gindex.js
var require_gindex = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/gindex.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;
    function bitIndexBigInt(v) {
      return v.toString(2).length - 1;
    }
    exports.bitIndexBigInt = bitIndexBigInt;
    function toGindex(depth, index) {
      const anchor = BigInt(1) << BigInt(depth);
      if (index >= anchor) {
        throw new Error(`index ${index} too large for depth ${depth}`);
      }
      return anchor | index;
    }
    exports.toGindex = toGindex;
    function toGindexBitstring(depth, index) {
      const str = index ? Number(index).toString(2) : "";
      if (str.length > depth) {
        throw new Error("index too large for depth");
      } else {
        return "1" + str.padStart(depth, "0");
      }
    }
    exports.toGindexBitstring = toGindexBitstring;
    function convertGindexToBitstring(gindex) {
      if (typeof gindex === "string") {
        if (gindex.length === 0) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        return gindex;
      } else {
        if (gindex < 1) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        return gindex.toString(2);
      }
    }
    exports.convertGindexToBitstring = convertGindexToBitstring;
    function countToDepth(count) {
      if (count <= 1) {
        return 0;
      }
      return (count - BigInt(1)).toString(2).length;
    }
    exports.countToDepth = countToDepth;
    function iterateAtDepth(depth, startIndex, count) {
      const anchor = BigInt(1) << BigInt(depth);
      if (startIndex + count > anchor) {
        throw new Error("Too large for depth");
      }
      let i = toGindex(depth, startIndex);
      const last = i + count;
      return {
        [Symbol.iterator]() {
          return {
            next() {
              if (i < last) {
                const value = i;
                i++;
                return { done: false, value };
              } else {
                return { done: true, value: void 0 };
              }
            }
          };
        }
      };
    }
    exports.iterateAtDepth = iterateAtDepth;
    function getGindicesAtDepth(depth, startIndex, count) {
      const anchor = BigInt(1) << BigInt(depth);
      if (startIndex + count > anchor) {
        throw new Error("Too large for depth");
      }
      let gindex = toGindex(depth, BigInt(startIndex));
      const gindices = [];
      for (let i = 0; i < count; i++) {
        gindices.push(gindex++);
      }
      return gindices;
    }
    exports.getGindicesAtDepth = getGindicesAtDepth;
    var ERR_INVALID_GINDEX = "Invalid gindex";
    function gindexIterator(gindex) {
      let bitstring;
      if (typeof gindex === "string") {
        if (!gindex.length) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex;
      } else {
        if (gindex < 1) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex.toString(2);
      }
      let i = 1;
      const next = () => {
        if (i === bitstring.length) {
          return { done: true, value: void 0 };
        }
        const bit = Number(bitstring[i]);
        i++;
        return { done: false, value: bit };
      };
      return {
        [Symbol.iterator]() {
          return { next };
        },
        remainingBitLength() {
          return bitstring.length - i;
        }
      };
    }
    exports.gindexIterator = gindexIterator;
    function getGindexBits(gindex) {
      let bitstring;
      if (typeof gindex === "string") {
        if (!gindex.length) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex;
      } else {
        if (gindex < 1) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex.toString(2);
      }
      const bits = [];
      for (let i = 1; i < bitstring.length; i++) {
        bits.push(Number(bitstring[i]));
      }
      return bits;
    }
    exports.getGindexBits = getGindexBits;
    function concatGindices(gindices) {
      return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), "0b1"));
    }
    exports.concatGindices = concatGindices;
    function gindexSibling(gindex) {
      return gindex ^ BigInt(1);
    }
    exports.gindexSibling = gindexSibling;
    function gindexParent(gindex) {
      return gindex / BigInt(2);
    }
    exports.gindexParent = gindexParent;
    function gindexChild(gindex, rightChild) {
      return gindex * BigInt(2) + BigInt(rightChild);
    }
    exports.gindexChild = gindexChild;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils2();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils2();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/as-sha256/lib/hashObject.js
var require_hashObject = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/as-sha256/lib/hashObject.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.byteArrayToHashObject = exports.hashObjectToByteArray = void 0;
    function hashObjectToByteArray(obj, byteArr, offset) {
      let tmp = obj.h0;
      byteArr[0 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[1 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[2 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[3 + offset] = tmp & 255;
      tmp = obj.h1;
      byteArr[4 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[5 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[6 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[7 + offset] = tmp & 255;
      tmp = obj.h2;
      byteArr[8 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[9 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[10 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[11 + offset] = tmp & 255;
      tmp = obj.h3;
      byteArr[12 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[13 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[14 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[15 + offset] = tmp & 255;
      tmp = obj.h4;
      byteArr[16 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[17 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[18 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[19 + offset] = tmp & 255;
      tmp = obj.h5;
      byteArr[20 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[21 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[22 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[23 + offset] = tmp & 255;
      tmp = obj.h6;
      byteArr[24 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[25 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[26 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[27 + offset] = tmp & 255;
      tmp = obj.h7;
      byteArr[28 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[29 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[30 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[31 + offset] = tmp & 255;
    }
    exports.hashObjectToByteArray = hashObjectToByteArray;
    function byteArrayToHashObject(byteArr) {
      let tmp = 0;
      tmp |= byteArr[3] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[2] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[1] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[0] & 255;
      const h0 = tmp;
      tmp = 0;
      tmp |= byteArr[7] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[6] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[5] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[4] & 255;
      const h1 = tmp;
      tmp = 0;
      tmp |= byteArr[11] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[10] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[9] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[8] & 255;
      const h2 = tmp;
      tmp = 0;
      tmp |= byteArr[15] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[14] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[13] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[12] & 255;
      const h3 = tmp;
      tmp = 0;
      tmp |= byteArr[19] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[18] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[17] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[16] & 255;
      const h4 = tmp;
      tmp = 0;
      tmp |= byteArr[23] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[22] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[21] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[20] & 255;
      const h5 = tmp;
      tmp = 0;
      tmp |= byteArr[27] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[26] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[25] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[24] & 255;
      const h6 = tmp;
      tmp = 0;
      tmp |= byteArr[31] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[30] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[29] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[28] & 255;
      const h7 = tmp;
      return {
        h0,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        h7
      };
    }
    exports.byteArrayToHashObject = byteArrayToHashObject;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/util.js
var require_util = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint8ArrayToHashObject = exports.hashObjectToUint8Array = void 0;
    var hashObject_1 = require_hashObject();
    function hashObjectToUint8Array(obj) {
      const byteArr = new Uint8Array(32);
      hashObject_1.hashObjectToByteArray(obj, byteArr, 0);
      return byteArr;
    }
    exports.hashObjectToUint8Array = hashObjectToUint8Array;
    function uint8ArrayToHashObject(byteArr) {
      return hashObject_1.byteArrayToHashObject(byteArr);
    }
    exports.uint8ArrayToHashObject = uint8ArrayToHashObject;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/noble.js
var require_noble = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/noble.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasher = void 0;
    var sha256_1 = require_sha256();
    var util_1 = require_util();
    var digest64 = (a, b) => sha256_1.sha256.create().update(a).update(b).digest();
    exports.hasher = {
      digest64,
      digest64HashObjects: (a, b) => util_1.uint8ArrayToHashObject(digest64(util_1.hashObjectToUint8Array(a), util_1.hashObjectToUint8Array(b)))
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/types.js
var require_types2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/index.js
var require_hasher = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setHasher = exports.hasher = void 0;
    var noble_1 = require_noble();
    __exportStar(require_types2(), exports);
    __exportStar(require_util(), exports);
    exports.hasher = noble_1.hasher;
    function setHasher(newHasher) {
      exports.hasher = newHasher;
    }
    exports.setHasher = setHasher;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/node.js
var require_node = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/node.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;
    var hasher_1 = require_hasher();
    var TWO_POWER_32 = 2 ** 32;
    var Node = class {
      constructor(h0, h1, h2, h3, h4, h5, h6, h7) {
        this.h0 = h0;
        this.h1 = h1;
        this.h2 = h2;
        this.h3 = h3;
        this.h4 = h4;
        this.h5 = h5;
        this.h6 = h6;
        this.h7 = h7;
      }
      applyHash(root) {
        this.h0 = root.h0;
        this.h1 = root.h1;
        this.h2 = root.h2;
        this.h3 = root.h3;
        this.h4 = root.h4;
        this.h5 = root.h5;
        this.h6 = root.h6;
        this.h7 = root.h7;
      }
    };
    exports.Node = Node;
    var BranchNode = class extends Node {
      constructor(_left, _right) {
        super(null, 0, 0, 0, 0, 0, 0, 0);
        this._left = _left;
        this._right = _right;
        if (!_left) {
          throw new Error("Left node is undefined");
        }
        if (!_right) {
          throw new Error("Right node is undefined");
        }
      }
      get rootHashObject() {
        if (this.h0 === null) {
          super.applyHash(hasher_1.hasher.digest64HashObjects(this.left.rootHashObject, this.right.rootHashObject));
        }
        return this;
      }
      get root() {
        return hasher_1.hashObjectToUint8Array(this.rootHashObject);
      }
      isLeaf() {
        return false;
      }
      get left() {
        return this._left;
      }
      get right() {
        return this._right;
      }
    };
    exports.BranchNode = BranchNode;
    var LeafNode = class extends Node {
      static fromRoot(root) {
        return this.fromHashObject(hasher_1.uint8ArrayToHashObject(root));
      }
      /**
       * New LeafNode from existing HashObject.
       */
      static fromHashObject(ho) {
        return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);
      }
      /**
       * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.
       */
      static fromZero() {
        return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
       * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.
       */
      static fromUint32(uint32) {
        return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
       * Create a new LeafNode with the same internal values. The returned instance is safe to mutate
       */
      clone() {
        return LeafNode.fromHashObject(this);
      }
      get rootHashObject() {
        return this;
      }
      get root() {
        return hasher_1.hashObjectToUint8Array(this);
      }
      isLeaf() {
        return true;
      }
      get left() {
        throw Error("LeafNode has no left node");
      }
      get right() {
        throw Error("LeafNode has no right node");
      }
      writeToBytes(data, start, size) {
        data.set(this.root.slice(0, size), start);
      }
      getUint(uintBytes, offsetBytes, clipInfinity) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          const h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            return 255 & h >> bitIndex;
          } else {
            return 65535 & h >> bitIndex;
          }
        } else if (uintBytes === 4) {
          return getNodeH(this, hIndex) >>> 0;
        } else if (uintBytes === 8) {
          const low = getNodeH(this, hIndex);
          const high = getNodeH(this, hIndex + 1);
          if (high === 0) {
            return low >>> 0;
          } else if (high === -1 && low === -1 && clipInfinity) {
            return Infinity;
          } else {
            return (low >>> 0) + (high >>> 0) * TWO_POWER_32;
          }
        } else {
          throw Error("uintBytes > 8");
        }
      }
      getUintBigint(uintBytes, offsetBytes) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          const h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            return BigInt(255 & h >> bitIndex);
          } else {
            return BigInt(65535 & h >> bitIndex);
          }
        } else if (uintBytes === 4) {
          return BigInt(getNodeH(this, hIndex) >>> 0);
        } else {
          const hRange = Math.ceil(uintBytes / 4);
          let v = BigInt(0);
          for (let i = 0; i < hRange; i++) {
            v += BigInt(getNodeH(this, hIndex + i) >>> 0) << BigInt(32 * i);
          }
          return v;
        }
      }
      setUint(uintBytes, offsetBytes, value, clipInfinity) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          let h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            h &= ~(255 << bitIndex);
            h |= value << bitIndex;
          } else {
            h &= ~(65535 << bitIndex);
            h |= value << bitIndex;
          }
          setNodeH(this, hIndex, h);
        } else if (uintBytes === 4) {
          setNodeH(this, hIndex, value);
        } else if (uintBytes === 8) {
          if (value === Infinity && clipInfinity) {
            setNodeH(this, hIndex, -1);
            setNodeH(this, hIndex + 1, -1);
          } else {
            setNodeH(this, hIndex, value & 4294967295);
            setNodeH(this, hIndex + 1, value / TWO_POWER_32 & 4294967295);
          }
        } else {
          throw Error("uintBytes > 8");
        }
      }
      setUintBigint(uintBytes, offsetBytes, valueBN) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const value = Number(valueBN);
          const bitIndex = offsetBytes % 4 * 8;
          let h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            h &= ~(255 << bitIndex);
            h |= value << bitIndex;
          } else {
            h &= ~(65535 << bitIndex);
            h |= value << bitIndex;
          }
          setNodeH(this, hIndex, h);
        } else if (uintBytes === 4) {
          setNodeH(this, hIndex, Number(valueBN));
        } else {
          const hEnd = hIndex + Math.ceil(uintBytes / 4);
          for (let i = hIndex; i < hEnd; i++) {
            setNodeH(this, i, Number(valueBN & BigInt(4294967295)));
            valueBN = valueBN >> BigInt(32);
          }
        }
      }
      bitwiseOrUint(uintBytes, offsetBytes, value) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          bitwiseOrNodeH(this, hIndex, value << bitIndex);
        } else if (uintBytes === 4) {
          bitwiseOrNodeH(this, hIndex, value);
        } else {
          const hEnd = hIndex + Math.ceil(uintBytes / 4);
          for (let i = hIndex; i < hEnd; i++) {
            bitwiseOrNodeH(this, i, value & 4294967295);
            value >>= 32;
          }
        }
      }
    };
    exports.LeafNode = LeafNode;
    function identity(n) {
      return n;
    }
    exports.identity = identity;
    function compose(inner, outer) {
      return function(n) {
        return outer(inner(n));
      };
    }
    exports.compose = compose;
    function getNodeH(node, hIndex) {
      if (hIndex === 0)
        return node.h0;
      else if (hIndex === 1)
        return node.h1;
      else if (hIndex === 2)
        return node.h2;
      else if (hIndex === 3)
        return node.h3;
      else if (hIndex === 4)
        return node.h4;
      else if (hIndex === 5)
        return node.h5;
      else if (hIndex === 6)
        return node.h6;
      else if (hIndex === 7)
        return node.h7;
      else
        throw Error("hIndex > 7");
    }
    exports.getNodeH = getNodeH;
    function setNodeH(node, hIndex, value) {
      if (hIndex === 0)
        node.h0 = value;
      else if (hIndex === 1)
        node.h1 = value;
      else if (hIndex === 2)
        node.h2 = value;
      else if (hIndex === 3)
        node.h3 = value;
      else if (hIndex === 4)
        node.h4 = value;
      else if (hIndex === 5)
        node.h5 = value;
      else if (hIndex === 6)
        node.h6 = value;
      else if (hIndex === 7)
        node.h7 = value;
      else
        throw Error("hIndex > 7");
    }
    exports.setNodeH = setNodeH;
    function bitwiseOrNodeH(node, hIndex, value) {
      if (hIndex === 0)
        node.h0 |= value;
      else if (hIndex === 1)
        node.h1 |= value;
      else if (hIndex === 2)
        node.h2 |= value;
      else if (hIndex === 3)
        node.h3 |= value;
      else if (hIndex === 4)
        node.h4 |= value;
      else if (hIndex === 5)
        node.h5 |= value;
      else if (hIndex === 6)
        node.h6 |= value;
      else if (hIndex === 7)
        node.h7 |= value;
      else
        throw Error("hIndex > 7");
    }
    exports.bitwiseOrNodeH = bitwiseOrNodeH;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/zeroNode.js
var require_zeroNode = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/zeroNode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroNode = void 0;
    var node_1 = require_node();
    var zeroes = [node_1.LeafNode.fromZero()];
    function zeroNode(height) {
      if (height >= zeroes.length) {
        for (let i = zeroes.length; i <= height; i++) {
          zeroes[i] = new node_1.BranchNode(zeroes[i - 1], zeroes[i - 1]);
        }
      }
      return zeroes[height];
    }
    exports.zeroNode = zeroNode;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/subtree.js
var require_subtree = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/subtree.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;
    var node_1 = require_node();
    var zeroNode_1 = require_zeroNode();
    function subtreeFillToDepth(bottom, depth) {
      let node = bottom;
      while (depth > 0) {
        node = new node_1.BranchNode(node, node);
        depth--;
      }
      return node;
    }
    exports.subtreeFillToDepth = subtreeFillToDepth;
    function subtreeFillToLength(bottom, depth, length) {
      const maxLength = 1 << depth;
      if (length > maxLength)
        throw new Error("ERR_TOO_MANY_NODES");
      if (length === maxLength)
        return subtreeFillToDepth(bottom, depth);
      if (depth === 0) {
        if (length === 1)
          return bottom;
        else
          throw new Error("ERR_NAVIGATION");
      }
      if (depth === 1) {
        return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));
      }
      const pivot = maxLength >> 1;
      if (length <= pivot) {
        return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));
      } else {
        return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));
      }
    }
    exports.subtreeFillToLength = subtreeFillToLength;
    function subtreeFillToContents(nodes, depth) {
      const maxLength = 2 ** depth;
      if (nodes.length > maxLength) {
        throw new Error(`nodes.length ${nodes.length} over maxIndex at depth ${depth}`);
      }
      if (nodes.length === 0) {
        return zeroNode_1.zeroNode(depth);
      }
      if (depth === 0) {
        return nodes[0];
      }
      if (depth === 1) {
        return nodes.length > 1 ? (
          // All nodes at depth 1 available
          new node_1.BranchNode(nodes[0], nodes[1])
        ) : (
          // Pad with zero node
          new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0))
        );
      }
      let count = nodes.length;
      for (let d = depth; d > 0; d--) {
        const countRemainder = count % 2;
        const countEven = count - countRemainder;
        for (let i = 0; i < countEven; i += 2) {
          nodes[i / 2] = new node_1.BranchNode(nodes[i], nodes[i + 1]);
        }
        if (countRemainder > 0) {
          nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));
        }
        count = countEven / 2 + countRemainder;
      }
      return nodes[0];
    }
    exports.subtreeFillToContents = subtreeFillToContents;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/packedNode.js
var require_packedNode = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/packedNode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;
    var subtree_1 = require_subtree();
    var node_1 = require_node();
    function packedRootsBytesToNode(depth, dataView, start, end) {
      const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);
      return subtree_1.subtreeFillToContents(leafNodes, depth);
    }
    exports.packedRootsBytesToNode = packedRootsBytesToNode;
    function packedRootsBytesToLeafNodes(dataView, start, end) {
      const size = end - start;
      const fullNodeCount = Math.floor(size / 32);
      const leafNodes = new Array(Math.ceil(size / 32));
      for (let i = 0; i < fullNodeCount; i++) {
        const offset = start + i * 32;
        leafNodes[i] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));
      }
      const remainderBytes = size % 32;
      if (remainderBytes > 0) {
        const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);
        leafNodes[fullNodeCount] = node;
        const fullHCount = Math.floor(remainderBytes / 4);
        for (let h = 0; h < fullHCount; h++) {
          node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));
        }
        const remainderUint32 = size % 4;
        if (remainderUint32 > 0) {
          let h = 0;
          for (let i = 0; i < remainderUint32; i++) {
            h |= dataView.getUint8(start + size - remainderUint32 + i) << i * 8;
          }
          node_1.setNodeH(node, fullHCount, h);
        }
      }
      return leafNodes;
    }
    exports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;
    function packedNodeRootsToBytes(dataView, start, size, nodes) {
      const remainderBytes = size % 32;
      const fullNodeCount = Math.floor(size / 32);
      for (let i = 0; i < fullNodeCount; i++) {
        const node = nodes[i];
        const offset = start + i * 32;
        dataView.setInt32(offset + 0, node.h0, true);
        dataView.setInt32(offset + 4, node.h1, true);
        dataView.setInt32(offset + 8, node.h2, true);
        dataView.setInt32(offset + 12, node.h3, true);
        dataView.setInt32(offset + 16, node.h4, true);
        dataView.setInt32(offset + 20, node.h5, true);
        dataView.setInt32(offset + 24, node.h6, true);
        dataView.setInt32(offset + 28, node.h7, true);
      }
      if (remainderBytes > 0) {
        const node = nodes[fullNodeCount];
        const fullHCount = Math.floor(remainderBytes / 4);
        for (let h = 0; h < fullHCount; h++) {
          dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);
        }
        const remainderUint32 = size % 4;
        if (remainderUint32 > 0) {
          const h = node_1.getNodeH(node, fullHCount);
          for (let i = 0; i < remainderUint32; i++) {
            dataView.setUint8(start + size - remainderUint32 + i, h >> i * 8 & 255);
          }
        }
      }
    }
    exports.packedNodeRootsToBytes = packedNodeRootsToBytes;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/single.js
var require_single = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/single.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;
    var node_1 = require_node();
    var gindex_1 = require_gindex();
    exports.ERR_INVALID_NAV = "Invalid tree navigation";
    function createSingleProof(rootNode, index) {
      const witnesses = [];
      let node = rootNode;
      for (const i of gindex_1.gindexIterator(index)) {
        if (i) {
          if (node.isLeaf())
            throw new Error(exports.ERR_INVALID_NAV);
          witnesses.push(node.left.root);
          node = node.right;
        } else {
          if (node.isLeaf())
            throw new Error(exports.ERR_INVALID_NAV);
          witnesses.push(node.right.root);
          node = node.left;
        }
      }
      return [node.root, witnesses.reverse()];
    }
    exports.createSingleProof = createSingleProof;
    function createNodeFromSingleProof(gindex, leaf, witnesses) {
      let node = node_1.LeafNode.fromRoot(leaf);
      const w = witnesses.slice().reverse();
      while (gindex > 1) {
        const sibling = node_1.LeafNode.fromRoot(w.pop());
        if (gindex % BigInt(2) === BigInt(0)) {
          node = new node_1.BranchNode(node, sibling);
        } else {
          node = new node_1.BranchNode(sibling, node);
        }
        gindex = gindex / BigInt(2);
      }
      return node;
    }
    exports.createNodeFromSingleProof = createNodeFromSingleProof;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/tree.js
var require_tree = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/tree.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;
    var zeroNode_1 = require_zeroNode();
    var gindex_1 = require_gindex();
    var node_1 = require_node();
    var proof_1 = require_proof();
    var single_1 = require_single();
    var Tree = class {
      constructor(node, hook) {
        this._rootNode = node;
        if (hook) {
          if (typeof WeakRef === "undefined") {
            this.hook = hook;
          } else {
            this.hook = new WeakRef(hook);
          }
        }
      }
      /**
       * Create a `Tree` from a `Proof` object
       */
      static createFromProof(proof) {
        return new Tree(proof_1.createNodeFromProof(proof));
      }
      /**
       * The root node of the tree
       */
      get rootNode() {
        return this._rootNode;
      }
      /**
       *
       * Setting the root node will trigger a call to the tree's `hook` if it exists.
       */
      set rootNode(newRootNode) {
        this._rootNode = newRootNode;
        if (this.hook) {
          if (typeof WeakRef === "undefined") {
            this.hook(newRootNode);
          } else {
            const hookVar = this.hook.deref();
            if (hookVar) {
              hookVar(newRootNode);
            } else {
              this.hook = void 0;
            }
          }
        }
      }
      /**
       * The root hash of the tree
       */
      get root() {
        return this.rootNode.root;
      }
      /**
       * Return a copy of the tree
       */
      clone() {
        return new Tree(this.rootNode);
      }
      /**
       * Return the subtree at the specified gindex.
       *
       * Note: The returned subtree will have a `hook` attached to the parent tree.
       * Updates to the subtree will result in updates to the parent.
       */
      getSubtree(index) {
        return new Tree(this.getNode(index), (node) => this.setNode(index, node));
      }
      /**
       * Return the node at the specified gindex.
       */
      getNode(gindex) {
        return getNode(this.rootNode, gindex);
      }
      /**
       * Return the node at the specified depth and index.
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      getNodeAtDepth(depth, index) {
        return getNodeAtDepth(this.rootNode, depth, index);
      }
      /**
       * Return the hash at the specified gindex.
       */
      getRoot(index) {
        return this.getNode(index).root;
      }
      /**
       * Set the node at at the specified gindex.
       */
      setNode(gindex, n) {
        this.rootNode = setNode(this.rootNode, gindex, n);
      }
      /**
       * Traverse to the node at the specified gindex,
       * then apply the function to get a new node and set the node at the specified gindex with the result.
       *
       * This is a convenient method to avoid traversing the tree 2 times to
       * get and set.
       */
      setNodeWithFn(gindex, getNewNode) {
        this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);
      }
      /**
       * Set the node at the specified depth and index.
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      setNodeAtDepth(depth, index, node) {
        this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);
      }
      /**
       * Set the hash at the specified gindex.
       *
       * Note: This will set a new `LeafNode` at the specified gindex.
       */
      setRoot(index, root) {
        this.setNode(index, node_1.LeafNode.fromRoot(root));
      }
      /**
       * Fast read-only iteration
       * In-order traversal of nodes at `depth`
       * starting from the `startIndex`-indexed node
       * iterating through `count` nodes
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      getNodesAtDepth(depth, startIndex, count) {
        return getNodesAtDepth(this.rootNode, depth, startIndex, count);
      }
      /**
       * Fast read-only iteration
       * In-order traversal of nodes at `depth`
       * starting from the `startIndex`-indexed node
       * iterating through `count` nodes
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      iterateNodesAtDepth(depth, startIndex, count) {
        return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);
      }
      /**
       * Return a merkle proof for the node at the specified gindex.
       */
      getSingleProof(index) {
        return single_1.createSingleProof(this.rootNode, index)[1];
      }
      /**
       * Return a merkle proof for the proof input.
       *
       * This method can be used to create multiproofs.
       */
      getProof(input) {
        return proof_1.createProof(this.rootNode, input);
      }
    };
    exports.Tree = Tree;
    function getNode(rootNode, gindex) {
      const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
      let node = rootNode;
      for (let i = 1; i < gindexBitstring.length; i++) {
        if (node.isLeaf()) {
          throw new Error(`Invalid tree - found leaf at depth ${i}`);
        }
        node = gindexBitstring[i] === "1" ? node.right : node.left;
      }
      return node;
    }
    exports.getNode = getNode;
    function setNode(rootNode, gindex, n) {
      const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
      const parentNodes = getParentNodes(rootNode, gindexBitstring);
      return rebindNodeToRoot(gindexBitstring, parentNodes, n);
    }
    exports.setNode = setNode;
    function setNodeWithFn(rootNode, gindex, getNewNode) {
      const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
      const parentNodes = getParentNodes(rootNode, gindexBitstring);
      const lastParentNode = parentNodes[parentNodes.length - 1];
      const lastBit = gindexBitstring[gindexBitstring.length - 1];
      const oldNode = lastBit === "1" ? lastParentNode.right : lastParentNode.left;
      const newNode = getNewNode(oldNode);
      return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);
    }
    exports.setNodeWithFn = setNodeWithFn;
    function getParentNodes(rootNode, bitstring) {
      let node = rootNode;
      const parentNodes = [rootNode];
      for (let i = 1; i < bitstring.length - 1; i++) {
        if (bitstring[i] === "1") {
          node = node.right;
        } else {
          node = node.left;
        }
        parentNodes.push(node);
      }
      return parentNodes;
    }
    function rebindNodeToRoot(bitstring, parentNodes, newNode) {
      let node = newNode;
      for (let i = bitstring.length - 1; i >= 1; i--) {
        if (bitstring[i] === "1") {
          node = new node_1.BranchNode(parentNodes[i - 1].left, node);
        } else {
          node = new node_1.BranchNode(node, parentNodes[i - 1].right);
        }
      }
      return node;
    }
    function getNodeAtDepth(rootNode, depth, index) {
      if (depth === 0) {
        return rootNode;
      }
      if (depth === 1) {
        return index === 0 ? rootNode.left : rootNode.right;
      }
      const depthiRoot = depth - 1;
      const depthiParent = 0;
      let node = rootNode;
      for (let d = depthiRoot; d >= depthiParent; d--) {
        node = isLeftNode(d, index) ? node.left : node.right;
      }
      return node;
    }
    exports.getNodeAtDepth = getNodeAtDepth;
    function setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {
      return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);
    }
    exports.setNodeAtDepth = setNodeAtDepth;
    function setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {
      if (nodesDepth === 0) {
        return nodes.length > 0 ? nodes[0] : rootNode;
      }
      const parentNodeStack = new Array(nodesDepth);
      const leftParentNodeStack = new Array(nodesDepth);
      const depthiRoot = nodesDepth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      parentNodeStack[depthiRoot] = rootNode;
      for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i];
        for (let d = depthi; d > depthiParent; d--) {
          node = isLeftNode(d, index) ? node.left : node.right;
          parentNodeStack[d - 1] = node;
        }
        depthi = depthiParent;
        const isLeftLeafNode = (index & 1) !== 1;
        if (isLeftLeafNode) {
          if (index + 1 === indexes[i + 1]) {
            node = new node_1.BranchNode(nodes[i], nodes[i + 1]);
            i++;
          } else {
            node = new node_1.BranchNode(nodes[i], node.right);
          }
        } else {
          node = new node_1.BranchNode(node.left, nodes[i]);
        }
        const isLastIndex = i >= indexes.length - 1;
        const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i + 1]);
        for (let d = depthiParent + 1; d <= diffDepthi; d++) {
          if (isLeftNode(d, index)) {
            if (isLastIndex || d !== diffDepthi) {
              node = new node_1.BranchNode(node, parentNodeStack[d].right);
            } else {
              leftParentNodeStack[d] = node;
              node = parentNodeStack[d];
            }
          } else {
            const leftNode = leftParentNodeStack[d];
            if (leftNode !== void 0) {
              node = new node_1.BranchNode(leftNode, node);
              leftParentNodeStack[d] = void 0;
            } else {
              node = new node_1.BranchNode(parentNodeStack[d].left, node);
            }
          }
        }
        depthi = diffDepthi;
      }
      return node;
    }
    exports.setNodesAtDepth = setNodesAtDepth;
    function getNodesAtDepth(rootNode, depth, startIndex, count) {
      if (depth === 0) {
        return startIndex === 0 && count > 0 ? [rootNode] : [];
      } else if (depth === 1) {
        if (count === 0) {
          return [];
        } else if (count === 1) {
          return startIndex === 0 ? [rootNode.left] : [rootNode.right];
        } else {
          return [rootNode.left, rootNode.right];
        }
      }
      const depthiRoot = depth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      const parentNodeStack = new Array(depth);
      const isLeftStack = new Array(depth);
      const nodes = new Array(count);
      parentNodeStack[depthiRoot] = rootNode;
      for (let i = 0; i < count; i++) {
        for (let d = depthi; d >= depthiParent; d--) {
          if (d !== depthi) {
            parentNodeStack[d] = node;
          }
          const isLeft = isLeftNode(d, startIndex + i);
          isLeftStack[d] = isLeft;
          node = isLeft ? node.left : node.right;
        }
        nodes[i] = node;
        for (let d = depthiParent; d <= depthiRoot; d++) {
          if (isLeftStack[d] === true) {
            depthi = d;
            break;
          }
        }
        node = parentNodeStack[depthi];
      }
      return nodes;
    }
    exports.getNodesAtDepth = getNodesAtDepth;
    function* iterateNodesAtDepth(rootNode, depth, startIndex, count) {
      const endIndex = startIndex + count;
      const depthiRoot = depth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      const parentNodeStack = new Array(depth);
      const isLeftStack = new Array(depth);
      parentNodeStack[depthiRoot] = rootNode;
      for (let index = startIndex; index < endIndex; index++) {
        for (let d = depthi; d >= depthiParent; d--) {
          if (d !== depthi) {
            parentNodeStack[d] = node;
          }
          const isLeft = isLeftNode(d, index);
          isLeftStack[d] = isLeft;
          node = isLeft ? node.left : node.right;
        }
        yield node;
        for (let d = depthiParent; d <= depthiRoot; d++) {
          if (isLeftStack[d] === true) {
            depthi = d;
            break;
          }
        }
        node = parentNodeStack[depthi];
      }
    }
    exports.iterateNodesAtDepth = iterateNodesAtDepth;
    function treeZeroAfterIndex(rootNode, nodesDepth, index) {
      if (index < 0) {
        return zeroNode_1.zeroNode(nodesDepth);
      }
      const parentNodeStack = new Array(nodesDepth);
      const depthiRoot = nodesDepth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      parentNodeStack[depthiRoot] = rootNode;
      for (let d = depthi; d >= depthiParent; d--) {
        node = isLeftNode(d, index) ? node.left : node.right;
        parentNodeStack[d - 1] = node;
      }
      depthi = depthiParent;
      for (let d = depthiParent; d <= depthiRoot; d++) {
        if (isLeftNode(d, index)) {
          node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));
        } else {
          node = new node_1.BranchNode(parentNodeStack[d].left, node);
        }
      }
      return node;
    }
    exports.treeZeroAfterIndex = treeZeroAfterIndex;
    function isLeftNode(depthi, index) {
      if (depthi > 31) {
        const indexHi = index / 2 ** 32 >>> 0;
        const mask2 = 1 << depthi - 32;
        return (indexHi & mask2) !== mask2;
      }
      const mask = 1 << depthi;
      return (index & mask) !== mask;
    }
    function findDiffDepthi(from, to) {
      return (
        // (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2
        Math.ceil(Math.log2(-~(from ^ to))) - // Must offset by one to match the depthi scale
        1
      );
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/util.js
var require_util2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;
    var gindex_1 = require_gindex();
    function computeProofGindices(gindex) {
      const path = /* @__PURE__ */ new Set();
      const branch = /* @__PURE__ */ new Set();
      let g = gindex;
      while (g > 1) {
        path.add(g);
        branch.add(gindex_1.gindexSibling(g));
        g = gindex_1.gindexParent(g);
      }
      return { path, branch };
    }
    exports.computeProofGindices = computeProofGindices;
    function computeProofBitstrings(gindex) {
      const path = /* @__PURE__ */ new Set();
      const branch = /* @__PURE__ */ new Set();
      let g = gindex;
      while (g.length > 1) {
        path.add(g);
        const lastBit = g[g.length - 1];
        const parent = g.substring(0, g.length - 1);
        branch.add(parent + (Number(lastBit) ^ 1));
        g = parent;
      }
      return { path, branch };
    }
    exports.computeProofBitstrings = computeProofBitstrings;
    function sortInOrderBitstrings(gindices, bitLength) {
      if (!gindices.length) {
        return [];
      }
      return gindices.map((g) => g.padEnd(bitLength)).sort().map((g) => g.trim());
    }
    exports.sortInOrderBitstrings = sortInOrderBitstrings;
    function sortDecreasingBitstrings(gindices) {
      if (!gindices.length) {
        return [];
      }
      return gindices.sort((a, b) => {
        if (a.length < b.length) {
          return 1;
        } else if (b.length < a.length) {
          return -1;
        }
        let aPos0 = a.indexOf("0");
        let bPos0 = b.indexOf("0");
        while (true) {
          if (aPos0 === -1) {
            return -1;
          } else if (bPos0 === -1) {
            return 1;
          }
          if (aPos0 < bPos0) {
            return 1;
          } else if (bPos0 < aPos0) {
            return -1;
          }
          aPos0 = a.indexOf("0", aPos0 + 1);
          bPos0 = b.indexOf("0", bPos0 + 1);
        }
      });
    }
    exports.sortDecreasingBitstrings = sortDecreasingBitstrings;
    function filterParentBitstrings(gindices) {
      const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);
      const filtered = [];
      outer:
        for (let i = 0; i < sortedBitstrings.length; i++) {
          const bsA = sortedBitstrings[i];
          for (let j = i + 1; j < sortedBitstrings.length; j++) {
            const bsB = sortedBitstrings[j];
            if (bsB.startsWith(bsA)) {
              continue outer;
            }
          }
          filtered.push(bsA);
        }
      return filtered;
    }
    exports.filterParentBitstrings = filterParentBitstrings;
    var SortOrder;
    (function(SortOrder2) {
      SortOrder2[SortOrder2["InOrder"] = 0] = "InOrder";
      SortOrder2[SortOrder2["Decreasing"] = 1] = "Decreasing";
      SortOrder2[SortOrder2["Unsorted"] = 2] = "Unsorted";
    })(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
    function computeMultiProofBitstrings(gindices, includeLeaves = true, sortOrder = SortOrder.InOrder) {
      const leaves = filterParentBitstrings(gindices);
      const proof = new Set(includeLeaves ? leaves : []);
      const paths = /* @__PURE__ */ new Set();
      const branches = /* @__PURE__ */ new Set();
      let maxBitLength = 1;
      for (const gindex of leaves) {
        if (gindex.length > maxBitLength)
          maxBitLength = gindex.length;
        const { path, branch } = computeProofBitstrings(gindex);
        path.forEach((g) => paths.add(g));
        branch.forEach((g) => branches.add(g));
      }
      paths.forEach((g) => branches.delete(g));
      branches.forEach((g) => proof.add(g));
      switch (sortOrder) {
        case SortOrder.InOrder:
          return sortInOrderBitstrings(Array.from(proof), maxBitLength);
        case SortOrder.Decreasing:
          return sortDecreasingBitstrings(Array.from(proof));
        case SortOrder.Unsorted:
          return Array.from(proof);
      }
    }
    exports.computeMultiProofBitstrings = computeMultiProofBitstrings;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/multi.js
var require_multi = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/multi.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNodeFromMultiProof = exports.createMultiProof = void 0;
    var node_1 = require_node();
    var tree_1 = require_tree();
    var util_1 = require_util2();
    function createMultiProof(rootNode, gindices) {
      const tree = new tree_1.Tree(rootNode);
      const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map((gindex) => gindex.toString(2)), false, util_1.SortOrder.Decreasing);
      const leafGindices = gindices.slice().sort((a, b) => a < b ? 1 : -1);
      const leaves = leafGindices.map((gindex) => tree.getRoot(gindex));
      const witnesses = witnessGindices.map((gindex) => tree.getRoot(gindex));
      return [leaves, witnesses, leafGindices];
    }
    exports.createMultiProof = createMultiProof;
    function createNodeFromMultiProof(leaves, witnesses, gindices) {
      var _a, _b;
      if (leaves.length !== gindices.length) {
        throw new Error("Leaves length should equal gindices length");
      }
      const leafBitstrings = gindices.map((gindex) => gindex.toString(2));
      const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);
      if (witnessBitstrings.length !== witnesses.length) {
        throw new Error("Witnesses length should equal witnesses gindices length");
      }
      const maxLevel = Math.max(((_a = leafBitstrings[0]) == null ? void 0 : _a.length) ?? 0, ((_b = witnessBitstrings[0]) == null ? void 0 : _b.length) ?? 0);
      const levels2 = Object.fromEntries(Array.from({ length: maxLevel }, (_, i) => [i + 1, {}]));
      for (let i = 0; i < leafBitstrings.length; i++) {
        const leafBitstring = leafBitstrings[i];
        const leaf = leaves[i];
        levels2[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);
      }
      for (let i = 0; i < witnessBitstrings.length; i++) {
        const witnessBitstring = witnessBitstrings[i];
        const witness = witnesses[i];
        levels2[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);
      }
      for (let i = maxLevel; i > 1; i--) {
        const level = levels2[i];
        const parentLevel = levels2[i - 1];
        for (const bitstring of Object.keys(level)) {
          const node = level[bitstring];
          if (!node) {
            continue;
          }
          const isLeft = bitstring[bitstring.length - 1] === "0";
          const parentBitstring = bitstring.substring(0, bitstring.length - 1);
          const siblingBitstring = parentBitstring + (isLeft ? "1" : "0");
          const siblingNode = level[siblingBitstring];
          if (!siblingNode) {
            throw new Error(`Sibling not found: ${siblingBitstring}`);
          }
          const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);
          parentLevel[parentBitstring] = parentNode;
          delete level[bitstring];
          delete level[siblingBitstring];
        }
      }
      const root = levels2[1]["1"];
      if (!root) {
        throw new Error("Internal consistency error: no root found");
      }
      return root;
    }
    exports.createNodeFromMultiProof = createNodeFromMultiProof;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/compactMulti.js
var require_compactMulti = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/compactMulti.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNodeFromCompactMultiProof = exports.createCompactMultiProof = exports.compactMultiProofToNode = exports.nodeToCompactMultiProof = exports.descriptorToBitlist = exports.computeDescriptor = void 0;
    var gindex_1 = require_gindex();
    var node_1 = require_node();
    var util_1 = require_util2();
    function computeDescriptor(indices) {
      const proofBitstrings = /* @__PURE__ */ new Set();
      const pathBitstrings = /* @__PURE__ */ new Set();
      for (const leafIndex of indices) {
        const leafBitstring = gindex_1.convertGindexToBitstring(leafIndex);
        proofBitstrings.add(leafBitstring);
        const { branch, path } = util_1.computeProofBitstrings(leafBitstring);
        path.delete(leafBitstring);
        for (const pathIndex of path) {
          pathBitstrings.add(pathIndex);
        }
        for (const branchIndex of branch) {
          proofBitstrings.add(branchIndex);
        }
      }
      for (const pathIndex of pathBitstrings) {
        proofBitstrings.delete(pathIndex);
      }
      const allBitstringsSorted = Array.from(proofBitstrings).sort((a, b) => a.localeCompare(b));
      let descriptorBitstring = "";
      for (const gindexBitstring of allBitstringsSorted) {
        for (let i = 0; i < gindexBitstring.length; i++) {
          if (gindexBitstring[gindexBitstring.length - 1 - i] === "1") {
            descriptorBitstring += "1".padStart(i + 1, "0");
            break;
          }
        }
      }
      if (descriptorBitstring.length % 8 != 0) {
        descriptorBitstring = descriptorBitstring.padEnd(8 - descriptorBitstring.length % 8 + descriptorBitstring.length, "0");
      }
      const descriptor = new Uint8Array(descriptorBitstring.length / 8);
      for (let i = 0; i < descriptor.length; i++) {
        descriptor[i] = Number("0b" + descriptorBitstring.substring(i * 8, (i + 1) * 8));
      }
      return descriptor;
    }
    exports.computeDescriptor = computeDescriptor;
    function getBit(bitlist, bitIndex) {
      const bit = bitIndex % 8;
      const byteIdx = Math.floor(bitIndex / 8);
      const byte = bitlist[byteIdx];
      switch (bit) {
        case 0:
          return (byte & 128) !== 0;
        case 1:
          return (byte & 64) !== 0;
        case 2:
          return (byte & 32) !== 0;
        case 3:
          return (byte & 16) !== 0;
        case 4:
          return (byte & 8) !== 0;
        case 5:
          return (byte & 4) !== 0;
        case 6:
          return (byte & 2) !== 0;
        case 7:
          return (byte & 1) !== 0;
        default:
          throw new Error("unreachable");
      }
    }
    function descriptorToBitlist(descriptor) {
      const bools = [];
      const maxBitLength = descriptor.length * 8;
      let count0 = 0;
      let count1 = 0;
      for (let i = 0; i < maxBitLength; i++) {
        const bit = getBit(descriptor, i);
        bools.push(bit);
        if (bit) {
          count1++;
        } else {
          count0++;
        }
        if (count1 > count0) {
          i++;
          if (i + 7 < maxBitLength) {
            throw new Error("Invalid descriptor: too many bytes");
          }
          for (; i < maxBitLength; i++) {
            const bit2 = getBit(descriptor, i);
            if (bit2) {
              throw new Error("Invalid descriptor: too many 1 bits");
            }
          }
          return bools;
        }
      }
      throw new Error("Invalid descriptor: not enough 1 bits");
    }
    exports.descriptorToBitlist = descriptorToBitlist;
    function nodeToCompactMultiProof(node, bitlist, bitIndex) {
      if (bitlist[bitIndex]) {
        return [node.root];
      } else {
        const left = nodeToCompactMultiProof(node.left, bitlist, bitIndex + 1);
        const right = nodeToCompactMultiProof(node.right, bitlist, bitIndex + left.length * 2);
        return [...left, ...right];
      }
    }
    exports.nodeToCompactMultiProof = nodeToCompactMultiProof;
    function compactMultiProofToNode(bitlist, leaves, pointer) {
      if (bitlist[pointer.bitIndex++]) {
        return node_1.LeafNode.fromRoot(leaves[pointer.leafIndex++]);
      } else {
        return new node_1.BranchNode(compactMultiProofToNode(bitlist, leaves, pointer), compactMultiProofToNode(bitlist, leaves, pointer));
      }
    }
    exports.compactMultiProofToNode = compactMultiProofToNode;
    function createCompactMultiProof(rootNode, descriptor) {
      return nodeToCompactMultiProof(rootNode, descriptorToBitlist(descriptor), 0);
    }
    exports.createCompactMultiProof = createCompactMultiProof;
    function createNodeFromCompactMultiProof(leaves, descriptor) {
      const bools = descriptorToBitlist(descriptor);
      if (bools.length !== leaves.length * 2 - 1) {
        throw new Error("Invalid multiproof: invalid number of leaves");
      }
      return compactMultiProofToNode(bools, leaves, { bitIndex: 0, leafIndex: 0 });
    }
    exports.createNodeFromCompactMultiProof = createNodeFromCompactMultiProof;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/treeOffset.js
var require_treeOffset = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/treeOffset.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeTreeOffsetProof = exports.serializeTreeOffsetProof = exports.computeTreeOffsetProofSerializedLength = exports.createNodeFromTreeOffsetProof = exports.createTreeOffsetProof = exports.treeOffsetProofToNode = exports.nodeToTreeOffsetProof = void 0;
    var node_1 = require_node();
    var util_1 = require_util2();
    function nodeToTreeOffsetProof(node, gindex, proofGindices) {
      if (!proofGindices.length || !proofGindices[0].startsWith(gindex)) {
        return [[], []];
      } else if (gindex === proofGindices[0]) {
        proofGindices.shift();
        return [[], [node.root]];
      } else {
        const [leftOffsets, leftLeaves] = nodeToTreeOffsetProof(node.left, gindex + "0", proofGindices);
        const [rightOffsets, rightLeaves] = nodeToTreeOffsetProof(node.right, gindex + "1", proofGindices);
        const pivot = leftLeaves.length;
        return [[pivot].concat(leftOffsets, rightOffsets), leftLeaves.concat(rightLeaves)];
      }
    }
    exports.nodeToTreeOffsetProof = nodeToTreeOffsetProof;
    function treeOffsetProofToNode(offsets, leaves) {
      if (!leaves.length) {
        throw new Error("Proof must contain gt 0 leaves");
      } else if (leaves.length === 1) {
        return node_1.LeafNode.fromRoot(leaves[0]);
      } else {
        const pivot = offsets[0];
        return new node_1.BranchNode(treeOffsetProofToNode(offsets.slice(1, pivot), leaves.slice(0, pivot)), treeOffsetProofToNode(offsets.slice(pivot), leaves.slice(pivot)));
      }
    }
    exports.treeOffsetProofToNode = treeOffsetProofToNode;
    function createTreeOffsetProof(rootNode, gindices) {
      return nodeToTreeOffsetProof(rootNode, "1", util_1.computeMultiProofBitstrings(gindices.map((g) => g.toString(2))));
    }
    exports.createTreeOffsetProof = createTreeOffsetProof;
    function createNodeFromTreeOffsetProof(offsets, leaves) {
      return treeOffsetProofToNode(offsets, leaves);
    }
    exports.createNodeFromTreeOffsetProof = createNodeFromTreeOffsetProof;
    function computeTreeOffsetProofSerializedLength(offsets, leaves) {
      return (offsets.length + 1) * 2 + leaves.length * 32;
    }
    exports.computeTreeOffsetProofSerializedLength = computeTreeOffsetProofSerializedLength;
    function serializeTreeOffsetProof(output, byteOffset, offsets, leaves) {
      const writer = new DataView(output.buffer, output.byteOffset, output.byteLength);
      writer.setUint16(byteOffset, leaves.length, true);
      const offsetsStartIndex = byteOffset + 2;
      for (let i = 0; i < offsets.length; i++) {
        writer.setUint16(i * 2 + offsetsStartIndex, offsets[i], true);
      }
      const leavesStartIndex = offsetsStartIndex + offsets.length * 2;
      for (let i = 0; i < leaves.length; i++) {
        output.set(leaves[i], i * 32 + leavesStartIndex);
      }
    }
    exports.serializeTreeOffsetProof = serializeTreeOffsetProof;
    function deserializeTreeOffsetProof(data, byteOffset) {
      const reader = new DataView(data.buffer, data.byteOffset, data.byteLength);
      const leafCount = reader.getUint16(byteOffset, true);
      if (data.length < (leafCount - 1) * 2 + leafCount * 32) {
        throw new Error("Unable to deserialize tree offset proof: not enough bytes");
      }
      const offsetsStartIndex = byteOffset + 2;
      const offsets = Array.from({ length: leafCount - 1 }, (_, i) => reader.getUint16(i * 2 + offsetsStartIndex, true));
      const leavesStartIndex = offsetsStartIndex + offsets.length * 2;
      const leaves = Array.from({ length: leafCount }, (_, i) => data.subarray(i * 32 + leavesStartIndex, (i + 1) * 32 + leavesStartIndex));
      return [offsets, leaves];
    }
    exports.deserializeTreeOffsetProof = deserializeTreeOffsetProof;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js
var require_proof = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = exports.descriptorToBitlist = exports.computeDescriptor = void 0;
    var multi_1 = require_multi();
    var compactMulti_1 = require_compactMulti();
    var single_1 = require_single();
    var treeOffset_1 = require_treeOffset();
    var compactMulti_2 = require_compactMulti();
    Object.defineProperty(exports, "computeDescriptor", { enumerable: true, get: function() {
      return compactMulti_2.computeDescriptor;
    } });
    Object.defineProperty(exports, "descriptorToBitlist", { enumerable: true, get: function() {
      return compactMulti_2.descriptorToBitlist;
    } });
    var ProofType;
    (function(ProofType2) {
      ProofType2["single"] = "single";
      ProofType2["treeOffset"] = "treeOffset";
      ProofType2["multi"] = "multi";
      ProofType2["compactMulti"] = "compactMulti";
    })(ProofType = exports.ProofType || (exports.ProofType = {}));
    exports.ProofTypeSerialized = [
      ProofType.single,
      ProofType.treeOffset,
      ProofType.multi,
      ProofType.compactMulti
      // 3
    ];
    function createProof(rootNode, input) {
      switch (input.type) {
        case ProofType.single: {
          const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);
          return {
            type: ProofType.single,
            gindex: input.gindex,
            leaf,
            witnesses
          };
        }
        case ProofType.treeOffset: {
          const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);
          return {
            type: ProofType.treeOffset,
            offsets,
            leaves
          };
        }
        case ProofType.multi: {
          const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);
          return {
            type: ProofType.multi,
            leaves,
            witnesses,
            gindices
          };
        }
        case ProofType.compactMulti: {
          const leaves = compactMulti_1.createCompactMultiProof(rootNode, input.descriptor);
          return {
            type: ProofType.compactMulti,
            leaves,
            descriptor: input.descriptor
          };
        }
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.createProof = createProof;
    function createNodeFromProof(proof) {
      switch (proof.type) {
        case ProofType.single:
          return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);
        case ProofType.treeOffset:
          return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);
        case ProofType.multi:
          return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);
        case ProofType.compactMulti:
          return compactMulti_1.createNodeFromCompactMultiProof(proof.leaves, proof.descriptor);
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.createNodeFromProof = createNodeFromProof;
    function serializeProof(proof) {
      switch (proof.type) {
        case ProofType.single:
        case ProofType.multi:
          throw new Error("Not implemented");
        case ProofType.treeOffset: {
          const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));
          output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);
          treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);
          return output;
        }
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.serializeProof = serializeProof;
    function deserializeProof(data) {
      const proofType = exports.ProofTypeSerialized[data[0]];
      if (!proofType) {
        throw new Error("Invalid proof type");
      }
      switch (proofType) {
        case ProofType.single:
        case ProofType.multi:
          throw new Error("Not implemented");
        case ProofType.treeOffset: {
          const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);
          return {
            type: ProofType.treeOffset,
            offsets,
            leaves
          };
        }
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.deserializeProof = deserializeProof;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/index.js
var require_lib = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/persistent-merkle-tree/lib/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_gindex(), exports);
    __exportStar(require_hasher(), exports);
    __exportStar(require_node(), exports);
    __exportStar(require_packedNode(), exports);
    __exportStar(require_proof(), exports);
    __exportStar(require_subtree(), exports);
    __exportStar(require_tree(), exports);
    __exportStar(require_zeroNode(), exports);
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/zeros.js
var require_zeros = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/zeros.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroHash = void 0;
    var index_1 = require_hasher();
    var zeroHashes = [new Uint8Array(32)];
    function zeroHash(depth) {
      if (depth >= zeroHashes.length) {
        for (let i = zeroHashes.length; i <= depth; i++) {
          zeroHashes[i] = index_1.hasher.digest64(zeroHashes[i - 1], zeroHashes[i - 1]);
        }
      }
      return zeroHashes[depth];
    }
    exports.zeroHash = zeroHash;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/merkleize.js
var require_merkleize = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/merkleize.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;
    var index_1 = require_hasher();
    var zeros_1 = require_zeros();
    function hash64(bytes32A, bytes32B) {
      return index_1.hasher.digest64(bytes32A, bytes32B);
    }
    exports.hash64 = hash64;
    function merkleize(chunks, padFor) {
      const layerCount = bitLength(nextPowerOf2(padFor) - 1);
      if (chunks.length == 0) {
        return zeros_1.zeroHash(layerCount);
      }
      let chunkCount = chunks.length;
      for (let l = 0; l < layerCount; l++) {
        const padCount = chunkCount % 2;
        const paddedChunkCount = chunkCount + padCount;
        for (let i = 0; i < padCount; i++) {
          chunks[chunkCount + i] = zeros_1.zeroHash(l);
        }
        for (let i = 0; i < paddedChunkCount; i += 2) {
          chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);
        }
        chunkCount = paddedChunkCount / 2;
      }
      return chunks[0];
    }
    exports.merkleize = merkleize;
    function splitIntoRootChunks(longChunk) {
      const chunkCount = Math.ceil(longChunk.length / 32);
      const chunks = new Array(chunkCount);
      for (let i = 0; i < chunkCount; i++) {
        const chunk = new Uint8Array(32);
        chunk.set(longChunk.slice(i * 32, (i + 1) * 32));
        chunks[i] = chunk;
      }
      return chunks;
    }
    exports.splitIntoRootChunks = splitIntoRootChunks;
    function mixInLength(root, length) {
      const lengthBuf = Buffer.alloc(32);
      lengthBuf.writeUIntLE(length, 0, 6);
      return hash64(root, lengthBuf);
    }
    exports.mixInLength = mixInLength;
    function bitLength(i) {
      if (i === 0) {
        return 0;
      }
      return Math.floor(Math.log2(i)) + 1;
    }
    exports.bitLength = bitLength;
    function maxChunksToDepth(n) {
      if (n === 0)
        return 0;
      return Math.ceil(Math.log2(n));
    }
    exports.maxChunksToDepth = maxChunksToDepth;
    function nextPowerOf2(n) {
      return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));
    }
    exports.nextPowerOf2 = nextPowerOf2;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/named.js
var require_named = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/named.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namedClass = void 0;
    function namedClass(superClass, className) {
      return new Function("superClass", `return class ${className} extends superClass {}`)(superClass);
    }
    exports.namedClass = namedClass;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/arrayBasic.js
var require_arrayBasic = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/arrayBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;
    var persistent_merkle_tree_1 = require_lib();
    function getLengthFromRootNode(node) {
      return node.right.getUint(4, 0);
    }
    exports.getLengthFromRootNode = getLengthFromRootNode;
    function getChunksNodeFromRootNode(node) {
      return node.left;
    }
    exports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;
    function addLengthNode(chunksNode, length) {
      return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length));
    }
    exports.addLengthNode = addLengthNode;
    function setChunksNode(rootNode, chunksNode, newLength) {
      const lengthNode = newLength !== void 0 ? (
        // If newLength is set, create a new node for length
        persistent_merkle_tree_1.LeafNode.fromUint32(newLength)
      ) : (
        // else re-use existing node
        rootNode.right
      );
      return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);
    }
    exports.setChunksNode = setChunksNode;
    function value_serializeToBytesArrayBasic(elementType, length, output, offset, value) {
      const elSize = elementType.byteLength;
      for (let i = 0; i < length; i++) {
        elementType.value_serializeToBytes(output, offset + i * elSize, value[i]);
      }
      return offset + length * elSize;
    }
    exports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;
    function value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {
      const elSize = elementType.byteLength;
      const length = (end - start) / elSize;
      assertValidArrayLength(length, arrayProps, true);
      const values = new Array(length);
      for (let i = 0; i < length; i++) {
        values[i] = elementType.value_deserializeFromBytes(data, start + i * elSize, start + (i + 1) * elSize);
      }
      return values;
    }
    exports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;
    function tree_serializeToBytesArrayBasic(elementType, length, depth, output, offset, node) {
      const size = elementType.byteLength * length;
      const chunkCount = Math.ceil(size / 32);
      const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);
      persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);
      return offset + size;
    }
    exports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic;
    function tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {
      const length = (end - start) / elementType.byteLength;
      assertValidArrayLength(length, arrayProps, true);
      const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);
      if (arrayProps.isList) {
        return addLengthNode(chunksNode, length);
      } else {
        return chunksNode;
      }
    }
    exports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;
    function value_fromJsonArray(elementType, json, arrayProps) {
      if (!Array.isArray(json)) {
        throw Error("JSON is not an array");
      }
      assertValidArrayLength(json.length, arrayProps);
      const value = new Array(json.length);
      for (let i = 0; i < json.length; i++) {
        value[i] = elementType.fromJson(json[i]);
      }
      return value;
    }
    exports.value_fromJsonArray = value_fromJsonArray;
    function value_toJsonArray(elementType, value, arrayProps) {
      const length = arrayProps.isList ? value.length : arrayProps.length;
      const json = new Array(length);
      for (let i = 0; i < length; i++) {
        json[i] = elementType.toJson(value[i]);
      }
      return json;
    }
    exports.value_toJsonArray = value_toJsonArray;
    function value_cloneArray(elementType, value) {
      const newValue = new Array(value.length);
      for (let i = 0; i < value.length; i++) {
        newValue[i] = elementType.clone(value[i]);
      }
      return newValue;
    }
    exports.value_cloneArray = value_cloneArray;
    function value_equals(elementType, a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!elementType.equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    exports.value_equals = value_equals;
    function value_defaultValueArray(elementType, length) {
      const values = new Array(length);
      for (let i = 0; i < length; i++) {
        values[i] = elementType.defaultValue();
      }
      return values;
    }
    exports.value_defaultValueArray = value_defaultValueArray;
    function assertValidArrayLength(length, arrayProps, checkNonDecimalLength) {
      if (checkNonDecimalLength && length % 1 !== 0) {
        throw Error("size not multiple of element fixedSize");
      }
      if (arrayProps.isList) {
        if (length > arrayProps.limit) {
          throw new Error(`Invalid list length ${length} over limit ${arrayProps.limit}`);
        }
      } else {
        if (length !== arrayProps.length) {
          throw new Error(`Incorrect vector length ${length} expected ${arrayProps.length}`);
        }
      }
    }
    exports.assertValidArrayLength = assertValidArrayLength;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/value/bitArray.js
var require_bitArray = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/value/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;
    var uint8ByteToBitBooleanArrays = new Array(256);
    var BitArray = class {
      constructor(uint8Array, bitLen) {
        this.uint8Array = uint8Array;
        this.bitLen = bitLen;
        if (uint8Array.length !== Math.ceil(bitLen / 8)) {
          throw Error("BitArray uint8Array length does not match bitLen");
        }
      }
      /** Returns a zero'ed BitArray of `bitLen` */
      static fromBitLen(bitLen) {
        return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);
      }
      /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */
      static fromSingleBit(bitLen, bitIndex) {
        const bitArray = BitArray.fromBitLen(bitLen);
        bitArray.set(bitIndex, true);
        return bitArray;
      }
      /** Returns a BitArray from an array of booleans representation */
      static fromBoolArray(bitBoolArr) {
        const bitArray = BitArray.fromBitLen(bitBoolArr.length);
        for (let i = 0; i < bitBoolArr.length; i++) {
          if (bitBoolArr[i] === true) {
            bitArray.set(i, true);
          }
        }
        return bitArray;
      }
      clone() {
        return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);
      }
      /**
       * Get bit value at index `bitIndex`
       */
      get(bitIndex) {
        const byteIdx = Math.floor(bitIndex / 8);
        const bitInBit = bitIndex % 8;
        const mask = 1 << bitInBit;
        return (this.uint8Array[byteIdx] & mask) === mask;
      }
      /**
       * Set bit value at index `bitIndex`
       */
      set(bitIndex, bit) {
        if (bitIndex >= this.bitLen) {
          throw Error(`BitArray set bitIndex ${bitIndex} beyond bitLen ${this.bitLen}`);
        }
        const byteIdx = Math.floor(bitIndex / 8);
        const bitInBit = bitIndex % 8;
        const mask = 1 << bitInBit;
        let byte = this.uint8Array[byteIdx];
        if (bit) {
          byte |= mask;
          this.uint8Array[byteIdx] = byte;
        } else {
          if ((byte & mask) === mask) {
            byte ^= mask;
            this.uint8Array[byteIdx] = byte;
          } else {
          }
        }
      }
      /** Merge two BitArray bitfields with OR. Must have the same bitLen */
      mergeOrWith(bitArray2) {
        if (bitArray2.bitLen !== this.bitLen) {
          throw Error("Must merge BitArrays of same bitLen");
        }
        for (let i = 0; i < this.uint8Array.length; i++) {
          this.uint8Array[i] = this.uint8Array[i] | bitArray2.uint8Array[i];
        }
      }
      /**
       * Returns an array with the indexes which have a bit set to true
       */
      intersectValues(values) {
        const yes = [];
        if (values.length !== this.bitLen) {
          throw Error(`Must not intersect values of length ${values.length} != bitLen ${this.bitLen}`);
        }
        const fullByteLen = Math.floor(this.bitLen / 8);
        const remainderBits = this.bitLen % 8;
        const bytes = this.uint8Array;
        for (let iByte = 0; iByte < fullByteLen; iByte++) {
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
          for (let iBit = 0; iBit < 8; iBit++) {
            if (booleansInByte[iBit]) {
              yes.push(values[iByte * 8 + iBit]);
            }
          }
        }
        if (remainderBits > 0) {
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]);
          for (let iBit = 0; iBit < remainderBits; iBit++) {
            if (booleansInByte[iBit]) {
              yes.push(values[fullByteLen * 8 + iBit]);
            }
          }
        }
        return yes;
      }
      /**
       * Returns the positions of all bits that are set to true
       */
      getTrueBitIndexes() {
        const indexes = [];
        const bytes = this.uint8Array;
        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
          for (let iBit = 0; iBit < 8; iBit++) {
            if (booleansInByte[iBit]) {
              indexes.push(iByte * 8 + iBit);
            }
          }
        }
        return indexes;
      }
      /**
       * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.
       * @returns
       *  - number: if there's a single bit set, the number it the single bit set position
       *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET
       * @throws
       *  - ERROR_MORE_THAN_ONE_BIT_SET
       *  - ERROR_NO_BIT_SET
       */
      getSingleTrueBit() {
        let index = null;
        const bytes = this.uint8Array;
        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {
          if (bytes[iByte] === 0) {
            continue;
          }
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
          for (let iBit = 0; iBit < 8; iBit++) {
            if (booleansInByte[iBit] === true) {
              if (index !== null) {
                return null;
              }
              index = iByte * 8 + iBit;
            }
          }
        }
        if (index === null) {
          return null;
        } else {
          return index;
        }
      }
      toBoolArray() {
        const bitBoolArr = new Array(this.bitLen);
        for (let i = 0; i < this.bitLen; i++) {
          bitBoolArr[i] = this.get(i);
        }
        return bitBoolArr;
      }
    };
    exports.BitArray = BitArray;
    function getUint8ByteToBitBooleanArray(byte) {
      if (!uint8ByteToBitBooleanArrays[byte]) {
        uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);
      }
      return uint8ByteToBitBooleanArrays[byte];
    }
    exports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;
    function computeUint8ByteToBitBooleanArray(byte) {
      const binaryStr = byte.toString(2);
      const binaryLength = binaryStr.length;
      const bits = new Array(8);
      for (let i = 0; i < 8; i++) {
        bits[i] = i < binaryLength ? (
          //
          binaryStr[binaryLength - i - 1] === "1"
        ) : false;
      }
      return bits;
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/byteArray.js
var require_byteArray = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/byteArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0;
    var hexByByte = new Array(256);
    function toHexString(bytes) {
      let hex3 = "0x";
      for (const byte of bytes) {
        if (!hexByByte[byte]) {
          hexByByte[byte] = byte < 16 ? "0" + byte.toString(16) : byte.toString(16);
        }
        hex3 += hexByByte[byte];
      }
      return hex3;
    }
    exports.toHexString = toHexString;
    function fromHexString(hex3) {
      if (typeof hex3 !== "string") {
        throw new Error(`hex argument type ${typeof hex3} must be of type string`);
      }
      if (hex3.startsWith("0x")) {
        hex3 = hex3.slice(2);
      }
      if (hex3.length % 2 !== 0) {
        throw new Error(`hex string length ${hex3.length} must be multiple of 2`);
      }
      const byteLen = hex3.length / 2;
      const bytes = new Uint8Array(byteLen);
      for (let i = 0; i < byteLen; i++) {
        const byte = parseInt(hex3.slice(i * 2, (i + 1) * 2), 16);
        bytes[i] = byte;
      }
      return bytes;
    }
    exports.fromHexString = fromHexString;
    function byteArrayEquals(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    exports.byteArrayEquals = byteArrayEquals;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/proof/treePostProcessFromProofNode.js
var require_treePostProcessFromProofNode = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/proof/treePostProcessFromProofNode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.treePostProcessFromProofNode = void 0;
    var persistent_merkle_tree_1 = require_lib();
    function isCompositeType(type) {
      return !type.isBasic;
    }
    function treePostProcessFromProofNode(node, type, bitstring = "", currentDepth = 0) {
      if (currentDepth === 0) {
        const nodePost = type.tree_fromProofNode(node);
        if (nodePost.done) {
          return nodePost.node;
        } else {
          node = nodePost.node;
        }
      }
      const atTypeDepth = type.depth === currentDepth;
      if (node.isLeaf()) {
        if (atTypeDepth) {
          const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));
          if (jsonPathProp === null) {
            return node;
          }
          const childType = type.getPropertyType(jsonPathProp);
          if (childType.maxChunkCount === 1 && isCompositeType(childType)) {
            return childType.tree_fromProofNode(node).node;
          } else {
            return node;
          }
        } else {
          return node;
        }
      } else {
        if (atTypeDepth) {
          const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));
          if (jsonPathProp === null) {
            return node;
          }
          const childType = type.getPropertyType(jsonPathProp);
          if (!isCompositeType(childType)) {
            throw Error("BranchNode does not map to CompositeType");
          }
          const nodePost = childType.tree_fromProofNode(node);
          if (nodePost.done) {
            return nodePost.node;
          } else {
            return treePostProcessFromProofNode(nodePost.node, childType);
          }
        } else {
          const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + "0", currentDepth + 1);
          const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + "1", currentDepth + 1);
          if (leftNode === node.left && rightNode === node.right) {
            return node;
          } else {
            return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);
          }
        }
      }
    }
    exports.treePostProcessFromProofNode = treePostProcessFromProofNode;
    function bitstringToIndex(bitstring) {
      if (bitstring === "")
        return 0;
      return parseInt(bitstring, 2);
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/abstract.js
var require_abstract = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/abstract.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = void 0;
    var Type = class {
      /** INTERNAL METHOD: Merkleize value to tree */
      value_toTree(value) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      /** INTERNAL METHOD: Un-merkleize tree to value */
      tree_toValue(node) {
        const uint8Array = new Uint8Array(this.tree_serializedSize(node));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.tree_serializeToBytes({ uint8Array, dataView }, 0, node);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      /** Serialize a value to binary data */
      serialize(value) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return uint8Array;
      }
      /** Deserialize binary data to value */
      deserialize(uint8Array) {
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
    };
    exports.Type = Type;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/composite.js
var require_composite = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/composite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var byteArray_1 = require_byteArray();
    var merkleize_1 = require_merkleize();
    var treePostProcessFromProofNode_1 = require_treePostProcessFromProofNode();
    var abstract_1 = require_abstract();
    exports.LENGTH_GINDEX = BigInt(3);
    var symbolCachedPermanentRoot = Symbol("ssz_cached_permanent_root");
    var CompositeType = class extends abstract_1.Type {
      constructor(cachePermanentRootStruct) {
        super();
        this.cachePermanentRootStruct = cachePermanentRootStruct;
        this.isBasic = false;
      }
      /** New instance of a recursive zero'ed value converted to Tree View */
      defaultView() {
        return this.toView(this.defaultValue());
      }
      /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */
      defaultViewDU() {
        return this.toViewDU(this.defaultValue());
      }
      /**
       * Deserialize binary data to a Tree View.
       * @see {@link CompositeType.getView}
       */
      deserializeToView(data) {
        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
      }
      /**
       * Deserialize binary data to a Deferred Update Tree View.
       * @see {@link CompositeType.getViewDU}
       */
      deserializeToViewDU(data) {
        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);
        return this.getViewDU(node);
      }
      /**
       * Transform value to a View.
       * @see {@link CompositeType.getView}
       */
      toView(value) {
        const node = this.value_toTree(value);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
      }
      /**
       * Transform value to a ViewDU.
       * @see {@link CompositeType.getViewDU}
       */
      toViewDU(value) {
        const node = this.value_toTree(value);
        return this.getViewDU(node);
      }
      /**
       * Transform value to a View.
       * @see {@link CompositeType.getView}
       */
      toValueFromView(view) {
        const node = this.commitView(view);
        return this.tree_toValue(node);
      }
      /**
       * Transform value to a ViewDU.
       * @see {@link CompositeType.getViewDU}
       */
      toValueFromViewDU(view) {
        const node = this.commitViewDU(view);
        return this.tree_toValue(node);
      }
      /**
       * Transform a ViewDU to a View.
       * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}
       */
      toViewFromViewDU(view) {
        const node = this.commitViewDU(view);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
      }
      /**
       * Transform a View to a ViewDU.
       * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}
       */
      toViewDUFromView(view) {
        const node = this.commitView(view);
        return this.getViewDU(node);
      }
      // Merkleize API
      hashTreeRoot(value) {
        if (this.cachePermanentRootStruct) {
          const cachedRoot = value[symbolCachedPermanentRoot];
          if (cachedRoot) {
            return cachedRoot;
          }
        }
        const root = merkleize_1.merkleize(this.getRoots(value), this.maxChunkCount);
        if (this.cachePermanentRootStruct) {
          value[symbolCachedPermanentRoot] = root;
        }
        return root;
      }
      // For debugging and testing this feature
      getCachedPermanentRoot(value) {
        return value[symbolCachedPermanentRoot];
      }
      // Proofs API
      /**
       * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.
       * @see {@link CompositeType.getView}
       */
      createFromProof(proof, root) {
        const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;
        const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);
        if (root !== void 0 && !byteArray_1.byteArrayEquals(rootNode.root, root)) {
          throw new Error("Proof does not match trusted root");
        }
        return this.getView(new persistent_merkle_tree_1.Tree(rootNode));
      }
      /** INTERNAL METHOD: For view's API, create proof from a tree */
      tree_createProof(node, jsonPaths) {
        const gindexes = this.tree_createProofGindexes(node, jsonPaths);
        return persistent_merkle_tree_1.createProof(node, {
          type: persistent_merkle_tree_1.ProofType.treeOffset,
          gindices: gindexes
        });
      }
      /** INTERNAL METHOD: For view's API, create proof from a tree */
      tree_createProofGindexes(node, jsonPaths) {
        const gindexes = [];
        for (const jsonPath of jsonPaths) {
          const { type, gindex } = this.getPathInfo(jsonPath);
          if (!isCompositeType(type)) {
            gindexes.push(gindex);
          } else {
            const leafGindexes = type.tree_getLeafGindices(gindex, type.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : void 0);
            for (const gindex2 of leafGindexes) {
              gindexes.push(gindex2);
            }
          }
        }
        return gindexes;
      }
      /**
       * Navigate to a subtype & gindex using a path
       */
      getPathInfo(path) {
        const gindices = [];
        let type = this;
        for (const prop of path) {
          if (type.isBasic) {
            throw new Error("Invalid path: cannot navigate beyond a basic type");
          }
          const gindex = type.getPropertyGindex(prop);
          if (gindex !== null) {
            gindices.push(gindex);
            type = type.getPropertyType(prop);
          }
        }
        return {
          type,
          gindex: persistent_merkle_tree_1.concatGindices(gindices)
        };
      }
      /**
       * INTERNAL METHOD: post process `Ǹode` instance created from a proof and return either the same node,
       * and a new node representing the same data is a different `Node` instance. Currently used exclusively
       * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.
       */
      tree_fromProofNode(node) {
        return { node, done: false };
      }
    };
    exports.CompositeType = CompositeType;
    function isCompositeType(type) {
      return !type.isBasic;
    }
    exports.isCompositeType = isCompositeType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/abstract.js
var require_abstract2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/abstract.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var TreeView = class {
      /** Serialize view to binary data */
      serialize() {
        const output = new Uint8Array(this.type.tree_serializedSize(this.node));
        const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);
        this.type.tree_serializeToBytes({ uint8Array: output, dataView }, 0, this.node);
        return output;
      }
      /**
       * Merkleize view and compute its hashTreeRoot.
       *
       * See spec for definition of hashTreeRoot:
       * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization
       */
      hashTreeRoot() {
        return this.node.root;
      }
      /**
       * Create a Merkle multiproof on this view's data.
       * A `path` is an array of 'JSON' paths into the data
       * @example
       * ```ts
       * state.createProof([
       *   ["validators", 1234, "slashed"],
       *   ["genesisTime"]
       * ])
       * ```
       *
       * See spec for definition of merkle multiproofs:
       * https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs
       */
      createProof(paths) {
        return this.type.tree_createProof(this.node, paths);
      }
      /**
       * Transform the view into a value, from the current node instance.
       * For ViewDU returns the value of the committed data, so call .commit() before if there are pending changes.
       */
      toValue() {
        return this.type.tree_toValue(this.node);
      }
      /** Return a new Tree View instance referencing the same internal `Node`. Drops its existing `Tree` hook if any */
      clone() {
        return this.type.getView(new persistent_merkle_tree_1.Tree(this.node));
      }
    };
    exports.TreeView = TreeView;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/bitArray.js
var require_bitArray2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitArrayTreeView = void 0;
    var abstract_1 = require_abstract2();
    var BitArrayTreeView = class extends abstract_1.TreeView {
      constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
        this.bitArray = type.tree_toValue(tree.rootNode);
      }
      get node() {
        return this.tree.rootNode;
      }
      // Wrapped API from BitArray
      /** @see BitArray.uint8Array */
      get uint8Array() {
        return this.bitArray.uint8Array;
      }
      /** @see BitArray.bitLen */
      get bitLen() {
        return this.bitArray.bitLen;
      }
      /** @see BitArray.get */
      get(bitIndex) {
        return this.bitArray.get(bitIndex);
      }
      /** @see BitArray.set */
      set(bitIndex, bit) {
        this.bitArray.set(bitIndex, bit);
        this.tree.rootNode = this.type.value_toTree(this.bitArray);
      }
      /** @see BitArray.mergeOrWith */
      mergeOrWith(bitArray2) {
        this.bitArray.mergeOrWith(bitArray2);
      }
      /** @see BitArray.intersectValues */
      intersectValues(values) {
        return this.bitArray.intersectValues(values);
      }
      /** @see BitArray.getTrueBitIndexes */
      getTrueBitIndexes() {
        return this.bitArray.getTrueBitIndexes();
      }
      /** @see BitArray.getSingleTrueBit */
      getSingleTrueBit() {
        return this.bitArray.getSingleTrueBit();
      }
      /** @see BitArray.toBoolArray */
      toBoolArray() {
        return this.bitArray.toBoolArray();
      }
    };
    exports.BitArrayTreeView = BitArrayTreeView;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/abstract.js
var require_abstract3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/abstract.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeViewDU = void 0;
    var abstract_1 = require_abstract2();
    var TreeViewDU = class extends abstract_1.TreeView {
      /**
       * Merkleize view and compute its hashTreeRoot.
       * Commits any pending changes before computing the root.
       *
       * See spec for definition of hashTreeRoot:
       * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization
       */
      hashTreeRoot() {
        this.commit();
        return super.hashTreeRoot();
      }
      /**
       * Serialize view to binary data.
       * Commits any pending changes before computing the root.
       */
      serialize() {
        this.commit();
        return super.serialize();
      }
      /**
       * Return a new ViewDU instance referencing the same internal `Node`.
       *
       * By default it will transfer the cache of this ViewDU to the new cloned instance. Set `dontTransferCache` to true
       * to NOT transfer the cache to the cloned instance.
       */
      clone(dontTransferCache) {
        if (dontTransferCache) {
          return this.type.getViewDU(this.node);
        } else {
          const cache = this.cache;
          this.clearCache();
          return this.type.getViewDU(this.node, cache);
        }
      }
    };
    exports.TreeViewDU = TreeViewDU;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/bitArray.js
var require_bitArray3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitArrayTreeViewDU = void 0;
    var abstract_1 = require_abstract3();
    var BitArrayTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type, _rootNode) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        this._bitArray = null;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return;
      }
      commit() {
        if (this._bitArray !== null) {
          this._rootNode = this.type.value_toTree(this._bitArray);
        }
      }
      // Wrapped API from BitArray
      /** @see BitArray.uint8Array */
      get uint8Array() {
        return this.bitArray.uint8Array;
      }
      /** @see BitArray.bitLen */
      get bitLen() {
        return this.bitArray.bitLen;
      }
      /** @see BitArray.get */
      get(bitIndex) {
        return this.bitArray.get(bitIndex);
      }
      /** @see BitArray.set */
      set(bitIndex, bit) {
        this.bitArray.set(bitIndex, bit);
      }
      /** @see BitArray.mergeOrWith */
      mergeOrWith(bitArray2) {
        this.bitArray.mergeOrWith(bitArray2);
      }
      /** @see BitArray.intersectValues */
      intersectValues(values) {
        return this.bitArray.intersectValues(values);
      }
      /** @see BitArray.getTrueBitIndexes */
      getTrueBitIndexes() {
        return this.bitArray.getTrueBitIndexes();
      }
      /** @see BitArray.getSingleTrueBit */
      getSingleTrueBit() {
        return this.bitArray.getSingleTrueBit();
      }
      /** @see BitArray.toBoolArray */
      toBoolArray() {
        return this.bitArray.toBoolArray();
      }
      /** Lazily computed bitArray instance */
      get bitArray() {
        if (this._bitArray === null) {
          this._bitArray = this.type.tree_toValue(this._rootNode);
        }
        return this._bitArray;
      }
      clearCache() {
        this._bitArray = null;
      }
    };
    exports.BitArrayTreeViewDU = BitArrayTreeViewDU;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/bitArray.js
var require_bitArray4 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitArrayType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var byteArray_1 = require_byteArray();
    var merkleize_1 = require_merkleize();
    var composite_1 = require_composite();
    var bitArray_1 = require_bitArray2();
    var bitArray_2 = require_bitArray3();
    var BitArrayType = class extends composite_1.CompositeType {
      constructor() {
        super(...arguments);
        this.isViewMutable = true;
      }
      getView(tree) {
        return new bitArray_1.BitArrayTreeView(this, tree);
      }
      getViewDU(node) {
        return new bitArray_2.BitArrayTreeViewDU(this, node);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Merkleization
      getRoots(value) {
        return merkleize_1.splitIntoRootChunks(value.uint8Array);
      }
      // Proofs
      getPropertyGindex() {
        return null;
      }
      getPropertyType() {
        throw Error("Must only request BitArray complete data");
      }
      getIndexProperty() {
        throw Error("Must only request BitArray complete data");
      }
      tree_fromProofNode(node) {
        return { node, done: true };
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        const byteLen = this.tree_getByteLen(rootNode);
        const chunkCount = Math.ceil(byteLen / 32);
        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
        const gindices = new Array(chunkCount);
        for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {
          gindices[i] = gindex;
        }
        if (this.isList) {
          gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        const uint8Array = byteArray_1.fromHexString(json);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      toJson(value) {
        return byteArray_1.toHexString(this.serialize(value));
      }
      clone(value) {
        return value.clone();
      }
      equals(a, b) {
        return a.bitLen === b.bitLen && byteArray_1.byteArrayEquals(a.uint8Array, b.uint8Array);
      }
    };
    exports.BitArrayType = BitArrayType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/bitList.js
var require_bitList = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/bitList.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitListType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var bitArray_1 = require_bitArray();
    var bitArray_2 = require_bitArray4();
    var BitListType = class extends bitArray_2.BitArrayType {
      constructor(limitBits, opts) {
        super();
        this.limitBits = limitBits;
        this.fixedSize = null;
        this.minSize = 1;
        this.isList = true;
        if (limitBits === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `BitList[${limitBits}]`;
        this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = 1 + this.chunkDepth;
        this.maxSize = Math.ceil(limitBits / 8) + 1;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);
      }
      defaultValue() {
        return bitArray_1.BitArray.fromBitLen(0);
      }
      // Views: inherited from BitArrayType
      // Serialization + deserialization
      value_serializedSize(value) {
        return bitLenToSerializedLength(value.bitLen);
      }
      value_serializeToBytes(output, offset, value) {
        output.uint8Array.set(value.uint8Array, offset);
        return applyPaddingBit(output.uint8Array, offset, value.bitLen);
      }
      value_deserializeFromBytes(data, start, end) {
        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);
        return new bitArray_1.BitArray(uint8Array, bitLen);
      }
      tree_serializedSize(node) {
        return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);
        const bitLen = arrayBasic_1.getLengthFromRootNode(node);
        const byteLen = Math.ceil(bitLen / 8);
        const chunkLen = Math.ceil(byteLen / 32);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);
        return applyPaddingBit(output.uint8Array, offset, bitLen);
      }
      tree_deserializeFromBytes(data, start, end) {
        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);
        return arrayBasic_1.addLengthNode(chunksNode, bitLen);
      }
      tree_getByteLen(node) {
        if (!node)
          throw new Error("BitListType requires a node to get leaves");
        return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);
      }
      // Merkleization: inherited from BitArrayType
      hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);
      }
      // Proofs: inherited from BitArrayType
      // JSON: inherited from BitArrayType
      // Deserializer helpers
      deserializeUint8ArrayBitListFromBytes(data, start, end) {
        const { uint8Array, bitLen } = deserializeUint8ArrayBitListFromBytes(data, start, end);
        if (bitLen > this.limitBits) {
          throw Error(`bitLen over limit ${bitLen} > ${this.limitBits}`);
        }
        return { uint8Array, bitLen };
      }
    };
    exports.BitListType = BitListType;
    function deserializeUint8ArrayBitListFromBytes(data, start, end) {
      if (end > data.length) {
        throw Error(`BitList attempting to read byte ${end} of data length ${data.length}`);
      }
      const lastByte = data[end - 1];
      const size = end - start;
      if (lastByte === 0) {
        throw new Error("Invalid deserialized bitlist, padding bit required");
      }
      if (lastByte === 1) {
        const uint8Array2 = Uint8Array.prototype.slice.call(data, start, end - 1);
        const bitLen2 = (size - 1) * 8;
        return { uint8Array: uint8Array2, bitLen: bitLen2 };
      }
      const uint8Array = Uint8Array.prototype.slice.call(data, start, end);
      const lastByteBitLength = lastByte.toString(2).length - 1;
      const bitLen = (size - 1) * 8 + lastByteBitLength;
      const mask = 255 >> 8 - lastByteBitLength;
      uint8Array[size - 1] &= mask;
      return { uint8Array, bitLen };
    }
    function bitLenToSerializedLength(bitLen) {
      const bytes = Math.ceil(bitLen / 8);
      return bitLen % 8 === 0 ? bytes + 1 : bytes;
    }
    function applyPaddingBit(output, offset, bitLen) {
      const byteLen = Math.ceil(bitLen / 8);
      const newOffset = offset + byteLen;
      if (bitLen % 8 === 0) {
        output[newOffset] = 1;
        return newOffset + 1;
      } else {
        output[newOffset - 1] |= 1 << bitLen % 8;
        return newOffset;
      }
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/bitVector.js
var require_bitVector = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/bitVector.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitVectorType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var bitArray_1 = require_bitArray();
    var bitArray_2 = require_bitArray4();
    var BitVectorType = class extends bitArray_2.BitArrayType {
      constructor(lengthBits, opts) {
        super();
        this.lengthBits = lengthBits;
        this.isList = false;
        if (lengthBits === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `BitVector[${lengthBits}]`;
        this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);
        this.maxChunkCount = this.chunkCount;
        this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);
        this.fixedSize = Math.ceil(this.lengthBits / 8);
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
        this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 255 & 255 << lengthBits % 8;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);
      }
      defaultValue() {
        return bitArray_1.BitArray.fromBitLen(this.lengthBits);
      }
      // Views: inherited from BitArrayType
      // Serialization + deserialization
      value_serializedSize() {
        return this.fixedSize;
      }
      value_serializeToBytes(output, offset, value) {
        output.uint8Array.set(value.uint8Array, offset);
        return offset + this.fixedSize;
      }
      value_deserializeFromBytes(data, start, end) {
        this.assertValidLength(data.uint8Array, start, end);
        return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);
      }
      tree_serializedSize() {
        return this.fixedSize;
      }
      tree_serializeToBytes(output, offset, node) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);
        return offset + this.fixedSize;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidLength(data.uint8Array, start, end);
        return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);
      }
      tree_getByteLen() {
        return this.fixedSize;
      }
      // Merkleization: inherited from BitArrayType
      // Proofs: inherited from BitArrayType
      // JSON: inherited from BitArrayType
      // Deserializer helpers
      assertValidLength(data, start, end) {
        const size = end - start;
        if (end - start !== this.fixedSize) {
          throw Error(`Invalid BitVector size ${size} != ${this.fixedSize}`);
        }
        if (
          // If zeroBitsMask == 0, then the BitVector uses full bytes only
          this.zeroBitsMask > 0 && // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed
          (data[end - 1] & this.zeroBitsMask) > 0
        ) {
          throw Error("BitVector: nonzero bits past length");
        }
      }
    };
    exports.BitVectorType = BitVectorType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/basic.js
var require_basic = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/basic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBasicType = exports.BasicType = void 0;
    var abstract_1 = require_abstract();
    var BasicType = class extends abstract_1.Type {
      constructor() {
        super(...arguments);
        this.isBasic = true;
        this.depth = 0;
        this.maxChunkCount = 1;
      }
      value_serializedSize() {
        return this.byteLength;
      }
      tree_serializedSize() {
        return this.byteLength;
      }
      assertValidSize(size) {
        if (size !== this.byteLength) {
          throw Error(`BasicType invalid size ${size} expected ${this.byteLength}`);
        }
      }
      hashTreeRoot(value) {
        const uint8Array = new Uint8Array(32);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return uint8Array;
      }
      clone(value) {
        return value;
      }
      equals(a, b) {
        return a === b;
      }
    };
    exports.BasicType = BasicType;
    function isBasicType(type) {
      return type.isBasic;
    }
    exports.isBasicType = isBasicType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/boolean.js
var require_boolean = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/boolean.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var named_1 = require_named();
    var basic_1 = require_basic();
    var BooleanType = class extends basic_1.BasicType {
      constructor(opts) {
        super();
        this.byteLength = 1;
        this.itemsPerChunk = 32;
        this.fixedSize = 1;
        this.minSize = 1;
        this.maxSize = 1;
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? "boolean";
      }
      static named(opts) {
        return new (named_1.namedClass(BooleanType, opts.typeName))(opts);
      }
      defaultValue() {
        return false;
      }
      // Serialization + deserialization
      value_serializeToBytes(output, offset, value) {
        output.uint8Array[offset] = value ? 1 : 0;
        return offset + 1;
      }
      value_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        switch (data.uint8Array[start]) {
          case 1:
            return true;
          case 0:
            return false;
          default:
            throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);
        }
      }
      tree_serializeToBytes(output, offset, node) {
        output.uint8Array[offset] = node.getUint(4, 0);
        return offset + 1;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const value = data.uint8Array[start];
        if (value > 1) {
          throw Error(`Boolean: invalid value ${value}`);
        }
        return persistent_merkle_tree_1.LeafNode.fromUint32(value);
      }
      // Fast tree opts
      tree_getFromNode(leafNode) {
        return leafNode.getUint(4, 0) === 1;
      }
      tree_setToNode(leafNode, value) {
        leafNode.setUint(4, 0, value ? 1 : 0);
      }
      tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = index % this.itemsPerChunk;
        return leafNode.getUint(1, offsetBytes) !== 0;
      }
      tree_setToPackedNode(leafNode, index, value) {
        const offsetBytes = index % this.itemsPerChunk;
        leafNode.setUint(1, offsetBytes, value ? 1 : 0);
      }
      // JSON
      fromJson(json) {
        if (typeof json !== "boolean") {
          throw Error(`JSON invalid type ${typeof json} expected boolean`);
        }
        return json;
      }
      toJson(value) {
        return value;
      }
    };
    exports.BooleanType = BooleanType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/byteArray.js
var require_byteArray2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/byteArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteArrayType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var byteArray_1 = require_byteArray();
    var merkleize_1 = require_merkleize();
    var composite_1 = require_composite();
    var ByteArrayType = class extends composite_1.CompositeType {
      constructor() {
        super(...arguments);
        this.isViewMutable = false;
      }
      defaultValue() {
        return new Uint8Array(this.minSize);
      }
      getView(tree) {
        return this.getViewDU(tree.rootNode);
      }
      getViewDU(node) {
        return this.tree_toValue(node);
      }
      commitView(view) {
        return this.commitViewDU(view);
      }
      commitViewDU(view) {
        const uint8Array = new Uint8Array(this.value_serializedSize(view));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, view);
        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      cacheOfViewDU() {
        return;
      }
      // Over-write to prevent serialize + deserialize
      toView(value) {
        return value;
      }
      toViewDU(value) {
        return value;
      }
      // Serialization + deserialization (only value is generic)
      value_serializeToBytes(output, offset, value) {
        output.uint8Array.set(value, offset);
        return offset + value.length;
      }
      value_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        return Uint8Array.prototype.slice.call(data.uint8Array, start, end);
      }
      // Merkleization
      getRoots(value) {
        return merkleize_1.splitIntoRootChunks(value);
      }
      // Proofs
      getPropertyGindex() {
        return null;
      }
      getPropertyType() {
        throw Error("Must only request ByteArray complete data");
      }
      getIndexProperty() {
        throw Error("Must only request ByteArray complete data");
      }
      tree_fromProofNode(node) {
        return { node, done: true };
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        const byteLen = this.tree_getByteLen(rootNode);
        const chunkCount = Math.ceil(byteLen / 32);
        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
        const gindices = new Array(chunkCount);
        for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {
          gindices[i] = gindex;
        }
        if (this.isList) {
          gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        const value = byteArray_1.fromHexString(json);
        this.assertValidSize(value.length);
        return value;
      }
      toJson(value) {
        return byteArray_1.toHexString(value);
      }
      // ByteArray is immutable
      clone(value) {
        return value;
      }
      equals(a, b) {
        return byteArray_1.byteArrayEquals(a, b);
      }
    };
    exports.ByteArrayType = ByteArrayType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/byteList.js
var require_byteList = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/byteList.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteListType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var byteArray_1 = require_byteArray2();
    var ByteListType = class extends byteArray_1.ByteArrayType {
      constructor(limitBytes, opts) {
        super();
        this.limitBytes = limitBytes;
        this.fixedSize = null;
        this.isList = true;
        if (limitBytes === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `ByteList[${limitBytes}]`;
        this.maxChunkCount = Math.ceil(this.limitBytes / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = 1 + this.chunkDepth;
        this.minSize = 0;
        this.maxSize = this.limitBytes;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(ByteListType, opts.typeName))(limitBits, opts);
      }
      // Views: inherited from ByteArrayType
      // Serialization + deserialization
      value_serializedSize(value) {
        return value.length;
      }
      // value_* inherited from ByteArrayType
      tree_serializedSize(node) {
        return arrayBasic_1.getLengthFromRootNode(node);
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);
        const byteLen = arrayBasic_1.getLengthFromRootNode(node);
        const chunkLen = Math.ceil(byteLen / 32);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);
        return offset + byteLen;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);
        return arrayBasic_1.addLengthNode(chunksNode, end - start);
      }
      tree_getByteLen(node) {
        if (!node)
          throw new Error("ByteListType requires a node to get leaves");
        return arrayBasic_1.getLengthFromRootNode(node);
      }
      // Merkleization: inherited from ByteArrayType
      hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);
      }
      // Proofs: inherited from BitArrayType
      // JSON: inherited from ByteArrayType
      assertValidSize(size) {
        if (size > this.limitBytes) {
          throw Error(`ByteList invalid size ${size} limit ${this.limitBytes}`);
        }
      }
    };
    exports.ByteListType = ByteListType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/byteVector.js
var require_byteVector = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/byteVector.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteVectorType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var byteArray_1 = require_byteArray2();
    var ByteVectorType = class extends byteArray_1.ByteArrayType {
      constructor(lengthBytes, opts) {
        super();
        this.lengthBytes = lengthBytes;
        this.isList = false;
        if (lengthBytes === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `ByteVector[${lengthBytes}]`;
        this.maxChunkCount = Math.ceil(this.lengthBytes / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = this.lengthBytes;
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);
      }
      // Views: inherited from ByteArrayType
      // Serialization + deserialization
      value_serializedSize() {
        return this.fixedSize;
      }
      // value_* inherited from ByteArrayType
      tree_serializedSize() {
        return this.fixedSize;
      }
      tree_serializeToBytes(output, offset, node) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);
        return offset + this.fixedSize;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);
      }
      tree_getByteLen() {
        return this.lengthBytes;
      }
      // Merkleization: inherited from ByteArrayType
      // Proofs: inherited from BitArrayType
      // JSON: inherited from ByteArrayType
      assertValidSize(size) {
        if (size !== this.lengthBytes) {
          throw Error(`ByteVector invalid size ${size} expected ${this.lengthBytes}`);
        }
      }
    };
    exports.ByteVectorType = ByteVectorType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/container.js
var require_container = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/container.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewClass = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var basic_1 = require_basic();
    var composite_1 = require_composite();
    var abstract_1 = require_abstract2();
    var ContainerTreeView = class extends abstract_1.TreeView {
      constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
      }
      get node() {
        return this.tree.rootNode;
      }
    };
    function getContainerTreeViewClass(type) {
      class CustomContainerTreeView extends ContainerTreeView {
      }
      for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        if (basic_1.isBasicType(fieldType)) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              const leafNode = persistent_merkle_tree_1.getNodeAtDepth(this.node, this.type.depth, index);
              return fieldType.tree_getFromNode(leafNode);
            },
            set: function(value) {
              const leafNodePrev = persistent_merkle_tree_1.getNodeAtDepth(this.node, this.type.depth, index);
              const leafNode = leafNodePrev.clone();
              fieldType.tree_setToNode(leafNode, value);
              this.tree.setNodeAtDepth(this.type.depth, index, leafNode);
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeView of fieldName
            get: function() {
              const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
              return fieldType.getView(this.tree.getSubtree(gindex));
            },
            // Expects TreeView of fieldName
            set: function(value) {
              const node = fieldType.commitView(value);
              this.tree.setNodeAtDepth(this.type.depth, index, node);
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeView, "name", { value: type.typeName, writable: false });
      return CustomContainerTreeView;
    }
    exports.getContainerTreeViewClass = getContainerTreeViewClass;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/container.js
var require_container2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/container.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewDUClass = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var basic_1 = require_basic();
    var composite_1 = require_composite();
    var abstract_1 = require_abstract3();
    var ContainerTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type, _rootNode, cache) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        this.nodes = [];
        this.nodesChanged = /* @__PURE__ */ new Set();
        this.viewsChanged = /* @__PURE__ */ new Map();
        if (cache) {
          this.nodes = cache.nodes;
          this.caches = cache.caches;
          this.nodesPopulated = cache.nodesPopulated;
        } else {
          this.nodes = [];
          this.caches = [];
          this.nodesPopulated = false;
        }
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return {
          nodes: this.nodes,
          caches: this.caches,
          nodesPopulated: this.nodesPopulated
        };
      }
      commit() {
        if (this.nodesChanged.size === 0 && this.viewsChanged.size === 0) {
          return;
        }
        const nodesChanged = [];
        for (const [index, view] of this.viewsChanged) {
          const fieldType = this.type.fieldsEntries[index].fieldType;
          const node = fieldType.commitViewDU(view);
          this.nodes[index] = node;
          nodesChanged.push({ index, node });
          const cache = fieldType.cacheOfViewDU(view);
          if (cache)
            this.caches[index] = cache;
        }
        for (const index of this.nodesChanged) {
          nodesChanged.push({ index, node: this.nodes[index] });
        }
        const nodesChangedSorted = nodesChanged.sort((a, b) => a.index - b.index);
        const indexes = nodesChangedSorted.map((entry) => entry.index);
        const nodes = nodesChangedSorted.map((entry) => entry.node);
        this._rootNode = persistent_merkle_tree_1.setNodesAtDepth(this._rootNode, this.type.depth, indexes, nodes);
        this.nodesChanged.clear();
        this.viewsChanged.clear();
      }
      clearCache() {
        this.nodes = [];
        this.caches = [];
        this.nodesPopulated = false;
        this.nodesChanged.clear();
        this.viewsChanged.clear();
      }
    };
    function getContainerTreeViewDUClass(type) {
      class CustomContainerTreeViewDU extends ContainerTreeViewDU {
      }
      for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        if (basic_1.isBasicType(fieldType)) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              let node = this.nodes[index];
              if (node === void 0) {
                node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                this.nodes[index] = node;
              }
              return fieldType.tree_getFromNode(node);
            },
            set: function(value) {
              let nodeChanged;
              if (this.nodesChanged.has(index)) {
                nodeChanged = this.nodes[index];
              } else {
                const nodePrev = this.nodes[index] ?? persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                nodeChanged = nodePrev.clone();
                this.nodes[index] = nodeChanged;
                this.nodesChanged.add(index);
              }
              fieldType.tree_setToNode(nodeChanged, value);
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeViewDU of fieldName
            get: function() {
              const viewChanged = this.viewsChanged.get(index);
              if (viewChanged) {
                return viewChanged;
              }
              let node = this.nodes[index];
              if (node === void 0) {
                node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                this.nodes[index] = node;
              }
              const view = fieldType.getViewDU(node, this.caches[index]);
              if (fieldType.isViewMutable) {
                this.viewsChanged.set(index, view);
              }
              return view;
            },
            // Expects TreeViewDU of fieldName
            set: function(view) {
              this.viewsChanged.set(index, view);
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeViewDU, "name", { value: type.typeName, writable: false });
      return CustomContainerTreeViewDU;
    }
    exports.getContainerTreeViewDUClass = getContainerTreeViewDUClass;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/strings.js
var require_strings = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/util/strings.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Case = void 0;
    exports.Case = {
      snake: (field) => field.replace(/[^0-z]/g, "").replace(/[a-z][A-Z]|[0-9][A-Z]/g, (substr) => substr[0] + "_" + substr[1].toLowerCase()),
      constant: (field) => field.replace(/[^0-z]/g, "").replace(/[a-z][A-Z]|[0-9][A-Z]/g, (substr) => substr[0] + "_" + substr[1]).toUpperCase(),
      pascal: (field) => {
        const first = field[0].toUpperCase();
        return (first + field.slice(1)).replace(/[^0-z]/g, "");
      },
      camel: (field) => {
        return field[0].toLowerCase() + field.slice(1);
      },
      header: (field) => {
        const first = field[0].toUpperCase();
        return first + field.slice(1).replace(/[^0-z]/g, "").replace(/[a-z][A-Z]|[0-9][A-Z]/g, (substr) => substr[0] + "-" + substr[1]);
      },
      eth2: (field) => exports.Case.snake(field).replace(/(\d)$/, "_$1")
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/container.js
var require_container3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/container.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var composite_1 = require_composite();
    var container_1 = require_container();
    var container_2 = require_container2();
    var strings_1 = require_strings();
    var ContainerType = class extends composite_1.CompositeType {
      constructor(fields, opts) {
        var _a, _b;
        super(opts == null ? void 0 : opts.cachePermanentRootStruct);
        this.fields = fields;
        this.opts = opts;
        this.isList = false;
        this.isViewMutable = true;
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? renderContainerTypeName(fields);
        this.maxChunkCount = Object.keys(fields).length;
        this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.fieldsEntries = [];
        for (const fieldName of Object.keys(fields)) {
          this.fieldsEntries.push({
            fieldName,
            fieldType: this.fields[fieldName],
            jsonKey: precomputeJsonKey(fieldName, opts == null ? void 0 : opts.casingMap, opts == null ? void 0 : opts.jsonCase),
            gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length))
          });
        }
        if (this.fieldsEntries.length === 0) {
          throw Error("Container must have > 0 fields");
        }
        this.fieldsGindex = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));
        }
        this.jsonKeyToFieldName = {};
        for (const { fieldName, jsonKey } of this.fieldsEntries) {
          this.jsonKeyToFieldName[jsonKey] = fieldName;
        }
        const { minLen, maxLen, fixedSize } = precomputeSizes(fields);
        this.minSize = minLen;
        this.maxSize = maxLen;
        this.fixedSize = fixedSize;
        const { isFixedLen, fieldRangesFixedLen, variableOffsetsPosition, fixedEnd } = precomputeSerdesData(fields);
        this.isFixedLen = isFixedLen;
        this.fieldRangesFixedLen = fieldRangesFixedLen;
        this.variableOffsetsPosition = variableOffsetsPosition;
        this.fixedEnd = fixedEnd;
        this.TreeView = ((_a = opts == null ? void 0 : opts.getContainerTreeViewClass) == null ? void 0 : _a.call(opts, this)) ?? container_1.getContainerTreeViewClass(this);
        this.TreeViewDU = ((_b = opts == null ? void 0 : opts.getContainerTreeViewDUClass) == null ? void 0 : _b.call(opts, this)) ?? container_2.getContainerTreeViewDUClass(this);
      }
      static named(fields, opts) {
        return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);
      }
      defaultValue() {
        const value = {};
        for (const { fieldName, fieldType } of this.fieldsEntries) {
          value[fieldName] = fieldType.defaultValue();
        }
        return value;
      }
      getView(tree) {
        return new this.TreeView(this, tree);
      }
      getViewDU(node, cache) {
        return new this.TreeViewDU(this, node, cache);
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      // Serialization + deserialization
      // -------------------------------
      // Containers can mix fixed length and variable length data.
      //
      // Fixed part                         Variable part
      // [field1 offset][field2 data       ][field1 data               ]
      // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]
      value_serializedSize(value) {
        let totalSize = 0;
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType } = this.fieldsEntries[i];
          totalSize += fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;
        }
        return totalSize;
      }
      value_serializeToBytes(output, offset, value) {
        let fixedIndex = offset;
        let variableIndex = offset + this.fixedEnd;
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType } = this.fieldsEntries[i];
          if (fieldType.fixedSize === null) {
            output.dataView.setUint32(fixedIndex, variableIndex - offset, true);
            fixedIndex += 4;
            variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);
          } else {
            fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);
          }
        }
        return variableIndex;
      }
      value_deserializeFromBytes(data, start, end) {
        const fieldRanges = this.getFieldRanges(data.dataView, start, end);
        const value = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType } = this.fieldsEntries[i];
          const fieldRange = fieldRanges[i];
          value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);
        }
        return value;
      }
      tree_serializedSize(node) {
        let totalSize = 0;
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldType } = this.fieldsEntries[i];
          const node2 = nodes[i];
          totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node2) : fieldType.fixedSize;
        }
        return totalSize;
      }
      tree_serializeToBytes(output, offset, node) {
        let fixedIndex = offset;
        let variableIndex = offset + this.fixedEnd;
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldType } = this.fieldsEntries[i];
          const node2 = nodes[i];
          if (fieldType.fixedSize === null) {
            output.dataView.setUint32(fixedIndex, variableIndex - offset, true);
            fixedIndex += 4;
            variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node2);
          } else {
            fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node2);
          }
        }
        return variableIndex;
      }
      tree_deserializeFromBytes(data, start, end) {
        const fieldRanges = this.getFieldRanges(data.dataView, start, end);
        const nodes = new Array(this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldType } = this.fieldsEntries[i];
          const fieldRange = fieldRanges[i];
          nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);
        }
        return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);
      }
      // Merkleization
      getRoots(struct) {
        const roots = new Array(this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType } = this.fieldsEntries[i];
          roots[i] = fieldType.hashTreeRoot(struct[fieldName]);
        }
        return roots;
      }
      // Proofs
      // getPropertyGindex
      // getPropertyType
      // tree_getLeafGindices
      getPropertyGindex(prop) {
        const gindex = this.fieldsGindex[prop] ?? this.fieldsGindex[this.jsonKeyToFieldName[prop]];
        if (gindex === void 0)
          throw Error(`Unknown container property ${prop}`);
        return gindex;
      }
      getPropertyType(prop) {
        const type = this.fields[prop] ?? this.fields[this.jsonKeyToFieldName[prop]];
        if (type === void 0)
          throw Error(`Unknown container property ${prop}`);
        return type;
      }
      getIndexProperty(index) {
        if (index >= this.fieldsEntries.length) {
          return null;
        }
        return this.fieldsEntries[index].fieldName;
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        const gindices = [];
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType } = this.fieldsEntries[i];
          const fieldGindex = this.fieldsGindex[fieldName];
          const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);
          if (fieldType.isBasic) {
            gindices.push(fieldGindexFromRoot);
          } else {
            const compositeType = fieldType;
            if (fieldType.fixedSize === null) {
              if (!rootNode) {
                throw new Error("variable type requires tree argument to get leaves");
              }
              gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));
            } else {
              gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));
            }
          }
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        if (typeof json !== "object") {
          throw Error("JSON must be of type object");
        }
        if (json === null) {
          throw Error("JSON must not be null");
        }
        const value = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];
          const jsonValue = json[jsonKey];
          if (jsonValue === void 0) {
            throw Error(`JSON expected key ${jsonKey} is undefined`);
          }
          value[fieldName] = fieldType.fromJson(jsonValue);
        }
        return value;
      }
      toJson(value) {
        const json = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];
          json[jsonKey] = fieldType.toJson(value[fieldName]);
        }
        return json;
      }
      clone(value) {
        const newValue = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType } = this.fieldsEntries[i];
          newValue[fieldName] = fieldType.clone(value[fieldName]);
        }
        return newValue;
      }
      equals(a, b) {
        for (let i = 0; i < this.fieldsEntries.length; i++) {
          const { fieldName, fieldType } = this.fieldsEntries[i];
          if (!fieldType.equals(a[fieldName], b[fieldName])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.
       * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].
       * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen
       * - For variable size fields does a first pass over the fixed section to read offsets
       */
      getFieldRanges(data, start, end) {
        if (this.variableOffsetsPosition.length === 0) {
          const size = end - start;
          if (size !== this.fixedEnd) {
            throw Error(`${this.typeName} size ${size} not equal fixed size ${this.fixedEnd}`);
          }
          return this.fieldRangesFixedLen;
        }
        const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);
        offsets.push(end - start);
        let variableIdx = 0;
        let fixedIdx = 0;
        const fieldRanges = new Array(this.isFixedLen.length);
        for (let i = 0; i < this.isFixedLen.length; i++) {
          if (this.isFixedLen[i]) {
            fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];
          } else {
            fieldRanges[i] = { start: offsets[variableIdx], end: offsets[variableIdx + 1] };
            variableIdx++;
          }
        }
        return fieldRanges;
      }
    };
    exports.ContainerType = ContainerType;
    function readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {
      const size = end - start;
      const offsets = new Array(variableOffsetsPosition.length);
      for (let i = 0; i < variableOffsetsPosition.length; i++) {
        const offset = data.getUint32(start + variableOffsetsPosition[i], true);
        if (offset > size) {
          throw new Error(`Offset out of bounds ${offset} > ${size}`);
        }
        if (i === 0) {
          if (offset !== fixedEnd) {
            throw new Error(`First offset must equal to fixedEnd ${offset} != ${fixedEnd}`);
          }
        } else {
          if (offset < offsets[i - 1]) {
            throw new Error(`Offsets must be increasing ${offset} < ${offsets[i - 1]}`);
          }
        }
        offsets[i] = offset;
      }
      return offsets;
    }
    function precomputeSerdesData(fields) {
      const isFixedLen = [];
      const fieldRangesFixedLen = [];
      const variableOffsetsPosition = [];
      let pointerFixed = 0;
      for (const fieldType of Object.values(fields)) {
        isFixedLen.push(fieldType.fixedSize !== null);
        if (fieldType.fixedSize === null) {
          variableOffsetsPosition.push(pointerFixed);
          pointerFixed += 4;
        } else {
          fieldRangesFixedLen.push({ start: pointerFixed, end: pointerFixed + fieldType.fixedSize });
          pointerFixed += fieldType.fixedSize;
        }
      }
      return {
        isFixedLen,
        fieldRangesFixedLen,
        variableOffsetsPosition,
        fixedEnd: pointerFixed
      };
    }
    function precomputeSizes(fields) {
      let minLen = 0;
      let maxLen = 0;
      let fixedSize = 0;
      for (const fieldType of Object.values(fields)) {
        minLen += fieldType.minSize;
        maxLen += fieldType.maxSize;
        if (fieldType.fixedSize === null) {
          minLen += 4;
          maxLen += 4;
          fixedSize = null;
        } else if (fixedSize !== null) {
          fixedSize += fieldType.fixedSize;
        }
      }
      return { minLen, maxLen, fixedSize };
    }
    function precomputeJsonKey(fieldName, casingMap, jsonCase) {
      if (casingMap) {
        const keyFromCaseMap = casingMap[fieldName];
        if (keyFromCaseMap === void 0) {
          throw Error(`casingMap[${fieldName}] not defined`);
        }
        return keyFromCaseMap;
      } else if (jsonCase) {
        return strings_1.Case[jsonCase](fieldName);
      } else {
        return fieldName;
      }
    }
    exports.precomputeJsonKey = precomputeJsonKey;
    function renderContainerTypeName(fields, prefix = "Container") {
      const fieldNames = Object.keys(fields);
      const fieldTypeNames = fieldNames.map((fieldName) => `${fieldName}: ${fields[fieldName].typeName}`).join(", ");
      return `${prefix}({${fieldTypeNames}})`;
    }
    exports.renderContainerTypeName = renderContainerTypeName;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/branchNodeStruct.js
var require_branchNodeStruct = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/branchNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BranchNodeStruct = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var BranchNodeStruct = class extends persistent_merkle_tree_1.Node {
      constructor(valueToNode, value) {
        super(null, 0, 0, 0, 0, 0, 0, 0);
        this.valueToNode = valueToNode;
        this.value = value;
      }
      get rootHashObject() {
        if (this.h0 === null) {
          const node = this.valueToNode(this.value);
          super.applyHash(node.rootHashObject);
        }
        return this;
      }
      get root() {
        return persistent_merkle_tree_1.hashObjectToUint8Array(this.rootHashObject);
      }
      isLeaf() {
        return false;
      }
      get left() {
        return this.valueToNode(this.value).left;
      }
      get right() {
        return this.valueToNode(this.value).right;
      }
    };
    exports.BranchNodeStruct = BranchNodeStruct;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/containerNodeStruct.js
var require_containerNodeStruct = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/containerNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewClass = void 0;
    var composite_1 = require_composite();
    var branchNodeStruct_1 = require_branchNodeStruct();
    var abstract_1 = require_abstract2();
    var ContainerTreeView = class extends abstract_1.TreeView {
      constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
      }
      get node() {
        return this.tree.rootNode;
      }
    };
    function getContainerTreeViewClass(type) {
      class CustomContainerTreeView extends ContainerTreeView {
      }
      for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        if (fieldType.isBasic) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              return this.tree.rootNode.value[fieldName];
            },
            set: function(value) {
              const node = this.tree.rootNode;
              const newNodeValue = this.type.clone(node.value);
              newNodeValue[fieldName] = value;
              this.tree.rootNode = new branchNodeStruct_1.BranchNodeStruct(node["valueToNode"], newNodeValue);
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeView of fieldName
            get: function() {
              const { value } = this.tree.rootNode;
              return fieldType.toView(value[fieldName]);
            },
            // Expects TreeView of fieldName
            set: function(view) {
              const node = this.tree.rootNode;
              const newNodeValue = this.type.clone(node.value);
              newNodeValue[fieldName] = fieldType.toValueFromView(view);
              this.tree.rootNode = new branchNodeStruct_1.BranchNodeStruct(node["valueToNode"], newNodeValue);
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeView, "name", { value: type.typeName, writable: false });
      return CustomContainerTreeView;
    }
    exports.getContainerTreeViewClass = getContainerTreeViewClass;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/containerNodeStruct.js
var require_containerNodeStruct2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/containerNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewDUClass = void 0;
    var composite_1 = require_composite();
    var abstract_1 = require_abstract3();
    var ContainerTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type, node) {
        super();
        this.type = type;
        this.valueChanged = null;
        this._rootNode = node;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return;
      }
      commit() {
        if (this.valueChanged === null) {
          return;
        }
        const value = this.valueChanged;
        this.valueChanged = null;
        this._rootNode = this.type.value_toTree(value);
      }
      clearCache() {
        this.valueChanged = null;
      }
    };
    function getContainerTreeViewDUClass(type) {
      class CustomContainerTreeViewDU extends ContainerTreeViewDU {
      }
      for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        if (fieldType.isBasic) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              return (this.valueChanged || this._rootNode.value)[fieldName];
            },
            set: function(value) {
              if (this.valueChanged === null) {
                this.valueChanged = this.type.clone(this._rootNode.value);
              }
              this.valueChanged[fieldName] = value;
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeViewDU of fieldName
            get: function() {
              const value = this.valueChanged || this._rootNode.value;
              return fieldType.toViewDU(value[fieldName]);
            },
            // Expects TreeViewDU of fieldName
            set: function(view) {
              if (this.valueChanged === null) {
                this.valueChanged = this.type.clone(this._rootNode.value);
              }
              const value = fieldType.toValueFromViewDU(view);
              this.valueChanged[fieldName] = value;
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeViewDU, "name", { value: type.typeName, writable: false });
      return CustomContainerTreeViewDU;
    }
    exports.getContainerTreeViewDUClass = getContainerTreeViewDUClass;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/containerNodeStruct.js
var require_containerNodeStruct3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/containerNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerNodeStructType = void 0;
    var composite_1 = require_composite();
    var container_1 = require_container3();
    var named_1 = require_named();
    var containerNodeStruct_1 = require_containerNodeStruct();
    var containerNodeStruct_2 = require_containerNodeStruct2();
    var branchNodeStruct_1 = require_branchNodeStruct();
    var ContainerNodeStructType = class extends container_1.ContainerType {
      constructor(fields, opts) {
        super(fields, {
          // Overwrite default "Container" typeName
          // Render detailed typeName. Consumers should overwrite since it can get long
          typeName: (opts == null ? void 0 : opts.typeName) ?? container_1.renderContainerTypeName(fields, "ContainerNodeStruct"),
          ...opts,
          getContainerTreeViewClass: containerNodeStruct_1.getContainerTreeViewClass,
          getContainerTreeViewDUClass: containerNodeStruct_2.getContainerTreeViewDUClass
        });
        this.fields = fields;
        for (const { fieldName, fieldType } of this.fieldsEntries) {
          if (composite_1.isCompositeType(fieldType) && fieldType.isViewMutable) {
            throw Error(`ContainerNodeStructType field '${fieldName}' ${fieldType.typeName} view is mutable`);
          }
        }
      }
      static named(fields, opts) {
        return new (named_1.namedClass(container_1.ContainerType, opts.typeName))(fields, opts);
      }
      tree_serializedSize(node) {
        return this.value_serializedSize(node.value);
      }
      tree_serializeToBytes(output, offset, node) {
        const { value } = node;
        return this.value_serializeToBytes(output, offset, value);
      }
      tree_deserializeFromBytes(data, start, end) {
        const value = this.value_deserializeFromBytes(data, start, end);
        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);
      }
      // Proofs
      // ContainerNodeStructType can only parse proofs that contain all the data.
      // TODO: Support converting a partial tree to a partial value
      getPropertyGindex() {
        return null;
      }
      // Post process tree to convert regular BranchNode to BranchNodeStruct
      // TODO: Optimize conversions
      tree_fromProofNode(node) {
        const uint8Array = new Uint8Array(super.tree_serializedSize(node));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        super.tree_serializeToBytes({ uint8Array, dataView }, 0, node);
        const value = this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
        return {
          node: new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value),
          done: true
        };
      }
      // Overwrites for fast conversion node <-> value
      tree_toValue(node) {
        return node.value;
      }
      value_toTree(value) {
        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);
      }
      // TODO: Optimize conversion
      valueToTree(value) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return super.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
    };
    exports.ContainerNodeStructType = ContainerNodeStructType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/arrayBasic.js
var require_arrayBasic2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/arrayBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayBasicTreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract2();
    var ArrayBasicTreeView = class extends abstract_1.TreeView {
      constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
      }
      /**
       * Number of elements in the array. Equal to the Uint32 value of the Tree's length node
       */
      get length() {
        return this.type.tree_getLength(this.tree.rootNode);
      }
      get node() {
        return this.tree.rootNode;
      }
      /**
       * Get element at `index`. Returns the Basic element type value directly
       */
      get(index) {
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        const leafNode = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);
        return this.type.elementType.tree_getFromPackedNode(leafNode, index);
      }
      /**
       * Set Basic element type `value` at `index`
       */
      set(index, value) {
        const length = this.length;
        if (index >= length) {
          throw Error(`Error setting index over length ${index} > ${length}`);
        }
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        const leafNodePrev = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);
        const leafNode = leafNodePrev.clone();
        this.type.elementType.tree_setToPackedNode(leafNode, index, value);
        this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);
      }
      /**
       * Get all values of this array as Basic element type values, from index zero to `this.length - 1`
       */
      getAll() {
        const length = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const chunkCount = Math.ceil(length / this.type.itemsPerChunk);
        const leafNodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);
        const values = new Array(length);
        const itemsPerChunk = this.type.itemsPerChunk;
        const lenFullNodes = Math.floor(length / itemsPerChunk);
        const remainder = length % itemsPerChunk;
        for (let n = 0; n < lenFullNodes; n++) {
          const leafNode = leafNodes[n];
          for (let i = 0; i < itemsPerChunk; i++) {
            values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
          }
        }
        if (remainder > 0) {
          const leafNode = leafNodes[lenFullNodes];
          for (let i = 0; i < remainder; i++) {
            values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
          }
        }
        return values;
      }
    };
    exports.ArrayBasicTreeView = ArrayBasicTreeView;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/listBasic.js
var require_listBasic = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/listBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListBasicTreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayBasic_1 = require_arrayBasic2();
    var ListBasicTreeView = class extends arrayBasic_1.ArrayBasicTreeView {
      constructor(type, tree) {
        super(type, tree);
        this.type = type;
        this.tree = tree;
      }
      /**
       * Adds one value element at the end of the array and adds 1 to the current Tree length.
       */
      push(value) {
        const length = this.length;
        if (length >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.type.tree_setLength(this.tree, length + 1);
        if (length % this.type.itemsPerChunk === 0) {
          const leafNode = persistent_merkle_tree_1.LeafNode.fromZero();
          this.type.elementType.tree_setToPackedNode(leafNode, length, value);
          const chunkIndex = Math.floor(length / this.type.itemsPerChunk);
          this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);
        } else {
          this.set(length, value);
        }
      }
    };
    exports.ListBasicTreeView = ListBasicTreeView;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/arrayBasic.js
var require_arrayBasic3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/arrayBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayBasicTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract3();
    var ArrayBasicTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type, _rootNode, cache) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        this.nodesChanged = /* @__PURE__ */ new Set();
        this.dirtyLength = false;
        if (cache) {
          this.nodes = cache.nodes;
          this._length = cache.length;
          this.nodesPopulated = cache.nodesPopulated;
        } else {
          this.nodes = [];
          this._length = this.type.tree_getLength(_rootNode);
          this.nodesPopulated = false;
        }
      }
      /**
       * Number of elements in the array. Equal to un-commited length of the array
       */
      get length() {
        return this._length;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return {
          nodes: this.nodes,
          length: this._length,
          nodesPopulated: this.nodesPopulated
        };
      }
      /**
       * Get element at `index`. Returns the Basic element type value directly
       */
      get(index) {
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        let node = this.nodes[chunkIndex];
        if (node === void 0) {
          node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);
          this.nodes[chunkIndex] = node;
        }
        return this.type.elementType.tree_getFromPackedNode(node, index);
      }
      /**
       * Set Basic element type `value` at `index`
       */
      set(index, value) {
        if (index >= this._length) {
          throw Error(`Error setting index over length ${index} > ${this._length}`);
        }
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        let nodeChanged;
        if (this.nodesChanged.has(chunkIndex)) {
          nodeChanged = this.nodes[chunkIndex];
        } else {
          const nodePrev = this.nodes[chunkIndex] ?? persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);
          nodeChanged = nodePrev.clone();
          this.nodes[chunkIndex] = nodeChanged;
          this.nodesChanged.add(chunkIndex);
        }
        this.type.elementType.tree_setToPackedNode(nodeChanged, index, value);
      }
      /**
       * Get all values of this array as Basic element type values, from index zero to `this.length - 1`
       */
      getAll() {
        if (!this.nodesPopulated) {
          const nodesPrev = this.nodes;
          const chunksNode = this.type.tree_getChunksNode(this.node);
          const chunkCount = Math.ceil(this._length / this.type.itemsPerChunk);
          this.nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);
          for (const index of this.nodesChanged) {
            this.nodes[index] = nodesPrev[index];
          }
          this.nodesPopulated = true;
        }
        const values = new Array(this._length);
        const itemsPerChunk = this.type.itemsPerChunk;
        const lenFullNodes = Math.floor(this._length / itemsPerChunk);
        const remainder = this._length % itemsPerChunk;
        for (let n = 0; n < lenFullNodes; n++) {
          const leafNode = this.nodes[n];
          for (let i = 0; i < itemsPerChunk; i++) {
            values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
          }
        }
        if (remainder > 0) {
          const leafNode = this.nodes[lenFullNodes];
          for (let i = 0; i < remainder; i++) {
            values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
          }
        }
        return values;
      }
      commit() {
        if (this.nodesChanged.size === 0) {
          return;
        }
        const indexes = Array.from(this.nodesChanged.keys()).sort((a, b) => a - b);
        const nodes = new Array(indexes.length);
        for (let i = 0; i < indexes.length; i++) {
          nodes[i] = this.nodes[indexes[i]];
        }
        const chunksNode = this.type.tree_getChunksNode(this._rootNode);
        const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);
        this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : void 0);
        this.nodesChanged.clear();
        this.dirtyLength = false;
      }
      clearCache() {
        this.nodes = [];
        this.nodesPopulated = false;
        this.nodesChanged.clear();
        if (this.dirtyLength) {
          this._length = this.type.tree_getLength(this._rootNode);
          this.dirtyLength = false;
        }
      }
    };
    exports.ArrayBasicTreeViewDU = ArrayBasicTreeViewDU;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/listBasic.js
var require_listBasic2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/listBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListBasicTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayBasic_1 = require_arrayBasic3();
    var ListBasicTreeViewDU = class extends arrayBasic_1.ArrayBasicTreeViewDU {
      constructor(type, _rootNode, cache) {
        super(type, _rootNode, cache);
        this.type = type;
        this._rootNode = _rootNode;
      }
      /**
       * Adds one value element at the end of the array and adds 1 to the un-commited ViewDU length
       */
      push(value) {
        if (this._length >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.dirtyLength = true;
        const index = this._length++;
        if (index % this.type.itemsPerChunk === 0) {
          const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
          this.nodes[chunkIndex] = persistent_merkle_tree_1.zeroNode(0);
        }
        this.set(index, value);
      }
    };
    exports.ListBasicTreeViewDU = ListBasicTreeViewDU;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/array.js
var require_array = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/array.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var composite_1 = require_composite();
    var arrayBasic_1 = require_arrayBasic();
    var ArrayType = class extends composite_1.CompositeType {
      constructor(elementType) {
        super();
        this.elementType = elementType;
      }
      defaultValue() {
        return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);
      }
      // Proofs
      getPropertyType() {
        return this.elementType;
      }
      getPropertyGindex(prop) {
        if (typeof prop !== "number") {
          throw Error(`Invalid array index: ${prop}`);
        }
        const chunkIdx = Math.floor(prop / this.itemsPerChunk);
        return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));
      }
      getIndexProperty(index) {
        return index;
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        let length;
        if (this.isList) {
          if (!rootNode) {
            throw new Error("List type requires tree argument to get leaves");
          }
          length = this.tree_getLength(rootNode);
        } else {
          length = this.tree_getLength(null);
        }
        const gindices = [];
        if (composite_1.isCompositeType(this.elementType)) {
          const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));
          const endGindex = startIndex + BigInt(length);
          const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);
          if (this.elementType.fixedSize === null) {
            if (!rootNode) {
              throw new Error("Array of variable size requires tree argument to get leaves");
            }
            for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {
              gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));
            }
          } else {
            for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {
              gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));
            }
          }
        } else {
          const chunkCount = Math.ceil(length / this.itemsPerChunk);
          const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
          const endGindex = startIndex + BigInt(chunkCount);
          for (let gindex = startIndex; gindex < endGindex; gindex++) {
            gindices.push(gindex);
          }
        }
        if (this.isList) {
          gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);
      }
      toJson(value) {
        return arrayBasic_1.value_toJsonArray(this.elementType, value, this);
      }
      clone(value) {
        return arrayBasic_1.value_cloneArray(this.elementType, value);
      }
      equals(a, b) {
        return arrayBasic_1.value_equals(this.elementType, a, b);
      }
    };
    exports.ArrayType = ArrayType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/listBasic.js
var require_listBasic3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/listBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListBasicType = void 0;
    var arrayBasic_1 = require_arrayBasic();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var listBasic_1 = require_listBasic();
    var listBasic_2 = require_listBasic2();
    var array_1 = require_array();
    var ListBasicType = class extends array_1.ArrayType {
      constructor(elementType, limit, opts) {
        super(elementType);
        this.elementType = elementType;
        this.limit = limit;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        this.defaultLen = 0;
        if (!elementType.isBasic)
          throw Error("elementType must be basic");
        if (limit === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `List[${elementType.typeName}, ${limit}]`;
        this.itemsPerChunk = 32 / elementType.byteLength;
        this.maxChunkCount = Math.ceil(this.limit * elementType.byteLength / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth + 1;
        this.minSize = 0;
        this.maxSize = this.limit * elementType.maxSize;
      }
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(ListBasicType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new listBasic_1.ListBasicTreeView(this, tree);
      }
      getViewDU(node, cache) {
        return new listBasic_2.ListBasicTreeViewDU(this, node, cache);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize(value) {
        return value.length * this.elementType.byteLength;
      }
      value_serializeToBytes(output, offset, value) {
        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value.length, output, offset, value);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);
      }
      tree_serializedSize(node) {
        return this.tree_getLength(node) * this.elementType.byteLength;
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length = this.tree_getLength(node);
        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, length, this.chunkDepth, output, offset, chunksNode);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.chunkDepth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength(node) {
        return node.right.getUint(4, 0);
      }
      tree_setLength(tree, length) {
        tree.rootNode = arrayBasic_1.addLengthNode(tree.rootNode.left, length);
      }
      tree_getChunksNode(node) {
        return node.left;
      }
      tree_setChunksNode(rootNode, chunksNode, newLength) {
        return arrayBasic_1.setChunksNode(rootNode, chunksNode, newLength);
      }
      // Merkleization
      hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);
      }
      getRoots(value) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value.length, { uint8Array, dataView }, 0, value);
        return merkleize_1.splitIntoRootChunks(uint8Array);
      }
    };
    exports.ListBasicType = ListBasicType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/arrayComposite.js
var require_arrayComposite = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/arrayComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.value_getRootsArrayComposite = exports.tree_deserializeFromBytesArrayComposite = exports.tree_serializeToBytesArrayComposite = exports.tree_serializedSizeArrayComposite = exports.value_deserializeFromBytesArrayComposite = exports.value_serializeToBytesArrayComposite = exports.value_serializedSizeArrayComposite = exports.maxSizeArrayComposite = exports.minSizeArrayComposite = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayBasic_1 = require_arrayBasic();
    function minSizeArrayComposite(elementType, minCount) {
      if (elementType.fixedSize === null) {
        return minCount * (4 + elementType.minSize);
      } else {
        return minCount * elementType.minSize;
      }
    }
    exports.minSizeArrayComposite = minSizeArrayComposite;
    function maxSizeArrayComposite(elementType, maxCount) {
      if (elementType.fixedSize === null) {
        return maxCount * (4 + elementType.maxSize);
      } else {
        return maxCount * elementType.maxSize;
      }
    }
    exports.maxSizeArrayComposite = maxSizeArrayComposite;
    function value_serializedSizeArrayComposite(elementType, length, value) {
      if (elementType.fixedSize === null) {
        let size = 0;
        for (let i = 0; i < length; i++) {
          size += 4 + elementType.value_serializedSize(value[i]);
        }
        return size;
      } else {
        return length * elementType.fixedSize;
      }
    }
    exports.value_serializedSizeArrayComposite = value_serializedSizeArrayComposite;
    function value_serializeToBytesArrayComposite(elementType, length, output, offset, value) {
      if (elementType.fixedSize === null) {
        let variableIndex = offset + length * 4;
        for (let i = 0; i < length; i++) {
          output.dataView.setUint32(offset + i * 4, variableIndex - offset, true);
          variableIndex = elementType.value_serializeToBytes(output, variableIndex, value[i]);
        }
        return variableIndex;
      } else {
        for (let i = 0; i < length; i++) {
          elementType.value_serializeToBytes(output, offset + i * elementType.fixedSize, value[i]);
        }
        return offset + length * elementType.fixedSize;
      }
    }
    exports.value_serializeToBytesArrayComposite = value_serializeToBytesArrayComposite;
    function value_deserializeFromBytesArrayComposite(elementType, data, start, end, arrayProps) {
      const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);
      const length = offsets.length;
      const values = new Array(length);
      for (let i = 0; i < length; i++) {
        const startEl = start + offsets[i];
        const endEl = i === length - 1 ? end : start + offsets[i + 1];
        values[i] = elementType.value_deserializeFromBytes(data, startEl, endEl);
      }
      return values;
    }
    exports.value_deserializeFromBytesArrayComposite = value_deserializeFromBytesArrayComposite;
    function tree_serializedSizeArrayComposite(elementType, length, depth, node) {
      if (elementType.fixedSize === null) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);
        let size = 0;
        for (let i = 0; i < nodes.length; i++) {
          size += 4 + elementType.tree_serializedSize(nodes[i]);
        }
        return size;
      } else {
        return length * elementType.fixedSize;
      }
    }
    exports.tree_serializedSizeArrayComposite = tree_serializedSizeArrayComposite;
    function tree_serializeToBytesArrayComposite(elementType, length, depth, node, output, offset) {
      const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);
      if (elementType.fixedSize === null) {
        let variableIndex = offset + length * 4;
        const { dataView } = output;
        for (let i = 0; i < nodes.length; i++) {
          dataView.setUint32(offset + i * 4, variableIndex - offset, true);
          variableIndex = elementType.tree_serializeToBytes(output, variableIndex, nodes[i]);
        }
        return variableIndex;
      } else {
        for (let i = 0; i < nodes.length; i++) {
          offset = elementType.tree_serializeToBytes(output, offset, nodes[i]);
        }
        return offset;
      }
    }
    exports.tree_serializeToBytesArrayComposite = tree_serializeToBytesArrayComposite;
    function tree_deserializeFromBytesArrayComposite(elementType, chunkDepth, data, start, end, arrayProps) {
      const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);
      const length = offsets.length;
      const nodes = new Array(length);
      for (let i = 0; i < length; i++) {
        const startEl = start + offsets[i];
        const endEl = i === length - 1 ? end : start + offsets[i + 1];
        nodes[i] = elementType.tree_deserializeFromBytes(data, startEl, endEl);
      }
      const chunksNode = persistent_merkle_tree_1.subtreeFillToContents(nodes, chunkDepth);
      if (arrayProps.isList) {
        return arrayBasic_1.addLengthNode(chunksNode, length);
      } else {
        return chunksNode;
      }
    }
    exports.tree_deserializeFromBytesArrayComposite = tree_deserializeFromBytesArrayComposite;
    function value_getRootsArrayComposite(elementType, length, value) {
      const roots = new Array(length);
      for (let i = 0; i < length; i++) {
        roots[i] = elementType.hashTreeRoot(value[i]);
      }
      return roots;
    }
    exports.value_getRootsArrayComposite = value_getRootsArrayComposite;
    function readOffsetsArrayComposite(elementFixedSize, data, start, end, arrayProps) {
      const size = end - start;
      let offsets;
      if (elementFixedSize === null) {
        offsets = readVariableOffsetsArrayComposite(data, start, size);
      } else {
        if (elementFixedSize === 0) {
          throw Error("element fixed length is 0");
        }
        if (size % elementFixedSize !== 0) {
          throw Error(`size ${size} is not multiple of element fixedSize ${elementFixedSize}`);
        }
        const length = size / elementFixedSize;
        offsets = new Uint32Array(length);
        for (let i = 0; i < length; i++) {
          offsets[i] = i * elementFixedSize;
        }
      }
      arrayBasic_1.assertValidArrayLength(offsets.length, arrayProps);
      return offsets;
    }
    function readVariableOffsetsArrayComposite(dataView, start, size) {
      if (size === 0) {
        return new Uint32Array(0);
      }
      const firstOffset = dataView.getUint32(start, true);
      const offsetDataLength = firstOffset;
      if (firstOffset === 0) {
        throw Error("First offset must be > 0");
      }
      if (offsetDataLength % 4 !== 0) {
        throw Error("Offset data length not multiple of 4");
      }
      const offsetCount = offsetDataLength / 4;
      const offsets = new Uint32Array(offsetCount);
      offsets[0] = firstOffset;
      for (let offsetIdx = 1; offsetIdx < offsetCount; offsetIdx++) {
        const offset = dataView.getUint32(start + offsetIdx * 4, true);
        offsets[offsetIdx] = offset;
        if (offset > size) {
          throw new Error(`Offset out of bounds ${offset} > ${size}`);
        }
        if (offset < offsets[offsetIdx - 1]) {
          throw new Error(`Offsets must be increasing ${offset} < ${offsets[offsetIdx - 1]}`);
        }
      }
      return offsets;
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/arrayComposite.js
var require_arrayComposite2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/arrayComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayCompositeTreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract2();
    var ArrayCompositeTreeView = class extends abstract_1.TreeView {
      constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
      }
      /**
       * Number of elements in the array. Equal to the Uint32 value of the Tree's length node
       */
      get length() {
        return this.type.tree_getLength(this.tree.rootNode);
      }
      /**
       * Returns the View's Tree rootNode
       */
      get node() {
        return this.tree.rootNode;
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type
       */
      get(index) {
        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
        const subtree = this.tree.getSubtree(gindex);
        return this.type.elementType.getView(subtree);
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type.
       * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.
       */
      getReadonly(index) {
        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
        const subtree = new persistent_merkle_tree_1.Tree(this.tree.getNode(gindex));
        return this.type.elementType.getView(subtree);
      }
      /**
       * Set Composite element type `view` at `index`
       */
      set(index, view) {
        const length = this.length;
        if (index >= length) {
          throw Error(`Error setting index over length ${index} > ${length}`);
        }
        const node = this.type.elementType.commitView(view);
        this.tree.setNodeAtDepth(this.type.depth, index, node);
      }
      /**
       * Returns an array of views of all elements in the array, from index zero to `this.length - 1`.
       * The returned views don't have a parent hook to this View's Tree, so changes in the returned views won't be
       * propagated upwards. To get linked element Views use `this.get()`
       */
      getAllReadonly() {
        const length = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);
        const views = new Array(length);
        for (let i = 0; i < length; i++) {
          views[i] = this.type.elementType.getView(new persistent_merkle_tree_1.Tree(nodes[i]));
        }
        return views;
      }
      /**
       * Returns an array of values of all elements in the array, from index zero to `this.length - 1`.
       * The returned values are not Views so any changes won't be propagated upwards.
       * To get linked element Views use `this.get()`
       */
      getAllReadonlyValues() {
        const length = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);
        const values = new Array(length);
        for (let i = 0; i < length; i++) {
          values[i] = this.type.elementType.tree_toValue(nodes[i]);
        }
        return values;
      }
    };
    exports.ArrayCompositeTreeView = ArrayCompositeTreeView;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/listComposite.js
var require_listComposite = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/view/listComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCompositeTreeView = void 0;
    var arrayComposite_1 = require_arrayComposite2();
    var ListCompositeTreeView = class extends arrayComposite_1.ArrayCompositeTreeView {
      constructor(type, tree) {
        super(type, tree);
        this.type = type;
        this.tree = tree;
      }
      /**
       * Adds one view element at the end of the array and adds 1 to the current Tree length.
       */
      push(view) {
        const length = this.length;
        if (length >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.type.tree_setLength(this.tree, length + 1);
        this.set(length, view);
      }
    };
    exports.ListCompositeTreeView = ListCompositeTreeView;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/arrayComposite.js
var require_arrayComposite3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/arrayComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayCompositeTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract3();
    var ArrayCompositeTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type, _rootNode, cache) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        this.viewsChanged = /* @__PURE__ */ new Map();
        this.dirtyLength = false;
        if (cache) {
          this.nodes = cache.nodes;
          this.caches = cache.caches;
          this._length = cache.length;
          this.nodesPopulated = cache.nodesPopulated;
        } else {
          this.nodes = [];
          this.caches = [];
          this._length = this.type.tree_getLength(_rootNode);
          this.nodesPopulated = this._length === 0;
        }
      }
      /**
       * Number of elements in the array. Equal to un-commited length of the array
       */
      get length() {
        return this._length;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return {
          nodes: this.nodes,
          caches: this.caches,
          length: this._length,
          nodesPopulated: this.nodesPopulated
        };
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type.
       *
       * NOTE: Assumes that any view created here will change and will call .commit() on it.
       * .get() should be used only for cases when something may mutate. To get all items without
       * triggering a .commit() in all them use .getAllReadOnly().
       */
      get(index) {
        const viewChanged = this.viewsChanged.get(index);
        if (viewChanged) {
          return viewChanged;
        }
        let node = this.nodes[index];
        if (node === void 0) {
          node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
          this.nodes[index] = node;
        }
        const view = this.type.elementType.getViewDU(node, this.caches[index]);
        if (this.type.elementType.isViewMutable) {
          this.viewsChanged.set(index, view);
        }
        return view;
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type.
       * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.
       */
      getReadonly(index) {
        const viewChanged = this.viewsChanged.get(index);
        if (viewChanged) {
          return viewChanged;
        }
        let node = this.nodes[index];
        if (node === void 0) {
          node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
          this.nodes[index] = node;
        }
        return this.type.elementType.getViewDU(node, this.caches[index]);
      }
      // Did not implemented
      // `getReadonlyValue(index: number): ValueOf<ElementType>`
      // because it can break in unexpected ways if there are pending changes in this.viewsChanged.
      // This function could first check if `this.viewsChanged` has a view for `index` and commit it,
      // but that would be pretty slow, and the same result can be achieved with
      // `this.getReadonly(index).toValue()`
      /**
       * Set Composite element type `view` at `index`
       */
      set(index, view) {
        if (index >= this._length) {
          throw Error(`Error setting index over length ${index} > ${this._length}`);
        }
        this.viewsChanged.set(index, view);
      }
      /**
       * WARNING: Returns all commited changes, if there are any pending changes commit them beforehand
       */
      getAllReadonly() {
        this.populateAllNodes();
        const views = new Array(this._length);
        for (let i = 0; i < this._length; i++) {
          views[i] = this.type.elementType.getViewDU(this.nodes[i], this.caches[i]);
        }
        return views;
      }
      /**
       * WARNING: Returns all commited changes, if there are any pending changes commit them beforehand
       */
      getAllReadonlyValues() {
        this.populateAllNodes();
        const values = new Array(this._length);
        for (let i = 0; i < this._length; i++) {
          values[i] = this.type.elementType.tree_toValue(this.nodes[i]);
        }
        return values;
      }
      commit() {
        if (this.viewsChanged.size === 0) {
          return;
        }
        const nodesChanged = [];
        for (const [index, view] of this.viewsChanged) {
          const node = this.type.elementType.commitViewDU(view);
          this.nodes[index] = node;
          nodesChanged.push({ index, node });
          const cache = this.type.elementType.cacheOfViewDU(view);
          if (cache)
            this.caches[index] = cache;
        }
        const nodesChangedSorted = nodesChanged.sort((a, b) => a.index - b.index);
        const indexes = nodesChangedSorted.map((entry) => entry.index);
        const nodes = nodesChangedSorted.map((entry) => entry.node);
        const chunksNode = this.type.tree_getChunksNode(this._rootNode);
        const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);
        this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : void 0);
        this.viewsChanged.clear();
        this.dirtyLength = false;
      }
      clearCache() {
        this.nodes = [];
        this.caches = [];
        this.nodesPopulated = false;
        this.viewsChanged.clear();
        if (this.dirtyLength) {
          this._length = this.type.tree_getLength(this._rootNode);
          this.dirtyLength = false;
        }
      }
      populateAllNodes() {
        if (this.viewsChanged.size > 0) {
          throw Error("Must commit changes before reading all nodes");
        }
        if (!this.nodesPopulated) {
          this.nodes = persistent_merkle_tree_1.getNodesAtDepth(this._rootNode, this.type.depth, 0, this.length);
          this.nodesPopulated = true;
        }
      }
    };
    exports.ArrayCompositeTreeViewDU = ArrayCompositeTreeViewDU;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/listComposite.js
var require_listComposite2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/viewDU/listComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCompositeTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayComposite_1 = require_arrayComposite3();
    var ListCompositeTreeViewDU = class extends arrayComposite_1.ArrayCompositeTreeViewDU {
      constructor(type, _rootNode, cache) {
        super(type, _rootNode, cache);
        this.type = type;
        this._rootNode = _rootNode;
      }
      /**
       * Adds one value element at the end of the array and adds 1 to the un-commited ViewDU length
       */
      push(view) {
        if (this._length >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.dirtyLength = true;
        const index = this._length++;
        this.set(index, view);
      }
      /**
       * Returns a new ListCompositeTreeViewDU instance with the values from 0 to `index`.
       * The new list is equivalent to (pseudo-code):
       *
       * ```ts
       * const nodes = getChunkNodes()
       * return listFromChunkNodes(nodes.slice(0, index + 1))
       * ```
       *
       * To achieve it, rebinds the underlying tree zero-ing all nodes right of `index`.
       *
       * Note: Using index = -1, returns an empty list of length 0.
       */
      sliceTo(index) {
        this.commit();
        const rootNode = this._rootNode;
        const length = this.type.tree_getLength(rootNode);
        if (index >= length - 1) {
          return this;
        }
        const chunksNode = this.type.tree_getChunksNode(rootNode);
        const newChunksNode = persistent_merkle_tree_1.treeZeroAfterIndex(chunksNode, this.type.chunkDepth, index);
        const newLength = index + 1;
        const newRootNode = this.type.tree_setChunksNode(rootNode, newChunksNode, newLength);
        return this.type.getViewDU(newRootNode);
      }
    };
    exports.ListCompositeTreeViewDU = ListCompositeTreeViewDU;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/listComposite.js
var require_listComposite3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/listComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCompositeType = void 0;
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var arrayComposite_1 = require_arrayComposite();
    var listComposite_1 = require_listComposite();
    var listComposite_2 = require_listComposite2();
    var array_1 = require_array();
    var ListCompositeType = class extends array_1.ArrayType {
      constructor(elementType, limit, opts) {
        super(elementType);
        this.elementType = elementType;
        this.limit = limit;
        this.itemsPerChunk = 1;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        this.defaultLen = 0;
        if (elementType.isBasic)
          throw Error("elementType must not be basic");
        if (limit === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `List[${elementType.typeName}, ${limit}]`;
        this.maxChunkCount = this.limit;
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth + 1;
        this.minSize = 0;
        this.maxSize = arrayComposite_1.maxSizeArrayComposite(elementType, this.limit);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(ListCompositeType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new listComposite_1.ListCompositeTreeView(this, tree);
      }
      getViewDU(node, cache) {
        return new listComposite_2.ListCompositeTreeViewDU(this, node, cache);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize(value) {
        return arrayComposite_1.value_serializedSizeArrayComposite(this.elementType, value.length, value);
      }
      value_serializeToBytes(output, offset, value) {
        return arrayComposite_1.value_serializeToBytesArrayComposite(this.elementType, value.length, output, offset, value);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.value_deserializeFromBytesArrayComposite(this.elementType, data, start, end, this);
      }
      tree_serializedSize(node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length = this.tree_getLength(node);
        return arrayComposite_1.tree_serializedSizeArrayComposite(this.elementType, length, this.chunkDepth, chunksNode);
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length = this.tree_getLength(node);
        return arrayComposite_1.tree_serializeToBytesArrayComposite(this.elementType, length, this.chunkDepth, chunksNode, output, offset);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.tree_deserializeFromBytesArrayComposite(this.elementType, this.chunkDepth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength(node) {
        return arrayBasic_1.getLengthFromRootNode(node);
      }
      tree_setLength(tree, length) {
        tree.rootNode = arrayBasic_1.addLengthNode(tree.rootNode.left, length);
      }
      tree_getChunksNode(node) {
        return node.left;
      }
      tree_setChunksNode(rootNode, chunksNode, newLength) {
        return arrayBasic_1.setChunksNode(rootNode, chunksNode, newLength);
      }
      // Merkleization
      hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);
      }
      getRoots(value) {
        return arrayComposite_1.value_getRootsArrayComposite(this.elementType, value.length, value);
      }
    };
    exports.ListCompositeType = ListCompositeType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/none.js
var require_none = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/none.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoneType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var basic_1 = require_basic();
    var NoneType = class extends basic_1.BasicType {
      constructor() {
        super(...arguments);
        this.typeName = "none";
        this.byteLength = 0;
        this.itemsPerChunk = 32;
        this.fixedSize = 0;
        this.minSize = 0;
        this.maxSize = 0;
      }
      defaultValue() {
        return null;
      }
      // bytes serdes
      value_serializeToBytes(output, offset, value) {
        return offset;
      }
      value_deserializeFromBytes(data, start) {
        return null;
      }
      tree_serializeToBytes(output, offset, node) {
        return offset;
      }
      tree_deserializeFromBytes(data, start, end) {
        return persistent_merkle_tree_1.zeroNode(0);
      }
      // Fast tree opts
      tree_getFromNode(leafNode) {
        return null;
      }
      tree_setToNode(leafNode, value) {
        return;
      }
      tree_getFromPackedNode(leafNode, index) {
        return null;
      }
      tree_setToPackedNode(leafNode, index, value) {
        return;
      }
      // JSON
      fromJson(json) {
        if (json !== null) {
          throw Error("JSON invalid type none must be null");
        }
        return null;
      }
      toJson(value) {
        return null;
      }
    };
    exports.NoneType = NoneType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/uint.js
var require_uint = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/uint.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var named_1 = require_named();
    var basic_1 = require_basic();
    var MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);
    var BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);
    var BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);
    var BIGINT_2_POW_192 = BigInt(2) ** BigInt(192);
    var NUMBER_2_POW_32 = 2 ** 32;
    var NUMBER_32_MAX = 4294967295;
    exports.uintNumberByteLens = [1, 2, 4, 8];
    exports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];
    var UintNumberType = class extends basic_1.BasicType {
      constructor(byteLength, opts) {
        super();
        this.byteLength = byteLength;
        if (byteLength > 8) {
          throw Error("UintNumber byteLength limit is 8");
        }
        if (Math.log2(byteLength) % 1 !== 0) {
          throw Error("byteLength must be a power of 2");
        }
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `uint${byteLength * 8}`;
        if (opts == null ? void 0 : opts.clipInfinity)
          this.typeName += "Inf";
        if (opts == null ? void 0 : opts.setBitwiseOR)
          this.typeName += "OR";
        this.itemsPerChunk = 32 / this.byteLength;
        this.fixedSize = byteLength;
        this.minSize = byteLength;
        this.maxSize = byteLength;
        this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);
        this.clipInfinity = (opts == null ? void 0 : opts.clipInfinity) === true;
        this.setBitwiseOR = (opts == null ? void 0 : opts.setBitwiseOR) === true;
      }
      static named(byteLength, opts) {
        return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength, opts);
      }
      defaultValue() {
        return 0;
      }
      // Serialization + deserialization
      value_serializeToBytes({ dataView }, offset, value) {
        switch (this.byteLength) {
          case 1:
            dataView.setInt8(offset, value);
            break;
          case 2:
            dataView.setUint16(offset, value, true);
            break;
          case 4:
            dataView.setUint32(offset, value, true);
            break;
          case 8:
            if (value === Infinity) {
              dataView.setUint32(offset, 4294967295);
              dataView.setUint32(offset + 4, 4294967295);
            } else {
              dataView.setUint32(offset, value & 4294967295, true);
              dataView.setUint32(offset + 4, value / NUMBER_2_POW_32 & 4294967295, true);
            }
            break;
        }
        return offset + this.byteLength;
      }
      value_deserializeFromBytes({ dataView }, start, end) {
        this.assertValidSize(end - start);
        switch (this.byteLength) {
          case 1:
            return dataView.getUint8(start);
          case 2:
            return dataView.getUint16(start, true);
          case 4:
            return dataView.getUint32(start, true);
          case 8: {
            const a = dataView.getUint32(start, true);
            const b = dataView.getUint32(start + 4, true);
            if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {
              return Infinity;
            } else {
              return b * NUMBER_2_POW_32 + a;
            }
          }
        }
      }
      tree_serializeToBytes(output, offset, node) {
        const value = node.getUint(this.byteLength, 0, this.clipInfinity);
        this.value_serializeToBytes(output, offset, value);
        return offset + this.byteLength;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const value = this.value_deserializeFromBytes(data, start, end);
        const node = persistent_merkle_tree_1.LeafNode.fromZero();
        node.setUint(this.byteLength, 0, value, this.clipInfinity);
        return node;
      }
      // Fast Tree access
      tree_getFromNode(leafNode) {
        return leafNode.getUint(this.byteLength, 0, this.clipInfinity);
      }
      tree_setToNode(leafNode, value) {
        this.tree_setToPackedNode(leafNode, 0, value);
      }
      tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);
      }
      tree_setToPackedNode(leafNode, index, value) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        if (this.setBitwiseOR) {
          leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value);
        } else {
          leafNode.setUint(this.byteLength, offsetBytes, value, this.clipInfinity);
        }
      }
      // JSON
      fromJson(json) {
        if (typeof json === "number") {
          return json;
        } else if (typeof json === "string") {
          if (this.clipInfinity && json === this.maxDecimalStr) {
            return Infinity;
          } else {
            const num = parseInt(json, 10);
            if (isNaN(num)) {
              throw Error("JSON invalid number isNaN");
            } else if (num > Number.MAX_SAFE_INTEGER) {
              throw Error("JSON invalid number > MAX_SAFE_INTEGER");
            } else {
              return num;
            }
          }
        } else if (typeof json === "bigint") {
          if (json > MAX_SAFE_INTEGER_BN) {
            throw Error("JSON invalid number > MAX_SAFE_INTEGER_BN");
          } else {
            return Number(json);
          }
        } else {
          throw Error(`JSON invalid type ${typeof json} expected number`);
        }
      }
      toJson(value) {
        if (value === Infinity) {
          return this.maxDecimalStr;
        } else {
          return value.toString(10);
        }
      }
    };
    exports.UintNumberType = UintNumberType;
    var UintBigintType = class extends basic_1.BasicType {
      constructor(byteLength, opts) {
        super();
        this.byteLength = byteLength;
        if (byteLength > 32) {
          throw Error("UintBigint byteLength limit is 32");
        }
        if (Math.log2(byteLength) % 1 !== 0) {
          throw Error("byteLength must be a power of 2");
        }
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `uintBigint${byteLength * 8}`;
        this.byteLength = byteLength;
        this.itemsPerChunk = 32 / this.byteLength;
        this.fixedSize = byteLength;
        this.minSize = byteLength;
        this.maxSize = byteLength;
      }
      static named(byteLength, opts) {
        return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength, opts);
      }
      defaultValue() {
        return BigInt(0);
      }
      // Serialization + deserialization
      value_serializeToBytes({ dataView }, offset, value) {
        switch (this.byteLength) {
          case 1:
            dataView.setInt8(offset, Number(value));
            break;
          case 2:
            dataView.setUint16(offset, Number(value), true);
            break;
          case 4:
            dataView.setUint32(offset, Number(value), true);
            break;
          case 8:
            dataView.setBigUint64(offset, value, true);
            break;
          default: {
            for (let i = 0; i < this.byteLength; i += 8) {
              if (i > 0)
                value = value / BIGINT_2_POW_64;
              const lo = BigInt.asUintN(64, value);
              dataView.setBigUint64(offset + i, lo, true);
            }
          }
        }
        return offset + this.byteLength;
      }
      value_deserializeFromBytes({ dataView }, start, end) {
        const size = end - start;
        if (size !== this.byteLength) {
          throw Error(`Invalid size ${size} expected ${this.byteLength}`);
        }
        switch (this.byteLength) {
          case 1:
            return BigInt(dataView.getUint8(start));
          case 2:
            return BigInt(dataView.getUint16(start, true));
          case 4:
            return BigInt(dataView.getUint32(start, true));
          case 8:
            return dataView.getBigUint64(start, true);
          case 16: {
            const a = dataView.getBigUint64(start, true);
            const b = dataView.getBigUint64(start + 8, true);
            return b * BIGINT_2_POW_64 + a;
          }
          case 32: {
            const a = dataView.getBigUint64(start, true);
            const b = dataView.getBigUint64(start + 8, true);
            const c = dataView.getBigUint64(start + 16, true);
            const d = dataView.getBigUint64(start + 24, true);
            return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;
          }
        }
      }
      tree_serializeToBytes(output, offset, node) {
        const value = node.getUintBigint(this.byteLength, 0);
        this.value_serializeToBytes(output, offset, value);
        return offset + this.byteLength;
      }
      tree_deserializeFromBytes(data, start, end) {
        const size = end - start;
        if (size !== this.byteLength) {
          throw Error(`Invalid size ${size} expected ${this.byteLength}`);
        }
        const value = this.value_deserializeFromBytes(data, start, end);
        const node = persistent_merkle_tree_1.LeafNode.fromZero();
        node.setUintBigint(this.byteLength, 0, value);
        return node;
      }
      // Fast Tree access
      tree_getFromNode(leafNode) {
        return leafNode.getUintBigint(this.byteLength, 0);
      }
      /** Mutates node to set value */
      tree_setToNode(leafNode, value) {
        this.tree_setToPackedNode(leafNode, 0, value);
      }
      /** EXAMPLE of `tree_getFromNode` */
      tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        return leafNode.getUintBigint(this.byteLength, offsetBytes);
      }
      /** Mutates node to set value */
      tree_setToPackedNode(leafNode, index, value) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        leafNode.setUintBigint(this.byteLength, offsetBytes, value);
      }
      // JSON
      fromJson(json) {
        if (typeof json === "bigint") {
          return json;
        } else if (typeof json === "string" || typeof json === "number") {
          return BigInt(json);
        } else {
          throw Error(`JSON invalid type ${typeof json} expected bigint`);
        }
      }
      toJson(value) {
        return value.toString(10);
      }
    };
    exports.UintBigintType = UintBigintType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/union.js
var require_union = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/union.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnionType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var composite_1 = require_composite();
    var arrayBasic_1 = require_arrayBasic();
    var none_1 = require_none();
    var VALUE_GINDEX = BigInt(2);
    var SELECTOR_GINDEX = BigInt(3);
    var UnionType = class extends composite_1.CompositeType {
      constructor(types, opts) {
        super();
        this.types = types;
        this.depth = 1;
        this.maxChunkCount = 1;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        if (types.length >= 128) {
          throw Error("Must have less than 128 types");
        }
        if (types.length === 0) {
          throw Error("Must have at least 1 type option");
        }
        if (types[0] instanceof none_1.NoneType && types.length < 2) {
          throw Error("Must have at least 2 type options if the first is None");
        }
        for (let i = 1; i < types.length; i++) {
          if (types[i] instanceof none_1.NoneType) {
            throw Error("None may only be the first option");
          }
        }
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `Union[${types.map((t) => t.typeName).join(",")}]`;
        const minLens = [];
        const maxLens = [];
        for (const _type of types) {
          minLens.push(_type.minSize);
          maxLens.push(_type.maxSize);
        }
        this.minSize = 1 + Math.min(...minLens);
        this.maxSize = 1 + Math.max(...maxLens);
        this.maxSelector = this.types.length - 1;
      }
      static named(types, opts) {
        return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);
      }
      defaultValue() {
        return {
          selector: 0,
          value: this.types[0].defaultValue()
        };
      }
      getView(tree) {
        return this.tree_toValue(tree.rootNode);
      }
      getViewDU(node) {
        return this.tree_toValue(node);
      }
      cacheOfViewDU() {
        return;
      }
      commitView(view) {
        return this.value_toTree(view);
      }
      commitViewDU(view) {
        return this.value_toTree(view);
      }
      value_serializedSize(value) {
        return 1 + this.types[value.selector].value_serializedSize(value.value);
      }
      value_serializeToBytes(output, offset, value) {
        output.uint8Array[offset] = value.selector;
        return this.types[value.selector].value_serializeToBytes(output, offset + 1, value.value);
      }
      value_deserializeFromBytes(data, start, end) {
        const selector = data.uint8Array[start];
        if (selector > this.maxSelector) {
          throw Error(`Invalid selector ${selector}`);
        }
        return {
          selector,
          value: this.types[selector].value_deserializeFromBytes(data, start + 1, end)
        };
      }
      tree_serializedSize(node) {
        const selector = arrayBasic_1.getLengthFromRootNode(node);
        const valueNode = node.left;
        return 1 + this.types[selector].value_serializedSize(valueNode);
      }
      tree_serializeToBytes(output, offset, node) {
        const selector = arrayBasic_1.getLengthFromRootNode(node);
        const valueNode = node.left;
        output.uint8Array[offset] = selector;
        return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);
      }
      tree_deserializeFromBytes(data, start, end) {
        const selector = data.uint8Array[start];
        if (selector > this.maxSelector) {
          throw Error(`Invalid selector ${selector}`);
        }
        const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);
        return arrayBasic_1.addLengthNode(valueNode, selector);
      }
      // Merkleization
      hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.selector);
      }
      getRoots(value) {
        const valueRoot = this.types[value.selector].hashTreeRoot(value.value);
        return [valueRoot];
      }
      // Proofs
      getPropertyGindex(prop) {
        switch (prop) {
          case "value":
            return VALUE_GINDEX;
          case "selector":
            return SELECTOR_GINDEX;
          default:
            throw new Error(`Invalid Union type property ${prop}`);
        }
      }
      getPropertyType() {
        throw new Error("Not applicable for Union type");
      }
      getIndexProperty(index) {
        if (index === 0)
          return "value";
        if (index === 1)
          return "selector";
        throw Error("Union index of out bounds");
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        if (!rootNode) {
          throw Error("rootNode required");
        }
        const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];
        const selector = arrayBasic_1.getLengthFromRootNode(rootNode);
        const type = this.types[selector];
        const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);
        if (composite_1.isCompositeType(type)) {
          gindices.push(...type.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));
        } else {
          gindices.push(extendedFieldGindex);
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        if (typeof json !== "object") {
          throw new Error("JSON must be of type object");
        }
        const union = json;
        if (typeof union.selector !== "number") {
          throw new Error("Invalid JSON Union selector must be number");
        }
        const type = this.types[union.selector];
        if (!type) {
          throw new Error("Invalid JSON Union selector out of range");
        }
        return {
          selector: union.selector,
          value: type.toJson(union.value)
        };
      }
      toJson(value) {
        return {
          selector: value.selector,
          value: this.types[value.selector].toJson(value.value)
        };
      }
      clone(value) {
        return {
          selector: value.selector,
          value: this.types[value.selector].clone(value.value)
        };
      }
      equals(a, b) {
        if (a.selector !== b.selector) {
          return false;
        }
        return this.types[a.selector].equals(a.value, b.value);
      }
    };
    exports.UnionType = UnionType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/vectorBasic.js
var require_vectorBasic = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/vectorBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorBasicType = void 0;
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var arrayBasic_2 = require_arrayBasic2();
    var arrayBasic_3 = require_arrayBasic3();
    var array_1 = require_array();
    var VectorBasicType = class extends array_1.ArrayType {
      constructor(elementType, length, opts) {
        super(elementType);
        this.elementType = elementType;
        this.length = length;
        this.isList = false;
        this.isViewMutable = true;
        if (!elementType.isBasic)
          throw Error("elementType must be basic");
        if (length === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `Vector[${elementType.typeName}, ${length}]`;
        this.itemsPerChunk = 32 / elementType.byteLength;
        this.maxChunkCount = Math.ceil(length * elementType.byteLength / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = length * elementType.byteLength;
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
        this.defaultLen = length;
      }
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(VectorBasicType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new arrayBasic_2.ArrayBasicTreeView(this, tree);
      }
      getViewDU(node, cache) {
        return new arrayBasic_3.ArrayBasicTreeViewDU(this, node, cache);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize() {
        return this.fixedSize;
      }
      value_serializeToBytes(output, offset, value) {
        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, output, offset, value);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);
      }
      tree_serializedSize() {
        return this.fixedSize;
      }
      tree_serializeToBytes(output, offset, node) {
        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, output, offset, node);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength() {
        return this.length;
      }
      tree_setLength() {
      }
      tree_getChunksNode(node) {
        return node;
      }
      tree_setChunksNode(rootNode, chunksNode) {
        return chunksNode;
      }
      // Merkleization
      getRoots(value) {
        const uint8Array = new Uint8Array(this.fixedSize);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, { uint8Array, dataView }, 0, value);
        return merkleize_1.splitIntoRootChunks(uint8Array);
      }
    };
    exports.VectorBasicType = VectorBasicType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/vectorComposite.js
var require_vectorComposite = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/type/vectorComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorCompositeType = void 0;
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayComposite_1 = require_arrayComposite();
    var arrayComposite_2 = require_arrayComposite2();
    var arrayComposite_3 = require_arrayComposite3();
    var array_1 = require_array();
    var VectorCompositeType = class extends array_1.ArrayType {
      constructor(elementType, length, opts) {
        super(elementType);
        this.elementType = elementType;
        this.length = length;
        this.itemsPerChunk = 1;
        this.isList = false;
        this.isViewMutable = true;
        if (elementType.isBasic)
          throw Error("elementType must not be basic");
        if (length === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `Vector[${elementType.typeName}, ${length}]`;
        this.maxChunkCount = length;
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = elementType.fixedSize === null ? null : length * elementType.fixedSize;
        this.minSize = arrayComposite_1.minSizeArrayComposite(elementType, length);
        this.maxSize = arrayComposite_1.maxSizeArrayComposite(elementType, length);
        this.defaultLen = length;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(VectorCompositeType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new arrayComposite_2.ArrayCompositeTreeView(this, tree);
      }
      getViewDU(node, cache) {
        return new arrayComposite_3.ArrayCompositeTreeViewDU(this, node, cache);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize(value) {
        return arrayComposite_1.value_serializedSizeArrayComposite(this.elementType, this.length, value);
      }
      value_serializeToBytes(output, offset, value) {
        return arrayComposite_1.value_serializeToBytesArrayComposite(this.elementType, this.length, output, offset, value);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.value_deserializeFromBytesArrayComposite(this.elementType, data, start, end, this);
      }
      tree_serializedSize(node) {
        return arrayComposite_1.tree_serializedSizeArrayComposite(this.elementType, this.length, this.depth, node);
      }
      tree_serializeToBytes(output, offset, node) {
        return arrayComposite_1.tree_serializeToBytesArrayComposite(this.elementType, this.length, this.depth, node, output, offset);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.tree_deserializeFromBytesArrayComposite(this.elementType, this.depth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength() {
        return this.length;
      }
      tree_setLength() {
      }
      tree_getChunksNode(node) {
        return node;
      }
      tree_setChunksNode(rootNode, chunksNode) {
        return chunksNode;
      }
      // Merkleization
      getRoots(value) {
        return arrayComposite_1.value_getRootsArrayComposite(this.elementType, this.length, value);
      }
    };
    exports.VectorCompositeType = VectorCompositeType;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@chainsafe/ssz/lib/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash64 = exports.byteArrayEquals = exports.toHexString = exports.fromHexString = exports.getUint8ByteToBitBooleanArray = exports.BitArray = exports.TreeViewDU = exports.TreeView = exports.isCompositeType = exports.CompositeType = exports.isBasicType = exports.BasicType = exports.Type = exports.ByteArrayType = exports.BitArrayType = exports.ArrayType = exports.VectorCompositeType = exports.VectorBasicType = exports.UnionType = exports.UintNumberType = exports.UintBigintType = exports.NoneType = exports.ListCompositeType = exports.ListBasicType = exports.ContainerNodeStructType = exports.ContainerType = exports.ByteVectorType = exports.ByteListType = exports.BooleanType = exports.BitVectorType = exports.BitListType = void 0;
    var bitList_1 = require_bitList();
    Object.defineProperty(exports, "BitListType", { enumerable: true, get: function() {
      return bitList_1.BitListType;
    } });
    var bitVector_1 = require_bitVector();
    Object.defineProperty(exports, "BitVectorType", { enumerable: true, get: function() {
      return bitVector_1.BitVectorType;
    } });
    var boolean_1 = require_boolean();
    Object.defineProperty(exports, "BooleanType", { enumerable: true, get: function() {
      return boolean_1.BooleanType;
    } });
    var byteList_1 = require_byteList();
    Object.defineProperty(exports, "ByteListType", { enumerable: true, get: function() {
      return byteList_1.ByteListType;
    } });
    var byteVector_1 = require_byteVector();
    Object.defineProperty(exports, "ByteVectorType", { enumerable: true, get: function() {
      return byteVector_1.ByteVectorType;
    } });
    var container_1 = require_container3();
    Object.defineProperty(exports, "ContainerType", { enumerable: true, get: function() {
      return container_1.ContainerType;
    } });
    var containerNodeStruct_1 = require_containerNodeStruct3();
    Object.defineProperty(exports, "ContainerNodeStructType", { enumerable: true, get: function() {
      return containerNodeStruct_1.ContainerNodeStructType;
    } });
    var listBasic_1 = require_listBasic3();
    Object.defineProperty(exports, "ListBasicType", { enumerable: true, get: function() {
      return listBasic_1.ListBasicType;
    } });
    var listComposite_1 = require_listComposite3();
    Object.defineProperty(exports, "ListCompositeType", { enumerable: true, get: function() {
      return listComposite_1.ListCompositeType;
    } });
    var none_1 = require_none();
    Object.defineProperty(exports, "NoneType", { enumerable: true, get: function() {
      return none_1.NoneType;
    } });
    var uint_1 = require_uint();
    Object.defineProperty(exports, "UintBigintType", { enumerable: true, get: function() {
      return uint_1.UintBigintType;
    } });
    Object.defineProperty(exports, "UintNumberType", { enumerable: true, get: function() {
      return uint_1.UintNumberType;
    } });
    var union_1 = require_union();
    Object.defineProperty(exports, "UnionType", { enumerable: true, get: function() {
      return union_1.UnionType;
    } });
    var vectorBasic_1 = require_vectorBasic();
    Object.defineProperty(exports, "VectorBasicType", { enumerable: true, get: function() {
      return vectorBasic_1.VectorBasicType;
    } });
    var vectorComposite_1 = require_vectorComposite();
    Object.defineProperty(exports, "VectorCompositeType", { enumerable: true, get: function() {
      return vectorComposite_1.VectorCompositeType;
    } });
    var array_1 = require_array();
    Object.defineProperty(exports, "ArrayType", { enumerable: true, get: function() {
      return array_1.ArrayType;
    } });
    var bitArray_1 = require_bitArray4();
    Object.defineProperty(exports, "BitArrayType", { enumerable: true, get: function() {
      return bitArray_1.BitArrayType;
    } });
    var byteArray_1 = require_byteArray2();
    Object.defineProperty(exports, "ByteArrayType", { enumerable: true, get: function() {
      return byteArray_1.ByteArrayType;
    } });
    var abstract_1 = require_abstract();
    Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
      return abstract_1.Type;
    } });
    var basic_1 = require_basic();
    Object.defineProperty(exports, "BasicType", { enumerable: true, get: function() {
      return basic_1.BasicType;
    } });
    Object.defineProperty(exports, "isBasicType", { enumerable: true, get: function() {
      return basic_1.isBasicType;
    } });
    var composite_1 = require_composite();
    Object.defineProperty(exports, "CompositeType", { enumerable: true, get: function() {
      return composite_1.CompositeType;
    } });
    Object.defineProperty(exports, "isCompositeType", { enumerable: true, get: function() {
      return composite_1.isCompositeType;
    } });
    var abstract_2 = require_abstract2();
    Object.defineProperty(exports, "TreeView", { enumerable: true, get: function() {
      return abstract_2.TreeView;
    } });
    var abstract_3 = require_abstract3();
    Object.defineProperty(exports, "TreeViewDU", { enumerable: true, get: function() {
      return abstract_3.TreeViewDU;
    } });
    var bitArray_2 = require_bitArray();
    Object.defineProperty(exports, "BitArray", { enumerable: true, get: function() {
      return bitArray_2.BitArray;
    } });
    Object.defineProperty(exports, "getUint8ByteToBitBooleanArray", { enumerable: true, get: function() {
      return bitArray_2.getUint8ByteToBitBooleanArray;
    } });
    var byteArray_2 = require_byteArray();
    Object.defineProperty(exports, "fromHexString", { enumerable: true, get: function() {
      return byteArray_2.fromHexString;
    } });
    Object.defineProperty(exports, "toHexString", { enumerable: true, get: function() {
      return byteArray_2.toHexString;
    } });
    Object.defineProperty(exports, "byteArrayEquals", { enumerable: true, get: function() {
      return byteArray_2.byteArrayEquals;
    } });
    var merkleize_1 = require_merkleize();
    Object.defineProperty(exports, "hash64", { enumerable: true, get: function() {
      return merkleize_1.hash64;
    } });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BYTES_PER_FIELD_ELEMENT = exports.FIELD_ELEMENTS_PER_BLOB = exports.MAX_TX_WRAP_KZG_COMMITMENTS = exports.LIMIT_BLOBS_PER_TX = exports.MAX_VERSIONED_HASHES_LIST_SIZE = exports.MAX_ACCESS_LIST_SIZE = exports.MAX_CALLDATA_SIZE = void 0;
    exports.MAX_CALLDATA_SIZE = 16777216;
    exports.MAX_ACCESS_LIST_SIZE = 16777216;
    exports.MAX_VERSIONED_HASHES_LIST_SIZE = 16777216;
    exports.LIMIT_BLOBS_PER_TX = 16777216;
    exports.MAX_TX_WRAP_KZG_COMMITMENTS = 16777216;
    exports.FIELD_ELEMENTS_PER_BLOB = 4096;
    exports.BYTES_PER_FIELD_ELEMENT = 32;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/types.js
var require_types3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobNetworkTransactionWrapper = exports.KZGProofType = exports.KZGCommitmentType = exports.SignedBlobTransactionType = exports.ECDSASignatureType = exports.BlobTransactionType = exports.AccessTupleType = exports.AddressType = exports.isAccessList = exports.isAccessListBuffer = exports.Capability = void 0;
    var ssz_1 = require_lib2();
    var constants_1 = require_constants();
    var Bytes20 = new ssz_1.ByteVectorType(20);
    var Bytes32 = new ssz_1.ByteVectorType(32);
    var Bytes48 = new ssz_1.ByteVectorType(48);
    var Uint64 = new ssz_1.UintBigintType(8);
    var Uint256 = new ssz_1.UintBigintType(32);
    var Capability;
    (function(Capability2) {
      Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
      Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
      Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
      Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
    })(Capability = exports.Capability || (exports.Capability = {}));
    function isAccessListBuffer(input) {
      if (input.length === 0) {
        return true;
      }
      const firstItem = input[0];
      if (Array.isArray(firstItem)) {
        return true;
      }
      return false;
    }
    exports.isAccessListBuffer = isAccessListBuffer;
    function isAccessList(input) {
      return !isAccessListBuffer(input);
    }
    exports.isAccessList = isAccessList;
    exports.AddressType = Bytes20;
    exports.AccessTupleType = new ssz_1.ContainerType({
      address: exports.AddressType,
      storageKeys: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE)
    });
    exports.BlobTransactionType = new ssz_1.ContainerType({
      chainId: Uint256,
      nonce: Uint64,
      maxPriorityFeePerGas: Uint256,
      maxFeePerGas: Uint256,
      gas: Uint64,
      to: new ssz_1.UnionType([new ssz_1.NoneType(), exports.AddressType]),
      value: Uint256,
      data: new ssz_1.ByteListType(constants_1.MAX_CALLDATA_SIZE),
      accessList: new ssz_1.ListCompositeType(exports.AccessTupleType, constants_1.MAX_ACCESS_LIST_SIZE),
      maxFeePerDataGas: Uint256,
      blobVersionedHashes: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE)
    });
    exports.ECDSASignatureType = new ssz_1.ContainerType({
      yParity: new ssz_1.BooleanType(),
      r: Uint256,
      s: Uint256
    });
    exports.SignedBlobTransactionType = new ssz_1.ContainerType({
      message: exports.BlobTransactionType,
      signature: exports.ECDSASignatureType
    });
    exports.KZGCommitmentType = Bytes48;
    exports.KZGProofType = exports.KZGCommitmentType;
    exports.BlobNetworkTransactionWrapper = new ssz_1.ContainerType({
      tx: exports.SignedBlobTransactionType,
      blobKzgs: new ssz_1.ListCompositeType(exports.KZGCommitmentType, constants_1.MAX_TX_WRAP_KZG_COMMITMENTS),
      blobs: new ssz_1.ListCompositeType(new ssz_1.ByteVectorType(constants_1.FIELD_ELEMENTS_PER_BLOB * constants_1.BYTES_PER_FIELD_ELEMENT), constants_1.LIMIT_BLOBS_PER_TX),
      kzgAggregatedProof: exports.KZGProofType
    });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/util.js
var require_util3 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.blobTxToNetworkWrapperDataFormat = exports.AccessLists = exports.checkMaxInitCodeSize = void 0;
    var util_1 = require_dist2();
    var types_1 = require_types3();
    function checkMaxInitCodeSize(common, length) {
      const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
      if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
        throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
      }
    }
    exports.checkMaxInitCodeSize = checkMaxInitCodeSize;
    var AccessLists = class {
      static getAccessListData(accessList) {
        let AccessListJSON;
        let bufferAccessList;
        if ((0, types_1.isAccessList)(accessList)) {
          AccessListJSON = accessList;
          const newAccessList = [];
          for (let i = 0; i < accessList.length; i++) {
            const item = accessList[i];
            const addressBuffer = (0, util_1.toBuffer)(item.address);
            const storageItems = [];
            for (let index = 0; index < item.storageKeys.length; index++) {
              storageItems.push((0, util_1.toBuffer)(item.storageKeys[index]));
            }
            newAccessList.push([addressBuffer, storageItems]);
          }
          bufferAccessList = newAccessList;
        } else {
          bufferAccessList = accessList ?? [];
          const json = [];
          for (let i = 0; i < bufferAccessList.length; i++) {
            const data = bufferAccessList[i];
            const address = (0, util_1.bufferToHex)(data[0]);
            const storageKeys = [];
            for (let item = 0; item < data[1].length; item++) {
              storageKeys.push((0, util_1.bufferToHex)(data[1][item]));
            }
            const jsonItem = {
              address,
              storageKeys
            };
            json.push(jsonItem);
          }
          AccessListJSON = json;
        }
        return {
          AccessListJSON,
          accessList: bufferAccessList
        };
      }
      static verifyAccessList(accessList) {
        for (let key = 0; key < accessList.length; key++) {
          const accessListItem = accessList[key];
          const address = accessListItem[0];
          const storageSlots = accessListItem[1];
          if (accessListItem[2] !== void 0) {
            throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
          }
          if (address.length !== 20) {
            throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
          }
          for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
            if (storageSlots[storageSlot].length !== 32) {
              throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
            }
          }
        }
      }
      static getAccessListJSON(accessList) {
        const accessListJSON = [];
        for (let index = 0; index < accessList.length; index++) {
          const item = accessList[index];
          const JSONItem = {
            address: "0x" + (0, util_1.setLengthLeft)(item[0], 20).toString("hex"),
            storageKeys: []
          };
          const storageSlots = item[1];
          for (let slot = 0; slot < storageSlots.length; slot++) {
            const storageSlot = storageSlots[slot];
            JSONItem.storageKeys.push("0x" + (0, util_1.setLengthLeft)(storageSlot, 32).toString("hex"));
          }
          accessListJSON.push(JSONItem);
        }
        return accessListJSON;
      }
      static getDataFeeEIP2930(accessList, common) {
        const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
        const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
        let slots = 0;
        for (let index = 0; index < accessList.length; index++) {
          const item = accessList[index];
          const storageSlots = item[1];
          slots += storageSlots.length;
        }
        const addresses = accessList.length;
        return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
      }
    };
    exports.AccessLists = AccessLists;
    var blobTxToNetworkWrapperDataFormat = (tx) => {
      var _a;
      const to = {
        selector: tx.to !== void 0 ? 1 : 0,
        value: ((_a = tx.to) == null ? void 0 : _a.toBuffer()) ?? null
      };
      return {
        message: {
          chainId: tx.common.chainId(),
          nonce: tx.nonce,
          maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
          maxFeePerGas: tx.maxFeePerGas,
          gas: tx.gasLimit,
          to,
          value: tx.value,
          data: tx.data,
          accessList: tx.accessList.map((listItem) => {
            return { address: listItem[0], storageKeys: listItem[1] };
          }),
          blobVersionedHashes: tx.versionedHashes,
          maxFeePerDataGas: tx.maxFeePerDataGas
        },
        // If transaction is unsigned, signature fields will be initialized to zeroes
        signature: {
          r: tx.r ?? BigInt(0),
          s: tx.s ?? BigInt(0),
          yParity: tx.v === BigInt(1) ? true : false
        }
      };
    };
    exports.blobTxToNetworkWrapperDataFormat = blobTxToNetworkWrapperDataFormat;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/baseTransaction.js
var require_baseTransaction = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/baseTransaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseTransaction = void 0;
    var common_1 = require_dist4();
    var util_1 = require_dist2();
    var types_1 = require_types3();
    var util_2 = require_util3();
    var BaseTransaction = class {
      constructor(txData, opts) {
        this.cache = {
          hash: void 0,
          dataFee: void 0
        };
        this.activeCapabilities = [];
        this.DEFAULT_CHAIN = common_1.Chain.Mainnet;
        this.DEFAULT_HARDFORK = common_1.Hardfork.Merge;
        const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
        this._type = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(type)));
        this.txOptions = opts;
        const toB = (0, util_1.toBuffer)(to === "" ? "0x" : to);
        const vB = (0, util_1.toBuffer)(v === "" ? "0x" : v);
        const rB = (0, util_1.toBuffer)(r === "" ? "0x" : r);
        const sB = (0, util_1.toBuffer)(s === "" ? "0x" : s);
        this.nonce = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(nonce === "" ? "0x" : nonce));
        this.gasLimit = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasLimit === "" ? "0x" : gasLimit));
        this.to = toB.length > 0 ? new util_1.Address(toB) : void 0;
        this.value = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(value === "" ? "0x" : value));
        this.data = (0, util_1.toBuffer)(data === "" ? "0x" : data);
        this.v = vB.length > 0 ? (0, util_1.bufferToBigInt)(vB) : void 0;
        this.r = rB.length > 0 ? (0, util_1.bufferToBigInt)(rB) : void 0;
        this.s = sB.length > 0 ? (0, util_1.bufferToBigInt)(sB) : void 0;
        this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
        this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
        this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
        const createContract = this.to === void 0 || this.to === null;
        const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false;
        const common = opts.common ?? this._getCommon();
        if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {
          (0, util_2.checkMaxInitCodeSize)(common, this.data.length);
        }
      }
      /**
       * Returns the transaction type.
       *
       * Note: legacy txs will return tx type `0`.
       */
      get type() {
        return this._type;
      }
      /**
       * Checks if a tx type defining capability is active
       * on a tx, for example the EIP-1559 fee market mechanism
       * or the EIP-2930 access list feature.
       *
       * Note that this is different from the tx type itself,
       * so EIP-2930 access lists can very well be active
       * on an EIP-1559 tx for example.
       *
       * This method can be useful for feature checks if the
       * tx type is unknown (e.g. when instantiated with
       * the tx factory).
       *
       * See `Capabilites` in the `types` module for a reference
       * on all supported capabilities.
       */
      supports(capability) {
        return this.activeCapabilities.includes(capability);
      }
      validate(stringError = false) {
        const errors = [];
        if (this.getBaseFee() > this.gasLimit) {
          errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
        }
        if (this.isSigned() && !this.verifySignature()) {
          errors.push("Invalid Signature");
        }
        return stringError ? errors : errors.length === 0;
      }
      _validateYParity() {
        const { v } = this;
        if (v !== void 0 && v !== BigInt(0) && v !== BigInt(1)) {
          const msg = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
          throw new Error(msg);
        }
      }
      /**
       * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.
       * Reasoning: https://ethereum.stackexchange.com/a/55728
       */
      _validateHighS() {
        const { s } = this;
        if (this.common.gteHardfork("homestead") && s !== void 0 && s > util_1.SECP256K1_ORDER_DIV_2) {
          const msg = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
          throw new Error(msg);
        }
      }
      /**
       * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
       */
      getBaseFee() {
        const txFee = this.common.param("gasPrices", "tx");
        let fee = this.getDataFee();
        if (txFee)
          fee += txFee;
        if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
          const txCreationFee = this.common.param("gasPrices", "txCreation");
          if (txCreationFee)
            fee += txCreationFee;
        }
        return fee;
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        const txDataZero = this.common.param("gasPrices", "txDataZero");
        const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
        let cost = BigInt(0);
        for (let i = 0; i < this.data.length; i++) {
          this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
        }
        if ((this.to === void 0 || this.to === null) && this.common.isActivatedEIP(3860)) {
          const dataLength = BigInt(Math.ceil(this.data.length / 32));
          const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
          cost += initCodeCost;
        }
        return cost;
      }
      /**
       * If the tx's `to` is to the creation address
       */
      toCreationAddress() {
        return this.to === void 0 || this.to.buf.length === 0;
      }
      isSigned() {
        const { v, r, s } = this;
        if (v === void 0 || r === void 0 || s === void 0) {
          return false;
        } else {
          return true;
        }
      }
      /**
       * Determines if the signature is valid
       */
      verifySignature() {
        try {
          const publicKey = this.getSenderPublicKey();
          return (0, util_1.unpadBuffer)(publicKey).length !== 0;
        } catch (e) {
          return false;
        }
      }
      /**
       * Returns the sender's address
       */
      getSenderAddress() {
        return new util_1.Address((0, util_1.publicToAddress)(this.getSenderPublicKey()));
      }
      /**
       * Signs a transaction.
       *
       * Note that the signed tx is returned as a new object,
       * use as follows:
       * ```javascript
       * const signedTx = tx.sign(privateKey)
       * ```
       */
      sign(privateKey) {
        if (privateKey.length !== 32) {
          const msg = this._errorMsg("Private key must be 32 bytes in length.");
          throw new Error(msg);
        }
        let hackApplied = false;
        if (this.type === 0 && this.common.gteHardfork("spuriousDragon") && !this.supports(types_1.Capability.EIP155ReplayProtection)) {
          this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
          hackApplied = true;
        }
        const msgHash = this.getMessageToSign(true);
        const { v, r, s } = (0, util_1.ecsign)(msgHash, privateKey);
        const tx = this._processSignature(v, r, s);
        if (hackApplied) {
          const index = this.activeCapabilities.indexOf(types_1.Capability.EIP155ReplayProtection);
          if (index > -1) {
            this.activeCapabilities.splice(index, 1);
          }
        }
        return tx;
      }
      /**
       * Does chain ID checks on common and returns a common
       * to be used on instantiation
       * @hidden
       *
       * @param common - {@link Common} instance from tx options
       * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)
       */
      _getCommon(common, chainId) {
        if (chainId !== void 0) {
          const chainIdBigInt = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(chainId));
          if (common) {
            if (common.chainId() !== chainIdBigInt) {
              const msg = this._errorMsg("The chain ID does not match the chain ID of Common");
              throw new Error(msg);
            }
            return common.copy();
          } else {
            if (common_1.Common.isSupportedChainId(chainIdBigInt)) {
              return new common_1.Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
            } else {
              return common_1.Common.custom({
                name: "custom-chain",
                networkId: chainIdBigInt,
                chainId: chainIdBigInt
              }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
            }
          }
        } else {
          return (common == null ? void 0 : common.copy()) ?? new common_1.Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
        }
      }
      /**
       * Validates that an object with BigInt values cannot exceed the specified bit limit.
       * @param values Object containing string keys and BigInt values
       * @param bits Number of bits to check (64 or 256)
       * @param cannotEqual Pass true if the number also cannot equal one less the maximum value
       */
      _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
        for (const [key, value] of Object.entries(values)) {
          switch (bits) {
            case 64:
              if (cannotEqual) {
                if (value !== void 0 && value >= util_1.MAX_UINT64) {
                  const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
                  throw new Error(msg);
                }
              } else {
                if (value !== void 0 && value > util_1.MAX_UINT64) {
                  const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
                  throw new Error(msg);
                }
              }
              break;
            case 256:
              if (cannotEqual) {
                if (value !== void 0 && value >= util_1.MAX_INTEGER) {
                  const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
                  throw new Error(msg);
                }
              } else {
                if (value !== void 0 && value > util_1.MAX_INTEGER) {
                  const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
                  throw new Error(msg);
                }
              }
              break;
            default: {
              const msg = this._errorMsg("unimplemented bits value");
              throw new Error(msg);
            }
          }
        }
      }
      static _validateNotArray(values) {
        const txDataKeys = [
          "nonce",
          "gasPrice",
          "gasLimit",
          "to",
          "value",
          "data",
          "v",
          "r",
          "s",
          "type",
          "baseFee",
          "maxFeePerGas",
          "chainId"
        ];
        for (const [key, value] of Object.entries(values)) {
          if (txDataKeys.includes(key)) {
            if (Array.isArray(value)) {
              throw new Error(`${key} cannot be an array`);
            }
          }
        }
      }
      /**
       * Returns the shared error postfix part for _error() method
       * tx type implementations.
       */
      _getSharedErrorPostfix() {
        let hash = "";
        try {
          hash = this.isSigned() ? (0, util_1.bufferToHex)(this.hash()) : "not available (unsigned)";
        } catch (e) {
          hash = "error";
        }
        let isSigned = "";
        try {
          isSigned = this.isSigned().toString();
        } catch (e) {
          hash = "error";
        }
        let hf = "";
        try {
          hf = this.common.hardfork();
        } catch (e) {
          hf = "error";
        }
        let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;
        postfix += `signed=${isSigned} hf=${hf}`;
        return postfix;
      }
    };
    exports.BaseTransaction = BaseTransaction;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/eip1559Transaction.js
var require_eip1559Transaction = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/eip1559Transaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FeeMarketEIP1559Transaction = void 0;
    var rlp_1 = require_dist();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var util_2 = require_util3();
    var TRANSACTION_TYPE = 2;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var FeeMarketEIP1559Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.DEFAULT_HARDFORK = "london";
        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (this.common.isActivatedEIP(1559) === false) {
          throw new Error("EIP-1559 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === "" ? "0x" : maxFeePerGas));
        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
        this._validateCannotExceedMaxInteger({
          maxFeePerGas: this.maxFeePerGas,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
          const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
          throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, v, r, s }
       *
       * Notes:
       * - `chainId` will be set automatically if not provided
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
        return new FeeMarketEIP1559Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS])`
       */
      static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
          throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized.slice(0, 1).toString("hex")}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(serialized.slice(1)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input: must be array");
        }
        return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS]`
       */
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 9 && values.length !== 12) {
          throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
        }
        const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
        return new FeeMarketEIP1559Transaction({
          chainId: (0, util_1.bufferToBigInt)(chainId),
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gasLimit,
          to,
          value,
          data,
          accessList: accessList ?? [],
          v: v !== void 0 ? (0, util_1.bufferToBigInt)(v) : void 0,
          r,
          s
        }, opts);
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: cost,
            hardfork: this.common.hardfork()
          };
        }
        return cost;
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       * @param baseFee The base fee of the block (will be set to 0 if not provided)
       */
      getUpfrontCost(baseFee = BigInt(0)) {
        const prio = this.maxPriorityFeePerGas;
        const maxBase = this.maxFeePerGas - baseFee;
        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
        const gasPrice = inclusionFeePerGas + baseFee;
        return this.gasLimit * gasPrice + this.value;
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the EIP-1559 transaction, in order.
       *
       * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS]`
       *
       * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block
       * with {@link Block.fromValuesArray}.
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.
       */
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),
          (0, util_1.bigIntToUnpaddedBuffer)(this.maxFeePerGas),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.accessList,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      /**
       * Returns the serialized encoding of the EIP-1559 transaction.
       *
       * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS])`
       *
       * Note that in contrast to the legacy tx serialization format this is not
       * valid RLP any more due to the raw tx type preceding and concatenated to
       * the RLP encoding of the values.
       */
      serialize() {
        const base = this.raw();
        return Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
      }
      /**
       * Returns the serialized unsigned tx (hashed or raw), which can be used
       * to sign the transaction (e.g. for sending to a hardware wallet).
       *
       * Note: in contrast to the legacy tx the raw message format is already
       * serialized and doesn't need to be RLP encoded any more.
       *
       * ```javascript
       * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
       * ```
       *
       * @param hashMessage - Return hashed message if set to true (default: true)
       */
      getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 9);
        const message = Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(message));
        } else {
          return message;
        }
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return FeeMarketEIP1559Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          maxFeePerGas: this.maxFeePerGas,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction
       */
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),
          maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.FeeMarketEIP1559Transaction = FeeMarketEIP1559Transaction;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/eip2930Transaction.js
var require_eip2930Transaction = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/eip2930Transaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccessListEIP2930Transaction = void 0;
    var rlp_1 = require_dist();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var util_2 = require_util3();
    var TRANSACTION_TYPE = 1;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var AccessListEIP2930Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.DEFAULT_HARDFORK = "berlin";
        const { chainId, accessList, gasPrice } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (!this.common.isActivatedEIP(2930)) {
          throw new Error("EIP-2930 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasPrice === "" ? "0x" : gasPrice));
        this._validateCannotExceedMaxInteger({
          gasPrice: this.gasPrice
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
          throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * v, r, s }
       *
       * Notes:
       * - `chainId` will be set automatically if not provided
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
        return new AccessListEIP2930Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)])`
       */
      static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
          throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized.slice(0, 1).toString("hex")}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized.slice(1))));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input: must be array");
        }
        return AccessListEIP2930Transaction.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)]`
       */
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 8 && values.length !== 11) {
          throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
        }
        const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        const emptyAccessList = [];
        return new AccessListEIP2930Transaction({
          chainId: (0, util_1.bufferToBigInt)(chainId),
          nonce,
          gasPrice,
          gasLimit,
          to,
          value,
          data,
          accessList: accessList ?? emptyAccessList,
          v: v !== void 0 ? (0, util_1.bufferToBigInt)(v) : void 0,
          r,
          s
        }, opts);
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: cost,
            hardfork: this.common.hardfork()
          };
        }
        return cost;
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       */
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.
       *
       * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)]`
       *
       * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block
       * with {@link Block.fromValuesArray}.
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.
       */
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.accessList,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      /**
       * Returns the serialized encoding of the EIP-2930 transaction.
       *
       * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)])`
       *
       * Note that in contrast to the legacy tx serialization format this is not
       * valid RLP any more due to the raw tx type preceding and concatenated to
       * the RLP encoding of the values.
       */
      serialize() {
        const base = this.raw();
        return Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
      }
      /**
       * Returns the serialized unsigned tx (hashed or raw), which can be used
       * to sign the transaction (e.g. for sending to a hardware wallet).
       *
       * Note: in contrast to the legacy tx the raw message format is already
       * serialized and doesn't need to be RLP encoded any more.
       *
       * ```javascript
       * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
       * ```
       *
       * @param hashMessage - Return hashed message if set to true (default: true)
       */
      getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 8);
        const message = Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(message));
        } else {
          return message;
        }
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return AccessListEIP2930Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction
       */
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        var _a;
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice} accessListCount=${((_a = this.accessList) == null ? void 0 : _a.length) ?? 0}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.AccessListEIP2930Transaction = AccessListEIP2930Transaction;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/kzg/kzg.js
var require_kzg = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/kzg/kzg.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initKZG = exports.kzg = void 0;
    function kzgNotLoaded() {
      throw Error("kzg library not loaded");
    }
    exports.kzg = {
      freeTrustedSetup: kzgNotLoaded,
      loadTrustedSetup: kzgNotLoaded,
      blobToKzgCommitment: kzgNotLoaded,
      computeAggregateKzgProof: kzgNotLoaded,
      verifyKzgProof: kzgNotLoaded,
      verifyAggregateKzgProof: kzgNotLoaded
    };
    function initKZG(kzgLib, trustedSetupPath) {
      exports.kzg = kzgLib;
      exports.kzg.loadTrustedSetup(trustedSetupPath);
    }
    exports.initKZG = initKZG;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/ethereum-cryptography/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/ethereum-cryptography/sha256.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils3();
    exports.sha256 = (0, utils_1.wrapHash)(sha256_1.sha256);
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/utils/blobHelpers.js
var require_blobHelpers = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/utils/blobHelpers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.commitmentsToVersionedHashes = exports.computeVersionedHash = exports.blobsToCommitments = exports.getBlobs = void 0;
    var sha256_1 = require_sha2562();
    var kzg_1 = require_kzg();
    var BYTES_PER_FIELD_ELEMENT = 32;
    var FIELD_ELEMENTS_PER_BLOB = 4096;
    var USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
    var MAX_BLOBS_PER_TX = 2;
    var MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;
    var BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;
    function get_padded(data, blobs_len) {
      const pdata = Buffer.alloc(blobs_len * USEFUL_BYTES_PER_BLOB);
      const datalen = Buffer.byteLength(data);
      pdata.fill(data, 0, datalen);
      pdata[datalen] = 128;
      return pdata;
    }
    function get_blob(data) {
      const blob = Buffer.alloc(BLOB_SIZE, "binary");
      for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {
        const chunk = Buffer.alloc(32, "binary");
        chunk.fill(data.subarray(i * 31, (i + 1) * 31), 0, 31);
        blob.fill(chunk, i * 32, (i + 1) * 32);
      }
      return blob;
    }
    var getBlobs = (input) => {
      const data = Buffer.from(input, "binary");
      const len = Buffer.byteLength(data);
      if (len === 0) {
        throw Error("invalid blob data");
      }
      if (len > MAX_USEFUL_BYTES_PER_TX) {
        throw Error("blob data is too large");
      }
      const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);
      const pdata = get_padded(data, blobs_len);
      const blobs = [];
      for (let i = 0; i < blobs_len; i++) {
        const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);
        const blob = get_blob(chunk);
        blobs.push(blob);
      }
      return blobs;
    };
    exports.getBlobs = getBlobs;
    var blobsToCommitments = (blobs) => {
      const commitments = [];
      for (const blob of blobs) {
        commitments.push(Buffer.from(kzg_1.kzg.blobToKzgCommitment(blob)));
      }
      return commitments;
    };
    exports.blobsToCommitments = blobsToCommitments;
    var computeVersionedHash = (commitment, blobCommitmentVersion) => {
      const computedVersionedHash = new Uint8Array(32);
      computedVersionedHash.set([blobCommitmentVersion], 0);
      computedVersionedHash.set((0, sha256_1.sha256)(commitment).slice(1), 1);
      return computedVersionedHash;
    };
    exports.computeVersionedHash = computeVersionedHash;
    var commitmentsToVersionedHashes = (commitments) => {
      const hashes = [];
      for (const commitment of commitments) {
        hashes.push(Buffer.from((0, exports.computeVersionedHash)(commitment, 1)));
      }
      return hashes;
    };
    exports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/eip4844Transaction.js
var require_eip4844Transaction = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/eip4844Transaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobEIP4844Transaction = void 0;
    var ssz_1 = require_lib2();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var constants_1 = require_constants();
    var kzg_1 = require_kzg();
    var types_1 = require_types3();
    var util_2 = require_util3();
    var blobHelpers_1 = require_blobHelpers();
    var TRANSACTION_TYPE = 5;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var validateBlobTransactionNetworkWrapper = (versionedHashes, blobs, commitments, kzgProof, version) => {
      if (!(versionedHashes.length === blobs.length && blobs.length === commitments.length)) {
        throw new Error("Number of versionedHashes, blobs, and commitments not all equal");
      }
      try {
        kzg_1.kzg.verifyAggregateKzgProof(blobs, commitments, kzgProof);
      } catch (e) {
        throw new Error("KZG proof cannot be verified from blobs/commitments");
      }
      for (let x = 0; x < versionedHashes.length; x++) {
        const computedVersionedHash = (0, blobHelpers_1.computeVersionedHash)(commitments[x], version);
        if (!(0, ssz_1.byteArrayEquals)(computedVersionedHash, versionedHashes[x])) {
          throw new Error(`commitment for blob at index ${x} does not match versionedHash`);
        }
      }
    };
    var BlobEIP4844Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static constructors or factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        var _a, _b;
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas, maxFeePerDataGas } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (this.common.isActivatedEIP(1559) === false) {
          throw new Error("EIP-1559 not enabled on Common");
        }
        if (this.common.isActivatedEIP(4844) === false) {
          throw new Error("EIP-4844 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === "" ? "0x" : maxFeePerGas));
        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
        this._validateCannotExceedMaxInteger({
          maxFeePerGas: this.maxFeePerGas,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
          const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
          throw new Error(msg);
        }
        this.maxFeePerDataGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)((maxFeePerDataGas ?? "") === "" ? "0x" : maxFeePerDataGas));
        this.versionedHashes = (txData.versionedHashes ?? []).map((vh) => (0, util_1.toBuffer)(vh));
        this._validateYParity();
        this._validateHighS();
        for (const hash of this.versionedHashes) {
          if (hash.length !== 32) {
            const msg = this._errorMsg("versioned hash is invalid length");
            throw new Error(msg);
          }
          if (BigInt(hash[0]) !== this.common.paramByEIP("sharding", "blobCommitmentVersionKzg", 4844)) {
            const msg = this._errorMsg("versioned hash does not start with KZG commitment version");
            throw new Error(msg);
          }
        }
        if (this.versionedHashes.length > constants_1.LIMIT_BLOBS_PER_TX) {
          const msg = this._errorMsg(`tx can contain at most ${constants_1.LIMIT_BLOBS_PER_TX} blobs`);
          throw new Error(msg);
        }
        this.blobs = (_a = txData.blobs) == null ? void 0 : _a.map((blob) => (0, util_1.toBuffer)(blob));
        this.kzgCommitments = (_b = txData.kzgCommitments) == null ? void 0 : _b.map((commitment) => (0, util_1.toBuffer)(commitment));
        this.aggregateKzgProof = (0, util_1.toBuffer)(txData.kzgProof);
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      static fromTxData(txData, opts) {
        return new BlobEIP4844Transaction(txData, opts);
      }
      /**
       * Creates the minimal representation of a blob transaction from the network wrapper version.
       * The minimal representation is used when adding transactions to an execution payload/block
       * @param txData a {@link BlobEIP4844Transaction} containing optional blobs/kzg commitments
       * @param opts - dictionary of {@link TxOptions}
       * @returns the "minimal" representation of a BlobEIP4844Transaction (i.e. transaction object minus blobs and kzg commitments)
       */
      static minimalFromNetworkWrapper(txData, opts) {
        const tx = BlobEIP4844Transaction.fromTxData({
          ...txData,
          ...{ blobs: void 0, kzgCommitments: void 0, kzgProof: void 0 }
        }, opts);
        return tx;
      }
      /**
       * Creates a transaction from the network encoding of a blob transaction (with blobs/commitments/proof)
       * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper
       * @param opts any TxOptions defined
       * @returns a BlobEIP4844Transaction
       * @throws if no KZG library is loaded -- using the `initKzg` helper method -- or if `opts.common` not provided
       */
      static fromSerializedBlobTxNetworkWrapper(serialized, opts) {
        if (!opts || !opts.common) {
          throw new Error("common instance required to validate versioned hashes");
        }
        const wrapper = types_1.BlobNetworkTransactionWrapper.deserialize(serialized.slice(1));
        const decodedTx = wrapper.tx.message;
        const version = Number(opts.common.paramByEIP("sharding", "blobCommitmentVersionKzg", 4844));
        validateBlobTransactionNetworkWrapper(decodedTx.blobVersionedHashes, wrapper.blobs, wrapper.blobKzgs, wrapper.kzgAggregatedProof, version);
        const accessList = [];
        for (const listItem of decodedTx.accessList) {
          const address = Buffer.from(listItem.address);
          const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));
          const accessListItem = [address, storageKeys];
          accessList.push(accessListItem);
        }
        const to = decodedTx.to.value === null ? void 0 : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(decodedTx.to.value)));
        const versionedHashes = decodedTx.blobVersionedHashes.map((el) => Buffer.from(el));
        const commitments = wrapper.blobKzgs.map((el) => Buffer.from(el));
        const blobs = wrapper.blobs.map((el) => Buffer.from(el));
        const txData = {
          ...decodedTx,
          ...{
            versionedHashes,
            accessList,
            to,
            blobs,
            kzgCommitments: commitments,
            kzgProof: Buffer.from(wrapper.kzgAggregatedProof),
            r: wrapper.tx.signature.r,
            s: wrapper.tx.signature.s,
            v: BigInt(wrapper.tx.signature.yParity),
            gasLimit: decodedTx.gas,
            maxFeePerGas: decodedTx.maxFeePerGas,
            maxPriorityFeePerGas: decodedTx.maxPriorityFeePerGas
          }
        };
        return new BlobEIP4844Transaction(txData, opts);
      }
      /**
       * Creates a transaction from the "minimal" encoding of a blob transaction (without blobs/commitments/kzg proof)
       * @param serialized a buffer representing a serialized signed blob transaction
       * @param opts any TxOptions defined
       * @returns a BlobEIP4844Transaction
       */
      static fromSerializedTx(serialized, opts) {
        const decoded = types_1.SignedBlobTransactionType.deserialize(serialized.slice(1));
        const tx = decoded.message;
        const accessList = [];
        for (const listItem of tx.accessList) {
          const address = Buffer.from(listItem.address);
          const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));
          const accessListItem = [address, storageKeys];
          accessList.push(accessListItem);
        }
        const to = tx.to.value === null ? void 0 : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(tx.to.value)));
        const versionedHashes = tx.blobVersionedHashes.map((el) => Buffer.from(el));
        const txData = {
          ...tx,
          ...{
            versionedHashes,
            to,
            accessList,
            r: decoded.signature.r,
            s: decoded.signature.s,
            v: BigInt(decoded.signature.yParity),
            gasLimit: decoded.message.gas
          }
        };
        return new BlobEIP4844Transaction(txData, opts);
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       * @param baseFee The base fee of the block (will be set to 0 if not provided)
       */
      getUpfrontCost(baseFee = BigInt(0)) {
        const prio = this.maxPriorityFeePerGas;
        const maxBase = this.maxFeePerGas - baseFee;
        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
        const gasPrice = inclusionFeePerGas + baseFee;
        return this.gasLimit * gasPrice + this.value;
      }
      /**
       * This method is not implemented for blob transactions as the `raw` method is used exclusively with
       * rlp encoding and these transactions use SSZ for serialization.
       */
      raw() {
        throw new Error("Method not implemented.");
      }
      toValue() {
        var _a;
        const to = {
          selector: this.to !== void 0 ? 1 : 0,
          value: ((_a = this.to) == null ? void 0 : _a.toBuffer()) ?? null
        };
        return {
          message: {
            chainId: this.common.chainId(),
            nonce: this.nonce,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas,
            maxFeePerGas: this.maxFeePerGas,
            gas: this.gasLimit,
            to,
            value: this.value,
            data: this.data,
            accessList: this.accessList.map((listItem) => {
              return { address: listItem[0], storageKeys: listItem[1] };
            }),
            blobVersionedHashes: this.versionedHashes,
            maxFeePerDataGas: this.maxFeePerDataGas
          },
          // TODO: Decide how to serialize an unsigned transaction
          signature: {
            r: this.r ?? BigInt(0),
            s: this.s ?? BigInt(0),
            yParity: this.v === BigInt(1) ? true : false
          }
        };
      }
      /**
       * Serialize a blob transaction to the execution payload variant
       * @returns the minimum (execution payload) serialization of a signed transaction
       */
      serialize() {
        const sszEncodedTx = types_1.SignedBlobTransactionType.serialize(this.toValue());
        return Buffer.concat([TRANSACTION_TYPE_BUFFER, sszEncodedTx]);
      }
      /**
       * @returns the serialized form of a blob transaction in the network wrapper format (used for gossipping mempool transactions over devp2p)
       */
      serializeNetworkWrapper() {
        var _a, _b, _c;
        if (this.blobs === void 0 || this.kzgCommitments === void 0 || this.aggregateKzgProof === void 0) {
          throw new Error("cannot serialize network wrapper without blobs, KZG commitments and aggregate KZG proof provided");
        }
        const to = {
          selector: this.to !== void 0 ? 1 : 0,
          value: ((_a = this.to) == null ? void 0 : _a.toBuffer()) ?? null
        };
        const blobArrays = ((_b = this.blobs) == null ? void 0 : _b.map((blob) => Uint8Array.from(blob))) ?? [];
        const serializedTxWrapper = types_1.BlobNetworkTransactionWrapper.serialize({
          blobs: blobArrays,
          blobKzgs: ((_c = this.kzgCommitments) == null ? void 0 : _c.map((commitment) => Uint8Array.from(commitment))) ?? [],
          tx: { ...(0, util_2.blobTxToNetworkWrapperDataFormat)(this), ...to },
          kzgAggregatedProof: Uint8Array.from(this.aggregateKzgProof ?? [])
        });
        return Buffer.concat([Buffer.from([5]), serializedTxWrapper]);
      }
      getMessageToSign(_hashMessage) {
        return this.unsignedHash();
      }
      /**
       * Returns the hash of a blob transaction
       */
      unsignedHash() {
        const serializedTx = types_1.BlobTransactionType.serialize(this.toValue().message);
        return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([TRANSACTION_TYPE_BUFFER, serializedTx])));
      }
      hash() {
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),
          maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0,
          maxFeePerDataGas: (0, util_1.bigIntToHex)(this.maxFeePerDataGas),
          versionedHashes: this.versionedHashes.map((hash) => (0, util_1.bufferToHex)(hash))
        };
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return BlobEIP4844Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          maxFeePerGas: this.maxFeePerGas,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s),
          maxFeePerDataGas: this.maxFeePerDataGas,
          versionedHashes: this.versionedHashes,
          blobs: this.blobs,
          kzgCommitments: this.kzgCommitments,
          kzgProof: this.aggregateKzgProof
        }, opts);
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
      /**
       * @returns the number of blobs included with this transaction
       */
      numBlobs() {
        return this.versionedHashes.length;
      }
    };
    exports.BlobEIP4844Transaction = BlobEIP4844Transaction;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/legacyTransaction.js
var require_legacyTransaction = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/legacyTransaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = void 0;
    var rlp_1 = require_dist();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var types_1 = require_types3();
    var TRANSACTION_TYPE = 0;
    function meetsEIP155(_v, chainId) {
      const v = Number(_v);
      const chainIdDoubled = Number(chainId) * 2;
      return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
    }
    var Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.common = this._validateTxV(this.v, opts.common);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.gasPrice === "" ? "0x" : txData.gasPrice));
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.common.gteHardfork("spuriousDragon")) {
          if (!this.isSigned()) {
            this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
          } else {
            if (meetsEIP155(this.v, this.common.chainId())) {
              this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
            }
          }
        }
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }
       *
       * Notes:
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
        return new Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
       */
      static fromSerializedTx(serialized, opts = {}) {
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input. Must be array");
        }
        return this.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
       */
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 6 && values.length !== 9) {
          throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
        }
        const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        return new Transaction({
          nonce,
          gasPrice,
          gasLimit,
          to,
          value,
          data,
          v,
          r,
          s
        }, opts);
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the legacy transaction, in order.
       *
       * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
       *
       * For legacy txs this is also the correct format to add transactions
       * to a block with {@link Block.fromValuesArray} (use the `serialize()` method
       * for typed txs).
       *
       * For an unsigned tx this method returns the empty Buffer values
       * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant
       * representation have a look at {@link Transaction.getMessageToSign}.
       */
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      /**
       * Returns the serialized encoding of the legacy transaction.
       *
       * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link Transaction.getMessageToSign}.
       */
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw())));
      }
      _getMessageToSign() {
        const values = [
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data
        ];
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
          values.push((0, util_1.toBuffer)(this.common.chainId()));
          values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
          values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
        }
        return values;
      }
      getMessageToSign(hashMessage = true) {
        const message = this._getMessageToSign();
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
        } else {
          return message;
        }
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: super.getDataFee(),
            hardfork: this.common.hardfork()
          };
        }
        return super.getDataFee();
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       */
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("This transaction is not signed");
          throw new Error(msg);
        }
        const message = this._getMessageToSign();
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(msgHash, v, (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s), this.supports(types_1.Capability.EIP155ReplayProtection) ? this.common.chainId() : void 0);
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      /**
       * Process the v, r, s values from the `sign` method of the base transaction.
       */
      _processSignature(v, r, s) {
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
          v += this.common.chainId() * BigInt(2) + BigInt(8);
        }
        const opts = { ...this.txOptions, common: this.common };
        return Transaction.fromTxData({
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          v,
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction.
       */
      toJSON() {
        return {
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      /**
       * Validates tx's `v` value
       */
      _validateTxV(_v, common) {
        let chainIdBigInt;
        const v = _v !== void 0 ? Number(_v) : void 0;
        if (v !== void 0) {
          if (v < 37 && v !== 27 && v !== 28) {
            throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
          }
        }
        if (v !== void 0 && v !== 0 && (!common || common.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
          if (common) {
            if (!meetsEIP155(BigInt(v), common.chainId())) {
              throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
            }
          } else {
            let numSub;
            if ((v - 35) % 2 === 0) {
              numSub = 35;
            } else {
              numSub = 36;
            }
            chainIdBigInt = BigInt(v - numSub) / BigInt(2);
          }
        }
        return this._getCommon(common, chainIdBigInt);
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.Transaction = Transaction;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/fromRpc.js
var require_fromRpc = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/fromRpc.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeTxParams = void 0;
    var util_1 = require_dist2();
    var normalizeTxParams = (_txParams) => {
      const txParams = Object.assign({}, _txParams);
      txParams.gasLimit = (0, util_1.toType)(txParams.gasLimit ?? txParams.gas, util_1.TypeOutput.BigInt);
      txParams.data = txParams.data === void 0 ? txParams.input : txParams.data;
      txParams.gasPrice = txParams.gasPrice !== void 0 ? BigInt(txParams.gasPrice) : void 0;
      txParams.value = txParams.value !== void 0 ? BigInt(txParams.value) : void 0;
      txParams.to = txParams.to !== null && txParams.to !== void 0 ? (0, util_1.setLengthLeft)((0, util_1.toBuffer)(txParams.to), 20) : null;
      txParams.v = txParams.v === "0x0" ? "0x" : txParams.v;
      txParams.r = txParams.r === "0x0" ? "0x" : txParams.r;
      txParams.s = txParams.s === "0x0" ? "0x" : txParams.s;
      if (txParams.v !== "0x") {
        txParams.v = (0, util_1.toType)(txParams.v, util_1.TypeOutput.BigInt);
      }
      return txParams;
    };
    exports.normalizeTxParams = normalizeTxParams;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/transactionFactory.js
var require_transactionFactory = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/transactionFactory.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionFactory = void 0;
    var util_1 = require_dist2();
    var eip1559Transaction_1 = require_eip1559Transaction();
    var eip2930Transaction_1 = require_eip2930Transaction();
    var eip4844Transaction_1 = require_eip4844Transaction();
    var fromRpc_1 = require_fromRpc();
    var legacyTransaction_1 = require_legacyTransaction();
    var TransactionFactory2 = class {
      // It is not possible to instantiate a TransactionFactory object.
      constructor() {
      }
      /**
       * Create a transaction from a `txData` object
       *
       * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
       * @param txOptions - Options to pass on to the constructor of the transaction
       */
      static fromTxData(txData, txOptions = {}) {
        if (!("type" in txData) || txData.type === void 0) {
          return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
        } else {
          const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));
          if (txType === 0) {
            return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
          } else if (txType === 1) {
            return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);
          } else if (txType === 2) {
            return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
          } else if (txType === 5) {
            return eip4844Transaction_1.BlobEIP4844Transaction.fromTxData(txData, txOptions);
          } else {
            throw new Error(`Tx instantiation with type ${txType} not supported`);
          }
        }
      }
      /**
       * This method tries to decode serialized data.
       *
       * @param data - The data Buffer
       * @param txOptions - The transaction options
       */
      static fromSerializedData(data, txOptions = {}) {
        if (data[0] <= 127) {
          switch (data[0]) {
            case 1:
              return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
            case 2:
              return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
            case 5:
              return eip4844Transaction_1.BlobEIP4844Transaction.fromSerializedTx(data, txOptions);
            default:
              throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
          }
        } else {
          return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);
        }
      }
      /**
       * When decoding a BlockBody, in the transactions field, a field is either:
       * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))
       * A Buffer[] (Legacy Transaction)
       * This method returns the right transaction.
       *
       * @param data - A Buffer or Buffer[]
       * @param txOptions - The transaction options
       */
      static fromBlockBodyData(data, txOptions = {}) {
        if (Buffer.isBuffer(data)) {
          return this.fromSerializedData(data, txOptions);
        } else if (Array.isArray(data)) {
          return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);
        } else {
          throw new Error("Cannot decode transaction: unknown type input");
        }
      }
      /**
       *  Method to retrieve a transaction from the provider
       * @param provider - An Ethers JsonRPCProvider
       * @param txHash - Transaction hash
       * @param txOptions - The transaction options
       * @returns the transaction specified by `txHash`
       */
      static async fromEthersProvider(provider, txHash, txOptions) {
        const prov = (0, util_1.getProvider)(provider);
        const txData = await (0, util_1.fetchFromProvider)(prov, {
          method: "eth_getTransactionByHash",
          params: [txHash]
        });
        if (txData === null) {
          throw new Error("No data returned from provider");
        }
        return TransactionFactory2.fromRPCTx(txData, txOptions);
      }
      /**
       * Method to decode data retrieved from RPC, such as `eth_getTransactionByHash`
       * Note that this normalizes some of the parameters
       * @param txData The RPC-encoded data
       * @param txOptions The transaction options
       * @returns
       */
      static async fromRPCTx(txData, txOptions = {}) {
        return TransactionFactory2.fromTxData((0, fromRpc_1.normalizeTxParams)(txData), txOptions);
      }
    };
    exports.TransactionFactory = TransactionFactory2;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeVersionedHash = exports.TransactionFactory = exports.Transaction = exports.kzg = exports.initKZG = exports.BlobEIP4844Transaction = exports.AccessListEIP2930Transaction = exports.FeeMarketEIP1559Transaction = void 0;
    var eip1559Transaction_1 = require_eip1559Transaction();
    Object.defineProperty(exports, "FeeMarketEIP1559Transaction", { enumerable: true, get: function() {
      return eip1559Transaction_1.FeeMarketEIP1559Transaction;
    } });
    var eip2930Transaction_1 = require_eip2930Transaction();
    Object.defineProperty(exports, "AccessListEIP2930Transaction", { enumerable: true, get: function() {
      return eip2930Transaction_1.AccessListEIP2930Transaction;
    } });
    var eip4844Transaction_1 = require_eip4844Transaction();
    Object.defineProperty(exports, "BlobEIP4844Transaction", { enumerable: true, get: function() {
      return eip4844Transaction_1.BlobEIP4844Transaction;
    } });
    var kzg_1 = require_kzg();
    Object.defineProperty(exports, "initKZG", { enumerable: true, get: function() {
      return kzg_1.initKZG;
    } });
    Object.defineProperty(exports, "kzg", { enumerable: true, get: function() {
      return kzg_1.kzg;
    } });
    var legacyTransaction_1 = require_legacyTransaction();
    Object.defineProperty(exports, "Transaction", { enumerable: true, get: function() {
      return legacyTransaction_1.Transaction;
    } });
    var transactionFactory_1 = require_transactionFactory();
    Object.defineProperty(exports, "TransactionFactory", { enumerable: true, get: function() {
      return transactionFactory_1.TransactionFactory;
    } });
    __exportStar(require_types3(), exports);
    var blobHelpers_1 = require_blobHelpers();
    Object.defineProperty(exports, "computeVersionedHash", { enumerable: true, get: function() {
      return blobHelpers_1.computeVersionedHash;
    } });
  }
});

// node_modules/ethjs-util/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/ethjs-util/lib/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var isHexPrefixed = require_src();
    var stripHexPrefix2 = require_src2();
    function padToEven(value) {
      var a = value;
      if (typeof a !== "string") {
        throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a + ", while padToEven.");
      }
      if (a.length % 2) {
        a = "0" + a;
      }
      return a;
    }
    function intToHex(i) {
      var hex3 = i.toString(16);
      return "0x" + hex3;
    }
    function intToBuffer(i) {
      var hex3 = intToHex(i);
      return new Buffer(padToEven(hex3.slice(2)), "hex");
    }
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str + "'.");
      }
      return Buffer.byteLength(str, "utf8");
    }
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
      }
      return subset[Boolean(some) && "some" || "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    function toUtf8(hex3) {
      var bufferValue = new Buffer(padToEven(stripHexPrefix2(hex3).replace(/^0+|0+$/g, "")), "hex");
      return bufferValue.toString("utf8");
    }
    function toAscii(hex3) {
      var str = "";
      var i = 0, l = hex3.length;
      if (hex3.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex3.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    function fromUtf8(stringValue) {
      var str = new Buffer(stringValue, "utf8");
      return "0x" + padToEven(str.toString("hex")).replace(/^0+|0+$/g, "");
    }
    function fromAscii(stringValue) {
      var hex3 = "";
      for (var i = 0; i < stringValue.length; i++) {
        var code = stringValue.charCodeAt(i);
        var n = code.toString(16);
        hex3 += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex3;
    }
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
      }
      if (typeof key !== "string") {
        throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key + "'.");
      }
      var result = [];
      for (var i = 0; i < params.length; i++) {
        var value = params[i][key];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi");
        }
        result.push(value);
      }
      return result;
    }
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    module.exports = {
      arrayContainsArray,
      intToBuffer,
      getBinarySize,
      isHexPrefixed,
      stripHexPrefix: stripHexPrefix2,
      padToEven,
      intToHex,
      fromAscii,
      fromUtf8,
      toAscii,
      toUtf8,
      getKeys,
      isHexString
    };
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/utils.js
var require_utils5 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberToBuffer = exports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;
    var util_1 = require_dist2();
    var ethjs_util_1 = require_lib3();
    function padWithZeroes(hexString, targetLength) {
      if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
      }
      if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
      }
      return String.prototype.padStart.call(hexString, targetLength, "0");
    }
    exports.padWithZeroes = padWithZeroes;
    function isNullish(value) {
      return value === null || value === void 0;
    }
    exports.isNullish = isNullish;
    function legacyToBuffer(value) {
      return typeof value === "string" && !(0, ethjs_util_1.isHexString)(value) ? Buffer.from(value) : (0, util_1.toBuffer)(value);
    }
    exports.legacyToBuffer = legacyToBuffer;
    function concatSig(v, r, s) {
      const rSig = (0, util_1.fromSigned)(r);
      const sSig = (0, util_1.fromSigned)(s);
      const vSig = (0, util_1.bufferToInt)(v);
      const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString("hex"), 64);
      const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString("hex"), 64);
      const vStr = (0, ethjs_util_1.stripHexPrefix)((0, ethjs_util_1.intToHex)(vSig));
      return (0, util_1.addHexPrefix)(rStr.concat(sStr, vStr));
    }
    exports.concatSig = concatSig;
    function recoverPublicKey(messageHash, signature) {
      const sigParams = (0, util_1.fromRpcSig)(signature);
      return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function normalize(input) {
      if (!input) {
        return void 0;
      }
      if (typeof input === "number") {
        if (input < 0) {
          return "0x";
        }
        const buffer = (0, util_1.toBuffer)(input);
        input = (0, util_1.bufferToHex)(buffer);
      }
      if (typeof input !== "string") {
        let msg = "eth-sig-util.normalize() requires hex string or integer input.";
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
      }
      return (0, util_1.addHexPrefix)(input.toLowerCase());
    }
    exports.normalize = normalize;
    function numberToBuffer(num) {
      const hexVal = num.toString(16);
      const prepend = hexVal.length % 2 ? "0" : "";
      return Buffer.from(prepend + hexVal, "hex");
    }
    exports.numberToBuffer = numberToBuffer;
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/personal-sign.js
var require_personal_sign = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/personal-sign.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;
    var util_1 = require_dist2();
    var utils_1 = require_utils5();
    function personalSign2({ privateKey, data }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const message = (0, utils_1.legacyToBuffer)(data);
      const msgHash = (0, util_1.hashPersonalMessage)(message);
      const sig = (0, util_1.ecsign)(msgHash, privateKey);
      const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
      return serialized;
    }
    exports.personalSign = personalSign2;
    function recoverPersonalSignature({ data, signature }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      const sender = (0, util_1.publicToAddress)(publicKey);
      const senderHex = (0, util_1.bufferToHex)(sender);
      return senderHex;
    }
    exports.recoverPersonalSignature = recoverPersonalSignature;
    function extractPublicKey({ data, signature }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      return `0x${publicKey.toString("hex")}`;
    }
    exports.extractPublicKey = extractPublicKey;
    function getPublicKeyFor(message, signature) {
      const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));
      return (0, utils_1.recoverPublicKey)(messageHash, signature);
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_process();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer = window.Buffer;
        } else {
          Buffer = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
      };
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/ethereumjs-abi-utils.js
var require_ethereumjs_abi_utils = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/ethereumjs-abi-utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEncode = exports.parseNumber = exports.solidityPack = void 0;
    var util_1 = require_dist2();
    var ethjs_util_1 = require_lib3();
    var bn_js_1 = __importDefault(require_bn2());
    var utils_1 = require_utils5();
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      const ret = [];
      for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        ret.push(solidityHexValue(type, value, null));
      }
      return Buffer.concat(ret);
    }
    exports.solidityPack = solidityPack;
    function isArray(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    function parseTypeArray(type) {
      const tmp = type.match(/(.*)\[(.*?)\]$/u);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseTypeN(type) {
      return parseInt(/^\D+(\d+)$/u.exec(type)[1], 10);
    }
    function parseNumber(arg) {
      const type = typeof arg;
      if (type === "string") {
        if ((0, util_1.isHexPrefixed)(arg)) {
          return new bn_js_1.default((0, ethjs_util_1.stripHexPrefix)(arg), 16);
        }
        return new bn_js_1.default(arg, 10);
      } else if (type === "number") {
        return new bn_js_1.default(arg);
      } else if (arg.toArray) {
        return arg;
      }
      throw new Error("Argument is not a number");
    }
    exports.parseNumber = parseNumber;
    function solidityHexValue(type, value, bitsize) {
      let size, num;
      if (isArray(type)) {
        const subType = type.replace(/\[.*?\]/u, "");
        if (!isArray(subType)) {
          const arraySize = parseTypeArray(type);
          if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
            throw new Error(`Elements exceed array size: ${arraySize}`);
          }
        }
        const arrayValues = value.map(function(v) {
          return solidityHexValue(subType, v, 256);
        });
        return Buffer.concat(arrayValues);
      } else if (type === "bytes") {
        return value;
      } else if (type === "string") {
        return Buffer.from(value, "utf8");
      } else if (type === "bool") {
        bitsize = bitsize || 8;
        const padding = Array(bitsize / 4).join("0");
        return Buffer.from(value ? `${padding}1` : `${padding}0`, "hex");
      } else if (type === "address") {
        let bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return (0, util_1.setLengthLeft)((0, util_1.toBuffer)(value), bytesize);
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof value === "number") {
          value = (0, utils_1.normalize)(value);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(value), size);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid uint<N> width: ${size}`);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, "be", bitsize / 8);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid int<N> width: ${size}`);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, "be", bitsize / 8);
      }
      throw new Error(`Unsupported or invalid type: ${type}`);
    }
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return `int256${name.slice(3)}`;
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return `uint256${name.slice(4)}`;
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return `fixed128x128${name.slice(5)}`;
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return `ufixed128x128${name.slice(6)}`;
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function rawEncode(types, values) {
      const output = [];
      const data = [];
      let headLength = 0;
      types.forEach(function(type) {
        if (isArray(type)) {
          const size = parseTypeArray(type);
          if (size !== "dynamic") {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        const cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    exports.rawEncode = rawEncode;
    function encodeSingle(type, arg) {
      let size, num, ret, i;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", Buffer.from(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error(`Elements exceed array size: ${size}`);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i in arg) {
          if (Object.prototype.hasOwnProperty.call(arg, i)) {
            ret.push(encodeSingle(type, arg[i]));
          }
        }
        if (size === "dynamic") {
          const length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = Buffer.from(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, (0, util_1.zeros)(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof arg === "number") {
          arg = (0, utils_1.normalize)(arg);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(arg), 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid uint<N> width: ${size}`);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid int<N> width: ${size}`);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
      }
      throw new Error(`Unsupported or invalid type: ${type}`);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function parseTypeNxM(type) {
      const tmp = /^\D+(\d+)x(\d+)$/u.exec(type);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js
var require_sign_typed_data = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;
    var ethjs_util_1 = require_lib3();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var ethereumjs_abi_utils_1 = require_ethereumjs_abi_utils();
    var utils_1 = require_utils5();
    var SignTypedDataVersion2;
    (function(SignTypedDataVersion3) {
      SignTypedDataVersion3["V1"] = "V1";
      SignTypedDataVersion3["V3"] = "V3";
      SignTypedDataVersion3["V4"] = "V4";
    })(SignTypedDataVersion2 = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
    exports.TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    function validateVersion(version, allowedVersions) {
      if (!Object.keys(SignTypedDataVersion2).includes(version)) {
        throw new Error(`Invalid version: '${version}'`);
      } else if (allowedVersions && !allowedVersions.includes(version)) {
        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(", ")}`);
      }
    }
    function encodeField(types, name, type, value, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      if (types[type] !== void 0) {
        return [
          "bytes32",
          version === SignTypedDataVersion2.V4 && value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version)))
        ];
      }
      if (value === void 0) {
        throw new Error(`missing value for field ${name} of type ${type}`);
      }
      if (type === "bytes") {
        if (typeof value === "number") {
          value = (0, utils_1.numberToBuffer)(value);
        } else if ((0, ethjs_util_1.isHexString)(value)) {
          const prepend = value.length % 2 ? "0" : "";
          value = Buffer.from(prepend + value.slice(2), "hex");
        } else {
          value = Buffer.from(value, "utf8");
        }
        return ["bytes32", (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
      }
      if (type === "string") {
        if (typeof value === "number") {
          value = (0, utils_1.numberToBuffer)(value);
        } else {
          value = Buffer.from(value !== null && value !== void 0 ? value : "", "utf8");
        }
        return ["bytes32", (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
      }
      if (type.lastIndexOf("]") === type.length - 1) {
        if (version === SignTypedDataVersion2.V3) {
          throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
        }
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));
        return [
          "bytes32",
          (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.rawEncode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))))
        ];
      }
      return [type, value];
    }
    function encodeData(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      const encodedTypes = ["bytes32"];
      const encodedValues = [hashType(primaryType, types)];
      for (const field of types[primaryType]) {
        if (version === SignTypedDataVersion2.V3 && data[field.name] === void 0) {
          continue;
        }
        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, ethereumjs_abi_utils_1.rawEncode)(encodedTypes, encodedValues);
    }
    function encodeType(primaryType, types) {
      let result = "";
      const unsortedDeps = findTypeDependencies(primaryType, types);
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        const children = types[type];
        if (!children) {
          throw new Error(`No type definition specified: ${type}`);
        }
        result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies(primaryType, types, results = /* @__PURE__ */ new Set()) {
      [primaryType] = primaryType.match(/^\w*/u);
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies(field.type, types, results);
      }
      return results;
    }
    function hashStruct(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      const encoded = encodeData(primaryType, data, types, version);
      const hashed = (0, keccak_1.keccak256)(encoded);
      const buf = (0, util_1.arrToBufArr)(hashed);
      return buf;
    }
    function hashType(primaryType, types) {
      const encodedHashType = Buffer.from(encodeType(primaryType, types), "utf-8");
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));
    }
    function sanitizeData(data) {
      const sanitizedData = {};
      for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {
        if (data[key]) {
          sanitizedData[key] = data[key];
        }
      }
      if ("types" in sanitizedData) {
        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
      }
      return sanitizedData;
    }
    function eip712DomainHash(typedData, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      const sanitizedData = sanitizeData(typedData);
      const { domain } = sanitizedData;
      const domainType = { EIP712Domain: sanitizedData.types.EIP712Domain };
      return hashStruct("EIP712Domain", domain, domainType, version);
    }
    function eip712Hash(typedData, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      const sanitizedData = sanitizeData(typedData);
      const parts = [Buffer.from("1901", "hex")];
      parts.push(eip712DomainHash(typedData, version));
      if (sanitizedData.primaryType !== "EIP712Domain") {
        parts.push(hashStruct(
          // TODO: Validate that this is a string, so this type cast can be removed.
          sanitizedData.primaryType,
          sanitizedData.message,
          sanitizedData.types,
          version
        ));
      }
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(Buffer.concat(parts)));
    }
    exports.TypedDataUtils = {
      encodeData,
      encodeType,
      findTypeDependencies,
      hashStruct,
      hashType,
      sanitizeData,
      eip712Hash,
      eip712DomainHash
    };
    function typedSignatureHash2(typedData) {
      const hashBuffer = _typedSignatureHash(typedData);
      return (0, util_1.bufferToHex)(hashBuffer);
    }
    exports.typedSignatureHash = typedSignatureHash2;
    function _typedSignatureHash(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !("length" in typedData) || !typedData.length) {
        throw error;
      }
      const data = typedData.map(function(e) {
        if (e.type !== "bytes") {
          return e.value;
        }
        return (0, utils_1.legacyToBuffer)(e.value);
      });
      const types = typedData.map(function(e) {
        return e.type;
      });
      const schema = typedData.map(function(e) {
        if (!e.name) {
          throw error;
        }
        return `${e.type} ${e.name}`;
      });
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(["bytes32", "bytes32"], [
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(new Array(typedData.length).fill("string"), schema)),
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(types, data))
      ])));
    }
    function signTypedData2({ privateKey, data, version }) {
      validateVersion(version);
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing private key parameter");
      }
      const messageHash = version === SignTypedDataVersion2.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const sig = (0, util_1.ecsign)(messageHash, privateKey);
      return (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
    }
    exports.signTypedData = signTypedData2;
    function recoverTypedSignature({ data, signature, version }) {
      validateVersion(version);
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const messageHash = version === SignTypedDataVersion2.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const publicKey = (0, utils_1.recoverPublicKey)(messageHash, signature);
      const sender = (0, util_1.publicToAddress)(publicKey);
      return (0, util_1.bufferToHex)(sender);
    }
    exports.recoverTypedSignature = recoverTypedSignature;
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    init_process();
    init_buffer();
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto = require_crypto();
          if (crypto && crypto.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/tweetnacl-util/nacl-util.js
var require_nacl_util = __commonJS({
  "node_modules/tweetnacl-util/nacl-util.js"(exports, module) {
    init_process();
    init_buffer();
    (function(root, f) {
      "use strict";
      if (typeof module !== "undefined" && module.exports)
        module.exports = f();
      else if (root.nacl)
        root.nacl.util = f();
      else {
        root.nacl = {};
        root.nacl.util = f();
      }
    })(exports, function() {
      "use strict";
      var util = {};
      function validateBase64(s) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s)) {
          throw new TypeError("invalid encoding");
        }
      }
      util.decodeUTF8 = function(s) {
        if (typeof s !== "string")
          throw new TypeError("expected string");
        var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++)
          b[i] = d.charCodeAt(i);
        return b;
      };
      util.encodeUTF8 = function(arr) {
        var i, s = [];
        for (i = 0; i < arr.length; i++)
          s.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, "base64"), 0));
          };
        } else {
          util.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s, "base64"), 0));
          };
        }
      } else {
        util.encodeBase64 = function(arr) {
          var i, s = [], len = arr.length;
          for (i = 0; i < len; i++)
            s.push(String.fromCharCode(arr[i]));
          return btoa(s.join(""));
        };
        util.decodeBase64 = function(s) {
          validateBase64(s);
          var i, d = atob(s), b = new Uint8Array(d.length);
          for (i = 0; i < d.length; i++)
            b[i] = d.charCodeAt(i);
          return b;
        };
      }
      return util;
    });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/encryption.js
var require_encryption = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/encryption.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;
    var nacl = __importStar(require_nacl_fast());
    var naclUtil = __importStar(require_nacl_util());
    var utils_1 = require_utils5();
    function encrypt({ publicKey, data, version }) {
      if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(version)) {
        throw new Error("Missing version parameter");
      }
      switch (version) {
        case "x25519-xsalsa20-poly1305": {
          if (typeof data !== "string") {
            throw new Error("Message data must be given as a string");
          }
          const ephemeralKeyPair = nacl.box.keyPair();
          let pubKeyUInt8Array;
          try {
            pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);
          } catch (err) {
            throw new Error("Bad public key");
          }
          const msgParamsUInt8Array = naclUtil.decodeUTF8(data);
          const nonce = nacl.randomBytes(nacl.box.nonceLength);
          const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
          const output = {
            version: "x25519-xsalsa20-poly1305",
            nonce: naclUtil.encodeBase64(nonce),
            ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
            ciphertext: naclUtil.encodeBase64(encryptedMessage)
          };
          return output;
        }
        default:
          throw new Error("Encryption type/version not supported");
      }
    }
    exports.encrypt = encrypt;
    function encryptSafely({ publicKey, data, version }) {
      if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(version)) {
        throw new Error("Missing version parameter");
      }
      const DEFAULT_PADDING_LENGTH = 2 ** 11;
      const NACL_EXTRA_BYTES = 16;
      if (typeof data === "object" && "toJSON" in data) {
        throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
      }
      const dataWithPadding = {
        data,
        padding: ""
      };
      const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), "utf-8");
      const modVal = dataLength % DEFAULT_PADDING_LENGTH;
      let padLength = 0;
      if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES;
      }
      dataWithPadding.padding = "0".repeat(padLength);
      const paddedMessage = JSON.stringify(dataWithPadding);
      return encrypt({ publicKey, data: paddedMessage, version });
    }
    exports.encryptSafely = encryptSafely;
    function decrypt2({ encryptedData, privateKey }) {
      if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      switch (encryptedData.version) {
        case "x25519-xsalsa20-poly1305": {
          const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);
          const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;
          const nonce = naclUtil.decodeBase64(encryptedData.nonce);
          const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
          const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
          const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);
          let output;
          try {
            output = naclUtil.encodeUTF8(decryptedMessage);
          } catch (err) {
            throw new Error("Decryption failed.");
          }
          if (output) {
            return output;
          }
          throw new Error("Decryption failed.");
        }
        default:
          throw new Error("Encryption type/version not supported.");
      }
    }
    exports.decrypt = decrypt2;
    function decryptSafely({ encryptedData, privateKey }) {
      if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const dataWithPadding = JSON.parse(decrypt2({ encryptedData, privateKey }));
      return dataWithPadding.data;
    }
    exports.decryptSafely = decryptSafely;
    function getEncryptionPublicKey2(privateKey) {
      const privateKeyUint8Array = nacl_decodeHex(privateKey);
      const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
      return naclUtil.encodeBase64(encryptionPublicKey);
    }
    exports.getEncryptionPublicKey = getEncryptionPublicKey2;
    function nacl_decodeHex(msgHex) {
      const msgBase64 = Buffer.from(msgHex, "hex").toString("base64");
      return naclUtil.decodeBase64(msgBase64);
    }
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@web3auth/ethereum-provider/node_modules/@metamask/eth-sig-util/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = exports.concatSig = void 0;
    __exportStar(require_personal_sign(), exports);
    __exportStar(require_sign_typed_data(), exports);
    __exportStar(require_encryption(), exports);
    var utils_1 = require_utils5();
    Object.defineProperty(exports, "concatSig", { enumerable: true, get: function() {
      return utils_1.concatSig;
    } });
    Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
      return utils_1.normalize;
    } });
  }
});

// node_modules/@web3auth/ethereum-provider/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
async function fetchAndTrace(url, init) {
  let _url = null;
  try {
    _url = new URL(url);
  } catch (error) {
  }
  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {
    const transaction = sentry.startTransaction({
      name: url
    });
    const span = transaction.startChild({
      op: "http"
    });
    const response = await fetch(url, init);
    span.finish();
    transaction.finish();
    return response;
  }
  return fetch(url, init);
}
function getApiKeyHeaders() {
  const headers = {};
  if (apiKey)
    headers[gatewayAuthHeader] = apiKey;
  if (embedHost)
    headers[gatewayEmbedHostHeader] = embedHost;
  return headers;
}
function debugLogResponse(response) {
  log2.info(`Response: ${response.status} ${response.statusText}`);
  log2.info(`Url: ${response.url}`);
}
var import_lodash, import_loglevel, log2, apiKey, embedHost, gatewayAuthHeader, gatewayEmbedHostHeader, sentry, tracingOrigins, tracingPaths, get;
var init_httpHelpers_esm = __esm({
  "node_modules/@web3auth/ethereum-provider/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    import_lodash = __toESM(require_lodash());
    import_loglevel = __toESM(require_loglevel());
    log2 = import_loglevel.default.getLogger("http-helpers");
    log2.setLevel(import_loglevel.levels.INFO);
    apiKey = "torus-default";
    embedHost = "";
    gatewayAuthHeader = "x-api-key";
    gatewayEmbedHostHeader = "x-embed-host";
    sentry = null;
    tracingOrigins = [];
    tracingPaths = [];
    get = async function(url) {
      let options_ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let customOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const defaultOptions = {
        mode: "cors",
        headers: {}
      };
      if (customOptions.useAPIKey) {
        defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());
      }
      const options = (0, import_lodash.default)(defaultOptions, options_, {
        method: "GET"
      });
      const response = await fetchAndTrace(url, options);
      if (response.ok) {
        return response.json();
      }
      debugLogResponse(response);
      throw response;
    };
  }
});

// node_modules/jsonschema/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/jsonschema/lib/helpers.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var uri = require_url();
    var ValidationError = exports.ValidationError = function ValidationError2(message, instance, schema, path, name, argument) {
      if (Array.isArray(path)) {
        this.path = path;
        this.property = path.reduce(function(sum, item) {
          return sum + makeSuffix(item);
        }, "instance");
      } else if (path !== void 0) {
        this.property = path;
      }
      if (message) {
        this.message = message;
      }
      if (schema) {
        var id = schema.$id || schema.id;
        this.schema = id || schema;
      }
      if (instance !== void 0) {
        this.instance = instance;
      }
      this.name = name;
      this.argument = argument;
      this.stack = this.toString();
    };
    ValidationError.prototype.toString = function toString() {
      return this.property + " " + this.message;
    };
    var ValidatorResult = exports.ValidatorResult = function ValidatorResult2(instance, schema, options, ctx) {
      this.instance = instance;
      this.schema = schema;
      this.options = options;
      this.path = ctx.path;
      this.propertyPath = ctx.propertyPath;
      this.errors = [];
      this.throwError = options && options.throwError;
      this.throwFirst = options && options.throwFirst;
      this.throwAll = options && options.throwAll;
      this.disableFormat = options && options.disableFormat === true;
    };
    ValidatorResult.prototype.addError = function addError(detail) {
      var err;
      if (typeof detail == "string") {
        err = new ValidationError(detail, this.instance, this.schema, this.path);
      } else {
        if (!detail)
          throw new Error("Missing error detail");
        if (!detail.message)
          throw new Error("Missing error message");
        if (!detail.name)
          throw new Error("Missing validator type");
        err = new ValidationError(detail.message, this.instance, this.schema, this.path, detail.name, detail.argument);
      }
      this.errors.push(err);
      if (this.throwFirst) {
        throw new ValidatorResultError(this);
      } else if (this.throwError) {
        throw err;
      }
      return err;
    };
    ValidatorResult.prototype.importErrors = function importErrors(res) {
      if (typeof res == "string" || res && res.validatorType) {
        this.addError(res);
      } else if (res && res.errors) {
        this.errors = this.errors.concat(res.errors);
      }
    };
    function stringizer(v, i) {
      return i + ": " + v.toString() + "\n";
    }
    ValidatorResult.prototype.toString = function toString(res) {
      return this.errors.map(stringizer).join("");
    };
    Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
      return !this.errors.length;
    } });
    module.exports.ValidatorResultError = ValidatorResultError;
    function ValidatorResultError(result) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ValidatorResultError);
      }
      this.instance = result.instance;
      this.schema = result.schema;
      this.options = result.options;
      this.errors = result.errors;
    }
    ValidatorResultError.prototype = new Error();
    ValidatorResultError.prototype.constructor = ValidatorResultError;
    ValidatorResultError.prototype.name = "Validation Error";
    var SchemaError = exports.SchemaError = function SchemaError2(msg, schema) {
      this.message = msg;
      this.schema = schema;
      Error.call(this, msg);
      Error.captureStackTrace(this, SchemaError2);
    };
    SchemaError.prototype = Object.create(
      Error.prototype,
      {
        constructor: { value: SchemaError, enumerable: false },
        name: { value: "SchemaError", enumerable: false }
      }
    );
    var SchemaContext = exports.SchemaContext = function SchemaContext2(schema, options, path, base, schemas) {
      this.schema = schema;
      this.options = options;
      if (Array.isArray(path)) {
        this.path = path;
        this.propertyPath = path.reduce(function(sum, item) {
          return sum + makeSuffix(item);
        }, "instance");
      } else {
        this.propertyPath = path;
      }
      this.base = base;
      this.schemas = schemas;
    };
    SchemaContext.prototype.resolve = function resolve(target) {
      return uri.resolve(this.base, target);
    };
    SchemaContext.prototype.makeChild = function makeChild(schema, propertyName) {
      var path = propertyName === void 0 ? this.path : this.path.concat([propertyName]);
      var id = schema.$id || schema.id;
      var base = uri.resolve(this.base, id || "");
      var ctx = new SchemaContext(schema, this.options, path, base, Object.create(this.schemas));
      if (id && !ctx.schemas[base]) {
        ctx.schemas[base] = schema;
      }
      return ctx;
    };
    var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
      // 7.3.1. Dates, Times, and Duration
      "date-time": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
      "date": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
      "time": /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,
      "duration": /P(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S)|\d+(D|M(\d+D)?|Y(\d+M(\d+D)?)?)(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S))?|\d+W)/i,
      // 7.3.2. Email Addresses
      // TODO: fix the email production
      "email": /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
      "idn-email": /^("(?:[!#-\[\]-\u{10FFFF}]|\\[\t -\u{10FFFF}])*"|[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*)@([!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*|\[[!-Z\^-\u{10FFFF}]*\])$/u,
      // 7.3.3. Hostnames
      // 7.3.4. IP Addresses
      "ip-address": /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
      // FIXME whitespace is invalid
      "ipv6": /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
      // 7.3.5. Resource Identifiers
      // TODO: A more accurate regular expression for "uri" goes:
      // [A-Za-z][+\-.0-9A-Za-z]*:((/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?)?#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])|/?%[0-9A-Fa-f]{2}|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*(#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?)?
      "uri": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
      "uri-reference": /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/,
      "iri": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
      "iri-reference": /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~-\u{10FFFF}]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~-\u{10FFFF}])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/u,
      "uuid": /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      // 7.3.6. uri-template
      "uri-template": /(%[0-9a-f]{2}|[!#$&(-;=?@\[\]_a-z~]|\{[!#&+,./;=?@|]?(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?(,(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?)*\})*/iu,
      // 7.3.7. JSON Pointers
      "json-pointer": /^(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*$/iu,
      "relative-json-pointer": /^\d+(#|(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*)$/iu,
      // hostname regex from: http://stackoverflow.com/a/1420225/5628
      "hostname": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "host-name": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "utc-millisec": function(input) {
        return typeof input === "string" && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
      },
      // 7.3.8. regex
      "regex": function(input) {
        var result = true;
        try {
          new RegExp(input);
        } catch (e) {
          result = false;
        }
        return result;
      },
      // Other definitions
      // "style" was removed from JSON Schema in draft-4 and is deprecated
      "style": /[\r\n\t ]*[^\r\n\t ][^:]*:[\r\n\t ]*[^\r\n\t ;]*[\r\n\t ]*;?/,
      // "color" was removed from JSON Schema in draft-4 and is deprecated
      "color": /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,
      "phone": /^\+(?:[0-9] ?){6,14}[0-9]$/,
      "alpha": /^[a-zA-Z]+$/,
      "alphanumeric": /^[a-zA-Z0-9]+$/
    };
    FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS["ip-address"];
    exports.isFormat = function isFormat(input, format, validator) {
      if (typeof input === "string" && FORMAT_REGEXPS[format] !== void 0) {
        if (FORMAT_REGEXPS[format] instanceof RegExp) {
          return FORMAT_REGEXPS[format].test(input);
        }
        if (typeof FORMAT_REGEXPS[format] === "function") {
          return FORMAT_REGEXPS[format](input);
        }
      } else if (validator && validator.customFormats && typeof validator.customFormats[format] === "function") {
        return validator.customFormats[format](input);
      }
      return true;
    };
    var makeSuffix = exports.makeSuffix = function makeSuffix2(key) {
      key = key.toString();
      if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
        return "." + key;
      }
      if (key.match(/^\d+$/)) {
        return "[" + key + "]";
      }
      return "[" + JSON.stringify(key) + "]";
    };
    exports.deepCompareStrict = function deepCompareStrict(a, b) {
      if (typeof a !== typeof b) {
        return false;
      }
      if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        return a.every(function(v, i) {
          return deepCompareStrict(a[i], b[i]);
        });
      }
      if (typeof a === "object") {
        if (!a || !b) {
          return a === b;
        }
        var aKeys = Object.keys(a);
        var bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        return aKeys.every(function(v) {
          return deepCompareStrict(a[v], b[v]);
        });
      }
      return a === b;
    };
    function deepMerger(target, dst, e, i) {
      if (typeof e === "object") {
        dst[i] = deepMerge(target[i], e);
      } else {
        if (target.indexOf(e) === -1) {
          dst.push(e);
        }
      }
    }
    function copyist(src, dst, key) {
      dst[key] = src[key];
    }
    function copyistWithDeepMerge(target, src, dst, key) {
      if (typeof src[key] !== "object" || !src[key]) {
        dst[key] = src[key];
      } else {
        if (!target[key]) {
          dst[key] = src[key];
        } else {
          dst[key] = deepMerge(target[key], src[key]);
        }
      }
    }
    function deepMerge(target, src) {
      var array = Array.isArray(src);
      var dst = array && [] || {};
      if (array) {
        target = target || [];
        dst = dst.concat(target);
        src.forEach(deepMerger.bind(null, target, dst));
      } else {
        if (target && typeof target === "object") {
          Object.keys(target).forEach(copyist.bind(null, target, dst));
        }
        Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
      }
      return dst;
    }
    module.exports.deepMerge = deepMerge;
    exports.objectGetPath = function objectGetPath(o, s) {
      var parts = s.split("/").slice(1);
      var k;
      while (typeof (k = parts.shift()) == "string") {
        var n = decodeURIComponent(k.replace(/~0/, "~").replace(/~1/g, "/"));
        if (!(n in o))
          return;
        o = o[n];
      }
      return o;
    };
    function pathEncoder(v) {
      return "/" + encodeURIComponent(v).replace(/~/g, "%7E");
    }
    exports.encodePath = function encodePointer(a) {
      return a.map(pathEncoder).join("");
    };
    exports.getDecimalPlaces = function getDecimalPlaces(number) {
      var decimalPlaces = 0;
      if (isNaN(number))
        return decimalPlaces;
      if (typeof number !== "number") {
        number = Number(number);
      }
      var parts = number.toString().split("e");
      if (parts.length === 2) {
        if (parts[1][0] !== "-") {
          return decimalPlaces;
        } else {
          decimalPlaces = Number(parts[1].slice(1));
        }
      }
      var decimalParts = parts[0].split(".");
      if (decimalParts.length === 2) {
        decimalPlaces += decimalParts[1].length;
      }
      return decimalPlaces;
    };
    exports.isSchema = function isSchema(val) {
      return typeof val === "object" && val || typeof val === "boolean";
    };
  }
});

// node_modules/jsonschema/lib/attribute.js
var require_attribute = __commonJS({
  "node_modules/jsonschema/lib/attribute.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var helpers = require_helpers();
    var ValidatorResult = helpers.ValidatorResult;
    var SchemaError = helpers.SchemaError;
    var attribute = {};
    attribute.ignoreProperties = {
      // informative properties
      "id": true,
      "default": true,
      "description": true,
      "title": true,
      // arguments to other properties
      "additionalItems": true,
      "then": true,
      "else": true,
      // special-handled properties
      "$schema": true,
      "$ref": true,
      "extends": true
    };
    var validators = attribute.validators = {};
    validators.type = function validateType(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var types = Array.isArray(schema.type) ? schema.type : [schema.type];
      if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
        var list = types.map(function(v) {
          if (!v)
            return;
          var id = v.$id || v.id;
          return id ? "<" + id + ">" : v + "";
        });
        result.addError({
          name: "type",
          argument: list,
          message: "is not of a type(s) " + list
        });
      }
      return result;
    };
    function testSchemaNoThrow(instance, options, ctx, callback, schema) {
      var throwError = options.throwError;
      var throwAll = options.throwAll;
      options.throwError = false;
      options.throwAll = false;
      var res = this.validateSchema(instance, schema, options, ctx);
      options.throwError = throwError;
      options.throwAll = throwAll;
      if (!res.valid && callback instanceof Function) {
        callback(res);
      }
      return res.valid;
    }
    validators.anyOf = function validateAnyOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      if (!Array.isArray(schema.anyOf)) {
        throw new SchemaError("anyOf must be an array");
      }
      if (!schema.anyOf.some(
        testSchemaNoThrow.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      )) {
        var list = schema.anyOf.map(function(v, i) {
          var id = v.$id || v.id;
          if (id)
            return "<" + id + ">";
          return v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
        });
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "anyOf",
          argument: list,
          message: "is not any of " + list.join(",")
        });
      }
      return result;
    };
    validators.allOf = function validateAllOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.allOf)) {
        throw new SchemaError("allOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var self2 = this;
      schema.allOf.forEach(function(v, i) {
        var valid = self2.validateSchema(instance, v, options, ctx);
        if (!valid.valid) {
          var id = v.$id || v.id;
          var msg = id || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
          result.addError({
            name: "allOf",
            argument: { id: msg, length: valid.errors.length, valid },
            message: "does not match allOf schema " + msg + " with " + valid.errors.length + " error[s]:"
          });
          result.importErrors(valid);
        }
      });
      return result;
    };
    validators.oneOf = function validateOneOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.oneOf)) {
        throw new SchemaError("oneOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      var count = schema.oneOf.filter(
        testSchemaNoThrow.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      ).length;
      var list = schema.oneOf.map(function(v, i) {
        var id = v.$id || v.id;
        return id || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
      });
      if (count !== 1) {
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "oneOf",
          argument: list,
          message: "is not exactly one from " + list.join(",")
        });
      }
      return result;
    };
    validators.if = function validateIf(instance, schema, options, ctx) {
      if (instance === void 0)
        return null;
      if (!helpers.isSchema(schema.if))
        throw new Error('Expected "if" keyword to be a schema');
      var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);
      var result = new ValidatorResult(instance, schema, options, ctx);
      var res;
      if (ifValid) {
        if (schema.then === void 0)
          return;
        if (!helpers.isSchema(schema.then))
          throw new Error('Expected "then" keyword to be a schema');
        res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));
        result.importErrors(res);
      } else {
        if (schema.else === void 0)
          return;
        if (!helpers.isSchema(schema.else))
          throw new Error('Expected "else" keyword to be a schema');
        res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));
        result.importErrors(res);
      }
      return result;
    };
    function getEnumerableProperty(object, key) {
      if (Object.hasOwnProperty.call(object, key))
        return object[key];
      if (!(key in object))
        return;
      while (object = Object.getPrototypeOf(object)) {
        if (Object.propertyIsEnumerable.call(object, key))
          return object[key];
      }
    }
    validators.propertyNames = function validatePropertyNames(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var subschema = schema.propertyNames !== void 0 ? schema.propertyNames : {};
      if (!helpers.isSchema(subschema))
        throw new SchemaError('Expected "propertyNames" to be a schema (object or boolean)');
      for (var property in instance) {
        if (getEnumerableProperty(instance, property) !== void 0) {
          var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));
          result.importErrors(res);
        }
      }
      return result;
    };
    validators.properties = function validateProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var properties = schema.properties || {};
      for (var property in properties) {
        var subschema = properties[property];
        if (subschema === void 0) {
          continue;
        } else if (subschema === null) {
          throw new SchemaError('Unexpected null, expected schema in "properties"');
        }
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, subschema, options, ctx);
        }
        var prop = getEnumerableProperty(instance, property);
        var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));
        if (res.instance !== result.instance[property])
          result.instance[property] = res.instance;
        result.importErrors(res);
      }
      return result;
    };
    function testAdditionalProperty(instance, schema, options, ctx, property, result) {
      if (!this.types.object(instance))
        return;
      if (schema.properties && schema.properties[property] !== void 0) {
        return;
      }
      if (schema.additionalProperties === false) {
        result.addError({
          name: "additionalProperties",
          argument: property,
          message: "is not allowed to have the additional property " + JSON.stringify(property)
        });
      } else {
        var additionalProperties = schema.additionalProperties || {};
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, additionalProperties, options, ctx);
        }
        var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
        if (res.instance !== result.instance[property])
          result.instance[property] = res.instance;
        result.importErrors(res);
      }
    }
    validators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var patternProperties = schema.patternProperties || {};
      for (var property in instance) {
        var test = true;
        for (var pattern in patternProperties) {
          var subschema = patternProperties[pattern];
          if (subschema === void 0) {
            continue;
          } else if (subschema === null) {
            throw new SchemaError('Unexpected null, expected schema in "patternProperties"');
          }
          try {
            var regexp = new RegExp(pattern, "u");
          } catch (_e) {
            regexp = new RegExp(pattern);
          }
          if (!regexp.test(property)) {
            continue;
          }
          test = false;
          if (typeof options.preValidateProperty == "function") {
            options.preValidateProperty(instance, property, subschema, options, ctx);
          }
          var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));
          if (res.instance !== result.instance[property])
            result.instance[property] = res.instance;
          result.importErrors(res);
        }
        if (test) {
          testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
        }
      }
      return result;
    };
    validators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      if (schema.patternProperties) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in instance) {
        testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
      }
      return result;
    };
    validators.minProperties = function validateMinProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length >= schema.minProperties)) {
        result.addError({
          name: "minProperties",
          argument: schema.minProperties,
          message: "does not meet minimum property length of " + schema.minProperties
        });
      }
      return result;
    };
    validators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length <= schema.maxProperties)) {
        result.addError({
          name: "maxProperties",
          argument: schema.maxProperties,
          message: "does not meet maximum property length of " + schema.maxProperties
        });
      }
      return result;
    };
    validators.items = function validateItems(instance, schema, options, ctx) {
      var self2 = this;
      if (!this.types.array(instance))
        return;
      if (schema.items === void 0)
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      instance.every(function(value, i) {
        if (Array.isArray(schema.items)) {
          var items = schema.items[i] === void 0 ? schema.additionalItems : schema.items[i];
        } else {
          var items = schema.items;
        }
        if (items === void 0) {
          return true;
        }
        if (items === false) {
          result.addError({
            name: "items",
            message: "additionalItems not permitted"
          });
          return false;
        }
        var res = self2.validateSchema(value, items, options, ctx.makeChild(items, i));
        if (res.instance !== result.instance[i])
          result.instance[i] = res.instance;
        result.importErrors(res);
        return true;
      });
      return result;
    };
    validators.contains = function validateContains(instance, schema, options, ctx) {
      var self2 = this;
      if (!this.types.array(instance))
        return;
      if (schema.contains === void 0)
        return;
      if (!helpers.isSchema(schema.contains))
        throw new Error('Expected "contains" keyword to be a schema');
      var result = new ValidatorResult(instance, schema, options, ctx);
      var count = instance.some(function(value, i) {
        var res = self2.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));
        return res.errors.length === 0;
      });
      if (count === false) {
        result.addError({
          name: "contains",
          argument: schema.contains,
          message: "must contain an item matching given schema"
        });
      }
      return result;
    };
    validators.minimum = function validateMinimum(instance, schema, options, ctx) {
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
        if (!(instance > schema.minimum)) {
          result.addError({
            name: "minimum",
            argument: schema.minimum,
            message: "must be greater than " + schema.minimum
          });
        }
      } else {
        if (!(instance >= schema.minimum)) {
          result.addError({
            name: "minimum",
            argument: schema.minimum,
            message: "must be greater than or equal to " + schema.minimum
          });
        }
      }
      return result;
    };
    validators.maximum = function validateMaximum(instance, schema, options, ctx) {
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
        if (!(instance < schema.maximum)) {
          result.addError({
            name: "maximum",
            argument: schema.maximum,
            message: "must be less than " + schema.maximum
          });
        }
      } else {
        if (!(instance <= schema.maximum)) {
          result.addError({
            name: "maximum",
            argument: schema.maximum,
            message: "must be less than or equal to " + schema.maximum
          });
        }
      }
      return result;
    };
    validators.exclusiveMinimum = function validateExclusiveMinimum(instance, schema, options, ctx) {
      if (typeof schema.exclusiveMinimum === "boolean")
        return;
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid = instance > schema.exclusiveMinimum;
      if (!valid) {
        result.addError({
          name: "exclusiveMinimum",
          argument: schema.exclusiveMinimum,
          message: "must be strictly greater than " + schema.exclusiveMinimum
        });
      }
      return result;
    };
    validators.exclusiveMaximum = function validateExclusiveMaximum(instance, schema, options, ctx) {
      if (typeof schema.exclusiveMaximum === "boolean")
        return;
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid = instance < schema.exclusiveMaximum;
      if (!valid) {
        result.addError({
          name: "exclusiveMaximum",
          argument: schema.exclusiveMaximum,
          message: "must be strictly less than " + schema.exclusiveMaximum
        });
      }
      return result;
    };
    var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy2(instance, schema, options, ctx, validationType, errorMessage) {
      if (!this.types.number(instance))
        return;
      var validationArgument = schema[validationType];
      if (validationArgument == 0) {
        throw new SchemaError(validationType + " cannot be zero");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var instanceDecimals = helpers.getDecimalPlaces(instance);
      var divisorDecimals = helpers.getDecimalPlaces(validationArgument);
      var maxDecimals = Math.max(instanceDecimals, divisorDecimals);
      var multiplier = Math.pow(10, maxDecimals);
      if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
        result.addError({
          name: validationType,
          argument: validationArgument,
          message: errorMessage + JSON.stringify(validationArgument)
        });
      }
      return result;
    };
    validators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
    };
    validators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
    };
    validators.required = function validateRequired(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (instance === void 0 && schema.required === true) {
        result.addError({
          name: "required",
          message: "is required"
        });
      } else if (this.types.object(instance) && Array.isArray(schema.required)) {
        schema.required.forEach(function(n) {
          if (getEnumerableProperty(instance, n) === void 0) {
            result.addError({
              name: "required",
              argument: n,
              message: "requires property " + JSON.stringify(n)
            });
          }
        });
      }
      return result;
    };
    validators.pattern = function validatePattern(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var pattern = schema.pattern;
      try {
        var regexp = new RegExp(pattern, "u");
      } catch (_e) {
        regexp = new RegExp(pattern);
      }
      if (!instance.match(regexp)) {
        result.addError({
          name: "pattern",
          argument: schema.pattern,
          message: "does not match pattern " + JSON.stringify(schema.pattern.toString())
        });
      }
      return result;
    };
    validators.format = function validateFormat(instance, schema, options, ctx) {
      if (instance === void 0)
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
        result.addError({
          name: "format",
          argument: schema.format,
          message: "does not conform to the " + JSON.stringify(schema.format) + " format"
        });
      }
      return result;
    };
    validators.minLength = function validateMinLength(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var hsp = instance.match(/[\uDC00-\uDFFF]/g);
      var length = instance.length - (hsp ? hsp.length : 0);
      if (!(length >= schema.minLength)) {
        result.addError({
          name: "minLength",
          argument: schema.minLength,
          message: "does not meet minimum length of " + schema.minLength
        });
      }
      return result;
    };
    validators.maxLength = function validateMaxLength(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var hsp = instance.match(/[\uDC00-\uDFFF]/g);
      var length = instance.length - (hsp ? hsp.length : 0);
      if (!(length <= schema.maxLength)) {
        result.addError({
          name: "maxLength",
          argument: schema.maxLength,
          message: "does not meet maximum length of " + schema.maxLength
        });
      }
      return result;
    };
    validators.minItems = function validateMinItems(instance, schema, options, ctx) {
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length >= schema.minItems)) {
        result.addError({
          name: "minItems",
          argument: schema.minItems,
          message: "does not meet minimum length of " + schema.minItems
        });
      }
      return result;
    };
    validators.maxItems = function validateMaxItems(instance, schema, options, ctx) {
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length <= schema.maxItems)) {
        result.addError({
          name: "maxItems",
          argument: schema.maxItems,
          message: "does not meet maximum length of " + schema.maxItems
        });
      }
      return result;
    };
    function testArrays(v, i, a) {
      var j, len = a.length;
      for (j = i + 1, len; j < len; j++) {
        if (helpers.deepCompareStrict(v, a[j])) {
          return false;
        }
      }
      return true;
    }
    validators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {
      if (schema.uniqueItems !== true)
        return;
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!instance.every(testArrays)) {
        result.addError({
          name: "uniqueItems",
          message: "contains duplicate item"
        });
      }
      return result;
    };
    validators.dependencies = function validateDependencies(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in schema.dependencies) {
        if (instance[property] === void 0) {
          continue;
        }
        var dep = schema.dependencies[property];
        var childContext = ctx.makeChild(dep, property);
        if (typeof dep == "string") {
          dep = [dep];
        }
        if (Array.isArray(dep)) {
          dep.forEach(function(prop) {
            if (instance[prop] === void 0) {
              result.addError({
                // FIXME there's two different "dependencies" errors here with slightly different outputs
                // Can we make these the same? Or should we create different error types?
                name: "dependencies",
                argument: childContext.propertyPath,
                message: "property " + prop + " not found, required by " + childContext.propertyPath
              });
            }
          });
        } else {
          var res = this.validateSchema(instance, dep, options, childContext);
          if (result.instance !== res.instance)
            result.instance = res.instance;
          if (res && res.errors.length) {
            result.addError({
              name: "dependencies",
              argument: childContext.propertyPath,
              message: "does not meet dependency required by " + childContext.propertyPath
            });
            result.importErrors(res);
          }
        }
      }
      return result;
    };
    validators["enum"] = function validateEnum(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema["enum"])) {
        throw new SchemaError("enum expects an array", schema);
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!schema["enum"].some(helpers.deepCompareStrict.bind(null, instance))) {
        result.addError({
          name: "enum",
          argument: schema["enum"],
          message: "is not one of enum values: " + schema["enum"].map(String).join(",")
        });
      }
      return result;
    };
    validators["const"] = function validateEnum(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!helpers.deepCompareStrict(schema["const"], instance)) {
        result.addError({
          name: "const",
          argument: schema["const"],
          message: "does not exactly match expected constant: " + schema["const"]
        });
      }
      return result;
    };
    validators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {
      var self2 = this;
      if (instance === void 0)
        return null;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var notTypes = schema.not || schema.disallow;
      if (!notTypes)
        return null;
      if (!Array.isArray(notTypes))
        notTypes = [notTypes];
      notTypes.forEach(function(type) {
        if (self2.testType(instance, schema, options, ctx, type)) {
          var id = type && (type.$id || type.id);
          var schemaId = id || type;
          result.addError({
            name: "not",
            argument: schemaId,
            message: "is of prohibited type " + schemaId
          });
        }
      });
      return result;
    };
    module.exports = attribute;
  }
});

// node_modules/jsonschema/lib/scan.js
var require_scan = __commonJS({
  "node_modules/jsonschema/lib/scan.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var urilib = require_url();
    var helpers = require_helpers();
    module.exports.SchemaScanResult = SchemaScanResult;
    function SchemaScanResult(found, ref) {
      this.id = found;
      this.ref = ref;
    }
    module.exports.scan = function scan(base, schema) {
      function scanSchema(baseuri, schema2) {
        if (!schema2 || typeof schema2 != "object")
          return;
        if (schema2.$ref) {
          var resolvedUri = urilib.resolve(baseuri, schema2.$ref);
          ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri] + 1 : 0;
          return;
        }
        var id = schema2.$id || schema2.id;
        var ourBase = id ? urilib.resolve(baseuri, id) : baseuri;
        if (ourBase) {
          if (ourBase.indexOf("#") < 0)
            ourBase += "#";
          if (found[ourBase]) {
            if (!helpers.deepCompareStrict(found[ourBase], schema2)) {
              throw new Error("Schema <" + ourBase + "> already exists with different definition");
            }
            return found[ourBase];
          }
          found[ourBase] = schema2;
          if (ourBase[ourBase.length - 1] == "#") {
            found[ourBase.substring(0, ourBase.length - 1)] = schema2;
          }
        }
        scanArray(ourBase + "/items", Array.isArray(schema2.items) ? schema2.items : [schema2.items]);
        scanArray(ourBase + "/extends", Array.isArray(schema2.extends) ? schema2.extends : [schema2.extends]);
        scanSchema(ourBase + "/additionalItems", schema2.additionalItems);
        scanObject(ourBase + "/properties", schema2.properties);
        scanSchema(ourBase + "/additionalProperties", schema2.additionalProperties);
        scanObject(ourBase + "/definitions", schema2.definitions);
        scanObject(ourBase + "/patternProperties", schema2.patternProperties);
        scanObject(ourBase + "/dependencies", schema2.dependencies);
        scanArray(ourBase + "/disallow", schema2.disallow);
        scanArray(ourBase + "/allOf", schema2.allOf);
        scanArray(ourBase + "/anyOf", schema2.anyOf);
        scanArray(ourBase + "/oneOf", schema2.oneOf);
        scanSchema(ourBase + "/not", schema2.not);
      }
      function scanArray(baseuri, schemas) {
        if (!Array.isArray(schemas))
          return;
        for (var i = 0; i < schemas.length; i++) {
          scanSchema(baseuri + "/" + i, schemas[i]);
        }
      }
      function scanObject(baseuri, schemas) {
        if (!schemas || typeof schemas != "object")
          return;
        for (var p in schemas) {
          scanSchema(baseuri + "/" + p, schemas[p]);
        }
      }
      var found = {};
      var ref = {};
      scanSchema(base, schema);
      return new SchemaScanResult(found, ref);
    };
  }
});

// node_modules/jsonschema/lib/validator.js
var require_validator = __commonJS({
  "node_modules/jsonschema/lib/validator.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var urilib = require_url();
    var attribute = require_attribute();
    var helpers = require_helpers();
    var scanSchema = require_scan().scan;
    var ValidatorResult = helpers.ValidatorResult;
    var ValidatorResultError = helpers.ValidatorResultError;
    var SchemaError = helpers.SchemaError;
    var SchemaContext = helpers.SchemaContext;
    var anonymousBase = "/";
    var Validator = function Validator2() {
      this.customFormats = Object.create(Validator2.prototype.customFormats);
      this.schemas = {};
      this.unresolvedRefs = [];
      this.types = Object.create(types);
      this.attributes = Object.create(attribute.validators);
    };
    Validator.prototype.customFormats = {};
    Validator.prototype.schemas = null;
    Validator.prototype.types = null;
    Validator.prototype.attributes = null;
    Validator.prototype.unresolvedRefs = null;
    Validator.prototype.addSchema = function addSchema(schema, base) {
      var self2 = this;
      if (!schema) {
        return null;
      }
      var scan = scanSchema(base || anonymousBase, schema);
      var ourUri = base || schema.$id || schema.id;
      for (var uri in scan.id) {
        this.schemas[uri] = scan.id[uri];
      }
      for (var uri in scan.ref) {
        this.unresolvedRefs.push(uri);
      }
      this.unresolvedRefs = this.unresolvedRefs.filter(function(uri2) {
        return typeof self2.schemas[uri2] === "undefined";
      });
      return this.schemas[ourUri];
    };
    Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
      if (!Array.isArray(schemas))
        return;
      for (var i = 0; i < schemas.length; i++) {
        this.addSubSchema(baseuri, schemas[i]);
      }
    };
    Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
      if (!schemas || typeof schemas != "object")
        return;
      for (var p in schemas) {
        this.addSubSchema(baseuri, schemas[p]);
      }
    };
    Validator.prototype.setSchemas = function setSchemas(schemas) {
      this.schemas = schemas;
    };
    Validator.prototype.getSchema = function getSchema(urn) {
      return this.schemas[urn];
    };
    Validator.prototype.validate = function validate(instance, schema, options, ctx) {
      if (typeof schema !== "boolean" && typeof schema !== "object" || schema === null) {
        throw new SchemaError("Expected `schema` to be an object or boolean");
      }
      if (!options) {
        options = {};
      }
      var id = schema.$id || schema.id;
      var base = urilib.resolve(options.base || anonymousBase, id || "");
      if (!ctx) {
        ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));
        if (!ctx.schemas[base]) {
          ctx.schemas[base] = schema;
        }
        var found = scanSchema(base, schema);
        for (var n in found.id) {
          var sch = found.id[n];
          ctx.schemas[n] = sch;
        }
      }
      if (options.required && instance === void 0) {
        var result = new ValidatorResult(instance, schema, options, ctx);
        result.addError("is required, but is undefined");
        return result;
      }
      var result = this.validateSchema(instance, schema, options, ctx);
      if (!result) {
        throw new Error("Result undefined");
      } else if (options.throwAll && result.errors.length) {
        throw new ValidatorResultError(result);
      }
      return result;
    };
    function shouldResolve(schema) {
      var ref = typeof schema === "string" ? schema : schema.$ref;
      if (typeof ref == "string")
        return ref;
      return false;
    }
    Validator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (typeof schema === "boolean") {
        if (schema === true) {
          schema = {};
        } else if (schema === false) {
          schema = { type: [] };
        }
      } else if (!schema) {
        throw new Error("schema is undefined");
      }
      if (schema["extends"]) {
        if (Array.isArray(schema["extends"])) {
          var schemaobj = { schema, ctx };
          schema["extends"].forEach(this.schemaTraverser.bind(this, schemaobj));
          schema = schemaobj.schema;
          schemaobj.schema = null;
          schemaobj.ctx = null;
          schemaobj = null;
        } else {
          schema = helpers.deepMerge(schema, this.superResolve(schema["extends"], ctx));
        }
      }
      var switchSchema = shouldResolve(schema);
      if (switchSchema) {
        var resolved = this.resolve(schema, switchSchema, ctx);
        var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);
        return this.validateSchema(instance, resolved.subschema, options, subctx);
      }
      var skipAttributes = options && options.skipAttributes || [];
      for (var key in schema) {
        if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
          var validatorErr = null;
          var validator = this.attributes[key];
          if (validator) {
            validatorErr = validator.call(this, instance, schema, options, ctx);
          } else if (options.allowUnknownAttributes === false) {
            throw new SchemaError("Unsupported attribute: " + key, schema);
          }
          if (validatorErr) {
            result.importErrors(validatorErr);
          }
        }
      }
      if (typeof options.rewrite == "function") {
        var value = options.rewrite.call(this, instance, schema, options, ctx);
        result.instance = value;
      }
      return result;
    };
    Validator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {
      schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
    };
    Validator.prototype.superResolve = function superResolve(schema, ctx) {
      var ref = shouldResolve(schema);
      if (ref) {
        return this.resolve(schema, ref, ctx).subschema;
      }
      return schema;
    };
    Validator.prototype.resolve = function resolve(schema, switchSchema, ctx) {
      switchSchema = ctx.resolve(switchSchema);
      if (ctx.schemas[switchSchema]) {
        return { subschema: ctx.schemas[switchSchema], switchSchema };
      }
      var parsed = urilib.parse(switchSchema);
      var fragment = parsed && parsed.hash;
      var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
      if (!document || !ctx.schemas[document]) {
        throw new SchemaError("no such schema <" + switchSchema + ">", schema);
      }
      var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
      if (subschema === void 0) {
        throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
      }
      return { subschema, switchSchema };
    };
    Validator.prototype.testType = function validateType(instance, schema, options, ctx, type) {
      if (type === void 0) {
        return;
      } else if (type === null) {
        throw new SchemaError('Unexpected null in "type" keyword');
      }
      if (typeof this.types[type] == "function") {
        return this.types[type].call(this, instance);
      }
      if (type && typeof type == "object") {
        var res = this.validateSchema(instance, type, options, ctx);
        return res === void 0 || !(res && res.errors.length);
      }
      return true;
    };
    var types = Validator.prototype.types = {};
    types.string = function testString(instance) {
      return typeof instance == "string";
    };
    types.number = function testNumber(instance) {
      return typeof instance == "number" && isFinite(instance);
    };
    types.integer = function testInteger(instance) {
      return typeof instance == "number" && instance % 1 === 0;
    };
    types.boolean = function testBoolean(instance) {
      return typeof instance == "boolean";
    };
    types.array = function testArray(instance) {
      return Array.isArray(instance);
    };
    types["null"] = function testNull(instance) {
      return instance === null;
    };
    types.date = function testDate(instance) {
      return instance instanceof Date;
    };
    types.any = function testAny(instance) {
      return true;
    };
    types.object = function testObject(instance) {
      return instance && typeof instance === "object" && !Array.isArray(instance) && !(instance instanceof Date);
    };
    module.exports = Validator;
  }
});

// node_modules/jsonschema/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/jsonschema/lib/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Validator = module.exports.Validator = require_validator();
    module.exports.ValidatorResult = require_helpers().ValidatorResult;
    module.exports.ValidatorResultError = require_helpers().ValidatorResultError;
    module.exports.ValidationError = require_helpers().ValidationError;
    module.exports.SchemaError = require_helpers().SchemaError;
    module.exports.SchemaScanResult = require_scan().SchemaScanResult;
    module.exports.scan = require_scan().scan;
    module.exports.validate = function(instance, schema, options) {
      var v = new Validator();
      return v.validate(instance, schema, options);
    };
  }
});

// node_modules/@web3auth/ethereum-provider/dist/ethereumProvider.esm.js
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function resemblesAddress(str) {
  return str.length === 2 + 20 * 2;
}
function createWalletMiddleware(_ref) {
  var getAccounts = _ref.getAccounts, getPrivateKey = _ref.getPrivateKey, processDecryptMessage = _ref.processDecryptMessage, processEncryptionPublicKey = _ref.processEncryptionPublicKey, processEthSignMessage = _ref.processEthSignMessage, processPersonalMessage = _ref.processPersonalMessage, processTransaction = _ref.processTransaction, processSignTransaction = _ref.processSignTransaction, processTypedMessage = _ref.processTypedMessage, processTypedMessageV3 = _ref.processTypedMessageV3, processTypedMessageV4 = _ref.processTypedMessageV4;
  if (!getAccounts) {
    throw new Error("opts.getAccounts is required");
  }
  function validateAndNormalizeKeyholder(_x, _x2) {
    return _validateAndNormalizeKeyholder.apply(this, arguments);
  }
  function _validateAndNormalizeKeyholder() {
    _validateAndNormalizeKeyholder = _asyncToGenerator(import_regenerator.default.mark(function _callee(address, req) {
      var accounts, normalizedAccounts, normalizedAddress;
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof address === "string" && address.length > 0)) {
                _context.next = 8;
                break;
              }
              _context.next = 3;
              return getAccounts(req);
            case 3:
              accounts = _context.sent;
              normalizedAccounts = accounts.map(function(_address) {
                return _address.toLowerCase();
              });
              normalizedAddress = address.toLowerCase();
              if (!normalizedAccounts.includes(normalizedAddress)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", normalizedAddress);
            case 8:
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams({
                message: "Invalid parameters: must provide an Ethereum address."
              });
            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _validateAndNormalizeKeyholder.apply(this, arguments);
  }
  function lookupAccounts(_x3, _x4) {
    return _lookupAccounts.apply(this, arguments);
  }
  function _lookupAccounts() {
    _lookupAccounts = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res) {
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return getAccounts(req);
            case 2:
              res.result = _context2.sent;
            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _lookupAccounts.apply(this, arguments);
  }
  function lookupDefaultAccount(_x5, _x6) {
    return _lookupDefaultAccount.apply(this, arguments);
  }
  function _lookupDefaultAccount() {
    _lookupDefaultAccount = _asyncToGenerator(import_regenerator.default.mark(function _callee3(req, res) {
      var accounts;
      return import_regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return getAccounts(req);
            case 2:
              accounts = _context3.sent;
              res.result = accounts[0] || null;
            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _lookupDefaultAccount.apply(this, arguments);
  }
  function sendTransaction(_x7, _x8) {
    return _sendTransaction.apply(this, arguments);
  }
  function _sendTransaction() {
    _sendTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee4(req, res) {
      var txParams;
      return import_regenerator.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (processTransaction) {
                _context4.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              txParams = req.params[0] || {
                from: ""
              };
              _context4.next = 5;
              return validateAndNormalizeKeyholder(txParams.from, req);
            case 5:
              txParams.from = _context4.sent;
              _context4.next = 8;
              return processTransaction(txParams, req);
            case 8:
              res.result = _context4.sent;
            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendTransaction.apply(this, arguments);
  }
  function signTransaction(_x9, _x10) {
    return _signTransaction.apply(this, arguments);
  }
  function _signTransaction() {
    _signTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee5(req, res) {
      var txParams;
      return import_regenerator.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (processSignTransaction) {
                _context5.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              txParams = req.params[0] || {
                from: ""
              };
              _context5.next = 5;
              return validateAndNormalizeKeyholder(txParams.from, req);
            case 5:
              txParams.from = _context5.sent;
              _context5.next = 8;
              return processSignTransaction(txParams, req);
            case 8:
              res.result = _context5.sent;
            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _signTransaction.apply(this, arguments);
  }
  function ethSign(_x11, _x12) {
    return _ethSign.apply(this, arguments);
  }
  function _ethSign() {
    _ethSign = _asyncToGenerator(import_regenerator.default.mark(function _callee6(req, res) {
      var address, message, extraParams, msgParams;
      return import_regenerator.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (processEthSignMessage) {
                _context6.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context6.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context6.sent;
              message = req.params[1];
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context6.next = 10;
              return processEthSignMessage(msgParams, req);
            case 10:
              res.result = _context6.sent;
            case 11:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));
    return _ethSign.apply(this, arguments);
  }
  function signTypedData2(_x13, _x14) {
    return _signTypedData.apply(this, arguments);
  }
  function _signTypedData() {
    _signTypedData = _asyncToGenerator(import_regenerator.default.mark(function _callee7(req, res) {
      var message, address, version, extraParams, msgParams;
      return import_regenerator.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (processTypedMessage) {
                _context7.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              message = req.params[0];
              _context7.next = 5;
              return validateAndNormalizeKeyholder(req.params[1], req);
            case 5:
              address = _context7.sent;
              version = "V1";
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context7.next = 11;
              return processTypedMessage(msgParams, req, version);
            case 11:
              res.result = _context7.sent;
            case 12:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));
    return _signTypedData.apply(this, arguments);
  }
  function signTypedDataV3(_x15, _x16) {
    return _signTypedDataV.apply(this, arguments);
  }
  function _signTypedDataV() {
    _signTypedDataV = _asyncToGenerator(import_regenerator.default.mark(function _callee8(req, res) {
      var address, message, version, msgParams;
      return import_regenerator.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (processTypedMessageV3) {
                _context8.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context8.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context8.sent;
              message = req.params[1];
              version = "V3";
              msgParams = {
                data: message,
                from: address,
                version
              };
              _context8.next = 10;
              return processTypedMessageV3(msgParams, req, version);
            case 10:
              res.result = _context8.sent;
            case 11:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));
    return _signTypedDataV.apply(this, arguments);
  }
  function signTypedDataV4(_x17, _x18) {
    return _signTypedDataV2.apply(this, arguments);
  }
  function _signTypedDataV2() {
    _signTypedDataV2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(req, res) {
      var address, message, version, msgParams;
      return import_regenerator.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (processTypedMessageV4) {
                _context9.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context9.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context9.sent;
              message = req.params[1];
              version = "V4";
              msgParams = {
                data: message,
                from: address,
                version
              };
              _context9.next = 10;
              return processTypedMessageV4(msgParams, req, version);
            case 10:
              res.result = _context9.sent;
            case 11:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));
    return _signTypedDataV2.apply(this, arguments);
  }
  function personalSign2(_x19, _x20) {
    return _personalSign.apply(this, arguments);
  }
  function _personalSign() {
    _personalSign = _asyncToGenerator(import_regenerator.default.mark(function _callee10(req, res) {
      var firstParam, secondParam, extraParams, address, message, warning, msgParams;
      return import_regenerator.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (processPersonalMessage) {
                _context10.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              firstParam = req.params[0];
              secondParam = req.params[1];
              extraParams = req.params[2] || {};
              if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
                warning = "The eth_personalSign method requires params ordered ";
                warning += "[message, address]. This was previously handled incorrectly, ";
                warning += "and has been corrected automatically. ";
                warning += "Please switch this param order for smooth behavior in the future.";
                res.warning = warning;
                address = firstParam;
                message = secondParam;
              } else {
                message = firstParam;
                address = secondParam;
              }
              _context10.next = 8;
              return validateAndNormalizeKeyholder(address, req);
            case 8:
              address = _context10.sent;
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context10.next = 12;
              return processPersonalMessage(msgParams, req);
            case 12:
              res.result = _context10.sent;
            case 13:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));
    return _personalSign.apply(this, arguments);
  }
  function encryptionPublicKey(_x21, _x22) {
    return _encryptionPublicKey.apply(this, arguments);
  }
  function _encryptionPublicKey() {
    _encryptionPublicKey = _asyncToGenerator(import_regenerator.default.mark(function _callee11(req, res) {
      var address;
      return import_regenerator.default.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (processEncryptionPublicKey) {
                _context11.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context11.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context11.sent;
              _context11.next = 7;
              return processEncryptionPublicKey(address, req);
            case 7:
              res.result = _context11.sent;
            case 8:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));
    return _encryptionPublicKey.apply(this, arguments);
  }
  function decryptMessage(_x23, _x24) {
    return _decryptMessage.apply(this, arguments);
  }
  function _decryptMessage() {
    _decryptMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee12(req, res) {
      var ciphertext, address, extraParams, msgParams;
      return import_regenerator.default.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (processDecryptMessage) {
                _context12.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              ciphertext = req.params[0];
              _context12.next = 5;
              return validateAndNormalizeKeyholder(req.params[1], req);
            case 5:
              address = _context12.sent;
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: ciphertext
              });
              res.result = processDecryptMessage(msgParams, req);
            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));
    return _decryptMessage.apply(this, arguments);
  }
  function fetchPrivateKey(_x25, _x26) {
    return _fetchPrivateKey.apply(this, arguments);
  }
  function _fetchPrivateKey() {
    _fetchPrivateKey = _asyncToGenerator(import_regenerator.default.mark(function _callee13(req, res) {
      return import_regenerator.default.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (getPrivateKey) {
                _context13.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              res.result = getPrivateKey(req);
            case 3:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));
    return _fetchPrivateKey.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    // account lookups
    eth_accounts: createAsyncMiddleware(lookupAccounts),
    eth_private_key: createAsyncMiddleware(fetchPrivateKey),
    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),
    // tx signatures
    eth_sendTransaction: createAsyncMiddleware(sendTransaction),
    eth_signTransaction: createAsyncMiddleware(signTransaction),
    // message signatures
    eth_sign: createAsyncMiddleware(ethSign),
    eth_signTypedData: createAsyncMiddleware(signTypedData2),
    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),
    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),
    personal_sign: createAsyncMiddleware(personalSign2),
    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),
    eth_decrypt: createAsyncMiddleware(decryptMessage)
  });
}
function createEthMiddleware(providerHandlers) {
  var getAccounts = providerHandlers.getAccounts, getPrivateKey = providerHandlers.getPrivateKey, processTransaction = providerHandlers.processTransaction, processSignTransaction = providerHandlers.processSignTransaction, processEthSignMessage = providerHandlers.processEthSignMessage, processTypedMessage = providerHandlers.processTypedMessage, processTypedMessageV3 = providerHandlers.processTypedMessageV3, processTypedMessageV4 = providerHandlers.processTypedMessageV4, processPersonalMessage = providerHandlers.processPersonalMessage, processEncryptionPublicKey = providerHandlers.processEncryptionPublicKey, processDecryptMessage = providerHandlers.processDecryptMessage;
  var ethMiddleware = mergeMiddleware([createScaffoldMiddleware({
    eth_syncing: false
  }), createWalletMiddleware({
    getAccounts,
    getPrivateKey,
    processTransaction,
    processEthSignMessage,
    processSignTransaction,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    processEncryptionPublicKey,
    processDecryptMessage
  })]);
  return ethMiddleware;
}
function createChainSwitchMiddleware(_ref) {
  var addChain = _ref.addChain, switchChain = _ref.switchChain;
  function addNewChain(_x, _x2) {
    return _addNewChain.apply(this, arguments);
  }
  function _addNewChain() {
    _addNewChain = _asyncToGenerator(import_regenerator.default.mark(function _callee(req, res) {
      var _req$params;
      var chainParams;
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : void 0;
              if (chainParams) {
                _context.next = 3;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chain params");
            case 3:
              if (chainParams.chainId) {
                _context.next = 5;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chainId in chainParams");
            case 5:
              if (!(!chainParams.rpcUrls || chainParams.rpcUrls.length === 0)) {
                _context.next = 7;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");
            case 7:
              if (chainParams.nativeCurrency) {
                _context.next = 9;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");
            case 9:
              _context.next = 11;
              return addChain(chainParams);
            case 11:
              res.result = _context.sent;
            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _addNewChain.apply(this, arguments);
  }
  function updateChain(_x3, _x4) {
    return _updateChain.apply(this, arguments);
  }
  function _updateChain() {
    _updateChain = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res) {
      var _req$params2;
      var chainParams;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : void 0;
              if (chainParams) {
                _context2.next = 3;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chainId");
            case 3:
              _context2.next = 5;
              return switchChain(chainParams);
            case 5:
              res.result = _context2.sent;
            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _updateChain.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),
    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)
  });
}
function createAccountMiddleware(_ref2) {
  var updatePrivatekey = _ref2.updatePrivatekey;
  function updateAccount(_x5, _x6) {
    return _updateAccount.apply(this, arguments);
  }
  function _updateAccount() {
    _updateAccount = _asyncToGenerator(import_regenerator.default.mark(function _callee3(req, res) {
      var _req$params3;
      var accountParams;
      return import_regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : void 0;
              if (accountParams !== null && accountParams !== void 0 && accountParams.privateKey) {
                _context3.next = 3;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing privateKey");
            case 3:
              _context3.next = 5;
              return updatePrivatekey(accountParams);
            case 5:
              res.result = _context3.sent;
            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _updateAccount.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    wallet_updateAccount: createAsyncMiddleware(updateAccount)
  });
}
function createChainIdMiddleware(chainId) {
  return function(req, res, next, end) {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return function(req, res, next, end) {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  var chainId = providerConfig.chainId, rpcTarget = providerConfig.rpcTarget;
  var fetchMiddleware = createFetchMiddleware({
    rpcTarget
  });
  var networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
function getProviderHandlers$1(_ref) {
  var connector = _ref.connector;
  return {
    getPrivateKey: function() {
      var _getPrivateKey = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function getPrivateKey() {
        return _getPrivateKey.apply(this, arguments);
      }
      return getPrivateKey;
    }(),
    getAccounts: function() {
      var _getAccounts = _asyncToGenerator(import_regenerator.default.mark(function _callee2(_) {
        var accounts;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                accounts = connector.accounts;
                if (!(accounts && accounts.length)) {
                  _context2.next = 3;
                  break;
                }
                return _context2.abrupt("return", accounts);
              case 3:
                throw new Error("Failed to get accounts");
              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      function getAccounts(_x) {
        return _getAccounts.apply(this, arguments);
      }
      return getAccounts;
    }(),
    processTransaction: function() {
      var _processTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee3(txParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return connector.sendTransaction(txParams);
              case 2:
                result = _context3.sent;
                return _context3.abrupt("return", result);
              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function processTransaction(_x2, _x3) {
        return _processTransaction.apply(this, arguments);
      }
      return processTransaction;
    }(),
    processSignTransaction: function() {
      var _processSignTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee4(txParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return connector.signTransaction(txParams);
              case 2:
                result = _context4.sent;
                return _context4.abrupt("return", result);
              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function processSignTransaction(_x4, _x5) {
        return _processSignTransaction.apply(this, arguments);
      }
      return processSignTransaction;
    }(),
    processEthSignMessage: function() {
      var _processEthSignMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee5(msgParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return connector.signMessage([msgParams.from, msgParams.data]);
              case 2:
                result = _context5.sent;
                return _context5.abrupt("return", result);
              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      function processEthSignMessage(_x6, _x7) {
        return _processEthSignMessage.apply(this, arguments);
      }
      return processEthSignMessage;
    }(),
    processPersonalMessage: function() {
      var _processPersonalMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee6(msgParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return connector.signPersonalMessage([msgParams.data, msgParams.from]);
              case 2:
                result = _context6.sent;
                return _context6.abrupt("return", result);
              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      function processPersonalMessage(_x8, _x9) {
        return _processPersonalMessage.apply(this, arguments);
      }
      return processPersonalMessage;
    }(),
    processTypedMessage: function() {
      var _processTypedMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee7(msgParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context7.sent;
                return _context7.abrupt("return", result);
              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      function processTypedMessage(_x10, _x11) {
        return _processTypedMessage.apply(this, arguments);
      }
      return processTypedMessage;
    }(),
    processTypedMessageV3: function() {
      var _processTypedMessageV = _asyncToGenerator(import_regenerator.default.mark(function _callee8(msgParams) {
        var result;
        return import_regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context8.sent;
                return _context8.abrupt("return", result);
              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));
      function processTypedMessageV3(_x12) {
        return _processTypedMessageV.apply(this, arguments);
      }
      return processTypedMessageV3;
    }(),
    processTypedMessageV4: function() {
      var _processTypedMessageV2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(msgParams) {
        var result;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context9.sent;
                return _context9.abrupt("return", result);
              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      function processTypedMessageV4(_x13) {
        return _processTypedMessageV2.apply(this, arguments);
      }
      return processTypedMessageV4;
    }(),
    processEncryptionPublicKey: function() {
      var _processEncryptionPublicKey = _asyncToGenerator(import_regenerator.default.mark(function _callee10(_) {
        return import_regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));
      function processEncryptionPublicKey(_x14) {
        return _processEncryptionPublicKey.apply(this, arguments);
      }
      return processEncryptionPublicKey;
    }(),
    processDecryptMessage: function processDecryptMessage(_) {
      throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
    }
  };
}
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function decGWEIToHexWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
}
function hexWEIToDecGWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
}
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function normalizeGWEIDecimalNumbers(n) {
  var numberAsWEIHex = decGWEIToHexWEI(n);
  var numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);
  return numberAsGWEI;
}
function fetchEip1159GasEstimates(_x) {
  return _fetchEip1159GasEstimates.apply(this, arguments);
}
function _fetchEip1159GasEstimates() {
  _fetchEip1159GasEstimates = _asyncToGenerator(import_regenerator.default.mark(function _callee(url) {
    var estimates, normalizedEstimates;
    return import_regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return get(url);
          case 2:
            estimates = _context.sent;
            normalizedEstimates = _objectSpread$3(_objectSpread$3({}, estimates), {}, {
              estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
              low: _objectSpread$3(_objectSpread$3({}, estimates.low), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)
              }),
              medium: _objectSpread$3(_objectSpread$3({}, estimates.medium), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)
              }),
              high: _objectSpread$3(_objectSpread$3({}, estimates.high), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)
              })
            });
            return _context.abrupt("return", normalizedEstimates);
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchEip1159GasEstimates.apply(this, arguments);
}
function fetchLegacyGasPriceEstimates(_x2) {
  return _fetchLegacyGasPriceEstimates.apply(this, arguments);
}
function _fetchLegacyGasPriceEstimates() {
  _fetchLegacyGasPriceEstimates = _asyncToGenerator(import_regenerator.default.mark(function _callee2(url) {
    var result;
    return import_regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return get(url, {
              referrer: url,
              referrerPolicy: "no-referrer-when-downgrade",
              method: "GET",
              mode: "cors"
            });
          case 2:
            result = _context2.sent;
            return _context2.abrupt("return", {
              low: result.SafeGasPrice,
              medium: result.ProposeGasPrice,
              high: result.FastGasPrice
            });
          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchLegacyGasPriceEstimates.apply(this, arguments);
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function signTx(_x, _x2, _x3) {
  return _signTx.apply(this, arguments);
}
function _signTx() {
  _signTx = _asyncToGenerator(import_regenerator.default.mark(function _callee11(txParams, privKey, txFormatter) {
    var finalTxParams, common, unsignedEthTx, signedTx;
    return import_regenerator.default.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return txFormatter.formatTransaction(txParams);
          case 2:
            finalTxParams = _context11.sent;
            _context11.next = 5;
            return txFormatter.getCommonConfiguration();
          case 5:
            common = _context11.sent;
            unsignedEthTx = import_tx.TransactionFactory.fromTxData(finalTxParams, {
              common
            });
            signedTx = unsignedEthTx.sign(Buffer.from(privKey, "hex")).serialize();
            return _context11.abrupt("return", signedTx);
          case 9:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _signTx.apply(this, arguments);
}
function getProviderHandlers(_ref) {
  var txFormatter = _ref.txFormatter, privKey = _ref.privKey, getProviderEngineProxy = _ref.getProviderEngineProxy;
  return {
    getAccounts: function() {
      var _getAccounts = _asyncToGenerator(import_regenerator.default.mark(function _callee(_) {
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", ["0x".concat((0, import_util.privateToAddress)(Buffer.from(privKey, "hex")).toString("hex"))]);
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function getAccounts(_x4) {
        return _getAccounts.apply(this, arguments);
      }
      return getAccounts;
    }(),
    getPrivateKey: function() {
      var _getPrivateKey = _asyncToGenerator(import_regenerator.default.mark(function _callee2(_) {
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", privKey);
              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      function getPrivateKey(_x5) {
        return _getPrivateKey.apply(this, arguments);
      }
      return getPrivateKey;
    }(),
    processTransaction: function() {
      var _processTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee3(txParams, _) {
        var providerEngineProxy, signedTx, txHash;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context3.next = 3;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 3:
                _context3.next = 5;
                return signTx(txParams, privKey, txFormatter);
              case 5:
                signedTx = _context3.sent;
                _context3.next = 8;
                return providerEngineProxy.request({
                  method: "eth_sendRawTransaction",
                  params: ["0x".concat(signedTx.toString("hex"))]
                });
              case 8:
                txHash = _context3.sent;
                return _context3.abrupt("return", txHash);
              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function processTransaction(_x6, _x7) {
        return _processTransaction.apply(this, arguments);
      }
      return processTransaction;
    }(),
    processSignTransaction: function() {
      var _processSignTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee4(txParams, _) {
        var providerEngineProxy, signedTx;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context4.next = 3;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 3:
                _context4.next = 5;
                return signTx(txParams, privKey, txFormatter);
              case 5:
                signedTx = _context4.sent;
                return _context4.abrupt("return", "0x".concat(signedTx.toString("hex")));
              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function processSignTransaction(_x8, _x9) {
        return _processSignTransaction.apply(this, arguments);
      }
      return processSignTransaction;
    }(),
    processEthSignMessage: function() {
      var _processEthSignMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee5(msgParams, _) {
        var rawMessageSig;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                rawMessageSig = signMessage(privKey, msgParams.data);
                return _context5.abrupt("return", rawMessageSig);
              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      function processEthSignMessage(_x10, _x11) {
        return _processEthSignMessage.apply(this, arguments);
      }
      return processEthSignMessage;
    }(),
    processPersonalMessage: function() {
      var _processPersonalMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee6(msgParams, _) {
        var privKeyBuffer, sig;
        return import_regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                privKeyBuffer = Buffer.from(privKey, "hex");
                sig = (0, import_eth_sig_util.personalSign)({
                  privateKey: privKeyBuffer,
                  data: msgParams.data
                });
                return _context6.abrupt("return", sig);
              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      function processPersonalMessage(_x12, _x13) {
        return _processPersonalMessage.apply(this, arguments);
      }
      return processPersonalMessage;
    }(),
    processTypedMessage: function() {
      var _processTypedMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee7(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, params, data, sig;
        return import_regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                log.debug("processTypedMessage", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context7.next = 5;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context7.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context7.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                params = _objectSpread$2(_objectSpread$2({}, msgParams), {}, {
                  version: import_eth_sig_util.SignTypedDataVersion.V1
                });
                validateTypedMessageParams(params, finalChainId);
                data = typeof params.data === "string" ? JSON.parse(params.data) : params.data;
                sig = (0, import_eth_sig_util.signTypedData)({
                  privateKey: privKeyBuffer,
                  data,
                  version: import_eth_sig_util.SignTypedDataVersion.V1
                });
                return _context7.abrupt("return", sig);
              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      function processTypedMessage(_x14, _x15) {
        return _processTypedMessage.apply(this, arguments);
      }
      return processTypedMessage;
    }(),
    processTypedMessageV3: function() {
      var _processTypedMessageV = _asyncToGenerator(import_regenerator.default.mark(function _callee8(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, data, sig;
        return import_regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                log.debug("processTypedMessageV3", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context8.next = 5;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context8.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context8.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                validateTypedMessageParams(msgParams, finalChainId);
                data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
                sig = (0, import_eth_sig_util.signTypedData)({
                  privateKey: privKeyBuffer,
                  data,
                  version: import_eth_sig_util.SignTypedDataVersion.V3
                });
                return _context8.abrupt("return", sig);
              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));
      function processTypedMessageV3(_x16, _x17) {
        return _processTypedMessageV.apply(this, arguments);
      }
      return processTypedMessageV3;
    }(),
    processTypedMessageV4: function() {
      var _processTypedMessageV2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, data, sig;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                log.debug("processTypedMessageV4", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context9.next = 5;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context9.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context9.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                validateTypedMessageParams(msgParams, finalChainId);
                data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
                sig = (0, import_eth_sig_util.signTypedData)({
                  privateKey: privKeyBuffer,
                  data,
                  version: import_eth_sig_util.SignTypedDataVersion.V4
                });
                return _context9.abrupt("return", sig);
              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      function processTypedMessageV4(_x18, _x19) {
        return _processTypedMessageV2.apply(this, arguments);
      }
      return processTypedMessageV4;
    }(),
    processEncryptionPublicKey: function() {
      var _processEncryptionPublicKey = _asyncToGenerator(import_regenerator.default.mark(function _callee10(address, _) {
        return import_regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                log.info("processEncryptionPublicKey", address);
                return _context10.abrupt("return", (0, import_eth_sig_util.getEncryptionPublicKey)(privKey));
              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));
      function processEncryptionPublicKey(_x20, _x21) {
        return _processEncryptionPublicKey.apply(this, arguments);
      }
      return processEncryptionPublicKey;
    }(),
    processDecryptMessage: function processDecryptMessage(msgParams, _) {
      log.info("processDecryptMessage", msgParams);
      var stripped = (0, import_util.stripHexPrefix)(msgParams.data);
      var buff = Buffer.from(stripped, "hex");
      var decrypted = (0, import_eth_sig_util.decrypt)({
        encryptedData: JSON.parse(buff.toString("utf8")),
        privateKey: privKey
      });
      return decrypted;
    }
  };
}
function bnLessThan(a, b) {
  if (a === null || a === void 0 || b === null || b === void 0) {
    return null;
  }
  return new BigNumber(a, 10).lt(b, 10);
}
function bnToHex(inputBn) {
  return (0, import_util.addHexPrefix)(inputBn.toString(16));
}
function hexToBn(inputHex) {
  if (import_bn.default.isBN(inputHex))
    return inputHex;
  return new import_bn.default((0, import_util.stripHexPrefix)(inputHex), 16);
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  var numberBN = new import_bn.default(numerator);
  var denomBN = new import_bn.default(denominator);
  return targetBN.mul(numberBN).div(denomBN);
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var import_regenerator, import_eth_rpc_errors, import_tx, import_util, import_eth_sig_util, import_assert, import_jsonschema, import_common, import_bn, WalletConnectProvider, BIG_NUMBER_WEI_MULTIPLIER, BIG_NUMBER_GWEI_MULTIPLIER, BIG_NUMBER_ETH_MULTIPLIER, toBigNumber, toNormalizedDenomination, toSpecifiedDenomination, baseChange, converter, conversionUtil, validateTypedMessageParams, LegacyGasAPIEndpoint, EIP1559APIEndpoint, TRANSACTION_ENVELOPE_TYPES, TRANSACTION_TYPES, GAS_ESTIMATE_TYPES, TransactionFormatter, EthereumPrivateKeyProvider;
var init_ethereumProvider_esm = __esm({
  "node_modules/@web3auth/ethereum-provider/dist/ethereumProvider.esm.js"() {
    init_process();
    init_buffer();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_regenerator = __toESM(require_regenerator());
    init_baseControllers_esm();
    init_openloginJrpc_esm();
    init_base_esm();
    init_baseProvider_esm();
    import_eth_rpc_errors = __toESM(require_dist3());
    import_tx = __toESM(require_dist5());
    import_util = __toESM(require_dist2());
    import_eth_sig_util = __toESM(require_dist6());
    init_typeof();
    init_httpHelpers_esm();
    import_assert = __toESM(require_assert());
    import_jsonschema = __toESM(require_lib4());
    init_bignumber();
    import_common = __toESM(require_dist4());
    import_bn = __toESM(require_bn());
    WalletConnectProvider = function(_BaseProvider) {
      _inherits(WalletConnectProvider2, _BaseProvider);
      var _super = _createSuper$1(WalletConnectProvider2);
      function WalletConnectProvider2(_ref) {
        var _this;
        var config = _ref.config, state = _ref.state, connector = _ref.connector;
        _classCallCheck(this, WalletConnectProvider2);
        _this = _super.call(this, {
          config: {
            chainConfig: _objectSpread$4(_objectSpread$4({}, config.chainConfig), {}, {
              chainNamespace: CHAIN_NAMESPACES.EIP155
            }),
            skipLookupNetwork: !!config.skipLookupNetwork
          },
          state: _objectSpread$4(_objectSpread$4({}, state || {}), {}, {
            chainId: "loading",
            accounts: []
          })
        });
        _defineProperty(_assertThisInitialized(_this), "connector", null);
        _this.connector = connector || null;
        return _this;
      }
      _createClass(WalletConnectProvider2, [{
        key: "enable",
        value: function() {
          var _enable = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.connector) {
                      _context.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Connector is not initialized, pass wallet connect connector in constructor",
                      code: 4902
                    });
                  case 2:
                    _context.next = 4;
                    return this.setupProvider(this.connector);
                  case 4:
                    return _context.abrupt("return", this._providerEngineProxy.request({
                      method: "eth_accounts"
                    }));
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function enable() {
            return _enable.apply(this, arguments);
          }
          return enable;
        }()
      }, {
        key: "setupProvider",
        value: function() {
          var _setupProvider = _asyncToGenerator(import_regenerator.default.mark(function _callee2(connector) {
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this.onConnectorStateUpdate(connector);
                    _context2.next = 3;
                    return this.setupEngine(connector);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function setupProvider(_x) {
            return _setupProvider.apply(this, arguments);
          }
          return setupProvider;
        }()
      }, {
        key: "switchChain",
        value: function() {
          var _switchChain = _asyncToGenerator(import_regenerator.default.mark(function _callee3(_ref2) {
            var chainId, _ref2$addChain, addChain, _ref2$lookup, lookup, currentChainConfig, rpcTarget, displayName;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    chainId = _ref2.chainId, _ref2$addChain = _ref2.addChain, addChain = _ref2$addChain === void 0 ? true : _ref2$addChain, _ref2$lookup = _ref2.lookup, lookup = _ref2$lookup === void 0 ? true : _ref2$lookup;
                    if (this.connector) {
                      _context3.next = 3;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Connector is not initialized, pass wallet connect connector in constructor",
                      code: 4902
                    });
                  case 3:
                    currentChainConfig = this.getChainConfig(chainId);
                    this.update({
                      chainId: "loading"
                    });
                    rpcTarget = currentChainConfig.rpcTarget, displayName = currentChainConfig.displayName;
                    if (!addChain) {
                      _context3.next = 15;
                      break;
                    }
                    _context3.prev = 7;
                    _context3.next = 10;
                    return this.connector.sendCustomRequest({
                      method: "wallet_addEthereumChain",
                      params: [{
                        chainId,
                        chainName: displayName,
                        rpcUrls: [rpcTarget]
                      }]
                    });
                  case 10:
                    _context3.next = 15;
                    break;
                  case 12:
                    _context3.prev = 12;
                    _context3.t0 = _context3["catch"](7);
                    log.error(_context3.t0);
                  case 15:
                    _context3.prev = 15;
                    _context3.next = 18;
                    return this.connector.sendCustomRequest({
                      method: "wallet_switchEthereumChain",
                      params: [{
                        chainId
                      }]
                    });
                  case 18:
                    _context3.next = 25;
                    break;
                  case 20:
                    _context3.prev = 20;
                    _context3.t1 = _context3["catch"](15);
                    log.error(_context3.t1);
                    if (!(_context3.t1.message !== "JSON RPC response format is invalid")) {
                      _context3.next = 25;
                      break;
                    }
                    throw _context3.t1;
                  case 25:
                    this.configure({
                      chainConfig: currentChainConfig
                    });
                    if (!lookup) {
                      _context3.next = 29;
                      break;
                    }
                    _context3.next = 29;
                    return this.lookupNetwork(this.connector);
                  case 29:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[7, 12], [15, 20]]);
          }));
          function switchChain(_x2) {
            return _switchChain.apply(this, arguments);
          }
          return switchChain;
        }()
      }, {
        key: "addChain",
        value: function() {
          var _addChain = _asyncToGenerator(import_regenerator.default.mark(function _callee4(chainConfig) {
            var rpcTarget, displayName;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this.connector) {
                      _context4.next = 2;
                      break;
                    }
                    throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
                  case 2:
                    rpcTarget = chainConfig.rpcTarget, displayName = chainConfig.displayName;
                    _context4.prev = 3;
                    _context4.next = 6;
                    return this.connector.sendCustomRequest({
                      method: "wallet_addEthereumChain",
                      params: [{
                        chainId: chainConfig.chainId,
                        chainName: displayName,
                        rpcUrls: [rpcTarget]
                      }]
                    });
                  case 6:
                    _get(_getPrototypeOf(WalletConnectProvider2.prototype), "addChain", this).call(this, chainConfig);
                    _context4.next = 13;
                    break;
                  case 9:
                    _context4.prev = 9;
                    _context4.t0 = _context4["catch"](3);
                    log.error(_context4.t0);
                    throw _context4.t0;
                  case 13:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[3, 9]]);
          }));
          function addChain(_x3) {
            return _addChain.apply(this, arguments);
          }
          return addChain;
        }()
      }, {
        key: "lookupNetwork",
        value: function() {
          var _lookupNetwork = _asyncToGenerator(import_regenerator.default.mark(function _callee5(connector) {
            var chainId, connectedHexChainId;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (connector.connected) {
                      _context5.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Wallet connect connector is not connected");
                  case 2:
                    if (this.provider) {
                      _context5.next = 4;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 4:
                    chainId = this.config.chainConfig.chainId;
                    connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : "0x".concat(connector.chainId.toString(16));
                    if (!(chainId !== connectedHexChainId)) {
                      _context5.next = 8;
                      break;
                    }
                    throw WalletInitializationError.rpcConnectionError("Invalid network, net_version is: ".concat(connectedHexChainId, ", expected: ").concat(chainId));
                  case 8:
                    this.provider.emit("connect", {
                      chainId
                    });
                    this.provider.emit("chainChanged", this.state.chainId);
                    return _context5.abrupt("return", connectedHexChainId);
                  case 11:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function lookupNetwork(_x4) {
            return _lookupNetwork.apply(this, arguments);
          }
          return lookupNetwork;
        }()
      }, {
        key: "setupEngine",
        value: function() {
          var _setupEngine = _asyncToGenerator(import_regenerator.default.mark(function _callee6(connector) {
            var providerHandlers, ethMiddleware, engine, _createJsonRpcClient, networkMiddleware, provider;
            return import_regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    providerHandlers = getProviderHandlers$1({
                      connector
                    });
                    this.update({
                      accounts: connector.accounts || []
                    });
                    ethMiddleware = createEthMiddleware(providerHandlers);
                    engine = new JRPCEngine();
                    _createJsonRpcClient = createJsonRpcClient(this.config.chainConfig), networkMiddleware = _createJsonRpcClient.networkMiddleware;
                    engine.push(ethMiddleware);
                    engine.push(networkMiddleware);
                    provider = providerFromEngine(engine);
                    this.updateProviderEngineProxy(provider);
                    if (this.config.skipLookupNetwork) {
                      _context6.next = 12;
                      break;
                    }
                    _context6.next = 12;
                    return this.lookupNetwork(connector);
                  case 12:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function setupEngine(_x5) {
            return _setupEngine.apply(this, arguments);
          }
          return setupEngine;
        }()
      }, {
        key: "onConnectorStateUpdate",
        value: function() {
          var _onConnectorStateUpdate = _asyncToGenerator(import_regenerator.default.mark(function _callee8(connector) {
            var _this2 = this;
            return import_regenerator.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    connector.on("session_update", function() {
                      var _ref3 = _asyncToGenerator(import_regenerator.default.mark(function _callee7(error, payload) {
                        var _payload$params$, accounts, connectedChainId, rpcUrl, connectedHexChainId, maybeConfig;
                        return import_regenerator.default.wrap(function _callee7$(_context7) {
                          while (1) {
                            switch (_context7.prev = _context7.next) {
                              case 0:
                                if (_this2.provider) {
                                  _context7.next = 2;
                                  break;
                                }
                                throw WalletLoginError.notConnectedError("Wallet connect connector is not connected");
                              case 2:
                                if (!error) {
                                  _context7.next = 5;
                                  break;
                                }
                                _this2.provider.emit("error", error);
                                return _context7.abrupt("return");
                              case 5:
                                _payload$params$ = payload.params[0], accounts = _payload$params$.accounts, connectedChainId = _payload$params$.chainId, rpcUrl = _payload$params$.rpcUrl;
                                if (accounts !== null && accounts !== void 0 && accounts.length && _this2.state.accounts[0] !== accounts[0]) {
                                  _this2.update({
                                    accounts
                                  });
                                  _this2.provider.emit("accountsChanged", accounts);
                                }
                                connectedHexChainId = "0x".concat(connectedChainId.toString(16));
                                if (!(connectedChainId && _this2.state.chainId !== connectedHexChainId)) {
                                  _context7.next = 13;
                                  break;
                                }
                                maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {};
                                _this2.configure({
                                  chainConfig: _objectSpread$4(_objectSpread$4({}, maybeConfig), {}, {
                                    chainId: connectedHexChainId,
                                    rpcTarget: rpcUrl,
                                    chainNamespace: CHAIN_NAMESPACES.EIP155
                                  })
                                });
                                _context7.next = 13;
                                return _this2.setupEngine(connector);
                              case 13:
                              case "end":
                                return _context7.stop();
                            }
                          }
                        }, _callee7);
                      }));
                      return function(_x7, _x8) {
                        return _ref3.apply(this, arguments);
                      };
                    }());
                  case 1:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          }));
          function onConnectorStateUpdate(_x6) {
            return _onConnectorStateUpdate.apply(this, arguments);
          }
          return onConnectorStateUpdate;
        }()
      }]);
      return WalletConnectProvider2;
    }(BaseProvider);
    _defineProperty(WalletConnectProvider, "getProviderInstance", function() {
      var _ref4 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(params) {
        var providerFactory;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                providerFactory = new WalletConnectProvider({
                  config: {
                    chainConfig: params.chainConfig,
                    skipLookupNetwork: params.skipLookupNetwork
                  }
                });
                _context9.next = 3;
                return providerFactory.setupProvider(params.connector);
              case 3:
                return _context9.abrupt("return", providerFactory);
              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      return function(_x9) {
        return _ref4.apply(this, arguments);
      };
    }());
    BIG_NUMBER_WEI_MULTIPLIER = new bignumber_default("1e18");
    BIG_NUMBER_GWEI_MULTIPLIER = new bignumber_default("1e9");
    BIG_NUMBER_ETH_MULTIPLIER = new bignumber_default("1");
    toBigNumber = {
      hex: function hex(n) {
        return typeof n === "string" ? new bignumber_default((0, import_util.stripHexPrefix)(n), 16) : new bignumber_default(n, 16);
      },
      dec: function dec(n) {
        return new bignumber_default(n, 10);
      }
    };
    toNormalizedDenomination = {
      WEI: function WEI(bigNumber) {
        return bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER);
      },
      GWEI: function GWEI(bigNumber) {
        return bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER);
      },
      ETH: function ETH(bigNumber) {
        return bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER);
      }
    };
    toSpecifiedDenomination = {
      WEI: function WEI2(bigNumber) {
        return bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, bignumber_default.ROUND_HALF_UP);
      },
      GWEI: function GWEI2(bigNumber) {
        return bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, bignumber_default.ROUND_HALF_UP);
      },
      ETH: function ETH2(bigNumber) {
        return bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, bignumber_default.ROUND_HALF_UP);
      }
    };
    baseChange = {
      hex: function hex2(n) {
        return n.toString(16);
      },
      dec: function dec2(n) {
        return new bignumber_default(n).toString(10);
      }
    };
    converter = function converter2(params) {
      var value = params.value, fromNumericBase = params.fromNumericBase, fromDenomination = params.fromDenomination, toNumericBase = params.toNumericBase, toDenomination = params.toDenomination, numberOfDecimals = params.numberOfDecimals;
      var convertedValue = toBigNumber[fromNumericBase](value);
      if (fromDenomination) {
        convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
      }
      if (toDenomination) {
        convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
      }
      if (numberOfDecimals) {
        convertedValue = convertedValue.dp(numberOfDecimals, bignumber_default.ROUND_HALF_DOWN);
      }
      if (toNumericBase) {
        convertedValue = baseChange[toNumericBase](convertedValue);
      }
      return convertedValue;
    };
    conversionUtil = function conversionUtil2(value, _ref) {
      var _ref$fromNumericBase = _ref.fromNumericBase, fromNumericBase = _ref$fromNumericBase === void 0 ? "hex" : _ref$fromNumericBase, toNumericBase = _ref.toNumericBase, fromDenomination = _ref.fromDenomination, toDenomination = _ref.toDenomination, numberOfDecimals = _ref.numberOfDecimals;
      return converter({
        fromNumericBase,
        toNumericBase,
        fromDenomination,
        toDenomination,
        numberOfDecimals,
        value: value || "0"
      });
    };
    validateTypedMessageParams = function validateTypedMessageParams2(parameters, activeChainId) {
      var _data$domain;
      try {
        import_assert.default.ok(parameters && _typeof(parameters) === "object", "Params must be an object.");
        import_assert.default.ok("data" in parameters, 'Params must include a "data" field.');
        import_assert.default.ok("from" in parameters, 'Params must include a "from" field.');
        import_assert.default.ok(typeof parameters.from === "string" && (0, import_util.isValidAddress)(parameters.from), '"from" field must be a valid, lowercase, hexadecimal Ethereum address string.');
        var data = null;
        var chainId = null;
        switch (parameters.version) {
          case import_eth_sig_util.SignTypedDataVersion.V1:
            if (typeof parameters.data === "string") {
              import_assert.default.doesNotThrow(function() {
                data = JSON.parse(parameters.data);
              }, '"data" must be a valid JSON string.');
            } else {
              data = parameters.data;
            }
            import_assert.default.ok(Array.isArray(data), "params.data must be an array.");
            import_assert.default.doesNotThrow(function() {
              (0, import_eth_sig_util.typedSignatureHash)(data);
            }, "Signing data must be valid EIP-712 typed data.");
            break;
          case import_eth_sig_util.SignTypedDataVersion.V3:
          case import_eth_sig_util.SignTypedDataVersion.V4:
            if (typeof parameters.data === "string") {
              import_assert.default.doesNotThrow(function() {
                data = JSON.parse(parameters.data);
              }, '"data" must be a valid JSON string.');
            } else {
              data = parameters.data;
            }
            import_assert.default.ok(data.primaryType in data.types, 'Primary type of "'.concat(data.primaryType, '" has no type definition.'));
            var validation = import_jsonschema.default.validate(data, import_eth_sig_util.TYPED_MESSAGE_SCHEMA.properties);
            import_assert.default.strictEqual(validation.errors.length, 0, "Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.");
            chainId = (_data$domain = data.domain) === null || _data$domain === void 0 ? void 0 : _data$domain.chainId;
            if (chainId) {
              import_assert.default.ok(!Number.isNaN(activeChainId), 'Cannot sign messages for chainId "'.concat(chainId, '", because Web3Auth is switching networks.'));
              if (typeof chainId === "string") {
                chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
              }
              import_assert.default.strictEqual(chainId, activeChainId, 'Provided chainId "'.concat(chainId, '" must match the active chainId "').concat(activeChainId, '"'));
            }
            break;
          default:
            import_assert.default.fail('Unknown typed data version "'.concat(parameters.version, '"'));
        }
      } catch (error) {
        throw import_eth_rpc_errors.ethErrors.rpc.invalidInput({
          message: error === null || error === void 0 ? void 0 : error.message
        });
      }
    };
    LegacyGasAPIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices";
    EIP1559APIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees";
    TRANSACTION_ENVELOPE_TYPES = {
      LEGACY: "0x0",
      ACCESS_LIST: "0x1",
      FEE_MARKET: "0x2"
    };
    TRANSACTION_TYPES = {
      SENT_ETHER: "sentEther",
      CONTRACT_INTERACTION: "contractInteraction",
      DEPLOY_CONTRACT: "contractDeployment",
      STANDARD_TRANSACTION: "transaction"
    };
    GAS_ESTIMATE_TYPES = {
      FEE_MARKET: "fee-market",
      LEGACY: "legacy",
      ETH_GASPRICE: "eth_gasPrice",
      NONE: "none"
    };
    TransactionFormatter = function() {
      function TransactionFormatter2(_ref) {
        var getProviderEngineProxy = _ref.getProviderEngineProxy;
        _classCallCheck(this, TransactionFormatter2);
        _defineProperty(this, "chainConfig", null);
        _defineProperty(this, "getProviderEngineProxy", void 0);
        _defineProperty(this, "isEIP1559Compatible", false);
        this.getProviderEngineProxy = getProviderEngineProxy;
      }
      _createClass(TransactionFormatter2, [{
        key: "providerProxy",
        get: function get2() {
          return this.getProviderEngineProxy();
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.providerProxy.request({
                      method: "eth_provider_config",
                      params: []
                    });
                  case 2:
                    this.chainConfig = _context.sent;
                    _context.next = 5;
                    return this.getEIP1559Compatibility();
                  case 5:
                    this.isEIP1559Compatible = _context.sent;
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "getCommonConfiguration",
        value: function() {
          var _getCommonConfiguration = _asyncToGenerator(import_regenerator.default.mark(function _callee2() {
            var _this$chainConfig, name, chainId, hardfork, customChainParams;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.chainConfig) {
                      _context2.next = 2;
                      break;
                    }
                    throw new Error("Chain config not initialized");
                  case 2:
                    _this$chainConfig = this.chainConfig, name = _this$chainConfig.displayName, chainId = _this$chainConfig.chainId;
                    hardfork = this.isEIP1559Compatible ? import_common.Hardfork.London : import_common.Hardfork.Berlin;
                    customChainParams = {
                      name,
                      chainId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
                      networkId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
                      defaultHardfork: hardfork
                    };
                    return _context2.abrupt("return", import_common.Common.custom(customChainParams));
                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getCommonConfiguration() {
            return _getCommonConfiguration.apply(this, arguments);
          }
          return getCommonConfiguration;
        }()
      }, {
        key: "formatTransaction",
        value: function() {
          var _formatTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee3(txParams) {
            var clonedTxParams, defaultGasLimit, _defaultGasLimit, _yield$this$getDefaul, defaultGasPrice, defaultMaxFeePerGas, defaultMaxPriorityFeePerGas;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (this.chainConfig) {
                      _context3.next = 2;
                      break;
                    }
                    throw new Error("Chain config not initialized");
                  case 2:
                    clonedTxParams = _objectSpread$1({}, txParams);
                    if (!(clonedTxParams.nonce === void 0)) {
                      _context3.next = 7;
                      break;
                    }
                    _context3.next = 6;
                    return this.providerProxy.request({
                      method: "eth_getTransactionCount",
                      params: [txParams.from, "latest"]
                    });
                  case 6:
                    clonedTxParams.nonce = _context3.sent;
                  case 7:
                    if (!(!this.isEIP1559Compatible && clonedTxParams.gasPrice)) {
                      _context3.next = 19;
                      break;
                    }
                    if (clonedTxParams.maxFeePerGas)
                      delete clonedTxParams.maxFeePerGas;
                    if (clonedTxParams.maxPriorityFeePerGas)
                      delete clonedTxParams.maxPriorityFeePerGas;
                    if (clonedTxParams.gas) {
                      _context3.next = 17;
                      break;
                    }
                    _context3.next = 13;
                    return this.getDefaultGasLimit(clonedTxParams);
                  case 13:
                    defaultGasLimit = _context3.sent;
                    if (defaultGasLimit) {
                      clonedTxParams.gasLimit = defaultGasLimit;
                    }
                    _context3.next = 18;
                    break;
                  case 17:
                    clonedTxParams.gasLimit = clonedTxParams.gas;
                  case 18:
                    return _context3.abrupt("return", clonedTxParams);
                  case 19:
                    if (clonedTxParams.gas) {
                      _context3.next = 26;
                      break;
                    }
                    _context3.next = 22;
                    return this.getDefaultGasLimit(clonedTxParams);
                  case 22:
                    _defaultGasLimit = _context3.sent;
                    if (_defaultGasLimit) {
                      clonedTxParams.gasLimit = _defaultGasLimit;
                    }
                    _context3.next = 27;
                    break;
                  case 26:
                    clonedTxParams.gasLimit = clonedTxParams.gas;
                  case 27:
                    _context3.next = 29;
                    return this.getDefaultGasFees(clonedTxParams);
                  case 29:
                    _yield$this$getDefaul = _context3.sent;
                    defaultGasPrice = _yield$this$getDefaul.gasPrice;
                    defaultMaxFeePerGas = _yield$this$getDefaul.maxFeePerGas;
                    defaultMaxPriorityFeePerGas = _yield$this$getDefaul.maxPriorityFeePerGas;
                    if (this.isEIP1559Compatible) {
                      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;
                        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? (0, import_util.stripHexPrefix)(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === "string" ? (0, import_util.stripHexPrefix)(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;
                      } else {
                        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {
                          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;
                        }
                        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
                        }
                        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {
                          clonedTxParams.maxFeePerGas = defaultGasPrice;
                        }
                        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;
                        }
                      }
                      delete clonedTxParams.gasPrice;
                    } else {
                      delete clonedTxParams.maxPriorityFeePerGas;
                      delete clonedTxParams.maxFeePerGas;
                    }
                    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {
                      clonedTxParams.gasPrice = defaultGasPrice;
                    }
                    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;
                    clonedTxParams.chainId = this.chainConfig.chainId;
                    return _context3.abrupt("return", clonedTxParams);
                  case 38:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function formatTransaction(_x) {
            return _formatTransaction.apply(this, arguments);
          }
          return formatTransaction;
        }()
      }, {
        key: "fetchEthGasPriceEstimate",
        value: function() {
          var _fetchEthGasPriceEstimate = _asyncToGenerator(import_regenerator.default.mark(function _callee4() {
            var gasPrice;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this.providerProxy.request({
                      method: "eth_gasPrice",
                      params: []
                    });
                  case 2:
                    gasPrice = _context4.sent;
                    return _context4.abrupt("return", {
                      gasPrice: hexWEIToDecGWEI(gasPrice).toString()
                    });
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function fetchEthGasPriceEstimate() {
            return _fetchEthGasPriceEstimate.apply(this, arguments);
          }
          return fetchEthGasPriceEstimate;
        }()
      }, {
        key: "getEIP1559Compatibility",
        value: function() {
          var _getEIP1559Compatibility = _asyncToGenerator(import_regenerator.default.mark(function _callee5() {
            var latestBlock, supportsEIP1559;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this.providerProxy.request({
                      method: "eth_getBlockByNumber",
                      params: ["latest", false]
                    });
                  case 2:
                    latestBlock = _context5.sent;
                    supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== void 0;
                    return _context5.abrupt("return", !!supportsEIP1559);
                  case 5:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getEIP1559Compatibility() {
            return _getEIP1559Compatibility.apply(this, arguments);
          }
          return getEIP1559Compatibility;
        }()
      }, {
        key: "fetchGasFeeEstimateData",
        value: function() {
          var _fetchGasFeeEstimateData = _asyncToGenerator(import_regenerator.default.mark(function _callee6() {
            var isLegacyGasAPICompatible, chainId, gasData, estimates, _estimates, _estimates2;
            return import_regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    if (this.chainConfig) {
                      _context6.next = 2;
                      break;
                    }
                    throw new Error("Chain config not initialized");
                  case 2:
                    isLegacyGasAPICompatible = this.chainConfig.chainId === "0x1";
                    chainId = Number.parseInt(this.chainConfig.chainId, 16);
                    _context6.prev = 4;
                    if (!this.isEIP1559Compatible) {
                      _context6.next = 12;
                      break;
                    }
                    _context6.next = 8;
                    return fetchEip1159GasEstimates(EIP1559APIEndpoint.replace("<chain_id>", "".concat(chainId)));
                  case 8:
                    estimates = _context6.sent;
                    gasData = {
                      gasFeeEstimates: estimates,
                      gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
                    };
                    _context6.next = 20;
                    break;
                  case 12:
                    if (!isLegacyGasAPICompatible) {
                      _context6.next = 19;
                      break;
                    }
                    _context6.next = 15;
                    return fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace("<chain_id>", "".concat(chainId)));
                  case 15:
                    _estimates = _context6.sent;
                    gasData = {
                      gasFeeEstimates: _estimates,
                      gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
                    };
                    _context6.next = 20;
                    break;
                  case 19:
                    throw new Error("Main gas fee/price estimation failed. Use fallback");
                  case 20:
                    _context6.next = 34;
                    break;
                  case 22:
                    _context6.prev = 22;
                    _context6.t0 = _context6["catch"](4);
                    _context6.prev = 24;
                    _context6.next = 27;
                    return this.fetchEthGasPriceEstimate();
                  case 27:
                    _estimates2 = _context6.sent;
                    gasData = {
                      gasFeeEstimates: _estimates2,
                      gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
                    };
                    _context6.next = 34;
                    break;
                  case 31:
                    _context6.prev = 31;
                    _context6.t1 = _context6["catch"](24);
                    throw new Error("Gas fee/price estimation failed. Message: ".concat(_context6.t1.message));
                  case 34:
                    return _context6.abrupt("return", gasData);
                  case 35:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[4, 22], [24, 31]]);
          }));
          function fetchGasFeeEstimateData() {
            return _fetchGasFeeEstimateData.apply(this, arguments);
          }
          return fetchGasFeeEstimateData;
        }()
      }, {
        key: "getDefaultGasFees",
        value: function() {
          var _getDefaultGasFees = _asyncToGenerator(import_regenerator.default.mark(function _callee7(txParams) {
            var _yield$this$fetchGasF, gasFeeEstimates, gasEstimateType, _gasFeeEstimates$medi, suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas, _yield$this$fetchEthG, gasPrice;
            return import_regenerator.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!(!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas)) {
                      _context7.next = 2;
                      break;
                    }
                    return _context7.abrupt("return", {});
                  case 2:
                    _context7.prev = 2;
                    _context7.next = 5;
                    return this.fetchGasFeeEstimateData();
                  case 5:
                    _yield$this$fetchGasF = _context7.sent;
                    gasFeeEstimates = _yield$this$fetchGasF.gasFeeEstimates;
                    gasEstimateType = _yield$this$fetchGasF.gasEstimateType;
                    if (!(this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET)) {
                      _context7.next = 16;
                      break;
                    }
                    _gasFeeEstimates$medi = gasFeeEstimates.medium;
                    _gasFeeEstimates$medi = _gasFeeEstimates$medi === void 0 ? {} : _gasFeeEstimates$medi;
                    suggestedMaxPriorityFeePerGas = _gasFeeEstimates$medi.suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas = _gasFeeEstimates$medi.suggestedMaxFeePerGas;
                    if (!(suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas)) {
                      _context7.next = 14;
                      break;
                    }
                    return _context7.abrupt("return", {
                      maxFeePerGas: (0, import_util.addHexPrefix)(decGWEIToHexWEI(suggestedMaxFeePerGas)),
                      maxPriorityFeePerGas: (0, import_util.addHexPrefix)(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))
                    });
                  case 14:
                    _context7.next = 22;
                    break;
                  case 16:
                    if (!(gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY)) {
                      _context7.next = 20;
                      break;
                    }
                    return _context7.abrupt("return", {
                      gasPrice: (0, import_util.addHexPrefix)(decGWEIToHexWEI(gasFeeEstimates.medium))
                    });
                  case 20:
                    if (!(gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE)) {
                      _context7.next = 22;
                      break;
                    }
                    return _context7.abrupt("return", {
                      gasPrice: (0, import_util.addHexPrefix)(decGWEIToHexWEI(gasFeeEstimates.gasPrice))
                    });
                  case 22:
                    _context7.next = 27;
                    break;
                  case 24:
                    _context7.prev = 24;
                    _context7.t0 = _context7["catch"](2);
                    log.error(_context7.t0);
                  case 27:
                    _context7.next = 29;
                    return this.fetchEthGasPriceEstimate();
                  case 29:
                    _yield$this$fetchEthG = _context7.sent;
                    gasPrice = _yield$this$fetchEthG.gasPrice;
                    return _context7.abrupt("return", {
                      gasPrice: (0, import_util.addHexPrefix)(decGWEIToHexWEI(gasPrice))
                    });
                  case 32:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this, [[2, 24]]);
          }));
          function getDefaultGasFees(_x2) {
            return _getDefaultGasFees.apply(this, arguments);
          }
          return getDefaultGasFees;
        }()
      }, {
        key: "estimateTxGas",
        value: function() {
          var _estimateTxGas = _asyncToGenerator(import_regenerator.default.mark(function _callee8(txMeta) {
            var txParams, gas;
            return import_regenerator.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    txParams = _objectSpread$1({}, txMeta);
                    delete txParams.gasPrice;
                    delete txParams.maxFeePerGas;
                    delete txParams.maxPriorityFeePerGas;
                    _context8.next = 6;
                    return this.providerProxy.request({
                      method: "eth_estimateGas",
                      params: [txParams]
                    });
                  case 6:
                    gas = _context8.sent;
                    return _context8.abrupt("return", gas);
                  case 8:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function estimateTxGas(_x3) {
            return _estimateTxGas.apply(this, arguments);
          }
          return estimateTxGas;
        }()
      }, {
        key: "analyzeGasUsage",
        value: function() {
          var _analyzeGasUsage = _asyncToGenerator(import_regenerator.default.mark(function _callee9(txMeta) {
            var block, blockGasLimitBN, saferGasLimitBN, estimatedGasHex;
            return import_regenerator.default.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return this.providerProxy.request({
                      method: "eth_getBlockByNumber",
                      params: ["latest", false]
                    });
                  case 2:
                    block = _context9.sent;
                    blockGasLimitBN = hexToBn(block.gasLimit);
                    saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
                    estimatedGasHex = bnToHex(saferGasLimitBN);
                    _context9.prev = 6;
                    _context9.next = 9;
                    return this.estimateTxGas(txMeta);
                  case 9:
                    estimatedGasHex = _context9.sent;
                    _context9.next = 15;
                    break;
                  case 12:
                    _context9.prev = 12;
                    _context9.t0 = _context9["catch"](6);
                    log.warn(_context9.t0);
                  case 15:
                    return _context9.abrupt("return", {
                      blockGasLimit: block.gasLimit,
                      estimatedGasHex
                    });
                  case 16:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this, [[6, 12]]);
          }));
          function analyzeGasUsage(_x4) {
            return _analyzeGasUsage.apply(this, arguments);
          }
          return analyzeGasUsage;
        }()
      }, {
        key: "addGasBuffer",
        value: function addGasBuffer(initialGasLimitHex, blockGasLimitHex) {
          var multiplier = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.5;
          var initialGasLimitBn = hexToBn(initialGasLimitHex);
          var blockGasLimitBn = hexToBn(blockGasLimitHex);
          var upperGasLimitBn = blockGasLimitBn.muln(0.9);
          var bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);
          if (initialGasLimitBn.gt(upperGasLimitBn))
            return bnToHex(initialGasLimitBn);
          if (bufferedGasLimitBn.lt(upperGasLimitBn))
            return bnToHex(bufferedGasLimitBn);
          return bnToHex(upperGasLimitBn);
        }
      }, {
        key: "determineTransactionCategory",
        value: function() {
          var _determineTransactionCategory = _asyncToGenerator(import_regenerator.default.mark(function _callee10(txParameters) {
            var data, to, code, txCategory, codeIsEmpty;
            return import_regenerator.default.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    data = txParameters.data, to = txParameters.to;
                    code = "";
                    if (!(data && !to)) {
                      _context10.next = 6;
                      break;
                    }
                    txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;
                    _context10.next = 17;
                    break;
                  case 6:
                    _context10.prev = 6;
                    _context10.next = 9;
                    return this.providerProxy.request({
                      method: "eth_getCode",
                      params: [to, "latest"]
                    });
                  case 9:
                    code = _context10.sent;
                    _context10.next = 15;
                    break;
                  case 12:
                    _context10.prev = 12;
                    _context10.t0 = _context10["catch"](6);
                    log.warn(_context10.t0);
                  case 15:
                    codeIsEmpty = !code || code === "0x" || code === "0x0";
                    txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;
                  case 17:
                    return _context10.abrupt("return", {
                      transactionCategory: txCategory,
                      code
                    });
                  case 18:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this, [[6, 12]]);
          }));
          function determineTransactionCategory(_x5) {
            return _determineTransactionCategory.apply(this, arguments);
          }
          return determineTransactionCategory;
        }()
      }, {
        key: "getDefaultGasLimit",
        value: function() {
          var _getDefaultGasLimit = _asyncToGenerator(import_regenerator.default.mark(function _callee11(txParams) {
            var _yield$this$determine, transactionCategory, TWENTY_ONE_THOUSAND, _yield$this$analyzeGa, blockGasLimit, estimatedGasHex, gasLimit;
            return import_regenerator.default.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this.determineTransactionCategory(_objectSpread$1({}, txParams));
                  case 2:
                    _yield$this$determine = _context11.sent;
                    transactionCategory = _yield$this$determine.transactionCategory;
                    if (!txParams.gas) {
                      _context11.next = 6;
                      break;
                    }
                    return _context11.abrupt("return", txParams.gas);
                  case 6:
                    if (!(txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER)) {
                      _context11.next = 11;
                      break;
                    }
                    if (!txParams.data) {
                      _context11.next = 9;
                      break;
                    }
                    throw Error("TxGasUtil - Trying to call a function on a non-contract address");
                  case 9:
                    TWENTY_ONE_THOUSAND = 21e3;
                    return _context11.abrupt("return", (0, import_util.addHexPrefix)(TWENTY_ONE_THOUSAND.toString(16)));
                  case 11:
                    _context11.next = 13;
                    return this.analyzeGasUsage(txParams);
                  case 13:
                    _yield$this$analyzeGa = _context11.sent;
                    blockGasLimit = _yield$this$analyzeGa.blockGasLimit;
                    estimatedGasHex = _yield$this$analyzeGa.estimatedGasHex;
                    gasLimit = this.addGasBuffer((0, import_util.addHexPrefix)(estimatedGasHex), blockGasLimit);
                    return _context11.abrupt("return", gasLimit);
                  case 18:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function getDefaultGasLimit(_x6) {
            return _getDefaultGasLimit.apply(this, arguments);
          }
          return getDefaultGasLimit;
        }()
      }]);
      return TransactionFormatter2;
    }();
    EthereumPrivateKeyProvider = function(_BaseProvider) {
      _inherits(EthereumPrivateKeyProvider2, _BaseProvider);
      var _super = _createSuper(EthereumPrivateKeyProvider2);
      function EthereumPrivateKeyProvider2(_ref) {
        var config = _ref.config, state = _ref.state;
        _classCallCheck(this, EthereumPrivateKeyProvider2);
        return _super.call(this, {
          config: {
            chainConfig: _objectSpread2(_objectSpread2({}, config.chainConfig), {}, {
              chainNamespace: CHAIN_NAMESPACES.EIP155
            })
          },
          state
        });
      }
      _createClass(EthereumPrivateKeyProvider2, [{
        key: "enable",
        value: function() {
          var _enable = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.state.privateKey) {
                      _context.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Private key is not found in state, plz pass it in constructor state param",
                      code: 4902
                    });
                  case 2:
                    _context.next = 4;
                    return this.setupProvider(this.state.privateKey);
                  case 4:
                    return _context.abrupt("return", this._providerEngineProxy.request({
                      method: "eth_accounts"
                    }));
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function enable() {
            return _enable.apply(this, arguments);
          }
          return enable;
        }()
      }, {
        key: "setupProvider",
        value: function() {
          var _setupProvider = _asyncToGenerator(import_regenerator.default.mark(function _callee2(privKey) {
            var txFormatter, providerHandlers, ethMiddleware, chainSwitchMiddleware, engine, _createJsonRpcClient, networkMiddleware, provider;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    txFormatter = new TransactionFormatter({
                      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
                    });
                    providerHandlers = getProviderHandlers({
                      txFormatter,
                      privKey,
                      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
                    });
                    ethMiddleware = createEthMiddleware(providerHandlers);
                    chainSwitchMiddleware = this.getChainSwitchMiddleware();
                    engine = new JRPCEngine();
                    _createJsonRpcClient = createJsonRpcClient(this.config.chainConfig), networkMiddleware = _createJsonRpcClient.networkMiddleware;
                    engine.push(ethMiddleware);
                    engine.push(chainSwitchMiddleware);
                    engine.push(this.getAccountMiddleware());
                    engine.push(networkMiddleware);
                    provider = providerFromEngine(engine);
                    this.updateProviderEngineProxy(provider);
                    _context2.next = 14;
                    return txFormatter.init();
                  case 14:
                    _context2.next = 16;
                    return this.lookupNetwork();
                  case 16:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function setupProvider(_x) {
            return _setupProvider.apply(this, arguments);
          }
          return setupProvider;
        }()
      }, {
        key: "updateAccount",
        value: function() {
          var _updateAccount = _asyncToGenerator(import_regenerator.default.mark(function _callee3(params) {
            var existingKey;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (this._providerEngineProxy) {
                      _context3.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 2:
                    _context3.next = 4;
                    return this._providerEngineProxy.request({
                      method: "eth_private_key"
                    });
                  case 4:
                    existingKey = _context3.sent;
                    if (!(existingKey !== params.privateKey)) {
                      _context3.next = 14;
                      break;
                    }
                    _context3.next = 8;
                    return this.setupProvider(params.privateKey);
                  case 8:
                    _context3.t0 = this._providerEngineProxy;
                    _context3.next = 11;
                    return this._providerEngineProxy.request({
                      method: "eth_accounts"
                    });
                  case 11:
                    _context3.t1 = _context3.sent;
                    _context3.t2 = {
                      accounts: _context3.t1
                    };
                    _context3.t0.emit.call(_context3.t0, "accountsChanged", _context3.t2);
                  case 14:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function updateAccount(_x2) {
            return _updateAccount.apply(this, arguments);
          }
          return updateAccount;
        }()
      }, {
        key: "switchChain",
        value: function() {
          var _switchChain = _asyncToGenerator(import_regenerator.default.mark(function _callee4(params) {
            var chainConfig, privKey;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this._providerEngineProxy) {
                      _context4.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 2:
                    chainConfig = this.getChainConfig(params.chainId);
                    this.update({
                      chainId: "loading"
                    });
                    this.configure({
                      chainConfig
                    });
                    _context4.next = 7;
                    return this._providerEngineProxy.request({
                      method: "eth_private_key"
                    });
                  case 7:
                    privKey = _context4.sent;
                    _context4.next = 10;
                    return this.setupProvider(privKey);
                  case 10:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function switchChain(_x3) {
            return _switchChain.apply(this, arguments);
          }
          return switchChain;
        }()
      }, {
        key: "lookupNetwork",
        value: function() {
          var _lookupNetwork = _asyncToGenerator(import_regenerator.default.mark(function _callee5() {
            var chainId, network;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (this._providerEngineProxy) {
                      _context5.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 2:
                    chainId = this.config.chainConfig.chainId;
                    if (chainId) {
                      _context5.next = 5;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("chainId is required while lookupNetwork");
                  case 5:
                    _context5.next = 7;
                    return this._providerEngineProxy.request({
                      method: "net_version",
                      params: []
                    });
                  case 7:
                    network = _context5.sent;
                    if (!(parseInt(chainId, 16) !== parseInt(network, 10))) {
                      _context5.next = 10;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.chainDisconnected("Invalid network, net_version is: ".concat(network));
                  case 10:
                    if (this.state.chainId !== chainId) {
                      this._providerEngineProxy.emit("chainChanged", chainId);
                      this._providerEngineProxy.emit("connect", {
                        chainId
                      });
                    }
                    this.update({
                      chainId
                    });
                    return _context5.abrupt("return", network);
                  case 13:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function lookupNetwork() {
            return _lookupNetwork.apply(this, arguments);
          }
          return lookupNetwork;
        }()
      }, {
        key: "getChainSwitchMiddleware",
        value: function getChainSwitchMiddleware() {
          var _this = this;
          var chainSwitchHandlers = {
            addChain: function() {
              var _addChain = _asyncToGenerator(import_regenerator.default.mark(function _callee6(params) {
                var chainId, chainName, rpcUrls, blockExplorerUrls, nativeCurrency;
                return import_regenerator.default.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        chainId = params.chainId, chainName = params.chainName, rpcUrls = params.rpcUrls, blockExplorerUrls = params.blockExplorerUrls, nativeCurrency = params.nativeCurrency;
                        _this.addChain({
                          chainNamespace: "eip155",
                          chainId,
                          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "ETH",
                          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Ether",
                          displayName: chainName,
                          rpcTarget: rpcUrls[0],
                          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || ""
                        });
                      case 2:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));
              function addChain(_x4) {
                return _addChain.apply(this, arguments);
              }
              return addChain;
            }(),
            switchChain: function() {
              var _switchChain2 = _asyncToGenerator(import_regenerator.default.mark(function _callee7(params) {
                var chainId;
                return import_regenerator.default.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        chainId = params.chainId;
                        _context7.next = 3;
                        return _this.switchChain({
                          chainId
                        });
                      case 3:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));
              function switchChain(_x5) {
                return _switchChain2.apply(this, arguments);
              }
              return switchChain;
            }()
          };
          var chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
          return chainSwitchMiddleware;
        }
      }, {
        key: "getAccountMiddleware",
        value: function getAccountMiddleware() {
          var _this2 = this;
          var accountHandlers = {
            updatePrivatekey: function() {
              var _updatePrivatekey = _asyncToGenerator(import_regenerator.default.mark(function _callee8(params) {
                var privateKey;
                return import_regenerator.default.wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        privateKey = params.privateKey;
                        _context8.next = 3;
                        return _this2.updateAccount({
                          privateKey
                        });
                      case 3:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8);
              }));
              function updatePrivatekey(_x6) {
                return _updatePrivatekey.apply(this, arguments);
              }
              return updatePrivatekey;
            }()
          };
          return createAccountMiddleware(accountHandlers);
        }
      }]);
      return EthereumPrivateKeyProvider2;
    }(BaseProvider);
    _defineProperty(EthereumPrivateKeyProvider, "getProviderInstance", function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(params) {
        var providerFactory;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                providerFactory = new EthereumPrivateKeyProvider({
                  config: {
                    chainConfig: params.chainConfig
                  }
                });
                _context9.next = 3;
                return providerFactory.setupProvider(params.privKey);
              case 3:
                return _context9.abrupt("return", providerFactory);
              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      return function(_x7) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
});

export {
  WalletConnectProvider,
  getProviderHandlers,
  TransactionFormatter,
  EthereumPrivateKeyProvider,
  init_ethereumProvider_esm
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)
*/
//# sourceMappingURL=chunk-B2MYMUV7.js.map
