import {
  require_browser,
  require_buffer,
  require_elliptic,
  require_events,
  require_js,
  require_lodash,
  require_readable_browser,
  require_util2 as require_util
} from "./chunk-3CFYJ5LS.js";
import {
  require_crypto
} from "./chunk-EG7FL5OY.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __export,
  __toESM,
  init_buffer,
  init_process,
  process
} from "./chunk-ARAA7IXG.js";

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value2 = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value2);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_process();
    init_buffer();
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_process();
    init_buffer();
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_process();
    init_buffer();
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
    o3.__proto__ = p2;
    return o3;
  };
  return _setPrototypeOf(o2, p);
}
var init_setPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_process();
    init_buffer();
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_process();
    init_buffer();
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value2) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_process();
    init_buffer();
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    init_process();
    init_buffer();
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(obj);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    init_process();
    init_buffer();
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime5() {
      "use strict";
      module.exports = _regeneratorRuntime5 = function _regeneratorRuntime6() {
        return exports2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value2) {
        return Object.defineProperty(obj, key, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function define3(obj, key, value2) {
          return obj[key] = value2;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value2 = result.value;
            return value2 && "object" == _typeof2(value2) && hasOwn.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
              invoke("next", value3, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value2(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              for (; ++i2 < iterable.length; )
                if (hasOwn.call(iterable, i2))
                  return next2.value = iterable[i2], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
        return this;
      }), define2(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type6, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type6 || "continue" === type6) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type6, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    module.exports = _regeneratorRuntime5, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    init_process();
    init_buffer();
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
var init_superPropBase = __esm({
  "node_modules/@babel/runtime/helpers/esm/superPropBase.js"() {
    init_process();
    init_buffer();
    init_getPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var init_get = __esm({
  "node_modules/@babel/runtime/helpers/esm/get.js"() {
    init_process();
    init_buffer();
    init_superPropBase();
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
var init_isNativeFunction = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var init_isNativeReflectConstruct = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
var init_construct = __esm({
  "node_modules/@babel/runtime/helpers/esm/construct.js"() {
    init_process();
    init_buffer();
    init_setPrototypeOf();
    init_isNativeReflectConstruct();
  }
});

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var init_wrapNativeSuper = __esm({
  "node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js"() {
    init_process();
    init_buffer();
    init_getPrototypeOf();
    init_setPrototypeOf();
    init_isNativeFunction();
    init_construct();
  }
});

// node_modules/base64url/dist/pad-string.js
var require_pad_string = __commonJS({
  "node_modules/base64url/dist/pad-string.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
        return input;
      }
      var position = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer = Buffer.alloc(paddedStringLength);
      buffer.write(input);
      while (padLength--) {
        buffer.write("=", position++);
      }
      return buffer.toString();
    }
    exports.default = padString;
  }
});

// node_modules/base64url/dist/base64url.js
var require_base64url = __commonJS({
  "node_modules/base64url/dist/base64url.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var pad_string_1 = require_pad_string();
    function encode3(input, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
    }
    function decode3(base64url3, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(toBase64(base64url3), "base64").toString(encoding);
    }
    function toBase64(base64url3) {
      base64url3 = base64url3.toString();
      return pad_string_1.default(base64url3).replace(/\-/g, "+").replace(/_/g, "/");
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBuffer(base64url3) {
      return Buffer.from(toBase64(base64url3), "base64");
    }
    var base64url2 = encode3;
    base64url2.encode = encode3;
    base64url2.decode = decode3;
    base64url2.toBase64 = toBase64;
    base64url2.fromBase64 = fromBase64;
    base64url2.toBuffer = toBuffer;
    exports.default = base64url2;
  }
});

// node_modules/base64url/index.js
var require_base64url2 = __commonJS({
  "node_modules/base64url/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_base64url().default;
    module.exports.default = module.exports;
  }
});

// node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function safeatob(str) {
  return base64url.decode(str);
}
function jsonToBase64(json) {
  return base64url.encode(JSON.stringify(json));
}
var import_randombytes, import_base64url, import_keccak, randomId, URLWithHashParams, base64url, keccak;
var init_openloginUtils_esm = __esm({
  "node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js"() {
    init_process();
    init_buffer();
    import_randombytes = __toESM(require_browser());
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_wrapNativeSuper();
    init_defineProperty();
    import_base64url = __toESM(require_base64url2());
    import_keccak = __toESM(require_js());
    randomId = function randomId2() {
      return (0, import_randombytes.default)(32).toString("hex");
    };
    URLWithHashParams = function(_URL) {
      _inherits(URLWithHashParams2, _URL);
      var _super = _createSuper(URLWithHashParams2);
      function URLWithHashParams2() {
        var _this;
        _classCallCheck(this, URLWithHashParams2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "hashParams", new URLSearchParams());
        return _this;
      }
      _createClass(URLWithHashParams2, [{
        key: "toString",
        value: function toString2() {
          this.hash = this.hashParams.toString();
          return _get(_getPrototypeOf(URLWithHashParams2.prototype), "toString", this).call(this);
        }
      }]);
      return URLWithHashParams2;
    }(_wrapNativeSuper(URL));
    base64url = import_base64url.default;
    keccak = import_keccak.default;
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = stringify4;
    stringify4.default = stringify4;
    stringify4.stable = deterministicStringify;
    stringify4.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify4(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i2;
      if (typeof val === "object" && val !== null) {
        for (i2 = 0; i2 < stack.length; i2++) {
          if (stack[i2] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i2 = 0; i2 < val.length; i2++) {
            decirc(val[i2], i2, i2, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            decirc(val[key], key, i2, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i2;
      if (typeof val === "object" && val !== null) {
        for (i2 = 0; i2 < stack.length; i2++) {
          if (stack[i2] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i2 = 0; i2 < val.length; i2++) {
            deterministicDecirc(val[i2], i2, i2, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            deterministicDecirc(val[key], key, i2, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i2 = 0; i2 < replacerStack.length; i2++) {
            var part = replacerStack[i2];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i2, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i2) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i2) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_process();
    init_buffer();
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_process();
    init_buffer();
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_, value2) {
      if (value2 === "[Circular]") {
        return void 0;
      }
      return value2;
    }
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError4(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError4;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    init_process();
    init_buffer();
    var wrappy = require_wrappy();
    module.exports = wrappy(once3);
    module.exports.strict = wrappy(onceStrict);
    once3.proto = once3(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once3(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once3(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    init_process();
    init_buffer();
    var once3 = require_once();
    var noop2 = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos3 = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos3(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once3(callback || noop2);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos3;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports, module) {
    init_process();
    init_buffer();
    var once3 = require_once();
    var eos3 = require_end_of_stream();
    var fs = require_fs();
    var noop2 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop2) || stream instanceof (fs.WriteStream || noop2)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos3(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop2);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump3 = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop2) && streams.pop() || noop2;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i2) {
        var reading = i2 < streams.length - 1;
        var writing = i2 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module.exports = pump3;
  }
});

// node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function noop() {
  return void 0;
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    setTimeout(function() {
      throw err;
    });
  }
}
function arrayClone(arr) {
  var n2 = arr.length;
  var copy = new Array(n2);
  for (var i2 = 0; i2 < n2; i2 += 1) {
    copy[i2] = arr[i2];
  }
  return copy;
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function createStreamMiddleware() {
  var idMap = {};
  function readNoop() {
    return false;
  }
  var events = new SafeEventEmitter();
  function processResponse(res) {
    var context = idMap[res.id];
    if (!context) {
      throw new Error('StreamMiddleware - Unknown response id "'.concat(res.id, '"'));
    }
    delete idMap[res.id];
    Object.assign(context.res, res);
    setTimeout(context.end);
  }
  function processNotification(res) {
    events.emit("notification", res);
  }
  function processMessage(res, _encoding, cb) {
    var err;
    try {
      var isNotification = !res.id;
      if (isNotification) {
        processNotification(res);
      } else {
        processResponse(res);
      }
    } catch (_err) {
      err = _err;
    }
    cb(err);
  }
  var stream = new import_readable_stream.Duplex({
    objectMode: true,
    read: readNoop,
    write: processMessage
  });
  var middleware = function middleware2(req, res, next, end) {
    stream.push(req);
    idMap[req.id] = {
      req,
      res,
      next,
      end
    };
  };
  return {
    events,
    middleware,
    stream
  };
}
function createScaffoldMiddleware(handlers) {
  return function(req, res, next, end) {
    var handler = handlers[req.method];
    if (handler === void 0) {
      return next();
    }
    if (typeof handler === "function") {
      return handler(req, res, next, end);
    }
    res.result = handler;
    return end();
  };
}
function createIdRemapMiddleware() {
  return function(req, res, next, _end) {
    var originalId = req.id;
    var newId = randomId();
    req.id = newId;
    res.id = newId;
    next(function(done) {
      req.id = originalId;
      res.id = originalId;
      done();
    });
  };
}
function createAsyncMiddleware(asyncMiddleware) {
  return function() {
    var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res, next, end) {
      var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              nextPromise = new Promise(function(resolve) {
                resolveNextPromise = resolve;
              });
              returnHandlerCallback = null;
              nextWasCalled = false;
              asyncNext = function() {
                var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
                  return import_regenerator.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          nextWasCalled = true;
                          next(function(runReturnHandlersCallback) {
                            returnHandlerCallback = runReturnHandlersCallback;
                            resolveNextPromise();
                          });
                          _context.next = 4;
                          return nextPromise;
                        case 4:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));
                return function asyncNext2() {
                  return _ref2.apply(this, arguments);
                };
              }();
              _context2.prev = 4;
              _context2.next = 7;
              return asyncMiddleware(req, res, asyncNext);
            case 7:
              if (!nextWasCalled) {
                _context2.next = 13;
                break;
              }
              _context2.next = 10;
              return nextPromise;
            case 10:
              returnHandlerCallback(null);
              _context2.next = 14;
              break;
            case 13:
              end(null);
            case 14:
              _context2.next = 19;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](4);
              if (returnHandlerCallback) {
                returnHandlerCallback(_context2.t0);
              } else {
                end(_context2.t0);
              }
            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[4, 16]]);
    }));
    return function(_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o2);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray2(o2, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function mergeMiddleware(middlewareStack) {
  var engine = new JRPCEngine();
  middlewareStack.forEach(function(middleware) {
    return engine.push(middleware);
  });
  return engine.asMiddleware();
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function anyStreamEnd(stream, _cb) {
  var cb = (0, import_once.default)(_cb);
  (0, import_end_of_stream.default)(stream, {
    readable: false
  }, cb);
  (0, import_end_of_stream.default)(stream, {
    writable: false
  }, cb);
}
function setupMultiplex(stream) {
  var mux = new ObjectMultiplex();
  mux.getStream = function streamHelper(name) {
    if (this._substreams[name]) {
      return this._substreams[name];
    }
    return this.createStream(name);
  };
  (0, import_pump.default)(stream, mux, stream, function(err) {
    if (err)
      window.console.error(err);
  });
  return mux;
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var import_readable_stream, import_regenerator, import_events, import_fast_safe_stringify, import_eth_rpc_errors, import_end_of_stream, import_once, import_pump, SYN, ACK, BRK, BasePostMessageStream, SafeEventEmitter, SerializableError, getRpcPromiseCallback, JRPCEngine, Substream, IGNORE_SUBSTREAM, ObjectMultiplex, PostMessageStream;
var init_openloginJrpc_esm = __esm({
  "node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js"() {
    init_process();
    init_buffer();
    init_typeof();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_readable_stream = __toESM(require_readable_browser());
    init_asyncToGenerator();
    import_regenerator = __toESM(require_regenerator());
    init_openloginUtils_esm();
    import_events = __toESM(require_events());
    init_wrapNativeSuper();
    import_fast_safe_stringify = __toESM(require_fast_safe_stringify());
    init_slicedToArray();
    import_eth_rpc_errors = __toESM(require_dist());
    import_end_of_stream = __toESM(require_end_of_stream());
    import_once = __toESM(require_once());
    import_pump = __toESM(require_pump());
    SYN = "SYN";
    ACK = "ACK";
    BRK = "BRK";
    BasePostMessageStream = function(_Duplex) {
      _inherits(BasePostMessageStream2, _Duplex);
      var _super = _createSuper$6(BasePostMessageStream2);
      function BasePostMessageStream2(_ref) {
        var _this;
        var name = _ref.name, target = _ref.target, _ref$targetWindow = _ref.targetWindow, targetWindow = _ref$targetWindow === void 0 ? window : _ref$targetWindow, _ref$targetOrigin = _ref.targetOrigin, targetOrigin = _ref$targetOrigin === void 0 ? "*" : _ref$targetOrigin;
        _classCallCheck(this, BasePostMessageStream2);
        _this = _super.call(this, {
          objectMode: true
        });
        _defineProperty(_assertThisInitialized(_this), "_init", void 0);
        _defineProperty(_assertThisInitialized(_this), "_haveSyn", void 0);
        _defineProperty(_assertThisInitialized(_this), "_name", void 0);
        _defineProperty(_assertThisInitialized(_this), "_target", void 0);
        _defineProperty(_assertThisInitialized(_this), "_targetWindow", void 0);
        _defineProperty(_assertThisInitialized(_this), "_targetOrigin", void 0);
        _defineProperty(_assertThisInitialized(_this), "_onMessage", void 0);
        _defineProperty(_assertThisInitialized(_this), "_synIntervalId", void 0);
        if (!name || !target) {
          throw new Error("Invalid input.");
        }
        _this._init = false;
        _this._haveSyn = false;
        _this._name = name;
        _this._target = target;
        _this._targetWindow = targetWindow;
        _this._targetOrigin = targetOrigin;
        _this._onMessage = _this.onMessage.bind(_assertThisInitialized(_this));
        _this._synIntervalId = null;
        window.addEventListener("message", _this._onMessage, false);
        _this._handShake();
        return _this;
      }
      _createClass(BasePostMessageStream2, [{
        key: "_break",
        value: function _break() {
          this.cork();
          this._write(BRK, null, noop);
          this._haveSyn = false;
          this._init = false;
        }
      }, {
        key: "_handShake",
        value: function _handShake() {
          this._write(SYN, null, noop);
          this.cork();
        }
      }, {
        key: "_onData",
        value: function _onData(data) {
          if (!this._init) {
            if (data === SYN) {
              this._haveSyn = true;
              this._write(ACK, null, noop);
            } else if (data === ACK) {
              this._init = true;
              if (!this._haveSyn) {
                this._write(ACK, null, noop);
              }
              this.uncork();
            }
          } else if (data === BRK) {
            this._break();
          } else {
            try {
              this.push(data);
            } catch (err) {
              this.emit("error", err);
            }
          }
        }
      }, {
        key: "_postMessage",
        value: function _postMessage(data) {
          var originConstraint = this._targetOrigin;
          this._targetWindow.postMessage({
            target: this._target,
            data
          }, originConstraint);
        }
      }, {
        key: "onMessage",
        value: function onMessage6(event) {
          var message = event.data;
          if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || _typeof(message) !== "object" || message.target !== this._name || !message.data) {
            return;
          }
          this._onData(message.data);
        }
      }, {
        key: "_read",
        value: function _read() {
          return void 0;
        }
      }, {
        key: "_write",
        value: function _write(data, _, cb) {
          this._postMessage(data);
          cb();
        }
      }, {
        key: "_destroy",
        value: function _destroy() {
          window.removeEventListener("message", this._onMessage, false);
        }
      }]);
      return BasePostMessageStream2;
    }(import_readable_stream.Duplex);
    SafeEventEmitter = function(_EventEmitter) {
      _inherits(SafeEventEmitter3, _EventEmitter);
      var _super = _createSuper$5(SafeEventEmitter3);
      function SafeEventEmitter3() {
        _classCallCheck(this, SafeEventEmitter3);
        return _super.apply(this, arguments);
      }
      _createClass(SafeEventEmitter3, [{
        key: "emit",
        value: function emit(type6) {
          var doError = type6 === "error";
          var events = this._events;
          if (events !== void 0) {
            doError = doError && events.error === void 0;
          } else if (!doError) {
            return false;
          }
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (doError) {
            var er;
            if (args.length > 0) {
              er = args[0];
            }
            if (er instanceof Error) {
              throw er;
            }
            var err = new Error("Unhandled error.".concat(er ? " (".concat(er.message, ")") : ""));
            err.context = er;
            throw err;
          }
          var handler = events[type6];
          if (handler === void 0) {
            return false;
          }
          if (typeof handler === "function") {
            safeApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler);
            for (var i2 = 0; i2 < len; i2 += 1) {
              safeApply(listeners[i2], this, args);
            }
          }
          return true;
        }
      }]);
      return SafeEventEmitter3;
    }(import_events.EventEmitter);
    SerializableError = function(_Error) {
      _inherits(SerializableError2, _Error);
      var _super = _createSuper$4(SerializableError2);
      function SerializableError2(_ref) {
        var _this;
        var code = _ref.code, message = _ref.message, data = _ref.data;
        _classCallCheck(this, SerializableError2);
        if (!Number.isInteger(code)) {
          throw new Error("code must be an integer");
        }
        if (!message || typeof message !== "string") {
          throw new Error("message must be string");
        }
        _this = _super.call(this, message);
        _defineProperty(_assertThisInitialized(_this), "code", void 0);
        _defineProperty(_assertThisInitialized(_this), "data", void 0);
        _this.code = code;
        if (data !== void 0) {
          _this.data = data;
        }
        return _this;
      }
      _createClass(SerializableError2, [{
        key: "toString",
        value: function toString2() {
          return (0, import_fast_safe_stringify.default)({
            code: this.code,
            message: this.message,
            data: this.data,
            stack: this.stack
          });
        }
      }]);
      return SerializableError2;
    }(_wrapNativeSuper(Error));
    getRpcPromiseCallback = function getRpcPromiseCallback2(resolve, reject) {
      var unwrapResult = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      return function(error, response) {
        if (error || response.error) {
          reject(error || response.error);
        } else if (!unwrapResult || Array.isArray(response)) {
          resolve(response);
        } else {
          resolve(response.result);
        }
      };
    };
    JRPCEngine = function(_SafeEventEmitter) {
      _inherits(JRPCEngine3, _SafeEventEmitter);
      var _super = _createSuper$3(JRPCEngine3);
      function JRPCEngine3() {
        var _this;
        _classCallCheck(this, JRPCEngine3);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "_middleware", void 0);
        _this._middleware = [];
        return _this;
      }
      _createClass(JRPCEngine3, [{
        key: "push",
        value: (
          /**
           * Add a middleware function to the engine's middleware stack.
           *
           * @param middleware - The middleware function to add.
           */
          function push(middleware) {
            this._middleware.push(middleware);
          }
        )
      }, {
        key: "handle",
        value: function handle(req, cb) {
          if (cb && typeof cb !== "function") {
            throw new Error('"callback" must be a function if provided.');
          }
          if (Array.isArray(req)) {
            if (cb) {
              return this._handleBatch(req, cb);
            }
            return this._handleBatch(req);
          }
          if (cb) {
            return this._handle(req, cb);
          }
          return this._promiseHandle(req);
        }
        /**
         * Returns this engine as a middleware function that can be pushed to other
         * engines.
         *
         * @returns This engine as a middleware function.
         */
      }, {
        key: "asMiddleware",
        value: function asMiddleware() {
          var _this2 = this;
          return function() {
            var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res, next, end) {
              var _yield$JRPCEngine$_ru, _yield$JRPCEngine$_ru2, middlewareError, isComplete, returnHandlers;
              return import_regenerator.default.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.prev = 0;
                      _context2.next = 3;
                      return JRPCEngine3._runAllMiddleware(req, res, _this2._middleware);
                    case 3:
                      _yield$JRPCEngine$_ru = _context2.sent;
                      _yield$JRPCEngine$_ru2 = _slicedToArray(_yield$JRPCEngine$_ru, 3);
                      middlewareError = _yield$JRPCEngine$_ru2[0];
                      isComplete = _yield$JRPCEngine$_ru2[1];
                      returnHandlers = _yield$JRPCEngine$_ru2[2];
                      if (!isComplete) {
                        _context2.next = 12;
                        break;
                      }
                      _context2.next = 11;
                      return JRPCEngine3._runReturnHandlers(returnHandlers);
                    case 11:
                      return _context2.abrupt("return", end(middlewareError));
                    case 12:
                      return _context2.abrupt("return", next(function() {
                        var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee(handlerCallback) {
                          return import_regenerator.default.wrap(function _callee$(_context) {
                            while (1) {
                              switch (_context.prev = _context.next) {
                                case 0:
                                  _context.prev = 0;
                                  _context.next = 3;
                                  return JRPCEngine3._runReturnHandlers(returnHandlers);
                                case 3:
                                  _context.next = 8;
                                  break;
                                case 5:
                                  _context.prev = 5;
                                  _context.t0 = _context["catch"](0);
                                  return _context.abrupt("return", handlerCallback(_context.t0));
                                case 8:
                                  return _context.abrupt("return", handlerCallback());
                                case 9:
                                case "end":
                                  return _context.stop();
                              }
                            }
                          }, _callee, null, [[0, 5]]);
                        }));
                        return function(_x5) {
                          return _ref2.apply(this, arguments);
                        };
                      }()));
                    case 15:
                      _context2.prev = 15;
                      _context2.t0 = _context2["catch"](0);
                      return _context2.abrupt("return", end(_context2.t0));
                    case 18:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, null, [[0, 15]]);
            }));
            return function(_x, _x2, _x3, _x4) {
              return _ref.apply(this, arguments);
            };
          }();
        }
      }, {
        key: "_handleBatch",
        value: function() {
          var _handleBatch2 = _asyncToGenerator(import_regenerator.default.mark(function _callee3(reqs, cb) {
            var responses;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.prev = 0;
                    _context3.next = 3;
                    return Promise.all(
                      // 1. Begin executing each request in the order received
                      reqs.map(this._promiseHandle.bind(this))
                    );
                  case 3:
                    responses = _context3.sent;
                    if (!cb) {
                      _context3.next = 6;
                      break;
                    }
                    return _context3.abrupt("return", cb(null, responses));
                  case 6:
                    return _context3.abrupt("return", responses);
                  case 9:
                    _context3.prev = 9;
                    _context3.t0 = _context3["catch"](0);
                    if (!cb) {
                      _context3.next = 13;
                      break;
                    }
                    return _context3.abrupt("return", cb(_context3.t0));
                  case 13:
                    throw _context3.t0;
                  case 14:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[0, 9]]);
          }));
          function _handleBatch(_x6, _x7) {
            return _handleBatch2.apply(this, arguments);
          }
          return _handleBatch;
        }()
        /**
         * A promise-wrapped _handle.
         */
      }, {
        key: "_promiseHandle",
        value: function _promiseHandle(req) {
          var _this3 = this;
          return new Promise(function(resolve) {
            _this3._handle(req, function(_err, res) {
              resolve(res);
            });
          });
        }
        /**
         * Ensures that the request object is valid, processes it, and passes any
         * error and the response object to the given callback.
         *
         * Does not reject.
         */
      }, {
        key: "_handle",
        value: function() {
          var _handle2 = _asyncToGenerator(import_regenerator.default.mark(function _callee4(callerReq, cb) {
            var _error2, _error3, req, res, error;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(!callerReq || Array.isArray(callerReq) || _typeof(callerReq) !== "object")) {
                      _context4.next = 3;
                      break;
                    }
                    _error2 = new SerializableError({
                      code: -32603,
                      message: "request must be plain object"
                    });
                    return _context4.abrupt("return", cb(_error2, {
                      id: void 0,
                      jsonrpc: "2.0",
                      error: _error2
                    }));
                  case 3:
                    if (!(typeof callerReq.method !== "string")) {
                      _context4.next = 6;
                      break;
                    }
                    _error3 = new SerializableError({
                      code: -32603,
                      message: "method must be string"
                    });
                    return _context4.abrupt("return", cb(_error3, {
                      id: callerReq.id,
                      jsonrpc: "2.0",
                      error: _error3
                    }));
                  case 6:
                    req = _objectSpread$1({}, callerReq);
                    res = {
                      id: req.id,
                      jsonrpc: req.jsonrpc
                    };
                    error = null;
                    _context4.prev = 9;
                    _context4.next = 12;
                    return this._processRequest(req, res);
                  case 12:
                    _context4.next = 17;
                    break;
                  case 14:
                    _context4.prev = 14;
                    _context4.t0 = _context4["catch"](9);
                    error = _context4.t0;
                  case 17:
                    if (error) {
                      delete res.result;
                      if (!res.error) {
                        res.error = (0, import_eth_rpc_errors.serializeError)(error);
                      }
                    }
                    return _context4.abrupt("return", cb(error, res));
                  case 19:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[9, 14]]);
          }));
          function _handle(_x8, _x9) {
            return _handle2.apply(this, arguments);
          }
          return _handle;
        }()
        /**
         * For the given request and response, runs all middleware and their return
         * handlers, if any, and ensures that internal request processing semantics
         * are satisfied.
         */
      }, {
        key: "_processRequest",
        value: function() {
          var _processRequest2 = _asyncToGenerator(import_regenerator.default.mark(function _callee5(req, res) {
            var _yield$JRPCEngine$_ru3, _yield$JRPCEngine$_ru4, error, isComplete, returnHandlers;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return JRPCEngine3._runAllMiddleware(req, res, this._middleware);
                  case 2:
                    _yield$JRPCEngine$_ru3 = _context5.sent;
                    _yield$JRPCEngine$_ru4 = _slicedToArray(_yield$JRPCEngine$_ru3, 3);
                    error = _yield$JRPCEngine$_ru4[0];
                    isComplete = _yield$JRPCEngine$_ru4[1];
                    returnHandlers = _yield$JRPCEngine$_ru4[2];
                    JRPCEngine3._checkForCompletion(req, res, isComplete);
                    _context5.next = 10;
                    return JRPCEngine3._runReturnHandlers(returnHandlers);
                  case 10:
                    if (!error) {
                      _context5.next = 12;
                      break;
                    }
                    throw error;
                  case 12:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function _processRequest(_x10, _x11) {
            return _processRequest2.apply(this, arguments);
          }
          return _processRequest;
        }()
      }], [{
        key: "_runAllMiddleware",
        value: function() {
          var _runAllMiddleware2 = _asyncToGenerator(import_regenerator.default.mark(function _callee6(req, res, middlewareStack) {
            var returnHandlers, error, isComplete, _iterator, _step, middleware, _yield$JRPCEngine$_ru5, _yield$JRPCEngine$_ru6;
            return import_regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    returnHandlers = [];
                    error = null;
                    isComplete = false;
                    _iterator = _createForOfIteratorHelper(middlewareStack);
                    _context6.prev = 4;
                    _iterator.s();
                  case 6:
                    if ((_step = _iterator.n()).done) {
                      _context6.next = 18;
                      break;
                    }
                    middleware = _step.value;
                    _context6.next = 10;
                    return JRPCEngine3._runMiddleware(req, res, middleware, returnHandlers);
                  case 10:
                    _yield$JRPCEngine$_ru5 = _context6.sent;
                    _yield$JRPCEngine$_ru6 = _slicedToArray(_yield$JRPCEngine$_ru5, 2);
                    error = _yield$JRPCEngine$_ru6[0];
                    isComplete = _yield$JRPCEngine$_ru6[1];
                    if (!isComplete) {
                      _context6.next = 16;
                      break;
                    }
                    return _context6.abrupt("break", 18);
                  case 16:
                    _context6.next = 6;
                    break;
                  case 18:
                    _context6.next = 23;
                    break;
                  case 20:
                    _context6.prev = 20;
                    _context6.t0 = _context6["catch"](4);
                    _iterator.e(_context6.t0);
                  case 23:
                    _context6.prev = 23;
                    _iterator.f();
                    return _context6.finish(23);
                  case 26:
                    return _context6.abrupt("return", [error, isComplete, returnHandlers.reverse()]);
                  case 27:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, null, [[4, 20, 23, 26]]);
          }));
          function _runAllMiddleware(_x12, _x13, _x14) {
            return _runAllMiddleware2.apply(this, arguments);
          }
          return _runAllMiddleware;
        }()
        /**
         * Runs an individual middleware.
         *
         * @returns An array of any error encountered during middleware exection,
         * and a boolean indicating whether the request should end.
         */
      }, {
        key: "_runMiddleware",
        value: function _runMiddleware(req, res, middleware, returnHandlers) {
          return new Promise(function(resolve) {
            var end = function end2(err) {
              var error = err || res.error;
              if (error) {
                res.error = (0, import_eth_rpc_errors.serializeError)(error);
              }
              resolve([error, true]);
            };
            var next = function next2(returnHandler) {
              if (res.error) {
                end(res.error);
              } else {
                if (returnHandler) {
                  if (typeof returnHandler !== "function") {
                    end(new SerializableError({
                      code: -32603,
                      message: "JRPCEngine: 'next' return handlers must be functions"
                    }));
                  }
                  returnHandlers.push(returnHandler);
                }
                resolve([null, false]);
              }
            };
            try {
              middleware(req, res, next, end);
            } catch (error) {
              end(error);
            }
          });
        }
        /**
         * Serially executes array of return handlers. The request and response are
         * assumed to be in their scope.
         */
      }, {
        key: "_runReturnHandlers",
        value: function() {
          var _runReturnHandlers2 = _asyncToGenerator(import_regenerator.default.mark(function _callee7(handlers) {
            var _iterator2, _step2, _loop;
            return import_regenerator.default.wrap(function _callee7$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _iterator2 = _createForOfIteratorHelper(handlers);
                    _context8.prev = 1;
                    _loop = import_regenerator.default.mark(function _loop2() {
                      var handler;
                      return import_regenerator.default.wrap(function _loop$(_context7) {
                        while (1) {
                          switch (_context7.prev = _context7.next) {
                            case 0:
                              handler = _step2.value;
                              _context7.next = 3;
                              return new Promise(function(resolve, reject) {
                                handler(function(err) {
                                  return err ? reject(err) : resolve();
                                });
                              });
                            case 3:
                            case "end":
                              return _context7.stop();
                          }
                        }
                      }, _loop2);
                    });
                    _iterator2.s();
                  case 4:
                    if ((_step2 = _iterator2.n()).done) {
                      _context8.next = 8;
                      break;
                    }
                    return _context8.delegateYield(_loop(), "t0", 6);
                  case 6:
                    _context8.next = 4;
                    break;
                  case 8:
                    _context8.next = 13;
                    break;
                  case 10:
                    _context8.prev = 10;
                    _context8.t1 = _context8["catch"](1);
                    _iterator2.e(_context8.t1);
                  case 13:
                    _context8.prev = 13;
                    _iterator2.f();
                    return _context8.finish(13);
                  case 16:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee7, null, [[1, 10, 13, 16]]);
          }));
          function _runReturnHandlers(_x15) {
            return _runReturnHandlers2.apply(this, arguments);
          }
          return _runReturnHandlers;
        }()
        /**
         * Throws an error if the response has neither a result nor an error, or if
         * the "isComplete" flag is falsy.
         */
      }, {
        key: "_checkForCompletion",
        value: function _checkForCompletion(req, res, isComplete) {
          if (!("result" in res) && !("error" in res)) {
            throw new SerializableError({
              code: -32603,
              message: "Response has no error or result for request"
            });
          }
          if (!isComplete) {
            throw new SerializableError({
              code: -32603,
              message: "Nothing ended request"
            });
          }
        }
      }]);
      return JRPCEngine3;
    }(SafeEventEmitter);
    Substream = function(_Duplex) {
      _inherits(Substream2, _Duplex);
      var _super = _createSuper$2(Substream2);
      function Substream2(_ref) {
        var _this;
        var parent = _ref.parent, name = _ref.name;
        _classCallCheck(this, Substream2);
        _this = _super.call(this, {
          objectMode: true
        });
        _defineProperty(_assertThisInitialized(_this), "_parent", void 0);
        _defineProperty(_assertThisInitialized(_this), "_name", void 0);
        _this._parent = parent;
        _this._name = name;
        return _this;
      }
      _createClass(Substream2, [{
        key: "_read",
        value: function _read() {
          return void 0;
        }
        /**
         * Called when data should be written to this writable stream.
         *
         * @param chunk - Arbitrary object to write
         * @param encoding - Encoding to use when writing payload
         * @param callback - Called when writing is complete or an error occurs
         */
      }, {
        key: "_write",
        value: function _write(chunk, _encoding, callback) {
          this._parent.push({
            name: this._name,
            data: chunk
          });
          callback();
        }
      }]);
      return Substream2;
    }(import_readable_stream.Duplex);
    IGNORE_SUBSTREAM = Symbol("IGNORE_SUBSTREAM");
    ObjectMultiplex = function(_Duplex) {
      _inherits(ObjectMultiplex2, _Duplex);
      var _super = _createSuper$1(ObjectMultiplex2);
      function ObjectMultiplex2() {
        var _this;
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, ObjectMultiplex2);
        _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {
          objectMode: true
        }));
        _defineProperty(_assertThisInitialized(_this), "_substreams", void 0);
        _defineProperty(_assertThisInitialized(_this), "getStream", void 0);
        _this._substreams = {};
        return _this;
      }
      _createClass(ObjectMultiplex2, [{
        key: "createStream",
        value: function createStream(name) {
          if (!name) {
            throw new Error("ObjectMultiplex - name must not be empty");
          }
          if (this._substreams[name]) {
            throw new Error('ObjectMultiplex - Substream for name "'.concat(name, '" already exists'));
          }
          var substream = new Substream({
            parent: this,
            name
          });
          this._substreams[name] = substream;
          anyStreamEnd(this, function(_error) {
            return substream.destroy(_error || void 0);
          });
          return substream;
        }
        // ignore streams (dont display orphaned data warning)
      }, {
        key: "ignoreStream",
        value: function ignoreStream(name) {
          if (!name) {
            throw new Error("ObjectMultiplex - name must not be empty");
          }
          if (this._substreams[name]) {
            throw new Error('ObjectMultiplex - Substream for name "'.concat(name, '" already exists'));
          }
          this._substreams[name] = IGNORE_SUBSTREAM;
        }
      }, {
        key: "_read",
        value: function _read() {
          return void 0;
        }
      }, {
        key: "_write",
        value: function _write(chunk, _encoding, callback) {
          var name = chunk.name, data = chunk.data;
          if (!name) {
            window.console.warn('ObjectMultiplex - malformed chunk without name "'.concat(chunk, '"'));
            return callback();
          }
          var substream = this._substreams[name];
          if (!substream) {
            window.console.warn('ObjectMultiplex - orphaned data for stream "'.concat(name, '"'));
            return callback();
          }
          if (substream !== IGNORE_SUBSTREAM) {
            substream.push(data);
          }
          return callback();
        }
      }]);
      return ObjectMultiplex2;
    }(import_readable_stream.Duplex);
    PostMessageStream = function(_BasePostMessageStrea) {
      _inherits(PostMessageStream2, _BasePostMessageStrea);
      var _super = _createSuper2(PostMessageStream2);
      function PostMessageStream2() {
        _classCallCheck(this, PostMessageStream2);
        return _super.apply(this, arguments);
      }
      _createClass(PostMessageStream2, [{
        key: "_postMessage",
        value: function _postMessage(data) {
          var originConstraint = this._targetOrigin;
          if (_typeof(data) === "object") {
            var dataObj = data;
            if (_typeof(dataObj.data) === "object") {
              var dataObjData = dataObj.data;
              if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {
                var dataObjDataParam = dataObjData.params[0];
                if (dataObjDataParam._origin) {
                  originConstraint = dataObjDataParam._origin;
                }
                dataObjDataParam._origin = window.location.origin;
              }
            }
          }
          this._targetWindow.postMessage({
            target: this._target,
            data
          }, originConstraint);
        }
      }]);
      return PostMessageStream2;
    }(BasePostMessageStream);
  }
});

// node_modules/ts-custom-error/dist/custom-error.mjs
function fixProto(target, prototype) {
  var setPrototypeOf = Object.setPrototypeOf;
  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
}
function fixStack(target, fn) {
  if (fn === void 0) {
    fn = target.constructor;
  }
  var captureStackTrace = Error.captureStackTrace;
  captureStackTrace && captureStackTrace(target, fn);
}
var __extends, CustomError;
var init_custom_error = __esm({
  "node_modules/ts-custom-error/dist/custom-error.mjs"() {
    init_process();
    init_buffer();
    __extends = function() {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
          }
        };
        return _extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        _extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    CustomError = function(_super) {
      __extends(CustomError2, _super);
      function CustomError2(message, options) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message, options) || this;
        Object.defineProperty(_this, "name", {
          value: _newTarget.name,
          enumerable: false,
          configurable: true
        });
        fixProto(_this, _newTarget.prototype);
        fixStack(_this);
        return _this;
      }
      return CustomError2;
    }(Error);
  }
});

// node_modules/lodash.merge/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    init_process();
    init_buffer();
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value2) {
        return func(value2);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value2) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value2) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value2]);
      } else {
        data[index][1] = value2;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value2) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value2);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value2) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value2]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value2);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value2, inherited) {
      var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length2 = result.length;
      for (var key in value2) {
        if ((inherited || hasOwnProperty.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value2) {
      if (value2 !== void 0 && !eq(object[key], value2) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    function assignValue(object, key, value2) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value2) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value2,
          "writable": true
        });
      } else {
        object[key] = value2;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    function baseIsArguments(value2) {
      return isObjectLike(value2) && baseGetTag(value2) == argsTag;
    }
    function baseIsNative(value2) {
      if (!isObject(value2) || isMasked(value2)) {
        return false;
      }
      var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value2));
    }
    function baseIsTypedArray(value2) {
      return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index < length2) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length2 = props.length;
      while (++index < length2) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object = Object(object);
        while (++index < length2) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value2 = getValue(object, key);
      return baseIsNative(value2) ? value2 : void 0;
    }
    function getRawTag(value2) {
      var isOwn = hasOwnProperty.call(value2, symToStringTag), tag = value2[symToStringTag];
      try {
        value2[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag] = tag;
        } else {
          delete value2[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value2, length2) {
      var type6 = typeof value2;
      length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
      return !!length2 && (type6 == "number" || type6 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
    }
    function isIterateeCall(value2, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type6 = typeof index;
      if (type6 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type6 == "string" && index in object) {
        return eq(object[index], value2);
      }
      return false;
    }
    function isKeyable(value2) {
      var type6 = typeof value2;
      return type6 == "string" || type6 == "number" || type6 == "symbol" || type6 == "boolean" ? value2 !== "__proto__" : value2 === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value2) {
      var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value2 === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value2) {
      return nativeObjectToString.call(value2);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length2 = nativeMax(args.length - start, 0), array = Array(length2);
        while (++index < length2) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value2, other) {
      return value2 === other || value2 !== value2 && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value2) {
      return isObjectLike(value2) && hasOwnProperty.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value2) {
      return value2 != null && isLength(value2.length) && !isFunction(value2);
    }
    function isArrayLikeObject(value2) {
      return isObjectLike(value2) && isArrayLike(value2);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value2) {
      if (!isObject(value2)) {
        return false;
      }
      var tag = baseGetTag(value2);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value2) {
      return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
    }
    function isObject(value2) {
      var type6 = typeof value2;
      return value2 != null && (type6 == "object" || type6 == "function");
    }
    function isObjectLike(value2) {
      return value2 != null && typeof value2 == "object";
    }
    function isPlainObject(value2) {
      if (!isObjectLike(value2) || baseGetTag(value2) != objectTag) {
        return false;
      }
      var proto = getPrototype(value2);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value2) {
      return copyObject(value2, keysIn(value2));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge4 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value2) {
      return function() {
        return value2;
      };
    }
    function identity(value2) {
      return value2;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge4;
  }
});

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/loglevel/lib/loglevel.js"(exports, module) {
    init_process();
    init_buffer();
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module === "object" && module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports, function() {
      "use strict";
      var noop2 = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e2) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace)
          console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop2;
        }
      }
      function replaceLoggingMethods(level, loggerName) {
        for (var i2 = 0; i2 < logMethods.length; i2++) {
          var methodName = logMethods[i2];
          this[methodName] = i2 < level ? noop2 : this.methodFactory(methodName, level, loggerName);
        }
        this.log = this.debug;
      }
      function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this, level, loggerName);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, level, loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, defaultLevel, factory) {
        var self2 = this;
        var currentLevel;
        defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
        var storageKey3 = "loglevel";
        if (typeof name === "string") {
          storageKey3 += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey3 = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey3)
            return;
          try {
            window.localStorage[storageKey3] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey3) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey3)
            return;
          try {
            storedLevel = window.localStorage[storageKey3];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var location2 = cookie.indexOf(
                encodeURIComponent(storageKey3) + "="
              );
              if (location2 !== -1) {
                storedLevel = /^([^;]+)/.exec(cookie.slice(location2))[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey3)
            return;
          try {
            window.localStorage.removeItem(storageKey3);
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey3) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          return currentLevel;
        };
        self2.setLevel = function(level, persist) {
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            currentLevel = level;
            if (persist !== false) {
              persistLevelIfPossible(level);
            }
            replaceLoggingMethods.call(self2, level, name);
            if (typeof console === undefinedType && level < self2.levels.SILENT) {
              return "No console available for logging";
            }
          } else {
            throw "log.setLevel() called with invalid level: " + level;
          }
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          self2.setLevel(defaultLevel, false);
          clearPersistedLevel();
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        var initialLevel = getPersistedLevel();
        if (initialLevel == null) {
          initialLevel = defaultLevel;
        }
        self2.setLevel(initialLevel, false);
      }
      var defaultLogger = new Logger();
      var _loggersByName = {};
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.getLevel(),
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/@web3auth/base/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
async function fetchAndTrace(url2, init) {
  let _url = null;
  try {
    _url = new URL(url2);
  } catch (error) {
  }
  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {
    const transaction = sentry.startTransaction({
      name: url2
    });
    const span = transaction.startChild({
      op: "http"
    });
    const response = await fetch(url2, init);
    span.finish();
    transaction.finish();
    return response;
  }
  return fetch(url2, init);
}
function getApiKeyHeaders() {
  const headers = {};
  if (apiKey)
    headers[gatewayAuthHeader] = apiKey;
  if (embedHost)
    headers[gatewayEmbedHostHeader] = embedHost;
  return headers;
}
function debugLogResponse(response) {
  log.info(`Response: ${response.status} ${response.statusText}`);
  log.info(`Url: ${response.url}`);
}
var import_lodash, import_loglevel, log, apiKey, embedHost, gatewayAuthHeader, gatewayEmbedHostHeader, sentry, tracingOrigins, tracingPaths, promiseTimeout, post;
var init_httpHelpers_esm = __esm({
  "node_modules/@web3auth/base/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    import_lodash = __toESM(require_lodash2());
    import_loglevel = __toESM(require_loglevel());
    log = import_loglevel.default.getLogger("http-helpers");
    log.setLevel(import_loglevel.levels.INFO);
    apiKey = "torus-default";
    embedHost = "";
    gatewayAuthHeader = "x-api-key";
    gatewayEmbedHostHeader = "x-embed-host";
    sentry = null;
    tracingOrigins = [];
    tracingPaths = [];
    promiseTimeout = (ms, promise) => {
      const timeout2 = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
          clearTimeout(id);
          reject(new Error(`Timed out in ${ms}ms`));
        }, ms);
      });
      return Promise.race([promise, timeout2]);
    };
    post = function(url2) {
      let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let options_ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let customOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const defaultOptions = {
        mode: "cors",
        headers: {
          "Content-Type": "application/json; charset=utf-8"
        }
      };
      if (customOptions.useAPIKey) {
        defaultOptions.headers = _objectSpread2(_objectSpread2({}, defaultOptions.headers), getApiKeyHeaders());
      }
      const options = (0, import_lodash.default)(defaultOptions, options_, {
        method: "POST"
      });
      if (customOptions.isUrlEncodedData) {
        options.body = data;
        if (options.headers["Content-Type"] === "application/json; charset=utf-8")
          delete options.headers["Content-Type"];
      } else {
        options.body = JSON.stringify(data);
      }
      return promiseTimeout(customOptions.timeout || 6e4, fetchAndTrace(url2, options).then((response) => {
        if (response.ok) {
          return response.json();
        }
        debugLogResponse(response);
        throw response;
      }));
    };
  }
});

// node_modules/jwt-decode/build/jwt-decode.esm.js
function e(e2) {
  this.message = e2;
}
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
var r, jwt_decode_esm_default;
var init_jwt_decode_esm = __esm({
  "node_modules/jwt-decode/build/jwt-decode.esm.js"() {
    init_process();
    init_buffer();
    e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
    r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
      var t2 = String(r2).replace(/=+$/, "");
      if (t2.length % 4 == 1)
        throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
      for (var n2, o2, a = 0, i2 = 0, c = ""; o2 = t2.charAt(i2++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
        o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
      return c;
    };
    n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
    jwt_decode_esm_default = o;
  }
});

// node_modules/@web3auth/base/dist/base.esm.js
var base_esm_exports = {};
__export(base_esm_exports, {
  ADAPTER_CATEGORY: () => ADAPTER_CATEGORY,
  ADAPTER_EVENTS: () => ADAPTER_EVENTS,
  ADAPTER_NAMESPACES: () => ADAPTER_NAMESPACES,
  ADAPTER_STATUS: () => ADAPTER_STATUS,
  BaseAdapter: () => BaseAdapter,
  BaseNetworkSwitch: () => BaseNetworkSwitch,
  CHAIN_NAMESPACES: () => CHAIN_NAMESPACES,
  EVM_ADAPTERS: () => EVM_ADAPTERS,
  MULTI_CHAIN_ADAPTERS: () => MULTI_CHAIN_ADAPTERS,
  PROVIDER_EVENTS: () => PROVIDER_EVENTS,
  SOLANA_ADAPTERS: () => SOLANA_ADAPTERS,
  WALLET_ADAPTERS: () => WALLET_ADAPTERS,
  WalletInitializationError: () => WalletInitializationError,
  WalletLoginError: () => WalletLoginError,
  Web3AuthError: () => Web3AuthError,
  authServer: () => authServer,
  checkIfTokenIsExpired: () => checkIfTokenIsExpired,
  clearToken: () => clearToken,
  getChainConfig: () => getChainConfig,
  getEvmChainConfig: () => getEvmChainConfig,
  getSavedToken: () => getSavedToken,
  getSolanaChainConfig: () => getSolanaChainConfig,
  isHexStrict: () => isHexStrict,
  log: () => log2,
  saveToken: () => saveToken,
  signChallenge: () => signChallenge,
  storageAvailable: () => storageAvailable,
  verifySignedChallenge: () => verifySignedChallenge
});
function _createSuper$12(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$12();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$12() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function ownKeys$12(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$12(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$12(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$12(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function storageAvailable(type6) {
  var storageExists = false;
  var storageLength = 0;
  var storage;
  try {
    storage = window[type6];
    storageExists = true;
    storageLength = storage.length;
    var x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    var _error = error;
    return !!(_error && // everything except Firefox
    (_error.code === 22 || // Firefox
    _error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    _error.name === "QuotaExceededError" || // Firefox
    _error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0);
  }
}
var import_regenerator2, import_loglevel2, CHAIN_NAMESPACES, ADAPTER_NAMESPACES, getDefaultNetworkId, getEvmChainConfig, getSolanaChainConfig, getChainConfig, Web3AuthError, WalletInitializationError, WalletLoginError, MULTI_CHAIN_ADAPTERS, SOLANA_ADAPTERS, EVM_ADAPTERS, WALLET_ADAPTERS, ADAPTER_CATEGORY, ADAPTER_STATUS, ADAPTER_EVENTS, BaseAdapter, BaseNetworkSwitch, authServer, log2, isHexStrict, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, getSavedToken, saveToken, clearToken, PROVIDER_EVENTS;
var init_base_esm = __esm({
  "node_modules/@web3auth/base/dist/base.esm.js"() {
    init_process();
    init_buffer();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    init_openloginJrpc_esm();
    init_custom_error();
    init_asyncToGenerator();
    import_regenerator2 = __toESM(require_regenerator());
    init_httpHelpers_esm();
    init_jwt_decode_esm();
    import_loglevel2 = __toESM(require_loglevel());
    CHAIN_NAMESPACES = {
      EIP155: "eip155",
      SOLANA: "solana",
      OTHER: "other"
    };
    ADAPTER_NAMESPACES = {
      EIP155: "eip155",
      SOLANA: "solana",
      MULTICHAIN: "multichain"
    };
    getDefaultNetworkId = function getDefaultNetworkId2(chainNamespace) {
      if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
        return 1;
      } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
        return 1;
      }
      throw new Error("Chain namespace ".concat(chainNamespace, " is not supported"));
    };
    getEvmChainConfig = function getEvmChainConfig2(chainId) {
      var chainNamespace = CHAIN_NAMESPACES.EIP155;
      if (chainId === 1) {
        return {
          chainNamespace,
          chainId: "0x1",
          rpcTarget: "https://rpc.ankr.com/eth",
          displayName: "Ethereum Mainnet",
          blockExplorer: "https://etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      }
      if (chainId === 3) {
        return {
          chainNamespace,
          chainId: "0x3",
          rpcTarget: "https://rpc.ankr.com/eth_ropsten",
          displayName: "Ropsten Testnet",
          blockExplorer: "https://ropsten.etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      }
      if (chainId === 4) {
        return {
          chainNamespace,
          chainId: "0x4",
          rpcTarget: "https://rpc.ankr.com/eth_rinkeby",
          displayName: "Rinkeby Testnet",
          blockExplorer: "https://rinkeby.etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      }
      if (chainId === 5) {
        return {
          chainNamespace,
          chainId: "0x5",
          rpcTarget: "https://rpc.ankr.com/eth_goerli",
          displayName: "Goerli Testnet",
          blockExplorer: "https://goerli.etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      }
      if (chainId === 137) {
        return {
          chainNamespace,
          chainId: "0x89",
          rpcTarget: "https://rpc.ankr.com/polygon",
          displayName: "Polygon Mainnet",
          blockExplorer: "https://polygonscan.com",
          ticker: "MATIC",
          tickerName: "Polygon"
        };
      }
      if (chainId === 80001) {
        return {
          chainNamespace,
          chainId: "0x13881",
          rpcTarget: "https://rpc.ankr.com/polygon_mumbai",
          displayName: "Polygon Mumbai Testnet",
          blockExplorer: "https://mumbai.polygonscan.com/",
          ticker: "MATIC",
          tickerName: "Polygon"
        };
      }
      if (chainId === 56) {
        return {
          chainNamespace,
          chainId: "0x38",
          rpcTarget: "https://rpc.ankr.com/bsc",
          displayName: "Binance SmartChain Mainnet",
          blockExplorer: "https://bscscan.com",
          ticker: "BNB",
          tickerName: "Binance SmartChain"
        };
      }
      if (chainId === 97) {
        return {
          chainNamespace,
          chainId: "0x61",
          rpcTarget: "https://rpc.ankr.com/bsc_testnet_chapel",
          displayName: "Binance SmartChain Testnet",
          blockExplorer: "https://testnet.bscscan.com",
          ticker: "BNB",
          tickerName: "Binance SmartChain"
        };
      }
      if (chainId === 25) {
        return {
          chainNamespace,
          chainId: "0x19",
          rpcTarget: "https://rpc.cronos.org",
          displayName: "Cronos Mainnet",
          blockExplorer: "https://cronoscan.com/",
          ticker: "CRO",
          tickerName: "Cronos"
        };
      }
      if (chainId === 338) {
        return {
          chainNamespace,
          chainId: "0x152",
          rpcTarget: "https://rpc-t3.cronos.org/",
          displayName: "Cronos Testnet",
          blockExplorer: "https://cronoscan.com/",
          ticker: "CRO",
          tickerName: "Cronos"
        };
      }
      if (chainId === 8217) {
        return {
          chainNamespace,
          chainId: "0x2019",
          rpcTarget: "https://public-node-api.klaytnapi.com/v1/cypress",
          displayName: "Klaytn Mainnet",
          blockExplorer: "https://scope.klaytn.com",
          ticker: "KLAY",
          tickerName: "Klaytn"
        };
      }
      return null;
    };
    getSolanaChainConfig = function getSolanaChainConfig2(chainId) {
      var chainNamespace = CHAIN_NAMESPACES.SOLANA;
      if (chainId === 1) {
        return {
          chainNamespace,
          chainId: "0x1",
          rpcTarget: "https://rpc.ankr.com/solana",
          displayName: "Solana Mainnet",
          blockExplorer: "https://explorer.solana.com",
          ticker: "SOL",
          tickerName: "Solana"
        };
      } else if (chainId === 2) {
        return {
          chainNamespace,
          chainId: "0x2",
          rpcTarget: "https://api.testnet.solana.com",
          displayName: "Solana Testnet",
          blockExplorer: "https://explorer.solana.com?cluster=testnet",
          ticker: "SOL",
          tickerName: "Solana"
        };
      } else if (chainId === 3) {
        return {
          chainNamespace,
          chainId: "0x3",
          rpcTarget: "https://api.devnet.solana.com",
          displayName: "Solana Devnet",
          blockExplorer: "https://explorer.solana.com?cluster=devnet",
          ticker: "SOL",
          tickerName: "Solana"
        };
      }
      return null;
    };
    getChainConfig = function getChainConfig2(chainNamespace, chainId) {
      if (chainNamespace === CHAIN_NAMESPACES.OTHER)
        return null;
      var finalChainId = chainId ? typeof chainId === "number" ? chainId : parseInt(chainId, 16) : getDefaultNetworkId(chainNamespace);
      if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
        return getEvmChainConfig(finalChainId);
      } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
        return getSolanaChainConfig(finalChainId);
      }
      return null;
    };
    Web3AuthError = function(_CustomError) {
      _inherits(Web3AuthError2, _CustomError);
      var _super = _createSuper$12(Web3AuthError2);
      function Web3AuthError2(code, message) {
        var _this;
        _classCallCheck(this, Web3AuthError2);
        _this = _super.call(this, message);
        _defineProperty(_assertThisInitialized(_this), "code", void 0);
        _defineProperty(_assertThisInitialized(_this), "message", void 0);
        _this.code = code;
        _this.message = message || "";
        Object.defineProperty(_assertThisInitialized(_this), "name", {
          value: "Web3AuthError"
        });
        return _this;
      }
      _createClass(Web3AuthError2, [{
        key: "toJSON",
        value: function toJSON() {
          return {
            name: this.name,
            code: this.code,
            message: this.message
          };
        }
      }, {
        key: "toString",
        value: function toString2() {
          return JSON.stringify(this.toJSON());
        }
      }]);
      return Web3AuthError2;
    }(CustomError);
    WalletInitializationError = function(_Web3AuthError) {
      _inherits(WalletInitializationError2, _Web3AuthError);
      var _super2 = _createSuper$12(WalletInitializationError2);
      function WalletInitializationError2(code, message) {
        var _this2;
        _classCallCheck(this, WalletInitializationError2);
        _this2 = _super2.call(this, code, message);
        Object.defineProperty(_assertThisInitialized(_this2), "name", {
          value: "WalletInitializationError"
        });
        return _this2;
      }
      _createClass(WalletInitializationError2, null, [{
        key: "fromCode",
        value: function fromCode(code) {
          var extraMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return new WalletInitializationError2(code, "".concat(WalletInitializationError2.messages[code], ", ").concat(extraMessage));
        }
        // Custom methods
      }, {
        key: "notFound",
        value: function notFound() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5001, extraMessage);
        }
      }, {
        key: "notInstalled",
        value: function notInstalled() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5002, extraMessage);
        }
      }, {
        key: "notReady",
        value: function notReady() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5003, extraMessage);
        }
      }, {
        key: "windowBlocked",
        value: function windowBlocked() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5004, extraMessage);
        }
      }, {
        key: "windowClosed",
        value: function windowClosed() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5005, extraMessage);
        }
      }, {
        key: "incompatibleChainNameSpace",
        value: function incompatibleChainNameSpace() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5006, extraMessage);
        }
      }, {
        key: "duplicateAdapterError",
        value: function duplicateAdapterError() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5007, extraMessage);
        }
      }, {
        key: "invalidProviderConfigError",
        value: function invalidProviderConfigError() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5008, extraMessage);
        }
      }, {
        key: "providerNotReadyError",
        value: function providerNotReadyError() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5009, extraMessage);
        }
      }, {
        key: "rpcConnectionError",
        value: function rpcConnectionError() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5010, extraMessage);
        }
      }, {
        key: "invalidParams",
        value: function invalidParams() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5011, extraMessage);
        }
      }, {
        key: "invalidNetwork",
        value: function invalidNetwork() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletInitializationError2.fromCode(5013, extraMessage);
        }
      }]);
      return WalletInitializationError2;
    }(Web3AuthError);
    _defineProperty(WalletInitializationError, "messages", {
      5e3: "Custom",
      5001: "Wallet is not found",
      5002: "Wallet is not installed",
      5003: "Wallet is not ready yet",
      5004: "Wallet window is blocked",
      5005: "Wallet window has been closed by the user",
      5006: "Incompatible chain namespace provided",
      5007: "Adapter has already been included",
      5008: "Invalid provider Config",
      5009: "Provider is not ready yet",
      5010: "Failed to connect with rpc url",
      5011: "Invalid params passed in",
      5013: "Invalid network provided"
    });
    WalletLoginError = function(_Web3AuthError2) {
      _inherits(WalletLoginError2, _Web3AuthError2);
      var _super3 = _createSuper$12(WalletLoginError2);
      function WalletLoginError2(code, message) {
        var _this3;
        _classCallCheck(this, WalletLoginError2);
        _this3 = _super3.call(this, code, message);
        Object.defineProperty(_assertThisInitialized(_this3), "name", {
          value: "WalletLoginError"
        });
        return _this3;
      }
      _createClass(WalletLoginError2, null, [{
        key: "fromCode",
        value: function fromCode(code) {
          var extraMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return new WalletLoginError2(code, "".concat(WalletLoginError2.messages[code]).concat(extraMessage));
        }
      }, {
        key: "connectionError",
        value: function connectionError() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletLoginError2.fromCode(5111, extraMessage);
        }
      }, {
        key: "disconnectionError",
        value: function disconnectionError() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletLoginError2.fromCode(5112, extraMessage);
        }
      }, {
        key: "notConnectedError",
        value: function notConnectedError() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletLoginError2.fromCode(5113, extraMessage);
        }
      }, {
        key: "popupClosed",
        value: function popupClosed() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletLoginError2.fromCode(5114, extraMessage);
        }
      }, {
        key: "mfaEnabled",
        value: function mfaEnabled() {
          var extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return WalletLoginError2.fromCode(5115, extraMessage);
        }
      }]);
      return WalletLoginError2;
    }(Web3AuthError);
    _defineProperty(WalletLoginError, "messages", {
      5e3: "Custom",
      5111: "Failed to connect with wallet",
      5112: "Failed to disconnect from wallet",
      5113: "Wallet is not connected",
      5114: "Wallet popup has been closed by the user",
      5115: "User has already enabled mfa, please use the @web3auth/web3auth-web sdk for login with mfa"
    });
    MULTI_CHAIN_ADAPTERS = {
      OPENLOGIN: "openlogin",
      WALLET_CONNECT_V1: "wallet-connect-v1",
      WALLET_CONNECT_V2: "wallet-connect-v2"
    };
    SOLANA_ADAPTERS = _objectSpread$12({
      TORUS_SOLANA: "torus-solana",
      PHANTOM: "phantom",
      SOLLET: "sollet",
      SOLLET_EXTENSION: "sollet-extension",
      SOLFLARE: "solflare",
      SLOPE: "slope"
    }, MULTI_CHAIN_ADAPTERS);
    EVM_ADAPTERS = _objectSpread$12({
      TORUS_EVM: "torus-evm",
      METAMASK: "metamask",
      COINBASE: "coinbase"
    }, MULTI_CHAIN_ADAPTERS);
    WALLET_ADAPTERS = _objectSpread$12(_objectSpread$12({}, EVM_ADAPTERS), SOLANA_ADAPTERS);
    ADAPTER_CATEGORY = {
      EXTERNAL: "external",
      IN_APP: "in_app"
    };
    ADAPTER_STATUS = {
      NOT_READY: "not_ready",
      READY: "ready",
      CONNECTING: "connecting",
      CONNECTED: "connected",
      DISCONNECTED: "disconnected",
      ERRORED: "errored"
    };
    ADAPTER_EVENTS = _objectSpread3(_objectSpread3({}, ADAPTER_STATUS), {}, {
      ADAPTER_DATA_UPDATED: "adapter_data_updated"
    });
    BaseAdapter = function(_SafeEventEmitter) {
      _inherits(BaseAdapter2, _SafeEventEmitter);
      var _super = _createSuper3(BaseAdapter2);
      function BaseAdapter2() {
        var _this;
        _classCallCheck(this, BaseAdapter2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "adapterData", {});
        _defineProperty(_assertThisInitialized(_this), "sessionTime", 86400);
        _defineProperty(_assertThisInitialized(_this), "chainConfig", null);
        return _this;
      }
      _createClass(BaseAdapter2, [{
        key: "chainConfigProxy",
        get: function get2() {
          return this.chainConfig ? _objectSpread3({}, this.chainConfig) : null;
        }
      }, {
        key: "setChainConfig",
        value: function setChainConfig(customChainConfig) {
          if (this.status === ADAPTER_STATUS.READY)
            return;
          if (!customChainConfig.chainNamespace)
            throw WalletInitializationError.notReady("ChainNamespace is required while setting chainConfig");
          var defaultChainConfig = getChainConfig(customChainConfig.chainNamespace, customChainConfig.chainId);
          this.chainConfig = _objectSpread3(_objectSpread3({}, defaultChainConfig), customChainConfig);
        }
      }, {
        key: "setAdapterSettings",
        value: function setAdapterSettings(_) {
        }
      }, {
        key: "checkConnectionRequirements",
        value: function checkConnectionRequirements() {
          if (this.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.status === ADAPTER_STATUS.CONNECTING)
            return;
          else if (this.status === ADAPTER_STATUS.CONNECTING)
            throw WalletInitializationError.notReady("Already connecting");
          if (this.status === ADAPTER_STATUS.CONNECTED)
            throw WalletLoginError.connectionError("Already connected");
          if (this.status !== ADAPTER_STATUS.READY)
            throw WalletLoginError.connectionError("Wallet adapter is not ready yet, Please wait for init function to resolve before calling connect/connectTo function");
          if (!this.clientId)
            throw WalletLoginError.connectionError("Please initialize Web3Auth with a valid clientId in constructor");
        }
      }, {
        key: "checkInitializationRequirements",
        value: function checkInitializationRequirements() {
          if (this.status === ADAPTER_STATUS.NOT_READY)
            return;
          if (this.status === ADAPTER_STATUS.CONNECTED)
            throw WalletInitializationError.notReady("Already connected");
          if (this.status === ADAPTER_STATUS.READY)
            throw WalletInitializationError.notReady("Adapter is already initialized");
        }
      }, {
        key: "updateAdapterData",
        value: function updateAdapterData(data) {
          this.adapterData = data;
          this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, {
            adapterName: this.name,
            data
          });
        }
      }]);
      return BaseAdapter2;
    }(SafeEventEmitter);
    BaseNetworkSwitch = _createClass(function BaseNetworkSwitch2() {
      _classCallCheck(this, BaseNetworkSwitch2);
    });
    authServer = "https://authjs.web3auth.io";
    log2 = import_loglevel2.default.getLogger("web3auth-logger");
    isHexStrict = function isHexStrict2(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
    };
    checkIfTokenIsExpired = function checkIfTokenIsExpired2(token) {
      var decoded = jwt_decode_esm_default(token);
      if (!decoded.exp) {
        return true;
      }
      if (decoded.exp < Math.floor(Date.now() / 1e3)) {
        return true;
      }
      return false;
    };
    signChallenge = function() {
      var _ref = _asyncToGenerator(import_regenerator2.default.mark(function _callee(payload, chainNamespace) {
        var t2, header, network, data, res;
        return import_regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                t2 = chainNamespace === "solana" ? "sip99" : "eip191";
                header = {
                  t: t2
                };
                network = chainNamespace === "solana" ? "solana" : "ethereum";
                data = {
                  payload,
                  header,
                  network
                };
                _context.next = 6;
                return post("".concat(authServer, "/siww/get"), data);
              case 6:
                res = _context.sent;
                if (res.success) {
                  _context.next = 9;
                  break;
                }
                throw new Error("Failed to authenticate user, Please reach out to Web3Auth Support team");
              case 9:
                return _context.abrupt("return", res.challenge);
              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function signChallenge2(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();
    verifySignedChallenge = function() {
      var _ref2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee2(chainNamespace, signedMessage, challenge, issuer, sessionTime, clientId) {
        var t2, sigData, idTokenRes;
        return import_regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                t2 = chainNamespace === "solana" ? "sip99" : "eip191";
                sigData = {
                  signature: {
                    s: signedMessage,
                    t: t2
                  },
                  message: challenge,
                  issuer,
                  audience: window.location.hostname,
                  timeout: sessionTime
                };
                _context2.next = 4;
                return post("".concat(authServer, "/siww/verify"), sigData, {
                  headers: {
                    client_id: clientId,
                    wallet_provider: issuer
                  }
                });
              case 4:
                idTokenRes = _context2.sent;
                if (idTokenRes.success) {
                  _context2.next = 8;
                  break;
                }
                log2.error("Failed to authenticate user, ,message verification failed", idTokenRes.error);
                throw new Error("Failed to authenticate user, ,message verification failed");
              case 8:
                return _context2.abrupt("return", idTokenRes.token);
              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function verifySignedChallenge2(_x3, _x4, _x5, _x6, _x7, _x8) {
        return _ref2.apply(this, arguments);
      };
    }();
    getSavedToken = function getSavedToken2(userAddress, issuer) {
      if (storageAvailable("localStorage")) {
        return localStorage.getItem("".concat(userAddress.toLowerCase(), "_").concat(issuer));
      }
      return null;
    };
    saveToken = function saveToken2(userAddress, issuer, token) {
      if (storageAvailable("localStorage")) {
        return localStorage.setItem("".concat(userAddress.toLowerCase(), "_").concat(issuer), token);
      }
      return null;
    };
    clearToken = function clearToken2(userAddress, issuer) {
      if (storageAvailable("localStorage")) {
        return localStorage.removeItem("".concat(userAddress.toLowerCase(), "_").concat(issuer));
      }
      return null;
    };
    PROVIDER_EVENTS = {
      INITIALIZED: "initialized",
      ERRORED: "errored"
    };
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n2) {
      if (!Number.isSafeInteger(n2) || n2 < 0)
        throw new Error(`Wrong positive integer: ${n2}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    exports.default = assert;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto2();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i2 = 0; i2 < uint8a.length; i2++) {
        hex += hexes[uint8a[i2]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j = i2 * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick2 = async () => {
    };
    exports.nextTick = nextTick2;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length2);
      for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
        const arr = arrays[i2];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    function setBigUint64(view, byteOffset, value2, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value2, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value2 >> _32n & _u32_max);
      const wl = Number(value2 & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
        to.length = length2;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length2 % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils2();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W[i2 - 15];
          const W2 = SHA256_W[i2 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils3 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a = (a) => a instanceof Uint8Array;
    var hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex += hexes[bytes[i2]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hex.length % 2)
        throw new Error("hex string is invalid: unpadded " + hex.length);
      const array = new Uint8Array(hex.length / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j = i2 * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    var numberToBytesBE = (n2, len) => hexToBytes(n2.toString(16).padStart(len * 2, "0"));
    exports.numberToBytesBE = numberToBytesBE;
    var numberToBytesLE = (n2, len) => (0, exports.numberToBytesBE)(n2, len).reverse();
    exports.numberToBytesLE = numberToBytesLE;
    var numberToVarBytesBE = (n2) => hexToBytes(numberToHexUnpadded(n2));
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e2) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e2}`);
        }
      } else if (u8a(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes;
    function concatBytes(...arrs) {
      const r2 = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrs.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r2.set(a, pad);
        pad += a.length;
      });
      return r2;
    }
    exports.concatBytes = concatBytes;
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i2 = 0; i2 < b1.length; i2++)
        if (b1[i2] !== b2[i2])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string") {
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes;
    function bitLen(n2) {
      let len;
      for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen;
    var bitGet = (n2, pos) => n2 >> BigInt(pos) & _1n;
    exports.bitGet = bitGet;
    var bitSet = (n2, pos, value2) => n2 | (value2 ? _1n : _0n) << BigInt(pos);
    exports.bitSet = bitSet;
    var bitMask = (n2) => (_2n << BigInt(n2 - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i2 = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i2 = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed2 = u8n()) => {
        k = h(u8fr([0]), seed2);
        v = h();
        if (seed2.length === 0)
          return;
        k = h(u8fr([1]), seed2);
        v = h();
      };
      const gen = () => {
        if (i2++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed2, pred) => {
        reset();
        reseed(seed2);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type6, isOptional) => {
        const checkVal = validatorFns[type6];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type6}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type6}`);
        }
      };
      for (const [fieldName, type6] of Object.entries(validators))
        checkField(fieldName, type6, false);
      for (const [fieldName, type6] of Object.entries(optValidators))
        checkField(fieldName, type6, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    exports.mod = mod;
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r2 = b % a;
        const m = x - u * q;
        const n2 = y - v * q;
        b = a, a = r2, x = u, y = v, u = m, v = n2;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n2) {
          const root = Fp.pow(n2, p1div4);
          if (!Fp.eql(Fp.sqr(root), n2))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n2) {
        if (Fp.pow(n2, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r2 = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n2, Q1div2);
        let b = Fp.pow(n2, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r2; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r2 - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r2 = m;
        }
        return x;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n2) {
          const root = Fp.pow(n2, p1div4);
          if (!Fp.eql(Fp.sqr(root), n2))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n2) {
          const n22 = Fp.mul(n2, _2n);
          const v = Fp.pow(n22, c1);
          const nv = Fp.mul(n2, v);
          const i2 = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i2, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n2))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map2, val) => {
        map2[val] = "function";
        return map2;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i2) => {
        if (f.is0(num))
          return acc;
        tmp[i2] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i2) => {
        if (f.is0(num))
          return acc;
        tmp[i2] = f.mul(acc, tmp[i2]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n2, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n2) => sqrtP(f, n2)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n2) {
          let p = c.ZERO;
          let d = elm;
          while (n2 > _0n) {
            if (n2 & _1n)
              p = p.add(d);
            d = d.double();
            n2 >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i2 = 1; i2 < windowSize; i2++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n2) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n2 & mask);
            n2 >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n2 += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n2, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n2);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod = require_modular();
    var ut = require_utils3();
    var utils_js_1 = require_utils3();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r2, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r: r2, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r2 = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r2.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r2}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((c, point, isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n2);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i2) => Fp.eql(i2, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint)
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n2) {
          return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i2) => p.toAffine(toInv[i2])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n2) {
          const I = Point.ZERO;
          if (n2 === _0n)
            return I;
          assertGE(n2);
          if (n2 === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n2);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n2 = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n2);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r2, s, recovery) {
          this.r = r2;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r: r2, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r2, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r: r2, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size (nBitLength+64)
         * as per FIPS 186 B.4.1 with modulo bias being neglible.
         */
        randomPrivateKey: () => {
          const rand = CURVE.randomBytes(Fp.BYTES + 8);
          const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);
          return ut.numberToBytesBE(num, CURVE.nByteLength);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e2 = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e2, Fp.BYTES));
        }
        const seed2 = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r2 = modN(q.x);
          if (r2 === _0n)
            return;
          const s = modN(ik * modN(m + r2 * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r2, normS, recovery);
        }
        return { seed: seed2, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign2(msgHash, privKey, opts = defaultSigOpts) {
        const { seed: seed2, k2sig } = prepSig(msgHash, privKey, opts);
        const drbg = ut.createHmacDrbg(CURVE.hash.outputLen, CURVE.nByteLength, CURVE.hmac);
        return drbg(seed2, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r3, s: s2 } = sg;
            _sig = new Signature(r3, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r: r2, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r2 * is);
        const R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r2;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign: sign2,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o2 = q - _1n; o2 % _2n === _0n; o2 /= _2n)
        l += _1n;
      const c1 = l;
      const c2 = (q - _1n) / _2n ** c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n ** c1 - _1n;
      const c5 = _2n ** (c1 - _1n);
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i2 = c1; i2 > _1n; i2--) {
          let tv52 = _2n ** (i2 - _2n);
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value: value2 } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value2);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value2, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    function validateDST(dst) {
      if (dst instanceof Uint8Array)
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value2, length2) {
      if (value2 < 0 || value2 >= 1 << 8 * length2) {
        throw new Error(`bad I2OSP call: value=${value2} length=${length2}`);
      }
      const res = Array.from({ length: length2 }).fill(0);
      for (let i2 = length2 - 1; i2 >= 0; i2--) {
        res[i2] = value2 & 255;
        value2 >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i2 = 0; i2 < a.length; i2++) {
        arr[i2] = a[i2] ^ b[i2];
      }
      return arr;
    }
    function isBytes(item) {
      if (!(item instanceof Uint8Array))
        throw new Error("Uint8Array expected");
    }
    function isNum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i2 = 1; i2 <= ell; i2++) {
        const args = [strxor(b_0, b[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
        b[i2] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "string",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      isBytes(msg);
      isNum(count);
      const DST = validateDST(_DST);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i2 = 0; i2 < count; i2++) {
        const e2 = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i2 * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e2[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i2] = e2;
      }
      return u;
    }
    exports.hash_to_field = hash_to_field;
    function isogenyMap(field, map2) {
      const COEFF = map2.map((i2) => Array.from(i2).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    exports.isogenyMap = isogenyMap;
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports.createHasher = createHasher;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils2();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create6 = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create6(defHash), create: create6 });
    }
    exports.createCurve = createCurve;
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils2();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var utils_js_1 = require_utils3();
    var htf = require_hash_to_curve();
    var _shortw_utils_js_1 = require_shortw_utils();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      b: BigInt(7),
      Fp,
      n: secp256k1N,
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n2 = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n2);
          const c2 = divNearest(-b1 * k, n2);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n2);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n2);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n2 - k1;
          if (k2neg)
            k2 = n2 - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n2) => (0, utils_js_1.numberToBytesBE)(n2, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t2 = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t2, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e2 = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e2 * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r2 = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r2))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e2 = challenge(numTo32b(r2), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e2));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r2)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = {
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    };
    var isoMap = htf.isogenyMap(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i2) => i2.map((j) => BigInt(j))));
    var mapSWU = (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    });
    _a = htf.createHasher(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }), exports.hashToCurve = _a.hashToCurve, exports.encodeToCurve = _a.encodeToCurve;
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = void 0;
    var secp256k1_1 = require_secp256k1();
    Object.defineProperty(exports, "secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.secp256k1;
    } });
  }
});

// node_modules/@ethereumjs/util/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@ethereumjs/util/dist/constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
    var buffer_1 = require_buffer();
    var secp256k1_1 = require_secp256k12();
    exports.MAX_UINT64 = BigInt("0xffffffffffffffff");
    exports.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    exports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;
    exports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);
    exports.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, "hex");
    exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([128]);
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
  }
});

// node_modules/@ethereumjs/util/dist/units.js
var require_units = __commonJS({
  "node_modules/@ethereumjs/util/dist/units.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GWEI_TO_WEI = void 0;
    exports.GWEI_TO_WEI = BigInt(1e9);
  }
});

// node_modules/@ethereumjs/rlp/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@ethereumjs/rlp/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RLP = exports.utils = exports.decode = exports.encode = void 0;
    function encode3(input) {
      if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for (let i2 = 0; i2 < input.length; i2++) {
          const encoded = encode3(input[i2]);
          output.push(encoded);
          outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
      }
      const inputBuf = toBytes(input);
      if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
      }
      return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
    }
    exports.encode = encode3;
    function safeSlice(input, start, end) {
      if (end > input.length) {
        throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
      }
      return input.slice(start, end);
    }
    function decodeLength(v) {
      if (v[0] === 0) {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseHexByte(bytesToHex(v));
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Uint8Array.from([len + offset]);
      }
      const hexLength = numberToHex(len);
      const lLength = hexLength.length / 2;
      const firstByte = numberToHex(offset + 55 + lLength);
      return Uint8Array.from(hexToBytes(firstByte + hexLength));
    }
    function decode3(input, stream = false) {
      if (typeof input === "undefined" || input === null || input.length === 0) {
        return Uint8Array.from([]);
      }
      const inputBytes = toBytes(input);
      const decoded = _decode(inputBytes);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid RLP: remainder must be zero");
      }
      return decoded.data;
    }
    exports.decode = decode3;
    function _decode(input) {
      let length2, llength, data, innerRemainder, d;
      const decoded = [];
      const firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length2 = firstByte - 127;
        if (firstByte === 128) {
          data = Uint8Array.from([]);
        } else {
          data = safeSlice(input, 1, length2);
        }
        if (length2 === 2 && data[0] < 128) {
          throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
        }
        return {
          data,
          remainder: input.slice(length2)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length2 = decodeLength(safeSlice(input, 1, llength));
        if (length2 <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = safeSlice(input, llength, length2 + llength);
        return {
          data,
          remainder: input.slice(length2 + llength)
        };
      } else if (firstByte <= 247) {
        length2 = firstByte - 191;
        innerRemainder = safeSlice(input, 1, length2);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length2)
        };
      } else {
        llength = firstByte - 246;
        length2 = decodeLength(safeSlice(input, 1, llength));
        if (length2 < 56) {
          throw new Error("invalid RLP: encoded list too short");
        }
        const totalLength = llength + length2;
        if (totalLength > input.length) {
          throw new Error("invalid RLP: total length is larger than the data");
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    var cachedHexes = Array.from({ length: 256 }, (_v, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      let hex = "";
      for (let i2 = 0; i2 < uint8a.length; i2++) {
        hex += cachedHexes[uint8a[i2]];
      }
      return hex;
    }
    function parseHexByte(hexByte) {
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte))
        throw new Error("Invalid byte sequence");
      return byte;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j = i2 * 2;
        array[i2] = parseHexByte(hex.slice(j, j + 2));
      }
      return array;
    }
    function concatBytes(...arrays) {
      if (arrays.length === 1)
        return arrays[0];
      const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length2);
      for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
        const arr = arrays[i2];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    function utf8ToBytes(utf) {
      return new TextEncoder().encode(utf);
    }
    function numberToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      const hex = integer.toString(16);
      return hex.length % 2 ? `0${hex}` : hex;
    }
    function padToEven(a) {
      return a.length % 2 ? `0${a}` : a;
    }
    function isHexPrefixed(str) {
      return str.length >= 2 && str[0] === "0" && str[1] === "x";
    }
    function stripHexPrefix2(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function toBytes(v) {
      if (v instanceof Uint8Array) {
        return v;
      }
      if (typeof v === "string") {
        if (isHexPrefixed(v)) {
          return hexToBytes(padToEven(stripHexPrefix2(v)));
        }
        return utf8ToBytes(v);
      }
      if (typeof v === "number" || typeof v === "bigint") {
        if (!v) {
          return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
      }
      if (v === null || v === void 0) {
        return Uint8Array.from([]);
      }
      throw new Error("toBytes: received unsupported type " + typeof v);
    }
    exports.utils = {
      bytesToHex,
      concatBytes,
      hexToBytes,
      utf8ToBytes
    };
    exports.RLP = { encode: encode3, decode: decode3 };
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n2) {
      if (!Number.isSafeInteger(n2) || n2 < 0)
        throw new Error(`Wrong positive integer: ${n2}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    exports.default = assert;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n2, le = false) {
      if (le)
        return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
      return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i2 = 0; i2 < lst.length; i2++) {
        const { h, l } = fromBig(lst[i2], le);
        [Ah[i2], Al[i2]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, l, s) => h >>> s;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H = (h, l) => l;
    var rotr32L = (h, l) => h;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u64 = {
      fromBig,
      split,
      toBig: exports.toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/utils.js
var require_utils4 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto3();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i2 = 0; i2 < uint8a.length; i2++) {
        hex += hexes[uint8a[i2]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j = i2 * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick2 = async () => {
    };
    exports.nextTick = nextTick2;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length2);
      for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
        const arr = arrays[i2];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils4();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t2 = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t2 ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t2);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t2 = 0; t2 < 24; t2++) {
          const shift = SHA3_ROTL[t2];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t2];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.number(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i2 = 0; i2 < take; i2++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js
var require_utils5 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    var _assert_1 = __importDefault(require_assert2());
    var utils_1 = require_utils4();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils4();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    exports.bytesToUtf8 = bytesToUtf8;
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    exports.hexToBytes = hexToBytes;
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    exports.equalsBytes = equalsBytes;
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.wrapHash = wrapHash;
    exports.crypto = (() => {
      const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js
var require_keccak = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils5();
    exports.keccak224 = (0, utils_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/@ethereumjs/util/dist/internal.js
var require_internal = __commonJS({
  "node_modules/@ethereumjs/util/dist/internal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix2 = (str) => {
      if (typeof str !== "string")
        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports.stripHexPrefix = stripHexPrefix2;
    function padToEven(value2) {
      let a = value2;
      if (typeof a !== "string") {
        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
      }
      if (a.length % 2)
        a = `0${a}`;
      return a;
    }
    exports.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
      }
      if (Array.isArray(subset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
      }
      return subset[some === true ? "some" : "every"]((value2) => superset.indexOf(value2) >= 0);
    }
    exports.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      let str = "";
      let i2 = 0;
      const l = hex.length;
      if (hex.substring(0, 2) === "0x")
        i2 = 2;
      for (; i2 < l; i2 += 2) {
        const code = parseInt(hex.substr(i2, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports.toAscii = toAscii;
    function fromUtf8(stringValue) {
      const str = Buffer.from(stringValue, "utf8");
      return `0x${padToEven(str.toString("hex")).replace(/^0+|0+$/g, "")}`;
    }
    exports.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      let hex = "";
      for (let i2 = 0; i2 < stringValue.length; i2++) {
        const code = stringValue.charCodeAt(i2);
        const n2 = code.toString(16);
        hex += n2.length < 2 ? `0${n2}` : n2;
      }
      return `0x${hex}`;
    }
    exports.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
      }
      if (typeof key !== "string") {
        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
      }
      const result = [];
      for (let i2 = 0; i2 < params.length; i2++) {
        let value2 = params[i2][key];
        if (allowEmpty === true && !value2) {
          value2 = "";
        } else if (typeof value2 !== "string") {
          throw new Error(`invalid abi - expected type 'string', received ${typeof value2}`);
        }
        result.push(value2);
      }
      return result;
    }
    exports.getKeys = getKeys;
    function isHexString(value2, length2) {
      if (typeof value2 !== "string" || !value2.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (typeof length2 !== "undefined" && length2 > 0 && value2.length !== 2 + 2 * length2)
        return false;
      return true;
    }
    exports.isHexString = isHexString;
  }
});

// node_modules/@ethereumjs/util/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/@ethereumjs/util/dist/helpers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;
    var internal_1 = require_internal();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        const msg = `This method only supports Buffer but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        const msg = `This method only supports number arrays but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        const msg = `This method only supports strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsString = assertIsString;
  }
});

// node_modules/@ethereumjs/util/dist/bytes.js
var require_bytes = __commonJS({
  "node_modules/@ethereumjs/util/dist/bytes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var intToHex = function(i2) {
      if (!Number.isSafeInteger(i2) || i2 < 0) {
        throw new Error(`Received an invalid integer type: ${i2}`);
      }
      return `0x${i2.toString(16)}`;
    };
    exports.intToHex = intToHex;
    var intToBuffer = function(i2) {
      const hex = (0, exports.intToHex)(i2);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.zeros = zeros;
    var setLength = function(msg, length2, right) {
      const buf = (0, exports.zeros)(length2);
      if (right) {
        if (msg.length < length2) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length2);
      } else {
        if (msg.length < length2) {
          msg.copy(buf, length2 - msg.length);
          return buf;
        }
        return msg.slice(-length2);
      }
    };
    var setLengthLeft = function(msg, length2) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length2, false);
    };
    exports.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length2) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length2, true);
    };
    exports.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      let first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
    };
    exports.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return "0x" + stripZeros(a);
    };
    exports.unpadHexString = unpadHexString;
    var toBuffer = function(v) {
      if (v === null || v === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_1.isHexString)(v)) {
          throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports.intToBuffer)(v);
      }
      if (typeof v === "bigint") {
        if (v < BigInt(0)) {
          throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);
        }
        let n2 = v.toString(16);
        if (n2.length % 2)
          n2 = "0" + n2;
        return Buffer.from(n2, "hex");
      }
      if (v.toArray) {
        return Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports.toBuffer = toBuffer;
    var bufferToHex = function(buf) {
      buf = (0, exports.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports.bufferToHex = bufferToHex;
    function bufferToBigInt2(buf) {
      const hex = (0, exports.bufferToHex)(buf);
      if (hex === "0x") {
        return BigInt(0);
      }
      return BigInt(hex);
    }
    exports.bufferToBigInt = bufferToBigInt2;
    function bigIntToBuffer2(num) {
      return (0, exports.toBuffer)("0x" + num.toString(16));
    }
    exports.bigIntToBuffer = bigIntToBuffer2;
    var bufferToInt = function(buf) {
      const res = Number(bufferToBigInt2(buf));
      if (!Number.isSafeInteger(res))
        throw new Error("Number exceeds 53 bits");
      return res;
    };
    exports.bufferToInt = bufferToInt;
    var fromSigned2 = function(num) {
      return BigInt.asIntN(256, bufferToBigInt2(num));
    };
    exports.fromSigned = fromSigned2;
    var toUnsigned2 = function(num) {
      return bigIntToBuffer2(BigInt.asUintN(256, num));
    };
    exports.toUnsigned = toUnsigned2;
    var addHexPrefix2 = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports.addHexPrefix = addHexPrefix2;
    function short(buffer, maxLength = 50) {
      const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString("hex") : buffer;
      if (bufferStr.length <= maxLength) {
        return bufferStr;
      }
      return bufferStr.slice(0, maxLength) + "…";
    }
    exports.short = short;
    var toUtf8 = function(hex) {
      const zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      const bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return `0x${ba.toString("hex")}`;
      } else if (ba instanceof Array) {
        const array = [];
        for (let i2 = 0; i2 < ba.length; i2++) {
          array.push((0, exports.baToJSON)(ba[i2]));
        }
        return array;
      }
    };
    exports.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      for (const [k, v] of Object.entries(values)) {
        if (v !== void 0 && v.length > 0 && v[0] === 0) {
          throw new Error(`${k} cannot have leading zeroes, received: ${v.toString("hex")}`);
        }
      }
    };
    exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map((a) => arrToBufArr(a));
    }
    exports.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr ?? []);
      }
      return arr.map((a) => bufArrToArr(a));
    }
    exports.bufArrToArr = bufArrToArr;
    var bigIntToHex2 = (num) => {
      return "0x" + num.toString(16);
    };
    exports.bigIntToHex = bigIntToHex2;
    function bigIntToUnpaddedBuffer(value2) {
      return (0, exports.unpadBuffer)(bigIntToBuffer2(value2));
    }
    exports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;
    function intToUnpaddedBuffer(value2) {
      return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value2));
    }
    exports.intToUnpaddedBuffer = intToUnpaddedBuffer;
  }
});

// node_modules/@ethereumjs/util/dist/account.js
var require_account = __commonJS({
  "node_modules/@ethereumjs/util/dist/account.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
    var rlp_1 = require_dist2();
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k12();
    var utils_1 = require_utils5();
    var bytes_1 = require_bytes();
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var _0n = BigInt(0);
    var Account = class {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating an Account from varying data types.
       */
      constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
        this.nonce = nonce;
        this.balance = balance;
        this.storageRoot = storageRoot;
        this.codeHash = codeHash;
        this._validate();
      }
      static fromAccountData(accountData) {
        const { nonce, balance, storageRoot, codeHash } = accountData;
        return new Account(nonce !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : void 0, balance !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : void 0, storageRoot !== void 0 ? (0, bytes_1.toBuffer)(storageRoot) : void 0, codeHash !== void 0 ? (0, bytes_1.toBuffer)(codeHash) : void 0);
      }
      static fromRlpSerializedAccount(serialized) {
        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized account input. Must be array");
        }
        return this.fromValuesArray(values);
      }
      static fromValuesArray(values) {
        const [nonce, balance, storageRoot, codeHash] = values;
        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);
      }
      _validate() {
        if (this.nonce < _0n) {
          throw new Error("nonce must be greater than zero");
        }
        if (this.balance < _0n) {
          throw new Error("balance must be greater than zero");
        }
        if (this.storageRoot.length !== 32) {
          throw new Error("storageRoot must have a length of 32");
        }
        if (this.codeHash.length !== 32) {
          throw new Error("codeHash must have a length of 32");
        }
      }
      /**
       * Returns a Buffer Array of the raw Buffers for the account, in order.
       */
      raw() {
        return [
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),
          this.storageRoot,
          this.codeHash
        ];
      }
      /**
       * Returns the RLP serialization of the account as a `Buffer`.
       */
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));
      }
      /**
       * Returns a `Boolean` determining if the account is a contract.
       */
      isContract() {
        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
      /**
       * Returns a `Boolean` determining if the account is empty complying to the definition of
       * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
       * "An account is considered empty when it has no code and zero nonce and zero balance."
       */
      isEmpty() {
        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
    };
    exports.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e2) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      let prefix = "";
      if (eip1191ChainId !== void 0) {
        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));
        prefix = chainId.toString() + "0x";
      }
      const buf = Buffer.from(prefix + address, "utf8");
      const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));
      let ret = "0x";
      for (let i2 = 0; i2 < address.length; i2++) {
        if (parseInt(hash[i2], 16) >= 8) {
          ret += address[i2].toUpperCase();
        } else {
          ret += address[i2];
        }
      }
      return ret;
    };
    exports.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);
      }
      return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);
    };
    exports.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      if (from.length !== 20) {
        throw new Error("Expected from to be of length 20");
      }
      if (salt.length !== 32) {
        throw new Error("Expected salt to be of length 32");
      }
      const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, keccak_1.keccak256)(initCode)]));
      return (0, bytes_1.toBuffer)(address).slice(-20);
    };
    exports.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);
    };
    exports.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        try {
          secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));
          return true;
        } catch (e2) {
          return false;
        }
      }
      if (!sanitize) {
        return false;
      }
      try {
        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
        return true;
      } catch (e2) {
        return false;
      }
    };
    exports.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));
      }
      if (pubKey.length !== 64) {
        throw new Error("Expected pubKey to be of length 64");
      }
      return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
    };
    exports.pubToAddress = pubToAddress;
    exports.publicToAddress = exports.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));
    };
    exports.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
    };
    exports.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));
      }
      return publicKey;
    };
    exports.importPublic = importPublic;
    var zeroAddress = function() {
      const addressLength = 20;
      const addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e2) {
        return false;
      }
      const zeroAddr = (0, exports.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports.isZeroAddress = isZeroAddress;
    function accountBodyFromSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash
      ];
    }
    exports.accountBodyFromSlim = accountBodyFromSlim;
    var emptyUint8Arr = new Uint8Array(0);
    function accountBodyToSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash
      ];
    }
    exports.accountBodyToSlim = accountBodyToSlim;
    function accountBodyToRLP(body, couldBeSlim = true) {
      const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;
      return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));
    }
    exports.accountBodyToRLP = accountBodyToRLP;
  }
});

// node_modules/@ethereumjs/util/dist/address.js
var require_address = __commonJS({
  "node_modules/@ethereumjs/util/dist/address.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address = void 0;
    var account_1 = require_account();
    var bytes_1 = require_bytes();
    var Address = class {
      constructor(buf) {
        if (buf.length !== 20) {
          throw new Error("Invalid address length");
        }
        this.buf = buf;
      }
      /**
       * Returns the zero address.
       */
      static zero() {
        return new Address((0, bytes_1.zeros)(20));
      }
      /**
       * Returns an Address object from a hex-encoded string.
       * @param str - Hex-encoded address
       */
      static fromString(str) {
        if (!(0, account_1.isValidAddress)(str)) {
          throw new Error("Invalid address");
        }
        return new Address((0, bytes_1.toBuffer)(str));
      }
      /**
       * Returns an address for a given public key.
       * @param pubKey The two points of an uncompressed key
       */
      static fromPublicKey(pubKey) {
        if (!Buffer.isBuffer(pubKey)) {
          throw new Error("Public key should be Buffer");
        }
        const buf = (0, account_1.pubToAddress)(pubKey);
        return new Address(buf);
      }
      /**
       * Returns an address for a given private key.
       * @param privateKey A private key must be 256 bits wide
       */
      static fromPrivateKey(privateKey) {
        if (!Buffer.isBuffer(privateKey)) {
          throw new Error("Private key should be Buffer");
        }
        const buf = (0, account_1.privateToAddress)(privateKey);
        return new Address(buf);
      }
      /**
       * Generates an address for a newly created contract.
       * @param from The address which is creating this new address
       * @param nonce The nonce of the from account
       */
      static generate(from, nonce) {
        if (typeof nonce !== "bigint") {
          throw new Error("Expected nonce to be a bigint");
        }
        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));
      }
      /**
       * Generates an address for a contract created using CREATE2.
       * @param from The address which is creating this new address
       * @param salt A salt
       * @param initCode The init code of the contract being created
       */
      static generate2(from, salt, initCode) {
        if (!Buffer.isBuffer(salt)) {
          throw new Error("Expected salt to be a Buffer");
        }
        if (!Buffer.isBuffer(initCode)) {
          throw new Error("Expected initCode to be a Buffer");
        }
        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
      }
      /**
       * Is address equal to another.
       */
      equals(address) {
        return this.buf.equals(address.buf);
      }
      /**
       * Is address zero.
       */
      isZero() {
        return this.equals(Address.zero());
      }
      /**
       * True if address is in the address range defined
       * by EIP-1352
       */
      isPrecompileOrSystemAddress() {
        const address = (0, bytes_1.bufferToBigInt)(this.buf);
        const rangeMin = BigInt(0);
        const rangeMax = BigInt("0xffff");
        return address >= rangeMin && address <= rangeMax;
      }
      /**
       * Returns hex encoding of address.
       */
      toString() {
        return "0x" + this.buf.toString("hex");
      }
      /**
       * Returns Buffer representation of address.
       */
      toBuffer() {
        return Buffer.from(this.buf);
      }
    };
    exports.Address = Address;
  }
});

// node_modules/@ethereumjs/util/dist/types.js
var require_types = __commonJS({
  "node_modules/@ethereumjs/util/dist/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toType = exports.TypeOutput = void 0;
    var bytes_1 = require_bytes();
    var internal_1 = require_internal();
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      const output = (0, bytes_1.toBuffer)(input);
      switch (outputType) {
        case TypeOutput.Buffer:
          return output;
        case TypeOutput.BigInt:
          return (0, bytes_1.bufferToBigInt)(output);
        case TypeOutput.Number: {
          const bigInt = (0, bytes_1.bufferToBigInt)(output);
          if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
          }
          return Number(bigInt);
        }
        case TypeOutput.PrefixedHexString:
          return (0, bytes_1.bufferToHex)(output);
        default:
          throw new Error("unknown outputType");
      }
    }
    exports.toType = toType;
  }
});

// node_modules/@ethereumjs/util/dist/withdrawal.js
var require_withdrawal = __commonJS({
  "node_modules/@ethereumjs/util/dist/withdrawal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Withdrawal = void 0;
    var address_1 = require_address();
    var bytes_1 = require_bytes();
    var types_1 = require_types();
    var Withdrawal = class {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
       * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
       */
      constructor(index, validatorIndex, address, amount) {
        this.index = index;
        this.validatorIndex = validatorIndex;
        this.address = address;
        this.amount = amount;
      }
      static fromWithdrawalData(withdrawalData) {
        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;
        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);
        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);
        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));
        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);
        return new Withdrawal(index, validatorIndex, address, amount);
      }
      static fromValuesArray(withdrawalArray) {
        if (withdrawalArray.length !== 4) {
          throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);
        }
        const [index, validatorIndex, address, amount] = withdrawalArray;
        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });
      }
      /**
       * Convert a withdrawal to a buffer array
       * @param withdrawal the withdrawal to convert
       * @returns buffer array of the withdrawal
       */
      static toBufferArray(withdrawal) {
        const { index, validatorIndex, address, amount } = withdrawal;
        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);
        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);
        let addressBuffer;
        if (address instanceof address_1.Address) {
          addressBuffer = address.buf;
        } else {
          addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);
        }
        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);
        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];
      }
      raw() {
        return Withdrawal.toBufferArray(this);
      }
      toValue() {
        return {
          index: this.index,
          validatorIndex: this.validatorIndex,
          address: this.address.buf,
          amount: this.amount
        };
      }
      toJSON() {
        return {
          index: (0, bytes_1.bigIntToHex)(this.index),
          validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),
          address: "0x" + this.address.buf.toString("hex"),
          amount: (0, bytes_1.bigIntToHex)(this.amount)
        };
      }
    };
    exports.Withdrawal = Withdrawal;
  }
});

// node_modules/@ethereumjs/util/dist/signature.js
var require_signature = __commonJS({
  "node_modules/@ethereumjs/util/dist/signature.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k12();
    var bytes_1 = require_bytes();
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    function ecsign2(msgHash, privateKey, chainId) {
      const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);
      const buf = sig.toCompactRawBytes();
      const r2 = Buffer.from(buf.slice(0, 32));
      const s = Buffer.from(buf.slice(32, 64));
      const v = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);
      return { r: r2, s, v };
    }
    exports.ecsign = ecsign2;
    function calculateSigRecovery(v, chainId) {
      if (v === BigInt(0) || v === BigInt(1))
        return v;
      if (chainId === void 0) {
        return v - BigInt(27);
      }
      return v - (chainId * BigInt(2) + BigInt(35));
    }
    function isValidSigRecovery(recovery) {
      return recovery === BigInt(0) || recovery === BigInt(1);
    }
    var ecrecover = function(msgHash, v, r2, s, chainId) {
      const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r2, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
      const senderPubKey = sig.recoverPublicKey(msgHash);
      return Buffer.from(senderPubKey.toRawBytes(false).slice(1));
    };
    exports.ecrecover = ecrecover;
    var toRpcSig = function(v, r2, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r2, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
    };
    exports.toRpcSig = toRpcSig;
    var toCompactSig = function(v, r2, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      let ss = s;
      if (v > BigInt(28) && v % BigInt(2) === BigInt(1) || v === BigInt(1) || v === BigInt(28)) {
        ss = Buffer.from(s);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r2, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      const buf = (0, bytes_1.toBuffer)(sig);
      let r2;
      let s;
      let v;
      if (buf.length >= 65) {
        r2 = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r2 = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);
        s[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v < 27) {
        v = v + BigInt(27);
      }
      return {
        v,
        r: r2,
        s
      };
    };
    exports.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v, r2, s, homesteadOrLater = true, chainId) {
      if (r2.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      const rBigInt = (0, bytes_1.bufferToBigInt)(r2);
      const sBigInt = (0, bytes_1.bufferToBigInt)(s);
      if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {
        return false;
      }
      if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {
        return false;
      }
      return true;
    };
    exports.isValidSignature = isValidSignature;
    var hashPersonalMessage2 = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      const prefix = Buffer.from(`Ethereum Signed Message:
${message.length}`, "utf-8");
      return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));
    };
    exports.hashPersonalMessage = hashPersonalMessage2;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/gindex.js
var require_gindex = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/gindex.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;
    function bitIndexBigInt(v) {
      return v.toString(2).length - 1;
    }
    exports.bitIndexBigInt = bitIndexBigInt;
    function toGindex(depth, index) {
      const anchor = BigInt(1) << BigInt(depth);
      if (index >= anchor) {
        throw new Error(`index ${index} too large for depth ${depth}`);
      }
      return anchor | index;
    }
    exports.toGindex = toGindex;
    function toGindexBitstring(depth, index) {
      const str = index ? Number(index).toString(2) : "";
      if (str.length > depth) {
        throw new Error("index too large for depth");
      } else {
        return "1" + str.padStart(depth, "0");
      }
    }
    exports.toGindexBitstring = toGindexBitstring;
    function convertGindexToBitstring(gindex) {
      if (typeof gindex === "string") {
        if (gindex.length === 0) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        return gindex;
      } else {
        if (gindex < 1) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        return gindex.toString(2);
      }
    }
    exports.convertGindexToBitstring = convertGindexToBitstring;
    function countToDepth(count) {
      if (count <= 1) {
        return 0;
      }
      return (count - BigInt(1)).toString(2).length;
    }
    exports.countToDepth = countToDepth;
    function iterateAtDepth(depth, startIndex, count) {
      const anchor = BigInt(1) << BigInt(depth);
      if (startIndex + count > anchor) {
        throw new Error("Too large for depth");
      }
      let i2 = toGindex(depth, startIndex);
      const last = i2 + count;
      return {
        [Symbol.iterator]() {
          return {
            next() {
              if (i2 < last) {
                const value2 = i2;
                i2++;
                return { done: false, value: value2 };
              } else {
                return { done: true, value: void 0 };
              }
            }
          };
        }
      };
    }
    exports.iterateAtDepth = iterateAtDepth;
    function getGindicesAtDepth(depth, startIndex, count) {
      const anchor = BigInt(1) << BigInt(depth);
      if (startIndex + count > anchor) {
        throw new Error("Too large for depth");
      }
      let gindex = toGindex(depth, BigInt(startIndex));
      const gindices = [];
      for (let i2 = 0; i2 < count; i2++) {
        gindices.push(gindex++);
      }
      return gindices;
    }
    exports.getGindicesAtDepth = getGindicesAtDepth;
    var ERR_INVALID_GINDEX = "Invalid gindex";
    function gindexIterator(gindex) {
      let bitstring;
      if (typeof gindex === "string") {
        if (!gindex.length) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex;
      } else {
        if (gindex < 1) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex.toString(2);
      }
      let i2 = 1;
      const next = () => {
        if (i2 === bitstring.length) {
          return { done: true, value: void 0 };
        }
        const bit = Number(bitstring[i2]);
        i2++;
        return { done: false, value: bit };
      };
      return {
        [Symbol.iterator]() {
          return { next };
        },
        remainingBitLength() {
          return bitstring.length - i2;
        }
      };
    }
    exports.gindexIterator = gindexIterator;
    function getGindexBits(gindex) {
      let bitstring;
      if (typeof gindex === "string") {
        if (!gindex.length) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex;
      } else {
        if (gindex < 1) {
          throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex.toString(2);
      }
      const bits = [];
      for (let i2 = 1; i2 < bitstring.length; i2++) {
        bits.push(Number(bitstring[i2]));
      }
      return bits;
    }
    exports.getGindexBits = getGindexBits;
    function concatGindices(gindices) {
      return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), "0b1"));
    }
    exports.concatGindices = concatGindices;
    function gindexSibling(gindex) {
      return gindex ^ BigInt(1);
    }
    exports.gindexSibling = gindexSibling;
    function gindexParent(gindex) {
      return gindex / BigInt(2);
    }
    exports.gindexParent = gindexParent;
    function gindexChild(gindex, rightChild) {
      return gindex * BigInt(2) + BigInt(rightChild);
    }
    exports.gindexChild = gindexChild;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/_sha2.js
var require_sha22 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils4();
    function setBigUint64(view, byteOffset, value2, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value2, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value2 >> _32n & _u32_max);
      const wl = Number(value2 & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
        to.length = length2;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length2 % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha22();
    var utils_js_1 = require_utils4();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W[i2 - 15];
          const W2 = SHA256_W[i2 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/as-sha256/lib/hashObject.js
var require_hashObject = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/as-sha256/lib/hashObject.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.byteArrayToHashObject = exports.hashObjectToByteArray = void 0;
    function hashObjectToByteArray(obj, byteArr, offset) {
      let tmp = obj.h0;
      byteArr[0 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[1 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[2 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[3 + offset] = tmp & 255;
      tmp = obj.h1;
      byteArr[4 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[5 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[6 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[7 + offset] = tmp & 255;
      tmp = obj.h2;
      byteArr[8 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[9 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[10 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[11 + offset] = tmp & 255;
      tmp = obj.h3;
      byteArr[12 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[13 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[14 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[15 + offset] = tmp & 255;
      tmp = obj.h4;
      byteArr[16 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[17 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[18 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[19 + offset] = tmp & 255;
      tmp = obj.h5;
      byteArr[20 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[21 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[22 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[23 + offset] = tmp & 255;
      tmp = obj.h6;
      byteArr[24 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[25 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[26 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[27 + offset] = tmp & 255;
      tmp = obj.h7;
      byteArr[28 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[29 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[30 + offset] = tmp & 255;
      tmp = tmp >> 8;
      byteArr[31 + offset] = tmp & 255;
    }
    exports.hashObjectToByteArray = hashObjectToByteArray;
    function byteArrayToHashObject(byteArr) {
      let tmp = 0;
      tmp |= byteArr[3] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[2] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[1] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[0] & 255;
      const h0 = tmp;
      tmp = 0;
      tmp |= byteArr[7] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[6] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[5] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[4] & 255;
      const h1 = tmp;
      tmp = 0;
      tmp |= byteArr[11] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[10] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[9] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[8] & 255;
      const h2 = tmp;
      tmp = 0;
      tmp |= byteArr[15] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[14] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[13] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[12] & 255;
      const h3 = tmp;
      tmp = 0;
      tmp |= byteArr[19] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[18] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[17] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[16] & 255;
      const h4 = tmp;
      tmp = 0;
      tmp |= byteArr[23] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[22] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[21] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[20] & 255;
      const h5 = tmp;
      tmp = 0;
      tmp |= byteArr[27] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[26] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[25] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[24] & 255;
      const h6 = tmp;
      tmp = 0;
      tmp |= byteArr[31] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[30] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[29] & 255;
      tmp = tmp << 8;
      tmp |= byteArr[28] & 255;
      const h7 = tmp;
      return {
        h0,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        h7
      };
    }
    exports.byteArrayToHashObject = byteArrayToHashObject;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/util.js
var require_util2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint8ArrayToHashObject = exports.hashObjectToUint8Array = void 0;
    var hashObject_1 = require_hashObject();
    function hashObjectToUint8Array(obj) {
      const byteArr = new Uint8Array(32);
      hashObject_1.hashObjectToByteArray(obj, byteArr, 0);
      return byteArr;
    }
    exports.hashObjectToUint8Array = hashObjectToUint8Array;
    function uint8ArrayToHashObject(byteArr) {
      return hashObject_1.byteArrayToHashObject(byteArr);
    }
    exports.uint8ArrayToHashObject = uint8ArrayToHashObject;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/noble.js
var require_noble = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/noble.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasher = void 0;
    var sha256_1 = require_sha2562();
    var util_1 = require_util2();
    var digest64 = (a, b) => sha256_1.sha256.create().update(a).update(b).digest();
    exports.hasher = {
      digest64,
      digest64HashObjects: (a, b) => util_1.uint8ArrayToHashObject(digest64(util_1.hashObjectToUint8Array(a), util_1.hashObjectToUint8Array(b)))
    };
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/types.js
var require_types2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/index.js
var require_hasher = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/hasher/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setHasher = exports.hasher = void 0;
    var noble_1 = require_noble();
    __exportStar(require_types2(), exports);
    __exportStar(require_util2(), exports);
    exports.hasher = noble_1.hasher;
    function setHasher(newHasher) {
      exports.hasher = newHasher;
    }
    exports.setHasher = setHasher;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/node.js
var require_node = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/node.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;
    var hasher_1 = require_hasher();
    var TWO_POWER_32 = 2 ** 32;
    var Node = class {
      constructor(h0, h1, h2, h3, h4, h5, h6, h7) {
        this.h0 = h0;
        this.h1 = h1;
        this.h2 = h2;
        this.h3 = h3;
        this.h4 = h4;
        this.h5 = h5;
        this.h6 = h6;
        this.h7 = h7;
      }
      applyHash(root) {
        this.h0 = root.h0;
        this.h1 = root.h1;
        this.h2 = root.h2;
        this.h3 = root.h3;
        this.h4 = root.h4;
        this.h5 = root.h5;
        this.h6 = root.h6;
        this.h7 = root.h7;
      }
    };
    exports.Node = Node;
    var BranchNode = class extends Node {
      constructor(_left, _right) {
        super(null, 0, 0, 0, 0, 0, 0, 0);
        this._left = _left;
        this._right = _right;
        if (!_left) {
          throw new Error("Left node is undefined");
        }
        if (!_right) {
          throw new Error("Right node is undefined");
        }
      }
      get rootHashObject() {
        if (this.h0 === null) {
          super.applyHash(hasher_1.hasher.digest64HashObjects(this.left.rootHashObject, this.right.rootHashObject));
        }
        return this;
      }
      get root() {
        return hasher_1.hashObjectToUint8Array(this.rootHashObject);
      }
      isLeaf() {
        return false;
      }
      get left() {
        return this._left;
      }
      get right() {
        return this._right;
      }
    };
    exports.BranchNode = BranchNode;
    var LeafNode = class extends Node {
      static fromRoot(root) {
        return this.fromHashObject(hasher_1.uint8ArrayToHashObject(root));
      }
      /**
       * New LeafNode from existing HashObject.
       */
      static fromHashObject(ho) {
        return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);
      }
      /**
       * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.
       */
      static fromZero() {
        return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
       * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.
       */
      static fromUint32(uint32) {
        return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
       * Create a new LeafNode with the same internal values. The returned instance is safe to mutate
       */
      clone() {
        return LeafNode.fromHashObject(this);
      }
      get rootHashObject() {
        return this;
      }
      get root() {
        return hasher_1.hashObjectToUint8Array(this);
      }
      isLeaf() {
        return true;
      }
      get left() {
        throw Error("LeafNode has no left node");
      }
      get right() {
        throw Error("LeafNode has no right node");
      }
      writeToBytes(data, start, size) {
        data.set(this.root.slice(0, size), start);
      }
      getUint(uintBytes, offsetBytes, clipInfinity) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          const h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            return 255 & h >> bitIndex;
          } else {
            return 65535 & h >> bitIndex;
          }
        } else if (uintBytes === 4) {
          return getNodeH(this, hIndex) >>> 0;
        } else if (uintBytes === 8) {
          const low = getNodeH(this, hIndex);
          const high = getNodeH(this, hIndex + 1);
          if (high === 0) {
            return low >>> 0;
          } else if (high === -1 && low === -1 && clipInfinity) {
            return Infinity;
          } else {
            return (low >>> 0) + (high >>> 0) * TWO_POWER_32;
          }
        } else {
          throw Error("uintBytes > 8");
        }
      }
      getUintBigint(uintBytes, offsetBytes) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          const h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            return BigInt(255 & h >> bitIndex);
          } else {
            return BigInt(65535 & h >> bitIndex);
          }
        } else if (uintBytes === 4) {
          return BigInt(getNodeH(this, hIndex) >>> 0);
        } else {
          const hRange = Math.ceil(uintBytes / 4);
          let v = BigInt(0);
          for (let i2 = 0; i2 < hRange; i2++) {
            v += BigInt(getNodeH(this, hIndex + i2) >>> 0) << BigInt(32 * i2);
          }
          return v;
        }
      }
      setUint(uintBytes, offsetBytes, value2, clipInfinity) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          let h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            h &= ~(255 << bitIndex);
            h |= value2 << bitIndex;
          } else {
            h &= ~(65535 << bitIndex);
            h |= value2 << bitIndex;
          }
          setNodeH(this, hIndex, h);
        } else if (uintBytes === 4) {
          setNodeH(this, hIndex, value2);
        } else if (uintBytes === 8) {
          if (value2 === Infinity && clipInfinity) {
            setNodeH(this, hIndex, -1);
            setNodeH(this, hIndex + 1, -1);
          } else {
            setNodeH(this, hIndex, value2 & 4294967295);
            setNodeH(this, hIndex + 1, value2 / TWO_POWER_32 & 4294967295);
          }
        } else {
          throw Error("uintBytes > 8");
        }
      }
      setUintBigint(uintBytes, offsetBytes, valueBN) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const value2 = Number(valueBN);
          const bitIndex = offsetBytes % 4 * 8;
          let h = getNodeH(this, hIndex);
          if (uintBytes === 1) {
            h &= ~(255 << bitIndex);
            h |= value2 << bitIndex;
          } else {
            h &= ~(65535 << bitIndex);
            h |= value2 << bitIndex;
          }
          setNodeH(this, hIndex, h);
        } else if (uintBytes === 4) {
          setNodeH(this, hIndex, Number(valueBN));
        } else {
          const hEnd = hIndex + Math.ceil(uintBytes / 4);
          for (let i2 = hIndex; i2 < hEnd; i2++) {
            setNodeH(this, i2, Number(valueBN & BigInt(4294967295)));
            valueBN = valueBN >> BigInt(32);
          }
        }
      }
      bitwiseOrUint(uintBytes, offsetBytes, value2) {
        const hIndex = Math.floor(offsetBytes / 4);
        if (uintBytes < 4) {
          const bitIndex = offsetBytes % 4 * 8;
          bitwiseOrNodeH(this, hIndex, value2 << bitIndex);
        } else if (uintBytes === 4) {
          bitwiseOrNodeH(this, hIndex, value2);
        } else {
          const hEnd = hIndex + Math.ceil(uintBytes / 4);
          for (let i2 = hIndex; i2 < hEnd; i2++) {
            bitwiseOrNodeH(this, i2, value2 & 4294967295);
            value2 >>= 32;
          }
        }
      }
    };
    exports.LeafNode = LeafNode;
    function identity(n2) {
      return n2;
    }
    exports.identity = identity;
    function compose(inner, outer) {
      return function(n2) {
        return outer(inner(n2));
      };
    }
    exports.compose = compose;
    function getNodeH(node, hIndex) {
      if (hIndex === 0)
        return node.h0;
      else if (hIndex === 1)
        return node.h1;
      else if (hIndex === 2)
        return node.h2;
      else if (hIndex === 3)
        return node.h3;
      else if (hIndex === 4)
        return node.h4;
      else if (hIndex === 5)
        return node.h5;
      else if (hIndex === 6)
        return node.h6;
      else if (hIndex === 7)
        return node.h7;
      else
        throw Error("hIndex > 7");
    }
    exports.getNodeH = getNodeH;
    function setNodeH(node, hIndex, value2) {
      if (hIndex === 0)
        node.h0 = value2;
      else if (hIndex === 1)
        node.h1 = value2;
      else if (hIndex === 2)
        node.h2 = value2;
      else if (hIndex === 3)
        node.h3 = value2;
      else if (hIndex === 4)
        node.h4 = value2;
      else if (hIndex === 5)
        node.h5 = value2;
      else if (hIndex === 6)
        node.h6 = value2;
      else if (hIndex === 7)
        node.h7 = value2;
      else
        throw Error("hIndex > 7");
    }
    exports.setNodeH = setNodeH;
    function bitwiseOrNodeH(node, hIndex, value2) {
      if (hIndex === 0)
        node.h0 |= value2;
      else if (hIndex === 1)
        node.h1 |= value2;
      else if (hIndex === 2)
        node.h2 |= value2;
      else if (hIndex === 3)
        node.h3 |= value2;
      else if (hIndex === 4)
        node.h4 |= value2;
      else if (hIndex === 5)
        node.h5 |= value2;
      else if (hIndex === 6)
        node.h6 |= value2;
      else if (hIndex === 7)
        node.h7 |= value2;
      else
        throw Error("hIndex > 7");
    }
    exports.bitwiseOrNodeH = bitwiseOrNodeH;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/zeroNode.js
var require_zeroNode = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/zeroNode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroNode = void 0;
    var node_1 = require_node();
    var zeroes = [node_1.LeafNode.fromZero()];
    function zeroNode(height) {
      if (height >= zeroes.length) {
        for (let i2 = zeroes.length; i2 <= height; i2++) {
          zeroes[i2] = new node_1.BranchNode(zeroes[i2 - 1], zeroes[i2 - 1]);
        }
      }
      return zeroes[height];
    }
    exports.zeroNode = zeroNode;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/subtree.js
var require_subtree = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/subtree.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;
    var node_1 = require_node();
    var zeroNode_1 = require_zeroNode();
    function subtreeFillToDepth(bottom, depth) {
      let node = bottom;
      while (depth > 0) {
        node = new node_1.BranchNode(node, node);
        depth--;
      }
      return node;
    }
    exports.subtreeFillToDepth = subtreeFillToDepth;
    function subtreeFillToLength(bottom, depth, length2) {
      const maxLength = 1 << depth;
      if (length2 > maxLength)
        throw new Error("ERR_TOO_MANY_NODES");
      if (length2 === maxLength)
        return subtreeFillToDepth(bottom, depth);
      if (depth === 0) {
        if (length2 === 1)
          return bottom;
        else
          throw new Error("ERR_NAVIGATION");
      }
      if (depth === 1) {
        return new node_1.BranchNode(bottom, length2 > 1 ? bottom : zeroNode_1.zeroNode(0));
      }
      const pivot = maxLength >> 1;
      if (length2 <= pivot) {
        return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length2), zeroNode_1.zeroNode(depth - 1));
      } else {
        return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length2 - pivot));
      }
    }
    exports.subtreeFillToLength = subtreeFillToLength;
    function subtreeFillToContents(nodes, depth) {
      const maxLength = 2 ** depth;
      if (nodes.length > maxLength) {
        throw new Error(`nodes.length ${nodes.length} over maxIndex at depth ${depth}`);
      }
      if (nodes.length === 0) {
        return zeroNode_1.zeroNode(depth);
      }
      if (depth === 0) {
        return nodes[0];
      }
      if (depth === 1) {
        return nodes.length > 1 ? (
          // All nodes at depth 1 available
          new node_1.BranchNode(nodes[0], nodes[1])
        ) : (
          // Pad with zero node
          new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0))
        );
      }
      let count = nodes.length;
      for (let d = depth; d > 0; d--) {
        const countRemainder = count % 2;
        const countEven = count - countRemainder;
        for (let i2 = 0; i2 < countEven; i2 += 2) {
          nodes[i2 / 2] = new node_1.BranchNode(nodes[i2], nodes[i2 + 1]);
        }
        if (countRemainder > 0) {
          nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));
        }
        count = countEven / 2 + countRemainder;
      }
      return nodes[0];
    }
    exports.subtreeFillToContents = subtreeFillToContents;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/packedNode.js
var require_packedNode = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/packedNode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;
    var subtree_1 = require_subtree();
    var node_1 = require_node();
    function packedRootsBytesToNode(depth, dataView, start, end) {
      const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);
      return subtree_1.subtreeFillToContents(leafNodes, depth);
    }
    exports.packedRootsBytesToNode = packedRootsBytesToNode;
    function packedRootsBytesToLeafNodes(dataView, start, end) {
      const size = end - start;
      const fullNodeCount = Math.floor(size / 32);
      const leafNodes = new Array(Math.ceil(size / 32));
      for (let i2 = 0; i2 < fullNodeCount; i2++) {
        const offset = start + i2 * 32;
        leafNodes[i2] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));
      }
      const remainderBytes = size % 32;
      if (remainderBytes > 0) {
        const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);
        leafNodes[fullNodeCount] = node;
        const fullHCount = Math.floor(remainderBytes / 4);
        for (let h = 0; h < fullHCount; h++) {
          node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));
        }
        const remainderUint32 = size % 4;
        if (remainderUint32 > 0) {
          let h = 0;
          for (let i2 = 0; i2 < remainderUint32; i2++) {
            h |= dataView.getUint8(start + size - remainderUint32 + i2) << i2 * 8;
          }
          node_1.setNodeH(node, fullHCount, h);
        }
      }
      return leafNodes;
    }
    exports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;
    function packedNodeRootsToBytes(dataView, start, size, nodes) {
      const remainderBytes = size % 32;
      const fullNodeCount = Math.floor(size / 32);
      for (let i2 = 0; i2 < fullNodeCount; i2++) {
        const node = nodes[i2];
        const offset = start + i2 * 32;
        dataView.setInt32(offset + 0, node.h0, true);
        dataView.setInt32(offset + 4, node.h1, true);
        dataView.setInt32(offset + 8, node.h2, true);
        dataView.setInt32(offset + 12, node.h3, true);
        dataView.setInt32(offset + 16, node.h4, true);
        dataView.setInt32(offset + 20, node.h5, true);
        dataView.setInt32(offset + 24, node.h6, true);
        dataView.setInt32(offset + 28, node.h7, true);
      }
      if (remainderBytes > 0) {
        const node = nodes[fullNodeCount];
        const fullHCount = Math.floor(remainderBytes / 4);
        for (let h = 0; h < fullHCount; h++) {
          dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);
        }
        const remainderUint32 = size % 4;
        if (remainderUint32 > 0) {
          const h = node_1.getNodeH(node, fullHCount);
          for (let i2 = 0; i2 < remainderUint32; i2++) {
            dataView.setUint8(start + size - remainderUint32 + i2, h >> i2 * 8 & 255);
          }
        }
      }
    }
    exports.packedNodeRootsToBytes = packedNodeRootsToBytes;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/single.js
var require_single = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/single.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;
    var node_1 = require_node();
    var gindex_1 = require_gindex();
    exports.ERR_INVALID_NAV = "Invalid tree navigation";
    function createSingleProof(rootNode, index) {
      const witnesses = [];
      let node = rootNode;
      for (const i2 of gindex_1.gindexIterator(index)) {
        if (i2) {
          if (node.isLeaf())
            throw new Error(exports.ERR_INVALID_NAV);
          witnesses.push(node.left.root);
          node = node.right;
        } else {
          if (node.isLeaf())
            throw new Error(exports.ERR_INVALID_NAV);
          witnesses.push(node.right.root);
          node = node.left;
        }
      }
      return [node.root, witnesses.reverse()];
    }
    exports.createSingleProof = createSingleProof;
    function createNodeFromSingleProof(gindex, leaf, witnesses) {
      let node = node_1.LeafNode.fromRoot(leaf);
      const w = witnesses.slice().reverse();
      while (gindex > 1) {
        const sibling = node_1.LeafNode.fromRoot(w.pop());
        if (gindex % BigInt(2) === BigInt(0)) {
          node = new node_1.BranchNode(node, sibling);
        } else {
          node = new node_1.BranchNode(sibling, node);
        }
        gindex = gindex / BigInt(2);
      }
      return node;
    }
    exports.createNodeFromSingleProof = createNodeFromSingleProof;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/tree.js
var require_tree = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/tree.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;
    var zeroNode_1 = require_zeroNode();
    var gindex_1 = require_gindex();
    var node_1 = require_node();
    var proof_1 = require_proof();
    var single_1 = require_single();
    var Tree = class {
      constructor(node, hook) {
        this._rootNode = node;
        if (hook) {
          if (typeof WeakRef === "undefined") {
            this.hook = hook;
          } else {
            this.hook = new WeakRef(hook);
          }
        }
      }
      /**
       * Create a `Tree` from a `Proof` object
       */
      static createFromProof(proof) {
        return new Tree(proof_1.createNodeFromProof(proof));
      }
      /**
       * The root node of the tree
       */
      get rootNode() {
        return this._rootNode;
      }
      /**
       *
       * Setting the root node will trigger a call to the tree's `hook` if it exists.
       */
      set rootNode(newRootNode) {
        this._rootNode = newRootNode;
        if (this.hook) {
          if (typeof WeakRef === "undefined") {
            this.hook(newRootNode);
          } else {
            const hookVar = this.hook.deref();
            if (hookVar) {
              hookVar(newRootNode);
            } else {
              this.hook = void 0;
            }
          }
        }
      }
      /**
       * The root hash of the tree
       */
      get root() {
        return this.rootNode.root;
      }
      /**
       * Return a copy of the tree
       */
      clone() {
        return new Tree(this.rootNode);
      }
      /**
       * Return the subtree at the specified gindex.
       *
       * Note: The returned subtree will have a `hook` attached to the parent tree.
       * Updates to the subtree will result in updates to the parent.
       */
      getSubtree(index) {
        return new Tree(this.getNode(index), (node) => this.setNode(index, node));
      }
      /**
       * Return the node at the specified gindex.
       */
      getNode(gindex) {
        return getNode(this.rootNode, gindex);
      }
      /**
       * Return the node at the specified depth and index.
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      getNodeAtDepth(depth, index) {
        return getNodeAtDepth(this.rootNode, depth, index);
      }
      /**
       * Return the hash at the specified gindex.
       */
      getRoot(index) {
        return this.getNode(index).root;
      }
      /**
       * Set the node at at the specified gindex.
       */
      setNode(gindex, n2) {
        this.rootNode = setNode(this.rootNode, gindex, n2);
      }
      /**
       * Traverse to the node at the specified gindex,
       * then apply the function to get a new node and set the node at the specified gindex with the result.
       *
       * This is a convenient method to avoid traversing the tree 2 times to
       * get and set.
       */
      setNodeWithFn(gindex, getNewNode) {
        this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);
      }
      /**
       * Set the node at the specified depth and index.
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      setNodeAtDepth(depth, index, node) {
        this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);
      }
      /**
       * Set the hash at the specified gindex.
       *
       * Note: This will set a new `LeafNode` at the specified gindex.
       */
      setRoot(index, root) {
        this.setNode(index, node_1.LeafNode.fromRoot(root));
      }
      /**
       * Fast read-only iteration
       * In-order traversal of nodes at `depth`
       * starting from the `startIndex`-indexed node
       * iterating through `count` nodes
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      getNodesAtDepth(depth, startIndex, count) {
        return getNodesAtDepth(this.rootNode, depth, startIndex, count);
      }
      /**
       * Fast read-only iteration
       * In-order traversal of nodes at `depth`
       * starting from the `startIndex`-indexed node
       * iterating through `count` nodes
       *
       * Supports index up to `Number.MAX_SAFE_INTEGER`.
       */
      iterateNodesAtDepth(depth, startIndex, count) {
        return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);
      }
      /**
       * Return a merkle proof for the node at the specified gindex.
       */
      getSingleProof(index) {
        return single_1.createSingleProof(this.rootNode, index)[1];
      }
      /**
       * Return a merkle proof for the proof input.
       *
       * This method can be used to create multiproofs.
       */
      getProof(input) {
        return proof_1.createProof(this.rootNode, input);
      }
    };
    exports.Tree = Tree;
    function getNode(rootNode, gindex) {
      const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
      let node = rootNode;
      for (let i2 = 1; i2 < gindexBitstring.length; i2++) {
        if (node.isLeaf()) {
          throw new Error(`Invalid tree - found leaf at depth ${i2}`);
        }
        node = gindexBitstring[i2] === "1" ? node.right : node.left;
      }
      return node;
    }
    exports.getNode = getNode;
    function setNode(rootNode, gindex, n2) {
      const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
      const parentNodes = getParentNodes(rootNode, gindexBitstring);
      return rebindNodeToRoot(gindexBitstring, parentNodes, n2);
    }
    exports.setNode = setNode;
    function setNodeWithFn(rootNode, gindex, getNewNode) {
      const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
      const parentNodes = getParentNodes(rootNode, gindexBitstring);
      const lastParentNode = parentNodes[parentNodes.length - 1];
      const lastBit = gindexBitstring[gindexBitstring.length - 1];
      const oldNode = lastBit === "1" ? lastParentNode.right : lastParentNode.left;
      const newNode = getNewNode(oldNode);
      return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);
    }
    exports.setNodeWithFn = setNodeWithFn;
    function getParentNodes(rootNode, bitstring) {
      let node = rootNode;
      const parentNodes = [rootNode];
      for (let i2 = 1; i2 < bitstring.length - 1; i2++) {
        if (bitstring[i2] === "1") {
          node = node.right;
        } else {
          node = node.left;
        }
        parentNodes.push(node);
      }
      return parentNodes;
    }
    function rebindNodeToRoot(bitstring, parentNodes, newNode) {
      let node = newNode;
      for (let i2 = bitstring.length - 1; i2 >= 1; i2--) {
        if (bitstring[i2] === "1") {
          node = new node_1.BranchNode(parentNodes[i2 - 1].left, node);
        } else {
          node = new node_1.BranchNode(node, parentNodes[i2 - 1].right);
        }
      }
      return node;
    }
    function getNodeAtDepth(rootNode, depth, index) {
      if (depth === 0) {
        return rootNode;
      }
      if (depth === 1) {
        return index === 0 ? rootNode.left : rootNode.right;
      }
      const depthiRoot = depth - 1;
      const depthiParent = 0;
      let node = rootNode;
      for (let d = depthiRoot; d >= depthiParent; d--) {
        node = isLeftNode(d, index) ? node.left : node.right;
      }
      return node;
    }
    exports.getNodeAtDepth = getNodeAtDepth;
    function setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {
      return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);
    }
    exports.setNodeAtDepth = setNodeAtDepth;
    function setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {
      if (nodesDepth === 0) {
        return nodes.length > 0 ? nodes[0] : rootNode;
      }
      const parentNodeStack = new Array(nodesDepth);
      const leftParentNodeStack = new Array(nodesDepth);
      const depthiRoot = nodesDepth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      parentNodeStack[depthiRoot] = rootNode;
      for (let i2 = 0; i2 < indexes.length; i2++) {
        const index = indexes[i2];
        for (let d = depthi; d > depthiParent; d--) {
          node = isLeftNode(d, index) ? node.left : node.right;
          parentNodeStack[d - 1] = node;
        }
        depthi = depthiParent;
        const isLeftLeafNode = (index & 1) !== 1;
        if (isLeftLeafNode) {
          if (index + 1 === indexes[i2 + 1]) {
            node = new node_1.BranchNode(nodes[i2], nodes[i2 + 1]);
            i2++;
          } else {
            node = new node_1.BranchNode(nodes[i2], node.right);
          }
        } else {
          node = new node_1.BranchNode(node.left, nodes[i2]);
        }
        const isLastIndex = i2 >= indexes.length - 1;
        const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i2 + 1]);
        for (let d = depthiParent + 1; d <= diffDepthi; d++) {
          if (isLeftNode(d, index)) {
            if (isLastIndex || d !== diffDepthi) {
              node = new node_1.BranchNode(node, parentNodeStack[d].right);
            } else {
              leftParentNodeStack[d] = node;
              node = parentNodeStack[d];
            }
          } else {
            const leftNode = leftParentNodeStack[d];
            if (leftNode !== void 0) {
              node = new node_1.BranchNode(leftNode, node);
              leftParentNodeStack[d] = void 0;
            } else {
              node = new node_1.BranchNode(parentNodeStack[d].left, node);
            }
          }
        }
        depthi = diffDepthi;
      }
      return node;
    }
    exports.setNodesAtDepth = setNodesAtDepth;
    function getNodesAtDepth(rootNode, depth, startIndex, count) {
      if (depth === 0) {
        return startIndex === 0 && count > 0 ? [rootNode] : [];
      } else if (depth === 1) {
        if (count === 0) {
          return [];
        } else if (count === 1) {
          return startIndex === 0 ? [rootNode.left] : [rootNode.right];
        } else {
          return [rootNode.left, rootNode.right];
        }
      }
      const depthiRoot = depth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      const parentNodeStack = new Array(depth);
      const isLeftStack = new Array(depth);
      const nodes = new Array(count);
      parentNodeStack[depthiRoot] = rootNode;
      for (let i2 = 0; i2 < count; i2++) {
        for (let d = depthi; d >= depthiParent; d--) {
          if (d !== depthi) {
            parentNodeStack[d] = node;
          }
          const isLeft = isLeftNode(d, startIndex + i2);
          isLeftStack[d] = isLeft;
          node = isLeft ? node.left : node.right;
        }
        nodes[i2] = node;
        for (let d = depthiParent; d <= depthiRoot; d++) {
          if (isLeftStack[d] === true) {
            depthi = d;
            break;
          }
        }
        node = parentNodeStack[depthi];
      }
      return nodes;
    }
    exports.getNodesAtDepth = getNodesAtDepth;
    function* iterateNodesAtDepth(rootNode, depth, startIndex, count) {
      const endIndex = startIndex + count;
      const depthiRoot = depth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      const parentNodeStack = new Array(depth);
      const isLeftStack = new Array(depth);
      parentNodeStack[depthiRoot] = rootNode;
      for (let index = startIndex; index < endIndex; index++) {
        for (let d = depthi; d >= depthiParent; d--) {
          if (d !== depthi) {
            parentNodeStack[d] = node;
          }
          const isLeft = isLeftNode(d, index);
          isLeftStack[d] = isLeft;
          node = isLeft ? node.left : node.right;
        }
        yield node;
        for (let d = depthiParent; d <= depthiRoot; d++) {
          if (isLeftStack[d] === true) {
            depthi = d;
            break;
          }
        }
        node = parentNodeStack[depthi];
      }
    }
    exports.iterateNodesAtDepth = iterateNodesAtDepth;
    function treeZeroAfterIndex(rootNode, nodesDepth, index) {
      if (index < 0) {
        return zeroNode_1.zeroNode(nodesDepth);
      }
      const parentNodeStack = new Array(nodesDepth);
      const depthiRoot = nodesDepth - 1;
      const depthiParent = 0;
      let depthi = depthiRoot;
      let node = rootNode;
      parentNodeStack[depthiRoot] = rootNode;
      for (let d = depthi; d >= depthiParent; d--) {
        node = isLeftNode(d, index) ? node.left : node.right;
        parentNodeStack[d - 1] = node;
      }
      depthi = depthiParent;
      for (let d = depthiParent; d <= depthiRoot; d++) {
        if (isLeftNode(d, index)) {
          node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));
        } else {
          node = new node_1.BranchNode(parentNodeStack[d].left, node);
        }
      }
      return node;
    }
    exports.treeZeroAfterIndex = treeZeroAfterIndex;
    function isLeftNode(depthi, index) {
      if (depthi > 31) {
        const indexHi = index / 2 ** 32 >>> 0;
        const mask2 = 1 << depthi - 32;
        return (indexHi & mask2) !== mask2;
      }
      const mask = 1 << depthi;
      return (index & mask) !== mask;
    }
    function findDiffDepthi(from, to) {
      return (
        // (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2
        Math.ceil(Math.log2(-~(from ^ to))) - // Must offset by one to match the depthi scale
        1
      );
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/util.js
var require_util3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;
    var gindex_1 = require_gindex();
    function computeProofGindices(gindex) {
      const path = /* @__PURE__ */ new Set();
      const branch = /* @__PURE__ */ new Set();
      let g = gindex;
      while (g > 1) {
        path.add(g);
        branch.add(gindex_1.gindexSibling(g));
        g = gindex_1.gindexParent(g);
      }
      return { path, branch };
    }
    exports.computeProofGindices = computeProofGindices;
    function computeProofBitstrings(gindex) {
      const path = /* @__PURE__ */ new Set();
      const branch = /* @__PURE__ */ new Set();
      let g = gindex;
      while (g.length > 1) {
        path.add(g);
        const lastBit = g[g.length - 1];
        const parent = g.substring(0, g.length - 1);
        branch.add(parent + (Number(lastBit) ^ 1));
        g = parent;
      }
      return { path, branch };
    }
    exports.computeProofBitstrings = computeProofBitstrings;
    function sortInOrderBitstrings(gindices, bitLength) {
      if (!gindices.length) {
        return [];
      }
      return gindices.map((g) => g.padEnd(bitLength)).sort().map((g) => g.trim());
    }
    exports.sortInOrderBitstrings = sortInOrderBitstrings;
    function sortDecreasingBitstrings(gindices) {
      if (!gindices.length) {
        return [];
      }
      return gindices.sort((a, b) => {
        if (a.length < b.length) {
          return 1;
        } else if (b.length < a.length) {
          return -1;
        }
        let aPos0 = a.indexOf("0");
        let bPos0 = b.indexOf("0");
        while (true) {
          if (aPos0 === -1) {
            return -1;
          } else if (bPos0 === -1) {
            return 1;
          }
          if (aPos0 < bPos0) {
            return 1;
          } else if (bPos0 < aPos0) {
            return -1;
          }
          aPos0 = a.indexOf("0", aPos0 + 1);
          bPos0 = b.indexOf("0", bPos0 + 1);
        }
      });
    }
    exports.sortDecreasingBitstrings = sortDecreasingBitstrings;
    function filterParentBitstrings(gindices) {
      const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);
      const filtered = [];
      outer:
        for (let i2 = 0; i2 < sortedBitstrings.length; i2++) {
          const bsA = sortedBitstrings[i2];
          for (let j = i2 + 1; j < sortedBitstrings.length; j++) {
            const bsB = sortedBitstrings[j];
            if (bsB.startsWith(bsA)) {
              continue outer;
            }
          }
          filtered.push(bsA);
        }
      return filtered;
    }
    exports.filterParentBitstrings = filterParentBitstrings;
    var SortOrder;
    (function(SortOrder2) {
      SortOrder2[SortOrder2["InOrder"] = 0] = "InOrder";
      SortOrder2[SortOrder2["Decreasing"] = 1] = "Decreasing";
      SortOrder2[SortOrder2["Unsorted"] = 2] = "Unsorted";
    })(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
    function computeMultiProofBitstrings(gindices, includeLeaves = true, sortOrder = SortOrder.InOrder) {
      const leaves = filterParentBitstrings(gindices);
      const proof = new Set(includeLeaves ? leaves : []);
      const paths = /* @__PURE__ */ new Set();
      const branches = /* @__PURE__ */ new Set();
      let maxBitLength = 1;
      for (const gindex of leaves) {
        if (gindex.length > maxBitLength)
          maxBitLength = gindex.length;
        const { path, branch } = computeProofBitstrings(gindex);
        path.forEach((g) => paths.add(g));
        branch.forEach((g) => branches.add(g));
      }
      paths.forEach((g) => branches.delete(g));
      branches.forEach((g) => proof.add(g));
      switch (sortOrder) {
        case SortOrder.InOrder:
          return sortInOrderBitstrings(Array.from(proof), maxBitLength);
        case SortOrder.Decreasing:
          return sortDecreasingBitstrings(Array.from(proof));
        case SortOrder.Unsorted:
          return Array.from(proof);
      }
    }
    exports.computeMultiProofBitstrings = computeMultiProofBitstrings;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/multi.js
var require_multi = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/multi.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNodeFromMultiProof = exports.createMultiProof = void 0;
    var node_1 = require_node();
    var tree_1 = require_tree();
    var util_1 = require_util3();
    function createMultiProof(rootNode, gindices) {
      const tree = new tree_1.Tree(rootNode);
      const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map((gindex) => gindex.toString(2)), false, util_1.SortOrder.Decreasing);
      const leafGindices = gindices.slice().sort((a, b) => a < b ? 1 : -1);
      const leaves = leafGindices.map((gindex) => tree.getRoot(gindex));
      const witnesses = witnessGindices.map((gindex) => tree.getRoot(gindex));
      return [leaves, witnesses, leafGindices];
    }
    exports.createMultiProof = createMultiProof;
    function createNodeFromMultiProof(leaves, witnesses, gindices) {
      var _a, _b;
      if (leaves.length !== gindices.length) {
        throw new Error("Leaves length should equal gindices length");
      }
      const leafBitstrings = gindices.map((gindex) => gindex.toString(2));
      const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);
      if (witnessBitstrings.length !== witnesses.length) {
        throw new Error("Witnesses length should equal witnesses gindices length");
      }
      const maxLevel = Math.max(((_a = leafBitstrings[0]) == null ? void 0 : _a.length) ?? 0, ((_b = witnessBitstrings[0]) == null ? void 0 : _b.length) ?? 0);
      const levels4 = Object.fromEntries(Array.from({ length: maxLevel }, (_, i2) => [i2 + 1, {}]));
      for (let i2 = 0; i2 < leafBitstrings.length; i2++) {
        const leafBitstring = leafBitstrings[i2];
        const leaf = leaves[i2];
        levels4[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);
      }
      for (let i2 = 0; i2 < witnessBitstrings.length; i2++) {
        const witnessBitstring = witnessBitstrings[i2];
        const witness = witnesses[i2];
        levels4[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);
      }
      for (let i2 = maxLevel; i2 > 1; i2--) {
        const level = levels4[i2];
        const parentLevel = levels4[i2 - 1];
        for (const bitstring of Object.keys(level)) {
          const node = level[bitstring];
          if (!node) {
            continue;
          }
          const isLeft = bitstring[bitstring.length - 1] === "0";
          const parentBitstring = bitstring.substring(0, bitstring.length - 1);
          const siblingBitstring = parentBitstring + (isLeft ? "1" : "0");
          const siblingNode = level[siblingBitstring];
          if (!siblingNode) {
            throw new Error(`Sibling not found: ${siblingBitstring}`);
          }
          const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);
          parentLevel[parentBitstring] = parentNode;
          delete level[bitstring];
          delete level[siblingBitstring];
        }
      }
      const root = levels4[1]["1"];
      if (!root) {
        throw new Error("Internal consistency error: no root found");
      }
      return root;
    }
    exports.createNodeFromMultiProof = createNodeFromMultiProof;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/compactMulti.js
var require_compactMulti = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/compactMulti.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNodeFromCompactMultiProof = exports.createCompactMultiProof = exports.compactMultiProofToNode = exports.nodeToCompactMultiProof = exports.descriptorToBitlist = exports.computeDescriptor = void 0;
    var gindex_1 = require_gindex();
    var node_1 = require_node();
    var util_1 = require_util3();
    function computeDescriptor(indices) {
      const proofBitstrings = /* @__PURE__ */ new Set();
      const pathBitstrings = /* @__PURE__ */ new Set();
      for (const leafIndex of indices) {
        const leafBitstring = gindex_1.convertGindexToBitstring(leafIndex);
        proofBitstrings.add(leafBitstring);
        const { branch, path } = util_1.computeProofBitstrings(leafBitstring);
        path.delete(leafBitstring);
        for (const pathIndex of path) {
          pathBitstrings.add(pathIndex);
        }
        for (const branchIndex of branch) {
          proofBitstrings.add(branchIndex);
        }
      }
      for (const pathIndex of pathBitstrings) {
        proofBitstrings.delete(pathIndex);
      }
      const allBitstringsSorted = Array.from(proofBitstrings).sort((a, b) => a.localeCompare(b));
      let descriptorBitstring = "";
      for (const gindexBitstring of allBitstringsSorted) {
        for (let i2 = 0; i2 < gindexBitstring.length; i2++) {
          if (gindexBitstring[gindexBitstring.length - 1 - i2] === "1") {
            descriptorBitstring += "1".padStart(i2 + 1, "0");
            break;
          }
        }
      }
      if (descriptorBitstring.length % 8 != 0) {
        descriptorBitstring = descriptorBitstring.padEnd(8 - descriptorBitstring.length % 8 + descriptorBitstring.length, "0");
      }
      const descriptor = new Uint8Array(descriptorBitstring.length / 8);
      for (let i2 = 0; i2 < descriptor.length; i2++) {
        descriptor[i2] = Number("0b" + descriptorBitstring.substring(i2 * 8, (i2 + 1) * 8));
      }
      return descriptor;
    }
    exports.computeDescriptor = computeDescriptor;
    function getBit(bitlist, bitIndex) {
      const bit = bitIndex % 8;
      const byteIdx = Math.floor(bitIndex / 8);
      const byte = bitlist[byteIdx];
      switch (bit) {
        case 0:
          return (byte & 128) !== 0;
        case 1:
          return (byte & 64) !== 0;
        case 2:
          return (byte & 32) !== 0;
        case 3:
          return (byte & 16) !== 0;
        case 4:
          return (byte & 8) !== 0;
        case 5:
          return (byte & 4) !== 0;
        case 6:
          return (byte & 2) !== 0;
        case 7:
          return (byte & 1) !== 0;
        default:
          throw new Error("unreachable");
      }
    }
    function descriptorToBitlist(descriptor) {
      const bools = [];
      const maxBitLength = descriptor.length * 8;
      let count0 = 0;
      let count1 = 0;
      for (let i2 = 0; i2 < maxBitLength; i2++) {
        const bit = getBit(descriptor, i2);
        bools.push(bit);
        if (bit) {
          count1++;
        } else {
          count0++;
        }
        if (count1 > count0) {
          i2++;
          if (i2 + 7 < maxBitLength) {
            throw new Error("Invalid descriptor: too many bytes");
          }
          for (; i2 < maxBitLength; i2++) {
            const bit2 = getBit(descriptor, i2);
            if (bit2) {
              throw new Error("Invalid descriptor: too many 1 bits");
            }
          }
          return bools;
        }
      }
      throw new Error("Invalid descriptor: not enough 1 bits");
    }
    exports.descriptorToBitlist = descriptorToBitlist;
    function nodeToCompactMultiProof(node, bitlist, bitIndex) {
      if (bitlist[bitIndex]) {
        return [node.root];
      } else {
        const left = nodeToCompactMultiProof(node.left, bitlist, bitIndex + 1);
        const right = nodeToCompactMultiProof(node.right, bitlist, bitIndex + left.length * 2);
        return [...left, ...right];
      }
    }
    exports.nodeToCompactMultiProof = nodeToCompactMultiProof;
    function compactMultiProofToNode(bitlist, leaves, pointer) {
      if (bitlist[pointer.bitIndex++]) {
        return node_1.LeafNode.fromRoot(leaves[pointer.leafIndex++]);
      } else {
        return new node_1.BranchNode(compactMultiProofToNode(bitlist, leaves, pointer), compactMultiProofToNode(bitlist, leaves, pointer));
      }
    }
    exports.compactMultiProofToNode = compactMultiProofToNode;
    function createCompactMultiProof(rootNode, descriptor) {
      return nodeToCompactMultiProof(rootNode, descriptorToBitlist(descriptor), 0);
    }
    exports.createCompactMultiProof = createCompactMultiProof;
    function createNodeFromCompactMultiProof(leaves, descriptor) {
      const bools = descriptorToBitlist(descriptor);
      if (bools.length !== leaves.length * 2 - 1) {
        throw new Error("Invalid multiproof: invalid number of leaves");
      }
      return compactMultiProofToNode(bools, leaves, { bitIndex: 0, leafIndex: 0 });
    }
    exports.createNodeFromCompactMultiProof = createNodeFromCompactMultiProof;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/treeOffset.js
var require_treeOffset = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/treeOffset.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeTreeOffsetProof = exports.serializeTreeOffsetProof = exports.computeTreeOffsetProofSerializedLength = exports.createNodeFromTreeOffsetProof = exports.createTreeOffsetProof = exports.treeOffsetProofToNode = exports.nodeToTreeOffsetProof = void 0;
    var node_1 = require_node();
    var util_1 = require_util3();
    function nodeToTreeOffsetProof(node, gindex, proofGindices) {
      if (!proofGindices.length || !proofGindices[0].startsWith(gindex)) {
        return [[], []];
      } else if (gindex === proofGindices[0]) {
        proofGindices.shift();
        return [[], [node.root]];
      } else {
        const [leftOffsets, leftLeaves] = nodeToTreeOffsetProof(node.left, gindex + "0", proofGindices);
        const [rightOffsets, rightLeaves] = nodeToTreeOffsetProof(node.right, gindex + "1", proofGindices);
        const pivot = leftLeaves.length;
        return [[pivot].concat(leftOffsets, rightOffsets), leftLeaves.concat(rightLeaves)];
      }
    }
    exports.nodeToTreeOffsetProof = nodeToTreeOffsetProof;
    function treeOffsetProofToNode(offsets, leaves) {
      if (!leaves.length) {
        throw new Error("Proof must contain gt 0 leaves");
      } else if (leaves.length === 1) {
        return node_1.LeafNode.fromRoot(leaves[0]);
      } else {
        const pivot = offsets[0];
        return new node_1.BranchNode(treeOffsetProofToNode(offsets.slice(1, pivot), leaves.slice(0, pivot)), treeOffsetProofToNode(offsets.slice(pivot), leaves.slice(pivot)));
      }
    }
    exports.treeOffsetProofToNode = treeOffsetProofToNode;
    function createTreeOffsetProof(rootNode, gindices) {
      return nodeToTreeOffsetProof(rootNode, "1", util_1.computeMultiProofBitstrings(gindices.map((g) => g.toString(2))));
    }
    exports.createTreeOffsetProof = createTreeOffsetProof;
    function createNodeFromTreeOffsetProof(offsets, leaves) {
      return treeOffsetProofToNode(offsets, leaves);
    }
    exports.createNodeFromTreeOffsetProof = createNodeFromTreeOffsetProof;
    function computeTreeOffsetProofSerializedLength(offsets, leaves) {
      return (offsets.length + 1) * 2 + leaves.length * 32;
    }
    exports.computeTreeOffsetProofSerializedLength = computeTreeOffsetProofSerializedLength;
    function serializeTreeOffsetProof(output, byteOffset, offsets, leaves) {
      const writer = new DataView(output.buffer, output.byteOffset, output.byteLength);
      writer.setUint16(byteOffset, leaves.length, true);
      const offsetsStartIndex = byteOffset + 2;
      for (let i2 = 0; i2 < offsets.length; i2++) {
        writer.setUint16(i2 * 2 + offsetsStartIndex, offsets[i2], true);
      }
      const leavesStartIndex = offsetsStartIndex + offsets.length * 2;
      for (let i2 = 0; i2 < leaves.length; i2++) {
        output.set(leaves[i2], i2 * 32 + leavesStartIndex);
      }
    }
    exports.serializeTreeOffsetProof = serializeTreeOffsetProof;
    function deserializeTreeOffsetProof(data, byteOffset) {
      const reader = new DataView(data.buffer, data.byteOffset, data.byteLength);
      const leafCount = reader.getUint16(byteOffset, true);
      if (data.length < (leafCount - 1) * 2 + leafCount * 32) {
        throw new Error("Unable to deserialize tree offset proof: not enough bytes");
      }
      const offsetsStartIndex = byteOffset + 2;
      const offsets = Array.from({ length: leafCount - 1 }, (_, i2) => reader.getUint16(i2 * 2 + offsetsStartIndex, true));
      const leavesStartIndex = offsetsStartIndex + offsets.length * 2;
      const leaves = Array.from({ length: leafCount }, (_, i2) => data.subarray(i2 * 32 + leavesStartIndex, (i2 + 1) * 32 + leavesStartIndex));
      return [offsets, leaves];
    }
    exports.deserializeTreeOffsetProof = deserializeTreeOffsetProof;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js
var require_proof = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = exports.descriptorToBitlist = exports.computeDescriptor = void 0;
    var multi_1 = require_multi();
    var compactMulti_1 = require_compactMulti();
    var single_1 = require_single();
    var treeOffset_1 = require_treeOffset();
    var compactMulti_2 = require_compactMulti();
    Object.defineProperty(exports, "computeDescriptor", { enumerable: true, get: function() {
      return compactMulti_2.computeDescriptor;
    } });
    Object.defineProperty(exports, "descriptorToBitlist", { enumerable: true, get: function() {
      return compactMulti_2.descriptorToBitlist;
    } });
    var ProofType;
    (function(ProofType2) {
      ProofType2["single"] = "single";
      ProofType2["treeOffset"] = "treeOffset";
      ProofType2["multi"] = "multi";
      ProofType2["compactMulti"] = "compactMulti";
    })(ProofType = exports.ProofType || (exports.ProofType = {}));
    exports.ProofTypeSerialized = [
      ProofType.single,
      ProofType.treeOffset,
      ProofType.multi,
      ProofType.compactMulti
      // 3
    ];
    function createProof(rootNode, input) {
      switch (input.type) {
        case ProofType.single: {
          const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);
          return {
            type: ProofType.single,
            gindex: input.gindex,
            leaf,
            witnesses
          };
        }
        case ProofType.treeOffset: {
          const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);
          return {
            type: ProofType.treeOffset,
            offsets,
            leaves
          };
        }
        case ProofType.multi: {
          const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);
          return {
            type: ProofType.multi,
            leaves,
            witnesses,
            gindices
          };
        }
        case ProofType.compactMulti: {
          const leaves = compactMulti_1.createCompactMultiProof(rootNode, input.descriptor);
          return {
            type: ProofType.compactMulti,
            leaves,
            descriptor: input.descriptor
          };
        }
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.createProof = createProof;
    function createNodeFromProof(proof) {
      switch (proof.type) {
        case ProofType.single:
          return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);
        case ProofType.treeOffset:
          return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);
        case ProofType.multi:
          return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);
        case ProofType.compactMulti:
          return compactMulti_1.createNodeFromCompactMultiProof(proof.leaves, proof.descriptor);
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.createNodeFromProof = createNodeFromProof;
    function serializeProof(proof) {
      switch (proof.type) {
        case ProofType.single:
        case ProofType.multi:
          throw new Error("Not implemented");
        case ProofType.treeOffset: {
          const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));
          output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);
          treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);
          return output;
        }
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.serializeProof = serializeProof;
    function deserializeProof(data) {
      const proofType = exports.ProofTypeSerialized[data[0]];
      if (!proofType) {
        throw new Error("Invalid proof type");
      }
      switch (proofType) {
        case ProofType.single:
        case ProofType.multi:
          throw new Error("Not implemented");
        case ProofType.treeOffset: {
          const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);
          return {
            type: ProofType.treeOffset,
            offsets,
            leaves
          };
        }
        default:
          throw new Error("Invalid proof type");
      }
    }
    exports.deserializeProof = deserializeProof;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/index.js
var require_lib = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/persistent-merkle-tree/lib/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_gindex(), exports);
    __exportStar(require_hasher(), exports);
    __exportStar(require_node(), exports);
    __exportStar(require_packedNode(), exports);
    __exportStar(require_proof(), exports);
    __exportStar(require_subtree(), exports);
    __exportStar(require_tree(), exports);
    __exportStar(require_zeroNode(), exports);
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/zeros.js
var require_zeros = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/zeros.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroHash = void 0;
    var index_1 = require_hasher();
    var zeroHashes = [new Uint8Array(32)];
    function zeroHash(depth) {
      if (depth >= zeroHashes.length) {
        for (let i2 = zeroHashes.length; i2 <= depth; i2++) {
          zeroHashes[i2] = index_1.hasher.digest64(zeroHashes[i2 - 1], zeroHashes[i2 - 1]);
        }
      }
      return zeroHashes[depth];
    }
    exports.zeroHash = zeroHash;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/merkleize.js
var require_merkleize = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/merkleize.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;
    var index_1 = require_hasher();
    var zeros_1 = require_zeros();
    function hash64(bytes32A, bytes32B) {
      return index_1.hasher.digest64(bytes32A, bytes32B);
    }
    exports.hash64 = hash64;
    function merkleize(chunks, padFor) {
      const layerCount = bitLength(nextPowerOf2(padFor) - 1);
      if (chunks.length == 0) {
        return zeros_1.zeroHash(layerCount);
      }
      let chunkCount = chunks.length;
      for (let l = 0; l < layerCount; l++) {
        const padCount = chunkCount % 2;
        const paddedChunkCount = chunkCount + padCount;
        for (let i2 = 0; i2 < padCount; i2++) {
          chunks[chunkCount + i2] = zeros_1.zeroHash(l);
        }
        for (let i2 = 0; i2 < paddedChunkCount; i2 += 2) {
          chunks[i2 / 2] = hash64(chunks[i2], chunks[i2 + 1]);
        }
        chunkCount = paddedChunkCount / 2;
      }
      return chunks[0];
    }
    exports.merkleize = merkleize;
    function splitIntoRootChunks(longChunk) {
      const chunkCount = Math.ceil(longChunk.length / 32);
      const chunks = new Array(chunkCount);
      for (let i2 = 0; i2 < chunkCount; i2++) {
        const chunk = new Uint8Array(32);
        chunk.set(longChunk.slice(i2 * 32, (i2 + 1) * 32));
        chunks[i2] = chunk;
      }
      return chunks;
    }
    exports.splitIntoRootChunks = splitIntoRootChunks;
    function mixInLength(root, length2) {
      const lengthBuf = Buffer.alloc(32);
      lengthBuf.writeUIntLE(length2, 0, 6);
      return hash64(root, lengthBuf);
    }
    exports.mixInLength = mixInLength;
    function bitLength(i2) {
      if (i2 === 0) {
        return 0;
      }
      return Math.floor(Math.log2(i2)) + 1;
    }
    exports.bitLength = bitLength;
    function maxChunksToDepth(n2) {
      if (n2 === 0)
        return 0;
      return Math.ceil(Math.log2(n2));
    }
    exports.maxChunksToDepth = maxChunksToDepth;
    function nextPowerOf2(n2) {
      return n2 <= 0 ? 1 : Math.pow(2, bitLength(n2 - 1));
    }
    exports.nextPowerOf2 = nextPowerOf2;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/named.js
var require_named = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/named.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namedClass = void 0;
    function namedClass(superClass, className) {
      return new Function("superClass", `return class ${className} extends superClass {}`)(superClass);
    }
    exports.namedClass = namedClass;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/arrayBasic.js
var require_arrayBasic = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/arrayBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;
    var persistent_merkle_tree_1 = require_lib();
    function getLengthFromRootNode(node) {
      return node.right.getUint(4, 0);
    }
    exports.getLengthFromRootNode = getLengthFromRootNode;
    function getChunksNodeFromRootNode(node) {
      return node.left;
    }
    exports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;
    function addLengthNode(chunksNode, length2) {
      return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length2));
    }
    exports.addLengthNode = addLengthNode;
    function setChunksNode(rootNode, chunksNode, newLength) {
      const lengthNode = newLength !== void 0 ? (
        // If newLength is set, create a new node for length
        persistent_merkle_tree_1.LeafNode.fromUint32(newLength)
      ) : (
        // else re-use existing node
        rootNode.right
      );
      return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);
    }
    exports.setChunksNode = setChunksNode;
    function value_serializeToBytesArrayBasic(elementType, length2, output, offset, value2) {
      const elSize = elementType.byteLength;
      for (let i2 = 0; i2 < length2; i2++) {
        elementType.value_serializeToBytes(output, offset + i2 * elSize, value2[i2]);
      }
      return offset + length2 * elSize;
    }
    exports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;
    function value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {
      const elSize = elementType.byteLength;
      const length2 = (end - start) / elSize;
      assertValidArrayLength(length2, arrayProps, true);
      const values = new Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        values[i2] = elementType.value_deserializeFromBytes(data, start + i2 * elSize, start + (i2 + 1) * elSize);
      }
      return values;
    }
    exports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;
    function tree_serializeToBytesArrayBasic(elementType, length2, depth, output, offset, node) {
      const size = elementType.byteLength * length2;
      const chunkCount = Math.ceil(size / 32);
      const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);
      persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);
      return offset + size;
    }
    exports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic;
    function tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {
      const length2 = (end - start) / elementType.byteLength;
      assertValidArrayLength(length2, arrayProps, true);
      const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);
      if (arrayProps.isList) {
        return addLengthNode(chunksNode, length2);
      } else {
        return chunksNode;
      }
    }
    exports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;
    function value_fromJsonArray(elementType, json, arrayProps) {
      if (!Array.isArray(json)) {
        throw Error("JSON is not an array");
      }
      assertValidArrayLength(json.length, arrayProps);
      const value2 = new Array(json.length);
      for (let i2 = 0; i2 < json.length; i2++) {
        value2[i2] = elementType.fromJson(json[i2]);
      }
      return value2;
    }
    exports.value_fromJsonArray = value_fromJsonArray;
    function value_toJsonArray(elementType, value2, arrayProps) {
      const length2 = arrayProps.isList ? value2.length : arrayProps.length;
      const json = new Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        json[i2] = elementType.toJson(value2[i2]);
      }
      return json;
    }
    exports.value_toJsonArray = value_toJsonArray;
    function value_cloneArray(elementType, value2) {
      const newValue = new Array(value2.length);
      for (let i2 = 0; i2 < value2.length; i2++) {
        newValue[i2] = elementType.clone(value2[i2]);
      }
      return newValue;
    }
    exports.value_cloneArray = value_cloneArray;
    function value_equals(elementType, a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (!elementType.equals(a[i2], b[i2])) {
          return false;
        }
      }
      return true;
    }
    exports.value_equals = value_equals;
    function value_defaultValueArray(elementType, length2) {
      const values = new Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        values[i2] = elementType.defaultValue();
      }
      return values;
    }
    exports.value_defaultValueArray = value_defaultValueArray;
    function assertValidArrayLength(length2, arrayProps, checkNonDecimalLength) {
      if (checkNonDecimalLength && length2 % 1 !== 0) {
        throw Error("size not multiple of element fixedSize");
      }
      if (arrayProps.isList) {
        if (length2 > arrayProps.limit) {
          throw new Error(`Invalid list length ${length2} over limit ${arrayProps.limit}`);
        }
      } else {
        if (length2 !== arrayProps.length) {
          throw new Error(`Incorrect vector length ${length2} expected ${arrayProps.length}`);
        }
      }
    }
    exports.assertValidArrayLength = assertValidArrayLength;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/value/bitArray.js
var require_bitArray = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/value/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;
    var uint8ByteToBitBooleanArrays = new Array(256);
    var BitArray = class {
      constructor(uint8Array, bitLen) {
        this.uint8Array = uint8Array;
        this.bitLen = bitLen;
        if (uint8Array.length !== Math.ceil(bitLen / 8)) {
          throw Error("BitArray uint8Array length does not match bitLen");
        }
      }
      /** Returns a zero'ed BitArray of `bitLen` */
      static fromBitLen(bitLen) {
        return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);
      }
      /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */
      static fromSingleBit(bitLen, bitIndex) {
        const bitArray = BitArray.fromBitLen(bitLen);
        bitArray.set(bitIndex, true);
        return bitArray;
      }
      /** Returns a BitArray from an array of booleans representation */
      static fromBoolArray(bitBoolArr) {
        const bitArray = BitArray.fromBitLen(bitBoolArr.length);
        for (let i2 = 0; i2 < bitBoolArr.length; i2++) {
          if (bitBoolArr[i2] === true) {
            bitArray.set(i2, true);
          }
        }
        return bitArray;
      }
      clone() {
        return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);
      }
      /**
       * Get bit value at index `bitIndex`
       */
      get(bitIndex) {
        const byteIdx = Math.floor(bitIndex / 8);
        const bitInBit = bitIndex % 8;
        const mask = 1 << bitInBit;
        return (this.uint8Array[byteIdx] & mask) === mask;
      }
      /**
       * Set bit value at index `bitIndex`
       */
      set(bitIndex, bit) {
        if (bitIndex >= this.bitLen) {
          throw Error(`BitArray set bitIndex ${bitIndex} beyond bitLen ${this.bitLen}`);
        }
        const byteIdx = Math.floor(bitIndex / 8);
        const bitInBit = bitIndex % 8;
        const mask = 1 << bitInBit;
        let byte = this.uint8Array[byteIdx];
        if (bit) {
          byte |= mask;
          this.uint8Array[byteIdx] = byte;
        } else {
          if ((byte & mask) === mask) {
            byte ^= mask;
            this.uint8Array[byteIdx] = byte;
          } else {
          }
        }
      }
      /** Merge two BitArray bitfields with OR. Must have the same bitLen */
      mergeOrWith(bitArray2) {
        if (bitArray2.bitLen !== this.bitLen) {
          throw Error("Must merge BitArrays of same bitLen");
        }
        for (let i2 = 0; i2 < this.uint8Array.length; i2++) {
          this.uint8Array[i2] = this.uint8Array[i2] | bitArray2.uint8Array[i2];
        }
      }
      /**
       * Returns an array with the indexes which have a bit set to true
       */
      intersectValues(values) {
        const yes = [];
        if (values.length !== this.bitLen) {
          throw Error(`Must not intersect values of length ${values.length} != bitLen ${this.bitLen}`);
        }
        const fullByteLen = Math.floor(this.bitLen / 8);
        const remainderBits = this.bitLen % 8;
        const bytes = this.uint8Array;
        for (let iByte = 0; iByte < fullByteLen; iByte++) {
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
          for (let iBit = 0; iBit < 8; iBit++) {
            if (booleansInByte[iBit]) {
              yes.push(values[iByte * 8 + iBit]);
            }
          }
        }
        if (remainderBits > 0) {
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]);
          for (let iBit = 0; iBit < remainderBits; iBit++) {
            if (booleansInByte[iBit]) {
              yes.push(values[fullByteLen * 8 + iBit]);
            }
          }
        }
        return yes;
      }
      /**
       * Returns the positions of all bits that are set to true
       */
      getTrueBitIndexes() {
        const indexes = [];
        const bytes = this.uint8Array;
        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
          for (let iBit = 0; iBit < 8; iBit++) {
            if (booleansInByte[iBit]) {
              indexes.push(iByte * 8 + iBit);
            }
          }
        }
        return indexes;
      }
      /**
       * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.
       * @returns
       *  - number: if there's a single bit set, the number it the single bit set position
       *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET
       * @throws
       *  - ERROR_MORE_THAN_ONE_BIT_SET
       *  - ERROR_NO_BIT_SET
       */
      getSingleTrueBit() {
        let index = null;
        const bytes = this.uint8Array;
        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {
          if (bytes[iByte] === 0) {
            continue;
          }
          const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
          for (let iBit = 0; iBit < 8; iBit++) {
            if (booleansInByte[iBit] === true) {
              if (index !== null) {
                return null;
              }
              index = iByte * 8 + iBit;
            }
          }
        }
        if (index === null) {
          return null;
        } else {
          return index;
        }
      }
      toBoolArray() {
        const bitBoolArr = new Array(this.bitLen);
        for (let i2 = 0; i2 < this.bitLen; i2++) {
          bitBoolArr[i2] = this.get(i2);
        }
        return bitBoolArr;
      }
    };
    exports.BitArray = BitArray;
    function getUint8ByteToBitBooleanArray(byte) {
      if (!uint8ByteToBitBooleanArrays[byte]) {
        uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);
      }
      return uint8ByteToBitBooleanArrays[byte];
    }
    exports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;
    function computeUint8ByteToBitBooleanArray(byte) {
      const binaryStr = byte.toString(2);
      const binaryLength = binaryStr.length;
      const bits = new Array(8);
      for (let i2 = 0; i2 < 8; i2++) {
        bits[i2] = i2 < binaryLength ? (
          //
          binaryStr[binaryLength - i2 - 1] === "1"
        ) : false;
      }
      return bits;
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/byteArray.js
var require_byteArray = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/byteArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0;
    var hexByByte = new Array(256);
    function toHexString(bytes) {
      let hex = "0x";
      for (const byte of bytes) {
        if (!hexByByte[byte]) {
          hexByByte[byte] = byte < 16 ? "0" + byte.toString(16) : byte.toString(16);
        }
        hex += hexByByte[byte];
      }
      return hex;
    }
    exports.toHexString = toHexString;
    function fromHexString(hex) {
      if (typeof hex !== "string") {
        throw new Error(`hex argument type ${typeof hex} must be of type string`);
      }
      if (hex.startsWith("0x")) {
        hex = hex.slice(2);
      }
      if (hex.length % 2 !== 0) {
        throw new Error(`hex string length ${hex.length} must be multiple of 2`);
      }
      const byteLen = hex.length / 2;
      const bytes = new Uint8Array(byteLen);
      for (let i2 = 0; i2 < byteLen; i2++) {
        const byte = parseInt(hex.slice(i2 * 2, (i2 + 1) * 2), 16);
        bytes[i2] = byte;
      }
      return bytes;
    }
    exports.fromHexString = fromHexString;
    function byteArrayEquals(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2])
          return false;
      }
      return true;
    }
    exports.byteArrayEquals = byteArrayEquals;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/proof/treePostProcessFromProofNode.js
var require_treePostProcessFromProofNode = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/proof/treePostProcessFromProofNode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.treePostProcessFromProofNode = void 0;
    var persistent_merkle_tree_1 = require_lib();
    function isCompositeType(type6) {
      return !type6.isBasic;
    }
    function treePostProcessFromProofNode(node, type6, bitstring = "", currentDepth = 0) {
      if (currentDepth === 0) {
        const nodePost = type6.tree_fromProofNode(node);
        if (nodePost.done) {
          return nodePost.node;
        } else {
          node = nodePost.node;
        }
      }
      const atTypeDepth = type6.depth === currentDepth;
      if (node.isLeaf()) {
        if (atTypeDepth) {
          const jsonPathProp = type6.getIndexProperty(bitstringToIndex(bitstring));
          if (jsonPathProp === null) {
            return node;
          }
          const childType = type6.getPropertyType(jsonPathProp);
          if (childType.maxChunkCount === 1 && isCompositeType(childType)) {
            return childType.tree_fromProofNode(node).node;
          } else {
            return node;
          }
        } else {
          return node;
        }
      } else {
        if (atTypeDepth) {
          const jsonPathProp = type6.getIndexProperty(bitstringToIndex(bitstring));
          if (jsonPathProp === null) {
            return node;
          }
          const childType = type6.getPropertyType(jsonPathProp);
          if (!isCompositeType(childType)) {
            throw Error("BranchNode does not map to CompositeType");
          }
          const nodePost = childType.tree_fromProofNode(node);
          if (nodePost.done) {
            return nodePost.node;
          } else {
            return treePostProcessFromProofNode(nodePost.node, childType);
          }
        } else {
          const leftNode = treePostProcessFromProofNode(node.left, type6, bitstring + "0", currentDepth + 1);
          const rightNode = treePostProcessFromProofNode(node.right, type6, bitstring + "1", currentDepth + 1);
          if (leftNode === node.left && rightNode === node.right) {
            return node;
          } else {
            return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);
          }
        }
      }
    }
    exports.treePostProcessFromProofNode = treePostProcessFromProofNode;
    function bitstringToIndex(bitstring) {
      if (bitstring === "")
        return 0;
      return parseInt(bitstring, 2);
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/abstract.js
var require_abstract = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/abstract.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = void 0;
    var Type = class {
      /** INTERNAL METHOD: Merkleize value to tree */
      value_toTree(value2) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value2));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value2);
        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      /** INTERNAL METHOD: Un-merkleize tree to value */
      tree_toValue(node) {
        const uint8Array = new Uint8Array(this.tree_serializedSize(node));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.tree_serializeToBytes({ uint8Array, dataView }, 0, node);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      /** Serialize a value to binary data */
      serialize(value2) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value2));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value2);
        return uint8Array;
      }
      /** Deserialize binary data to value */
      deserialize(uint8Array) {
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
    };
    exports.Type = Type;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/composite.js
var require_composite = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/composite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var byteArray_1 = require_byteArray();
    var merkleize_1 = require_merkleize();
    var treePostProcessFromProofNode_1 = require_treePostProcessFromProofNode();
    var abstract_1 = require_abstract();
    exports.LENGTH_GINDEX = BigInt(3);
    var symbolCachedPermanentRoot = Symbol("ssz_cached_permanent_root");
    var CompositeType = class extends abstract_1.Type {
      constructor(cachePermanentRootStruct) {
        super();
        this.cachePermanentRootStruct = cachePermanentRootStruct;
        this.isBasic = false;
      }
      /** New instance of a recursive zero'ed value converted to Tree View */
      defaultView() {
        return this.toView(this.defaultValue());
      }
      /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */
      defaultViewDU() {
        return this.toViewDU(this.defaultValue());
      }
      /**
       * Deserialize binary data to a Tree View.
       * @see {@link CompositeType.getView}
       */
      deserializeToView(data) {
        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
      }
      /**
       * Deserialize binary data to a Deferred Update Tree View.
       * @see {@link CompositeType.getViewDU}
       */
      deserializeToViewDU(data) {
        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);
        return this.getViewDU(node);
      }
      /**
       * Transform value to a View.
       * @see {@link CompositeType.getView}
       */
      toView(value2) {
        const node = this.value_toTree(value2);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
      }
      /**
       * Transform value to a ViewDU.
       * @see {@link CompositeType.getViewDU}
       */
      toViewDU(value2) {
        const node = this.value_toTree(value2);
        return this.getViewDU(node);
      }
      /**
       * Transform value to a View.
       * @see {@link CompositeType.getView}
       */
      toValueFromView(view) {
        const node = this.commitView(view);
        return this.tree_toValue(node);
      }
      /**
       * Transform value to a ViewDU.
       * @see {@link CompositeType.getViewDU}
       */
      toValueFromViewDU(view) {
        const node = this.commitViewDU(view);
        return this.tree_toValue(node);
      }
      /**
       * Transform a ViewDU to a View.
       * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}
       */
      toViewFromViewDU(view) {
        const node = this.commitViewDU(view);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
      }
      /**
       * Transform a View to a ViewDU.
       * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}
       */
      toViewDUFromView(view) {
        const node = this.commitView(view);
        return this.getViewDU(node);
      }
      // Merkleize API
      hashTreeRoot(value2) {
        if (this.cachePermanentRootStruct) {
          const cachedRoot = value2[symbolCachedPermanentRoot];
          if (cachedRoot) {
            return cachedRoot;
          }
        }
        const root = merkleize_1.merkleize(this.getRoots(value2), this.maxChunkCount);
        if (this.cachePermanentRootStruct) {
          value2[symbolCachedPermanentRoot] = root;
        }
        return root;
      }
      // For debugging and testing this feature
      getCachedPermanentRoot(value2) {
        return value2[symbolCachedPermanentRoot];
      }
      // Proofs API
      /**
       * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.
       * @see {@link CompositeType.getView}
       */
      createFromProof(proof, root) {
        const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;
        const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);
        if (root !== void 0 && !byteArray_1.byteArrayEquals(rootNode.root, root)) {
          throw new Error("Proof does not match trusted root");
        }
        return this.getView(new persistent_merkle_tree_1.Tree(rootNode));
      }
      /** INTERNAL METHOD: For view's API, create proof from a tree */
      tree_createProof(node, jsonPaths) {
        const gindexes = this.tree_createProofGindexes(node, jsonPaths);
        return persistent_merkle_tree_1.createProof(node, {
          type: persistent_merkle_tree_1.ProofType.treeOffset,
          gindices: gindexes
        });
      }
      /** INTERNAL METHOD: For view's API, create proof from a tree */
      tree_createProofGindexes(node, jsonPaths) {
        const gindexes = [];
        for (const jsonPath of jsonPaths) {
          const { type: type6, gindex } = this.getPathInfo(jsonPath);
          if (!isCompositeType(type6)) {
            gindexes.push(gindex);
          } else {
            const leafGindexes = type6.tree_getLeafGindices(gindex, type6.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : void 0);
            for (const gindex2 of leafGindexes) {
              gindexes.push(gindex2);
            }
          }
        }
        return gindexes;
      }
      /**
       * Navigate to a subtype & gindex using a path
       */
      getPathInfo(path) {
        const gindices = [];
        let type6 = this;
        for (const prop of path) {
          if (type6.isBasic) {
            throw new Error("Invalid path: cannot navigate beyond a basic type");
          }
          const gindex = type6.getPropertyGindex(prop);
          if (gindex !== null) {
            gindices.push(gindex);
            type6 = type6.getPropertyType(prop);
          }
        }
        return {
          type: type6,
          gindex: persistent_merkle_tree_1.concatGindices(gindices)
        };
      }
      /**
       * INTERNAL METHOD: post process `Ǹode` instance created from a proof and return either the same node,
       * and a new node representing the same data is a different `Node` instance. Currently used exclusively
       * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.
       */
      tree_fromProofNode(node) {
        return { node, done: false };
      }
    };
    exports.CompositeType = CompositeType;
    function isCompositeType(type6) {
      return !type6.isBasic;
    }
    exports.isCompositeType = isCompositeType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/abstract.js
var require_abstract2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/abstract.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var TreeView = class {
      /** Serialize view to binary data */
      serialize() {
        const output = new Uint8Array(this.type.tree_serializedSize(this.node));
        const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);
        this.type.tree_serializeToBytes({ uint8Array: output, dataView }, 0, this.node);
        return output;
      }
      /**
       * Merkleize view and compute its hashTreeRoot.
       *
       * See spec for definition of hashTreeRoot:
       * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization
       */
      hashTreeRoot() {
        return this.node.root;
      }
      /**
       * Create a Merkle multiproof on this view's data.
       * A `path` is an array of 'JSON' paths into the data
       * @example
       * ```ts
       * state.createProof([
       *   ["validators", 1234, "slashed"],
       *   ["genesisTime"]
       * ])
       * ```
       *
       * See spec for definition of merkle multiproofs:
       * https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs
       */
      createProof(paths) {
        return this.type.tree_createProof(this.node, paths);
      }
      /**
       * Transform the view into a value, from the current node instance.
       * For ViewDU returns the value of the committed data, so call .commit() before if there are pending changes.
       */
      toValue() {
        return this.type.tree_toValue(this.node);
      }
      /** Return a new Tree View instance referencing the same internal `Node`. Drops its existing `Tree` hook if any */
      clone() {
        return this.type.getView(new persistent_merkle_tree_1.Tree(this.node));
      }
    };
    exports.TreeView = TreeView;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/bitArray.js
var require_bitArray2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitArrayTreeView = void 0;
    var abstract_1 = require_abstract2();
    var BitArrayTreeView = class extends abstract_1.TreeView {
      constructor(type6, tree) {
        super();
        this.type = type6;
        this.tree = tree;
        this.bitArray = type6.tree_toValue(tree.rootNode);
      }
      get node() {
        return this.tree.rootNode;
      }
      // Wrapped API from BitArray
      /** @see BitArray.uint8Array */
      get uint8Array() {
        return this.bitArray.uint8Array;
      }
      /** @see BitArray.bitLen */
      get bitLen() {
        return this.bitArray.bitLen;
      }
      /** @see BitArray.get */
      get(bitIndex) {
        return this.bitArray.get(bitIndex);
      }
      /** @see BitArray.set */
      set(bitIndex, bit) {
        this.bitArray.set(bitIndex, bit);
        this.tree.rootNode = this.type.value_toTree(this.bitArray);
      }
      /** @see BitArray.mergeOrWith */
      mergeOrWith(bitArray2) {
        this.bitArray.mergeOrWith(bitArray2);
      }
      /** @see BitArray.intersectValues */
      intersectValues(values) {
        return this.bitArray.intersectValues(values);
      }
      /** @see BitArray.getTrueBitIndexes */
      getTrueBitIndexes() {
        return this.bitArray.getTrueBitIndexes();
      }
      /** @see BitArray.getSingleTrueBit */
      getSingleTrueBit() {
        return this.bitArray.getSingleTrueBit();
      }
      /** @see BitArray.toBoolArray */
      toBoolArray() {
        return this.bitArray.toBoolArray();
      }
    };
    exports.BitArrayTreeView = BitArrayTreeView;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/abstract.js
var require_abstract3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/abstract.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeViewDU = void 0;
    var abstract_1 = require_abstract2();
    var TreeViewDU = class extends abstract_1.TreeView {
      /**
       * Merkleize view and compute its hashTreeRoot.
       * Commits any pending changes before computing the root.
       *
       * See spec for definition of hashTreeRoot:
       * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization
       */
      hashTreeRoot() {
        this.commit();
        return super.hashTreeRoot();
      }
      /**
       * Serialize view to binary data.
       * Commits any pending changes before computing the root.
       */
      serialize() {
        this.commit();
        return super.serialize();
      }
      /**
       * Return a new ViewDU instance referencing the same internal `Node`.
       *
       * By default it will transfer the cache of this ViewDU to the new cloned instance. Set `dontTransferCache` to true
       * to NOT transfer the cache to the cloned instance.
       */
      clone(dontTransferCache) {
        if (dontTransferCache) {
          return this.type.getViewDU(this.node);
        } else {
          const cache2 = this.cache;
          this.clearCache();
          return this.type.getViewDU(this.node, cache2);
        }
      }
    };
    exports.TreeViewDU = TreeViewDU;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/bitArray.js
var require_bitArray3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitArrayTreeViewDU = void 0;
    var abstract_1 = require_abstract3();
    var BitArrayTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type6, _rootNode) {
        super();
        this.type = type6;
        this._rootNode = _rootNode;
        this._bitArray = null;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return;
      }
      commit() {
        if (this._bitArray !== null) {
          this._rootNode = this.type.value_toTree(this._bitArray);
        }
      }
      // Wrapped API from BitArray
      /** @see BitArray.uint8Array */
      get uint8Array() {
        return this.bitArray.uint8Array;
      }
      /** @see BitArray.bitLen */
      get bitLen() {
        return this.bitArray.bitLen;
      }
      /** @see BitArray.get */
      get(bitIndex) {
        return this.bitArray.get(bitIndex);
      }
      /** @see BitArray.set */
      set(bitIndex, bit) {
        this.bitArray.set(bitIndex, bit);
      }
      /** @see BitArray.mergeOrWith */
      mergeOrWith(bitArray2) {
        this.bitArray.mergeOrWith(bitArray2);
      }
      /** @see BitArray.intersectValues */
      intersectValues(values) {
        return this.bitArray.intersectValues(values);
      }
      /** @see BitArray.getTrueBitIndexes */
      getTrueBitIndexes() {
        return this.bitArray.getTrueBitIndexes();
      }
      /** @see BitArray.getSingleTrueBit */
      getSingleTrueBit() {
        return this.bitArray.getSingleTrueBit();
      }
      /** @see BitArray.toBoolArray */
      toBoolArray() {
        return this.bitArray.toBoolArray();
      }
      /** Lazily computed bitArray instance */
      get bitArray() {
        if (this._bitArray === null) {
          this._bitArray = this.type.tree_toValue(this._rootNode);
        }
        return this._bitArray;
      }
      clearCache() {
        this._bitArray = null;
      }
    };
    exports.BitArrayTreeViewDU = BitArrayTreeViewDU;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/bitArray.js
var require_bitArray4 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/bitArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitArrayType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var byteArray_1 = require_byteArray();
    var merkleize_1 = require_merkleize();
    var composite_1 = require_composite();
    var bitArray_1 = require_bitArray2();
    var bitArray_2 = require_bitArray3();
    var BitArrayType = class extends composite_1.CompositeType {
      constructor() {
        super(...arguments);
        this.isViewMutable = true;
      }
      getView(tree) {
        return new bitArray_1.BitArrayTreeView(this, tree);
      }
      getViewDU(node) {
        return new bitArray_2.BitArrayTreeViewDU(this, node);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Merkleization
      getRoots(value2) {
        return merkleize_1.splitIntoRootChunks(value2.uint8Array);
      }
      // Proofs
      getPropertyGindex() {
        return null;
      }
      getPropertyType() {
        throw Error("Must only request BitArray complete data");
      }
      getIndexProperty() {
        throw Error("Must only request BitArray complete data");
      }
      tree_fromProofNode(node) {
        return { node, done: true };
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        const byteLen = this.tree_getByteLen(rootNode);
        const chunkCount = Math.ceil(byteLen / 32);
        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
        const gindices = new Array(chunkCount);
        for (let i2 = 0, gindex = startIndex; i2 < chunkCount; i2++, gindex++) {
          gindices[i2] = gindex;
        }
        if (this.isList) {
          gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        const uint8Array = byteArray_1.fromHexString(json);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      toJson(value2) {
        return byteArray_1.toHexString(this.serialize(value2));
      }
      clone(value2) {
        return value2.clone();
      }
      equals(a, b) {
        return a.bitLen === b.bitLen && byteArray_1.byteArrayEquals(a.uint8Array, b.uint8Array);
      }
    };
    exports.BitArrayType = BitArrayType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/bitList.js
var require_bitList = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/bitList.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitListType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var bitArray_1 = require_bitArray();
    var bitArray_2 = require_bitArray4();
    var BitListType = class extends bitArray_2.BitArrayType {
      constructor(limitBits, opts) {
        super();
        this.limitBits = limitBits;
        this.fixedSize = null;
        this.minSize = 1;
        this.isList = true;
        if (limitBits === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `BitList[${limitBits}]`;
        this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = 1 + this.chunkDepth;
        this.maxSize = Math.ceil(limitBits / 8) + 1;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);
      }
      defaultValue() {
        return bitArray_1.BitArray.fromBitLen(0);
      }
      // Views: inherited from BitArrayType
      // Serialization + deserialization
      value_serializedSize(value2) {
        return bitLenToSerializedLength(value2.bitLen);
      }
      value_serializeToBytes(output, offset, value2) {
        output.uint8Array.set(value2.uint8Array, offset);
        return applyPaddingBit(output.uint8Array, offset, value2.bitLen);
      }
      value_deserializeFromBytes(data, start, end) {
        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);
        return new bitArray_1.BitArray(uint8Array, bitLen);
      }
      tree_serializedSize(node) {
        return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);
        const bitLen = arrayBasic_1.getLengthFromRootNode(node);
        const byteLen = Math.ceil(bitLen / 8);
        const chunkLen = Math.ceil(byteLen / 32);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);
        return applyPaddingBit(output.uint8Array, offset, bitLen);
      }
      tree_deserializeFromBytes(data, start, end) {
        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);
        return arrayBasic_1.addLengthNode(chunksNode, bitLen);
      }
      tree_getByteLen(node) {
        if (!node)
          throw new Error("BitListType requires a node to get leaves");
        return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);
      }
      // Merkleization: inherited from BitArrayType
      hashTreeRoot(value2) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value2), value2.bitLen);
      }
      // Proofs: inherited from BitArrayType
      // JSON: inherited from BitArrayType
      // Deserializer helpers
      deserializeUint8ArrayBitListFromBytes(data, start, end) {
        const { uint8Array, bitLen } = deserializeUint8ArrayBitListFromBytes(data, start, end);
        if (bitLen > this.limitBits) {
          throw Error(`bitLen over limit ${bitLen} > ${this.limitBits}`);
        }
        return { uint8Array, bitLen };
      }
    };
    exports.BitListType = BitListType;
    function deserializeUint8ArrayBitListFromBytes(data, start, end) {
      if (end > data.length) {
        throw Error(`BitList attempting to read byte ${end} of data length ${data.length}`);
      }
      const lastByte = data[end - 1];
      const size = end - start;
      if (lastByte === 0) {
        throw new Error("Invalid deserialized bitlist, padding bit required");
      }
      if (lastByte === 1) {
        const uint8Array2 = Uint8Array.prototype.slice.call(data, start, end - 1);
        const bitLen2 = (size - 1) * 8;
        return { uint8Array: uint8Array2, bitLen: bitLen2 };
      }
      const uint8Array = Uint8Array.prototype.slice.call(data, start, end);
      const lastByteBitLength = lastByte.toString(2).length - 1;
      const bitLen = (size - 1) * 8 + lastByteBitLength;
      const mask = 255 >> 8 - lastByteBitLength;
      uint8Array[size - 1] &= mask;
      return { uint8Array, bitLen };
    }
    function bitLenToSerializedLength(bitLen) {
      const bytes = Math.ceil(bitLen / 8);
      return bitLen % 8 === 0 ? bytes + 1 : bytes;
    }
    function applyPaddingBit(output, offset, bitLen) {
      const byteLen = Math.ceil(bitLen / 8);
      const newOffset = offset + byteLen;
      if (bitLen % 8 === 0) {
        output[newOffset] = 1;
        return newOffset + 1;
      } else {
        output[newOffset - 1] |= 1 << bitLen % 8;
        return newOffset;
      }
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/bitVector.js
var require_bitVector = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/bitVector.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitVectorType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var bitArray_1 = require_bitArray();
    var bitArray_2 = require_bitArray4();
    var BitVectorType = class extends bitArray_2.BitArrayType {
      constructor(lengthBits, opts) {
        super();
        this.lengthBits = lengthBits;
        this.isList = false;
        if (lengthBits === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `BitVector[${lengthBits}]`;
        this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);
        this.maxChunkCount = this.chunkCount;
        this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);
        this.fixedSize = Math.ceil(this.lengthBits / 8);
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
        this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 255 & 255 << lengthBits % 8;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);
      }
      defaultValue() {
        return bitArray_1.BitArray.fromBitLen(this.lengthBits);
      }
      // Views: inherited from BitArrayType
      // Serialization + deserialization
      value_serializedSize() {
        return this.fixedSize;
      }
      value_serializeToBytes(output, offset, value2) {
        output.uint8Array.set(value2.uint8Array, offset);
        return offset + this.fixedSize;
      }
      value_deserializeFromBytes(data, start, end) {
        this.assertValidLength(data.uint8Array, start, end);
        return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);
      }
      tree_serializedSize() {
        return this.fixedSize;
      }
      tree_serializeToBytes(output, offset, node) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);
        return offset + this.fixedSize;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidLength(data.uint8Array, start, end);
        return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);
      }
      tree_getByteLen() {
        return this.fixedSize;
      }
      // Merkleization: inherited from BitArrayType
      // Proofs: inherited from BitArrayType
      // JSON: inherited from BitArrayType
      // Deserializer helpers
      assertValidLength(data, start, end) {
        const size = end - start;
        if (end - start !== this.fixedSize) {
          throw Error(`Invalid BitVector size ${size} != ${this.fixedSize}`);
        }
        if (
          // If zeroBitsMask == 0, then the BitVector uses full bytes only
          this.zeroBitsMask > 0 && // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed
          (data[end - 1] & this.zeroBitsMask) > 0
        ) {
          throw Error("BitVector: nonzero bits past length");
        }
      }
    };
    exports.BitVectorType = BitVectorType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/basic.js
var require_basic = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/basic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBasicType = exports.BasicType = void 0;
    var abstract_1 = require_abstract();
    var BasicType = class extends abstract_1.Type {
      constructor() {
        super(...arguments);
        this.isBasic = true;
        this.depth = 0;
        this.maxChunkCount = 1;
      }
      value_serializedSize() {
        return this.byteLength;
      }
      tree_serializedSize() {
        return this.byteLength;
      }
      assertValidSize(size) {
        if (size !== this.byteLength) {
          throw Error(`BasicType invalid size ${size} expected ${this.byteLength}`);
        }
      }
      hashTreeRoot(value2) {
        const uint8Array = new Uint8Array(32);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value2);
        return uint8Array;
      }
      clone(value2) {
        return value2;
      }
      equals(a, b) {
        return a === b;
      }
    };
    exports.BasicType = BasicType;
    function isBasicType(type6) {
      return type6.isBasic;
    }
    exports.isBasicType = isBasicType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/boolean.js
var require_boolean = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/boolean.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var named_1 = require_named();
    var basic_1 = require_basic();
    var BooleanType = class extends basic_1.BasicType {
      constructor(opts) {
        super();
        this.byteLength = 1;
        this.itemsPerChunk = 32;
        this.fixedSize = 1;
        this.minSize = 1;
        this.maxSize = 1;
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? "boolean";
      }
      static named(opts) {
        return new (named_1.namedClass(BooleanType, opts.typeName))(opts);
      }
      defaultValue() {
        return false;
      }
      // Serialization + deserialization
      value_serializeToBytes(output, offset, value2) {
        output.uint8Array[offset] = value2 ? 1 : 0;
        return offset + 1;
      }
      value_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        switch (data.uint8Array[start]) {
          case 1:
            return true;
          case 0:
            return false;
          default:
            throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);
        }
      }
      tree_serializeToBytes(output, offset, node) {
        output.uint8Array[offset] = node.getUint(4, 0);
        return offset + 1;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const value2 = data.uint8Array[start];
        if (value2 > 1) {
          throw Error(`Boolean: invalid value ${value2}`);
        }
        return persistent_merkle_tree_1.LeafNode.fromUint32(value2);
      }
      // Fast tree opts
      tree_getFromNode(leafNode) {
        return leafNode.getUint(4, 0) === 1;
      }
      tree_setToNode(leafNode, value2) {
        leafNode.setUint(4, 0, value2 ? 1 : 0);
      }
      tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = index % this.itemsPerChunk;
        return leafNode.getUint(1, offsetBytes) !== 0;
      }
      tree_setToPackedNode(leafNode, index, value2) {
        const offsetBytes = index % this.itemsPerChunk;
        leafNode.setUint(1, offsetBytes, value2 ? 1 : 0);
      }
      // JSON
      fromJson(json) {
        if (typeof json !== "boolean") {
          throw Error(`JSON invalid type ${typeof json} expected boolean`);
        }
        return json;
      }
      toJson(value2) {
        return value2;
      }
    };
    exports.BooleanType = BooleanType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/byteArray.js
var require_byteArray2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/byteArray.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteArrayType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var byteArray_1 = require_byteArray();
    var merkleize_1 = require_merkleize();
    var composite_1 = require_composite();
    var ByteArrayType = class extends composite_1.CompositeType {
      constructor() {
        super(...arguments);
        this.isViewMutable = false;
      }
      defaultValue() {
        return new Uint8Array(this.minSize);
      }
      getView(tree) {
        return this.getViewDU(tree.rootNode);
      }
      getViewDU(node) {
        return this.tree_toValue(node);
      }
      commitView(view) {
        return this.commitViewDU(view);
      }
      commitViewDU(view) {
        const uint8Array = new Uint8Array(this.value_serializedSize(view));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, view);
        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
      cacheOfViewDU() {
        return;
      }
      // Over-write to prevent serialize + deserialize
      toView(value2) {
        return value2;
      }
      toViewDU(value2) {
        return value2;
      }
      // Serialization + deserialization (only value is generic)
      value_serializeToBytes(output, offset, value2) {
        output.uint8Array.set(value2, offset);
        return offset + value2.length;
      }
      value_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        return Uint8Array.prototype.slice.call(data.uint8Array, start, end);
      }
      // Merkleization
      getRoots(value2) {
        return merkleize_1.splitIntoRootChunks(value2);
      }
      // Proofs
      getPropertyGindex() {
        return null;
      }
      getPropertyType() {
        throw Error("Must only request ByteArray complete data");
      }
      getIndexProperty() {
        throw Error("Must only request ByteArray complete data");
      }
      tree_fromProofNode(node) {
        return { node, done: true };
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        const byteLen = this.tree_getByteLen(rootNode);
        const chunkCount = Math.ceil(byteLen / 32);
        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
        const gindices = new Array(chunkCount);
        for (let i2 = 0, gindex = startIndex; i2 < chunkCount; i2++, gindex++) {
          gindices[i2] = gindex;
        }
        if (this.isList) {
          gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        const value2 = byteArray_1.fromHexString(json);
        this.assertValidSize(value2.length);
        return value2;
      }
      toJson(value2) {
        return byteArray_1.toHexString(value2);
      }
      // ByteArray is immutable
      clone(value2) {
        return value2;
      }
      equals(a, b) {
        return byteArray_1.byteArrayEquals(a, b);
      }
    };
    exports.ByteArrayType = ByteArrayType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/byteList.js
var require_byteList = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/byteList.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteListType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var byteArray_1 = require_byteArray2();
    var ByteListType = class extends byteArray_1.ByteArrayType {
      constructor(limitBytes, opts) {
        super();
        this.limitBytes = limitBytes;
        this.fixedSize = null;
        this.isList = true;
        if (limitBytes === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `ByteList[${limitBytes}]`;
        this.maxChunkCount = Math.ceil(this.limitBytes / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = 1 + this.chunkDepth;
        this.minSize = 0;
        this.maxSize = this.limitBytes;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(ByteListType, opts.typeName))(limitBits, opts);
      }
      // Views: inherited from ByteArrayType
      // Serialization + deserialization
      value_serializedSize(value2) {
        return value2.length;
      }
      // value_* inherited from ByteArrayType
      tree_serializedSize(node) {
        return arrayBasic_1.getLengthFromRootNode(node);
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);
        const byteLen = arrayBasic_1.getLengthFromRootNode(node);
        const chunkLen = Math.ceil(byteLen / 32);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);
        return offset + byteLen;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);
        return arrayBasic_1.addLengthNode(chunksNode, end - start);
      }
      tree_getByteLen(node) {
        if (!node)
          throw new Error("ByteListType requires a node to get leaves");
        return arrayBasic_1.getLengthFromRootNode(node);
      }
      // Merkleization: inherited from ByteArrayType
      hashTreeRoot(value2) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value2), value2.length);
      }
      // Proofs: inherited from BitArrayType
      // JSON: inherited from ByteArrayType
      assertValidSize(size) {
        if (size > this.limitBytes) {
          throw Error(`ByteList invalid size ${size} limit ${this.limitBytes}`);
        }
      }
    };
    exports.ByteListType = ByteListType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/byteVector.js
var require_byteVector = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/byteVector.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteVectorType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var byteArray_1 = require_byteArray2();
    var ByteVectorType = class extends byteArray_1.ByteArrayType {
      constructor(lengthBytes, opts) {
        super();
        this.lengthBytes = lengthBytes;
        this.isList = false;
        if (lengthBytes === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `ByteVector[${lengthBytes}]`;
        this.maxChunkCount = Math.ceil(this.lengthBytes / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = this.lengthBytes;
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
      }
      static named(limitBits, opts) {
        return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);
      }
      // Views: inherited from ByteArrayType
      // Serialization + deserialization
      value_serializedSize() {
        return this.fixedSize;
      }
      // value_* inherited from ByteArrayType
      tree_serializedSize() {
        return this.fixedSize;
      }
      tree_serializeToBytes(output, offset, node) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);
        return offset + this.fixedSize;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);
      }
      tree_getByteLen() {
        return this.lengthBytes;
      }
      // Merkleization: inherited from ByteArrayType
      // Proofs: inherited from BitArrayType
      // JSON: inherited from ByteArrayType
      assertValidSize(size) {
        if (size !== this.lengthBytes) {
          throw Error(`ByteVector invalid size ${size} expected ${this.lengthBytes}`);
        }
      }
    };
    exports.ByteVectorType = ByteVectorType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/container.js
var require_container = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/container.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewClass = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var basic_1 = require_basic();
    var composite_1 = require_composite();
    var abstract_1 = require_abstract2();
    var ContainerTreeView = class extends abstract_1.TreeView {
      constructor(type6, tree) {
        super();
        this.type = type6;
        this.tree = tree;
      }
      get node() {
        return this.tree.rootNode;
      }
    };
    function getContainerTreeViewClass(type6) {
      class CustomContainerTreeView extends ContainerTreeView {
      }
      for (let index = 0; index < type6.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type6.fieldsEntries[index];
        if (basic_1.isBasicType(fieldType)) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              const leafNode = persistent_merkle_tree_1.getNodeAtDepth(this.node, this.type.depth, index);
              return fieldType.tree_getFromNode(leafNode);
            },
            set: function(value2) {
              const leafNodePrev = persistent_merkle_tree_1.getNodeAtDepth(this.node, this.type.depth, index);
              const leafNode = leafNodePrev.clone();
              fieldType.tree_setToNode(leafNode, value2);
              this.tree.setNodeAtDepth(this.type.depth, index, leafNode);
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeView of fieldName
            get: function() {
              const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
              return fieldType.getView(this.tree.getSubtree(gindex));
            },
            // Expects TreeView of fieldName
            set: function(value2) {
              const node = fieldType.commitView(value2);
              this.tree.setNodeAtDepth(this.type.depth, index, node);
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeView, "name", { value: type6.typeName, writable: false });
      return CustomContainerTreeView;
    }
    exports.getContainerTreeViewClass = getContainerTreeViewClass;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/container.js
var require_container2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/container.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewDUClass = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var basic_1 = require_basic();
    var composite_1 = require_composite();
    var abstract_1 = require_abstract3();
    var ContainerTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type6, _rootNode, cache2) {
        super();
        this.type = type6;
        this._rootNode = _rootNode;
        this.nodes = [];
        this.nodesChanged = /* @__PURE__ */ new Set();
        this.viewsChanged = /* @__PURE__ */ new Map();
        if (cache2) {
          this.nodes = cache2.nodes;
          this.caches = cache2.caches;
          this.nodesPopulated = cache2.nodesPopulated;
        } else {
          this.nodes = [];
          this.caches = [];
          this.nodesPopulated = false;
        }
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return {
          nodes: this.nodes,
          caches: this.caches,
          nodesPopulated: this.nodesPopulated
        };
      }
      commit() {
        if (this.nodesChanged.size === 0 && this.viewsChanged.size === 0) {
          return;
        }
        const nodesChanged = [];
        for (const [index, view] of this.viewsChanged) {
          const fieldType = this.type.fieldsEntries[index].fieldType;
          const node = fieldType.commitViewDU(view);
          this.nodes[index] = node;
          nodesChanged.push({ index, node });
          const cache2 = fieldType.cacheOfViewDU(view);
          if (cache2)
            this.caches[index] = cache2;
        }
        for (const index of this.nodesChanged) {
          nodesChanged.push({ index, node: this.nodes[index] });
        }
        const nodesChangedSorted = nodesChanged.sort((a, b) => a.index - b.index);
        const indexes = nodesChangedSorted.map((entry) => entry.index);
        const nodes = nodesChangedSorted.map((entry) => entry.node);
        this._rootNode = persistent_merkle_tree_1.setNodesAtDepth(this._rootNode, this.type.depth, indexes, nodes);
        this.nodesChanged.clear();
        this.viewsChanged.clear();
      }
      clearCache() {
        this.nodes = [];
        this.caches = [];
        this.nodesPopulated = false;
        this.nodesChanged.clear();
        this.viewsChanged.clear();
      }
    };
    function getContainerTreeViewDUClass(type6) {
      class CustomContainerTreeViewDU extends ContainerTreeViewDU {
      }
      for (let index = 0; index < type6.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type6.fieldsEntries[index];
        if (basic_1.isBasicType(fieldType)) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              let node = this.nodes[index];
              if (node === void 0) {
                node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                this.nodes[index] = node;
              }
              return fieldType.tree_getFromNode(node);
            },
            set: function(value2) {
              let nodeChanged;
              if (this.nodesChanged.has(index)) {
                nodeChanged = this.nodes[index];
              } else {
                const nodePrev = this.nodes[index] ?? persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                nodeChanged = nodePrev.clone();
                this.nodes[index] = nodeChanged;
                this.nodesChanged.add(index);
              }
              fieldType.tree_setToNode(nodeChanged, value2);
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeViewDU of fieldName
            get: function() {
              const viewChanged = this.viewsChanged.get(index);
              if (viewChanged) {
                return viewChanged;
              }
              let node = this.nodes[index];
              if (node === void 0) {
                node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                this.nodes[index] = node;
              }
              const view = fieldType.getViewDU(node, this.caches[index]);
              if (fieldType.isViewMutable) {
                this.viewsChanged.set(index, view);
              }
              return view;
            },
            // Expects TreeViewDU of fieldName
            set: function(view) {
              this.viewsChanged.set(index, view);
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeViewDU, "name", { value: type6.typeName, writable: false });
      return CustomContainerTreeViewDU;
    }
    exports.getContainerTreeViewDUClass = getContainerTreeViewDUClass;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/strings.js
var require_strings = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/util/strings.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Case = void 0;
    exports.Case = {
      snake: (field) => field.replace(/[^0-z]/g, "").replace(/[a-z][A-Z]|[0-9][A-Z]/g, (substr) => substr[0] + "_" + substr[1].toLowerCase()),
      constant: (field) => field.replace(/[^0-z]/g, "").replace(/[a-z][A-Z]|[0-9][A-Z]/g, (substr) => substr[0] + "_" + substr[1]).toUpperCase(),
      pascal: (field) => {
        const first = field[0].toUpperCase();
        return (first + field.slice(1)).replace(/[^0-z]/g, "");
      },
      camel: (field) => {
        return field[0].toLowerCase() + field.slice(1);
      },
      header: (field) => {
        const first = field[0].toUpperCase();
        return first + field.slice(1).replace(/[^0-z]/g, "").replace(/[a-z][A-Z]|[0-9][A-Z]/g, (substr) => substr[0] + "-" + substr[1]);
      },
      eth2: (field) => exports.Case.snake(field).replace(/(\d)$/, "_$1")
    };
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/container.js
var require_container3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/container.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var composite_1 = require_composite();
    var container_1 = require_container();
    var container_2 = require_container2();
    var strings_1 = require_strings();
    var ContainerType = class extends composite_1.CompositeType {
      constructor(fields, opts) {
        var _a, _b;
        super(opts == null ? void 0 : opts.cachePermanentRootStruct);
        this.fields = fields;
        this.opts = opts;
        this.isList = false;
        this.isViewMutable = true;
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? renderContainerTypeName(fields);
        this.maxChunkCount = Object.keys(fields).length;
        this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.fieldsEntries = [];
        for (const fieldName of Object.keys(fields)) {
          this.fieldsEntries.push({
            fieldName,
            fieldType: this.fields[fieldName],
            jsonKey: precomputeJsonKey(fieldName, opts == null ? void 0 : opts.casingMap, opts == null ? void 0 : opts.jsonCase),
            gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length))
          });
        }
        if (this.fieldsEntries.length === 0) {
          throw Error("Container must have > 0 fields");
        }
        this.fieldsGindex = {};
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          this.fieldsGindex[this.fieldsEntries[i2].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i2));
        }
        this.jsonKeyToFieldName = {};
        for (const { fieldName, jsonKey } of this.fieldsEntries) {
          this.jsonKeyToFieldName[jsonKey] = fieldName;
        }
        const { minLen, maxLen, fixedSize } = precomputeSizes(fields);
        this.minSize = minLen;
        this.maxSize = maxLen;
        this.fixedSize = fixedSize;
        const { isFixedLen, fieldRangesFixedLen, variableOffsetsPosition, fixedEnd } = precomputeSerdesData(fields);
        this.isFixedLen = isFixedLen;
        this.fieldRangesFixedLen = fieldRangesFixedLen;
        this.variableOffsetsPosition = variableOffsetsPosition;
        this.fixedEnd = fixedEnd;
        this.TreeView = ((_a = opts == null ? void 0 : opts.getContainerTreeViewClass) == null ? void 0 : _a.call(opts, this)) ?? container_1.getContainerTreeViewClass(this);
        this.TreeViewDU = ((_b = opts == null ? void 0 : opts.getContainerTreeViewDUClass) == null ? void 0 : _b.call(opts, this)) ?? container_2.getContainerTreeViewDUClass(this);
      }
      static named(fields, opts) {
        return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);
      }
      defaultValue() {
        const value2 = {};
        for (const { fieldName, fieldType } of this.fieldsEntries) {
          value2[fieldName] = fieldType.defaultValue();
        }
        return value2;
      }
      getView(tree) {
        return new this.TreeView(this, tree);
      }
      getViewDU(node, cache2) {
        return new this.TreeViewDU(this, node, cache2);
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      // Serialization + deserialization
      // -------------------------------
      // Containers can mix fixed length and variable length data.
      //
      // Fixed part                         Variable part
      // [field1 offset][field2 data       ][field1 data               ]
      // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]
      value_serializedSize(value2) {
        let totalSize = 0;
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType } = this.fieldsEntries[i2];
          totalSize += fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value2[fieldName]) : fieldType.fixedSize;
        }
        return totalSize;
      }
      value_serializeToBytes(output, offset, value2) {
        let fixedIndex = offset;
        let variableIndex = offset + this.fixedEnd;
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType } = this.fieldsEntries[i2];
          if (fieldType.fixedSize === null) {
            output.dataView.setUint32(fixedIndex, variableIndex - offset, true);
            fixedIndex += 4;
            variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value2[fieldName]);
          } else {
            fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value2[fieldName]);
          }
        }
        return variableIndex;
      }
      value_deserializeFromBytes(data, start, end) {
        const fieldRanges = this.getFieldRanges(data.dataView, start, end);
        const value2 = {};
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType } = this.fieldsEntries[i2];
          const fieldRange = fieldRanges[i2];
          value2[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);
        }
        return value2;
      }
      tree_serializedSize(node) {
        let totalSize = 0;
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldType } = this.fieldsEntries[i2];
          const node2 = nodes[i2];
          totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node2) : fieldType.fixedSize;
        }
        return totalSize;
      }
      tree_serializeToBytes(output, offset, node) {
        let fixedIndex = offset;
        let variableIndex = offset + this.fixedEnd;
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldType } = this.fieldsEntries[i2];
          const node2 = nodes[i2];
          if (fieldType.fixedSize === null) {
            output.dataView.setUint32(fixedIndex, variableIndex - offset, true);
            fixedIndex += 4;
            variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node2);
          } else {
            fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node2);
          }
        }
        return variableIndex;
      }
      tree_deserializeFromBytes(data, start, end) {
        const fieldRanges = this.getFieldRanges(data.dataView, start, end);
        const nodes = new Array(this.fieldsEntries.length);
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldType } = this.fieldsEntries[i2];
          const fieldRange = fieldRanges[i2];
          nodes[i2] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);
        }
        return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);
      }
      // Merkleization
      getRoots(struct) {
        const roots = new Array(this.fieldsEntries.length);
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType } = this.fieldsEntries[i2];
          roots[i2] = fieldType.hashTreeRoot(struct[fieldName]);
        }
        return roots;
      }
      // Proofs
      // getPropertyGindex
      // getPropertyType
      // tree_getLeafGindices
      getPropertyGindex(prop) {
        const gindex = this.fieldsGindex[prop] ?? this.fieldsGindex[this.jsonKeyToFieldName[prop]];
        if (gindex === void 0)
          throw Error(`Unknown container property ${prop}`);
        return gindex;
      }
      getPropertyType(prop) {
        const type6 = this.fields[prop] ?? this.fields[this.jsonKeyToFieldName[prop]];
        if (type6 === void 0)
          throw Error(`Unknown container property ${prop}`);
        return type6;
      }
      getIndexProperty(index) {
        if (index >= this.fieldsEntries.length) {
          return null;
        }
        return this.fieldsEntries[index].fieldName;
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        const gindices = [];
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType } = this.fieldsEntries[i2];
          const fieldGindex = this.fieldsGindex[fieldName];
          const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);
          if (fieldType.isBasic) {
            gindices.push(fieldGindexFromRoot);
          } else {
            const compositeType = fieldType;
            if (fieldType.fixedSize === null) {
              if (!rootNode) {
                throw new Error("variable type requires tree argument to get leaves");
              }
              gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));
            } else {
              gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));
            }
          }
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        if (typeof json !== "object") {
          throw Error("JSON must be of type object");
        }
        if (json === null) {
          throw Error("JSON must not be null");
        }
        const value2 = {};
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i2];
          const jsonValue = json[jsonKey];
          if (jsonValue === void 0) {
            throw Error(`JSON expected key ${jsonKey} is undefined`);
          }
          value2[fieldName] = fieldType.fromJson(jsonValue);
        }
        return value2;
      }
      toJson(value2) {
        const json = {};
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i2];
          json[jsonKey] = fieldType.toJson(value2[fieldName]);
        }
        return json;
      }
      clone(value2) {
        const newValue = {};
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType } = this.fieldsEntries[i2];
          newValue[fieldName] = fieldType.clone(value2[fieldName]);
        }
        return newValue;
      }
      equals(a, b) {
        for (let i2 = 0; i2 < this.fieldsEntries.length; i2++) {
          const { fieldName, fieldType } = this.fieldsEntries[i2];
          if (!fieldType.equals(a[fieldName], b[fieldName])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.
       * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].
       * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen
       * - For variable size fields does a first pass over the fixed section to read offsets
       */
      getFieldRanges(data, start, end) {
        if (this.variableOffsetsPosition.length === 0) {
          const size = end - start;
          if (size !== this.fixedEnd) {
            throw Error(`${this.typeName} size ${size} not equal fixed size ${this.fixedEnd}`);
          }
          return this.fieldRangesFixedLen;
        }
        const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);
        offsets.push(end - start);
        let variableIdx = 0;
        let fixedIdx = 0;
        const fieldRanges = new Array(this.isFixedLen.length);
        for (let i2 = 0; i2 < this.isFixedLen.length; i2++) {
          if (this.isFixedLen[i2]) {
            fieldRanges[i2] = this.fieldRangesFixedLen[fixedIdx++];
          } else {
            fieldRanges[i2] = { start: offsets[variableIdx], end: offsets[variableIdx + 1] };
            variableIdx++;
          }
        }
        return fieldRanges;
      }
    };
    exports.ContainerType = ContainerType;
    function readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {
      const size = end - start;
      const offsets = new Array(variableOffsetsPosition.length);
      for (let i2 = 0; i2 < variableOffsetsPosition.length; i2++) {
        const offset = data.getUint32(start + variableOffsetsPosition[i2], true);
        if (offset > size) {
          throw new Error(`Offset out of bounds ${offset} > ${size}`);
        }
        if (i2 === 0) {
          if (offset !== fixedEnd) {
            throw new Error(`First offset must equal to fixedEnd ${offset} != ${fixedEnd}`);
          }
        } else {
          if (offset < offsets[i2 - 1]) {
            throw new Error(`Offsets must be increasing ${offset} < ${offsets[i2 - 1]}`);
          }
        }
        offsets[i2] = offset;
      }
      return offsets;
    }
    function precomputeSerdesData(fields) {
      const isFixedLen = [];
      const fieldRangesFixedLen = [];
      const variableOffsetsPosition = [];
      let pointerFixed = 0;
      for (const fieldType of Object.values(fields)) {
        isFixedLen.push(fieldType.fixedSize !== null);
        if (fieldType.fixedSize === null) {
          variableOffsetsPosition.push(pointerFixed);
          pointerFixed += 4;
        } else {
          fieldRangesFixedLen.push({ start: pointerFixed, end: pointerFixed + fieldType.fixedSize });
          pointerFixed += fieldType.fixedSize;
        }
      }
      return {
        isFixedLen,
        fieldRangesFixedLen,
        variableOffsetsPosition,
        fixedEnd: pointerFixed
      };
    }
    function precomputeSizes(fields) {
      let minLen = 0;
      let maxLen = 0;
      let fixedSize = 0;
      for (const fieldType of Object.values(fields)) {
        minLen += fieldType.minSize;
        maxLen += fieldType.maxSize;
        if (fieldType.fixedSize === null) {
          minLen += 4;
          maxLen += 4;
          fixedSize = null;
        } else if (fixedSize !== null) {
          fixedSize += fieldType.fixedSize;
        }
      }
      return { minLen, maxLen, fixedSize };
    }
    function precomputeJsonKey(fieldName, casingMap, jsonCase) {
      if (casingMap) {
        const keyFromCaseMap = casingMap[fieldName];
        if (keyFromCaseMap === void 0) {
          throw Error(`casingMap[${fieldName}] not defined`);
        }
        return keyFromCaseMap;
      } else if (jsonCase) {
        return strings_1.Case[jsonCase](fieldName);
      } else {
        return fieldName;
      }
    }
    exports.precomputeJsonKey = precomputeJsonKey;
    function renderContainerTypeName(fields, prefix = "Container") {
      const fieldNames = Object.keys(fields);
      const fieldTypeNames = fieldNames.map((fieldName) => `${fieldName}: ${fields[fieldName].typeName}`).join(", ");
      return `${prefix}({${fieldTypeNames}})`;
    }
    exports.renderContainerTypeName = renderContainerTypeName;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/branchNodeStruct.js
var require_branchNodeStruct = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/branchNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BranchNodeStruct = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var BranchNodeStruct = class extends persistent_merkle_tree_1.Node {
      constructor(valueToNode, value2) {
        super(null, 0, 0, 0, 0, 0, 0, 0);
        this.valueToNode = valueToNode;
        this.value = value2;
      }
      get rootHashObject() {
        if (this.h0 === null) {
          const node = this.valueToNode(this.value);
          super.applyHash(node.rootHashObject);
        }
        return this;
      }
      get root() {
        return persistent_merkle_tree_1.hashObjectToUint8Array(this.rootHashObject);
      }
      isLeaf() {
        return false;
      }
      get left() {
        return this.valueToNode(this.value).left;
      }
      get right() {
        return this.valueToNode(this.value).right;
      }
    };
    exports.BranchNodeStruct = BranchNodeStruct;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/containerNodeStruct.js
var require_containerNodeStruct = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/containerNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewClass = void 0;
    var composite_1 = require_composite();
    var branchNodeStruct_1 = require_branchNodeStruct();
    var abstract_1 = require_abstract2();
    var ContainerTreeView = class extends abstract_1.TreeView {
      constructor(type6, tree) {
        super();
        this.type = type6;
        this.tree = tree;
      }
      get node() {
        return this.tree.rootNode;
      }
    };
    function getContainerTreeViewClass(type6) {
      class CustomContainerTreeView extends ContainerTreeView {
      }
      for (let index = 0; index < type6.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type6.fieldsEntries[index];
        if (fieldType.isBasic) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              return this.tree.rootNode.value[fieldName];
            },
            set: function(value2) {
              const node = this.tree.rootNode;
              const newNodeValue = this.type.clone(node.value);
              newNodeValue[fieldName] = value2;
              this.tree.rootNode = new branchNodeStruct_1.BranchNodeStruct(node["valueToNode"], newNodeValue);
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeView of fieldName
            get: function() {
              const { value: value2 } = this.tree.rootNode;
              return fieldType.toView(value2[fieldName]);
            },
            // Expects TreeView of fieldName
            set: function(view) {
              const node = this.tree.rootNode;
              const newNodeValue = this.type.clone(node.value);
              newNodeValue[fieldName] = fieldType.toValueFromView(view);
              this.tree.rootNode = new branchNodeStruct_1.BranchNodeStruct(node["valueToNode"], newNodeValue);
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeView, "name", { value: type6.typeName, writable: false });
      return CustomContainerTreeView;
    }
    exports.getContainerTreeViewClass = getContainerTreeViewClass;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/containerNodeStruct.js
var require_containerNodeStruct2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/containerNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerTreeViewDUClass = void 0;
    var composite_1 = require_composite();
    var abstract_1 = require_abstract3();
    var ContainerTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type6, node) {
        super();
        this.type = type6;
        this.valueChanged = null;
        this._rootNode = node;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return;
      }
      commit() {
        if (this.valueChanged === null) {
          return;
        }
        const value2 = this.valueChanged;
        this.valueChanged = null;
        this._rootNode = this.type.value_toTree(value2);
      }
      clearCache() {
        this.valueChanged = null;
      }
    };
    function getContainerTreeViewDUClass(type6) {
      class CustomContainerTreeViewDU extends ContainerTreeViewDU {
      }
      for (let index = 0; index < type6.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type6.fieldsEntries[index];
        if (fieldType.isBasic) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // TODO: Review the memory cost of this closures
            get: function() {
              return (this.valueChanged || this._rootNode.value)[fieldName];
            },
            set: function(value2) {
              if (this.valueChanged === null) {
                this.valueChanged = this.type.clone(this._rootNode.value);
              }
              this.valueChanged[fieldName] = value2;
            }
          });
        } else if (composite_1.isCompositeType(fieldType)) {
          Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
            configurable: false,
            enumerable: true,
            // Returns TreeViewDU of fieldName
            get: function() {
              const value2 = this.valueChanged || this._rootNode.value;
              return fieldType.toViewDU(value2[fieldName]);
            },
            // Expects TreeViewDU of fieldName
            set: function(view) {
              if (this.valueChanged === null) {
                this.valueChanged = this.type.clone(this._rootNode.value);
              }
              const value2 = fieldType.toValueFromViewDU(view);
              this.valueChanged[fieldName] = value2;
            }
          });
        } else {
          throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
      }
      Object.defineProperty(CustomContainerTreeViewDU, "name", { value: type6.typeName, writable: false });
      return CustomContainerTreeViewDU;
    }
    exports.getContainerTreeViewDUClass = getContainerTreeViewDUClass;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/containerNodeStruct.js
var require_containerNodeStruct3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/containerNodeStruct.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerNodeStructType = void 0;
    var composite_1 = require_composite();
    var container_1 = require_container3();
    var named_1 = require_named();
    var containerNodeStruct_1 = require_containerNodeStruct();
    var containerNodeStruct_2 = require_containerNodeStruct2();
    var branchNodeStruct_1 = require_branchNodeStruct();
    var ContainerNodeStructType = class extends container_1.ContainerType {
      constructor(fields, opts) {
        super(fields, {
          // Overwrite default "Container" typeName
          // Render detailed typeName. Consumers should overwrite since it can get long
          typeName: (opts == null ? void 0 : opts.typeName) ?? container_1.renderContainerTypeName(fields, "ContainerNodeStruct"),
          ...opts,
          getContainerTreeViewClass: containerNodeStruct_1.getContainerTreeViewClass,
          getContainerTreeViewDUClass: containerNodeStruct_2.getContainerTreeViewDUClass
        });
        this.fields = fields;
        for (const { fieldName, fieldType } of this.fieldsEntries) {
          if (composite_1.isCompositeType(fieldType) && fieldType.isViewMutable) {
            throw Error(`ContainerNodeStructType field '${fieldName}' ${fieldType.typeName} view is mutable`);
          }
        }
      }
      static named(fields, opts) {
        return new (named_1.namedClass(container_1.ContainerType, opts.typeName))(fields, opts);
      }
      tree_serializedSize(node) {
        return this.value_serializedSize(node.value);
      }
      tree_serializeToBytes(output, offset, node) {
        const { value: value2 } = node;
        return this.value_serializeToBytes(output, offset, value2);
      }
      tree_deserializeFromBytes(data, start, end) {
        const value2 = this.value_deserializeFromBytes(data, start, end);
        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value2);
      }
      // Proofs
      // ContainerNodeStructType can only parse proofs that contain all the data.
      // TODO: Support converting a partial tree to a partial value
      getPropertyGindex() {
        return null;
      }
      // Post process tree to convert regular BranchNode to BranchNodeStruct
      // TODO: Optimize conversions
      tree_fromProofNode(node) {
        const uint8Array = new Uint8Array(super.tree_serializedSize(node));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        super.tree_serializeToBytes({ uint8Array, dataView }, 0, node);
        const value2 = this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
        return {
          node: new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value2),
          done: true
        };
      }
      // Overwrites for fast conversion node <-> value
      tree_toValue(node) {
        return node.value;
      }
      value_toTree(value2) {
        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value2);
      }
      // TODO: Optimize conversion
      valueToTree(value2) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value2));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value2);
        return super.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
      }
    };
    exports.ContainerNodeStructType = ContainerNodeStructType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/arrayBasic.js
var require_arrayBasic2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/arrayBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayBasicTreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract2();
    var ArrayBasicTreeView = class extends abstract_1.TreeView {
      constructor(type6, tree) {
        super();
        this.type = type6;
        this.tree = tree;
      }
      /**
       * Number of elements in the array. Equal to the Uint32 value of the Tree's length node
       */
      get length() {
        return this.type.tree_getLength(this.tree.rootNode);
      }
      get node() {
        return this.tree.rootNode;
      }
      /**
       * Get element at `index`. Returns the Basic element type value directly
       */
      get(index) {
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        const leafNode = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);
        return this.type.elementType.tree_getFromPackedNode(leafNode, index);
      }
      /**
       * Set Basic element type `value` at `index`
       */
      set(index, value2) {
        const length2 = this.length;
        if (index >= length2) {
          throw Error(`Error setting index over length ${index} > ${length2}`);
        }
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        const leafNodePrev = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);
        const leafNode = leafNodePrev.clone();
        this.type.elementType.tree_setToPackedNode(leafNode, index, value2);
        this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);
      }
      /**
       * Get all values of this array as Basic element type values, from index zero to `this.length - 1`
       */
      getAll() {
        const length2 = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const chunkCount = Math.ceil(length2 / this.type.itemsPerChunk);
        const leafNodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);
        const values = new Array(length2);
        const itemsPerChunk = this.type.itemsPerChunk;
        const lenFullNodes = Math.floor(length2 / itemsPerChunk);
        const remainder = length2 % itemsPerChunk;
        for (let n2 = 0; n2 < lenFullNodes; n2++) {
          const leafNode = leafNodes[n2];
          for (let i2 = 0; i2 < itemsPerChunk; i2++) {
            values[n2 * itemsPerChunk + i2] = this.type.elementType.tree_getFromPackedNode(leafNode, i2);
          }
        }
        if (remainder > 0) {
          const leafNode = leafNodes[lenFullNodes];
          for (let i2 = 0; i2 < remainder; i2++) {
            values[lenFullNodes * itemsPerChunk + i2] = this.type.elementType.tree_getFromPackedNode(leafNode, i2);
          }
        }
        return values;
      }
    };
    exports.ArrayBasicTreeView = ArrayBasicTreeView;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/listBasic.js
var require_listBasic = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/listBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListBasicTreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayBasic_1 = require_arrayBasic2();
    var ListBasicTreeView = class extends arrayBasic_1.ArrayBasicTreeView {
      constructor(type6, tree) {
        super(type6, tree);
        this.type = type6;
        this.tree = tree;
      }
      /**
       * Adds one value element at the end of the array and adds 1 to the current Tree length.
       */
      push(value2) {
        const length2 = this.length;
        if (length2 >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.type.tree_setLength(this.tree, length2 + 1);
        if (length2 % this.type.itemsPerChunk === 0) {
          const leafNode = persistent_merkle_tree_1.LeafNode.fromZero();
          this.type.elementType.tree_setToPackedNode(leafNode, length2, value2);
          const chunkIndex = Math.floor(length2 / this.type.itemsPerChunk);
          this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);
        } else {
          this.set(length2, value2);
        }
      }
    };
    exports.ListBasicTreeView = ListBasicTreeView;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/arrayBasic.js
var require_arrayBasic3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/arrayBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayBasicTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract3();
    var ArrayBasicTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type6, _rootNode, cache2) {
        super();
        this.type = type6;
        this._rootNode = _rootNode;
        this.nodesChanged = /* @__PURE__ */ new Set();
        this.dirtyLength = false;
        if (cache2) {
          this.nodes = cache2.nodes;
          this._length = cache2.length;
          this.nodesPopulated = cache2.nodesPopulated;
        } else {
          this.nodes = [];
          this._length = this.type.tree_getLength(_rootNode);
          this.nodesPopulated = false;
        }
      }
      /**
       * Number of elements in the array. Equal to un-commited length of the array
       */
      get length() {
        return this._length;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return {
          nodes: this.nodes,
          length: this._length,
          nodesPopulated: this.nodesPopulated
        };
      }
      /**
       * Get element at `index`. Returns the Basic element type value directly
       */
      get(index) {
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        let node = this.nodes[chunkIndex];
        if (node === void 0) {
          node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);
          this.nodes[chunkIndex] = node;
        }
        return this.type.elementType.tree_getFromPackedNode(node, index);
      }
      /**
       * Set Basic element type `value` at `index`
       */
      set(index, value2) {
        if (index >= this._length) {
          throw Error(`Error setting index over length ${index} > ${this._length}`);
        }
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        let nodeChanged;
        if (this.nodesChanged.has(chunkIndex)) {
          nodeChanged = this.nodes[chunkIndex];
        } else {
          const nodePrev = this.nodes[chunkIndex] ?? persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);
          nodeChanged = nodePrev.clone();
          this.nodes[chunkIndex] = nodeChanged;
          this.nodesChanged.add(chunkIndex);
        }
        this.type.elementType.tree_setToPackedNode(nodeChanged, index, value2);
      }
      /**
       * Get all values of this array as Basic element type values, from index zero to `this.length - 1`
       */
      getAll() {
        if (!this.nodesPopulated) {
          const nodesPrev = this.nodes;
          const chunksNode = this.type.tree_getChunksNode(this.node);
          const chunkCount = Math.ceil(this._length / this.type.itemsPerChunk);
          this.nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);
          for (const index of this.nodesChanged) {
            this.nodes[index] = nodesPrev[index];
          }
          this.nodesPopulated = true;
        }
        const values = new Array(this._length);
        const itemsPerChunk = this.type.itemsPerChunk;
        const lenFullNodes = Math.floor(this._length / itemsPerChunk);
        const remainder = this._length % itemsPerChunk;
        for (let n2 = 0; n2 < lenFullNodes; n2++) {
          const leafNode = this.nodes[n2];
          for (let i2 = 0; i2 < itemsPerChunk; i2++) {
            values[n2 * itemsPerChunk + i2] = this.type.elementType.tree_getFromPackedNode(leafNode, i2);
          }
        }
        if (remainder > 0) {
          const leafNode = this.nodes[lenFullNodes];
          for (let i2 = 0; i2 < remainder; i2++) {
            values[lenFullNodes * itemsPerChunk + i2] = this.type.elementType.tree_getFromPackedNode(leafNode, i2);
          }
        }
        return values;
      }
      commit() {
        if (this.nodesChanged.size === 0) {
          return;
        }
        const indexes = Array.from(this.nodesChanged.keys()).sort((a, b) => a - b);
        const nodes = new Array(indexes.length);
        for (let i2 = 0; i2 < indexes.length; i2++) {
          nodes[i2] = this.nodes[indexes[i2]];
        }
        const chunksNode = this.type.tree_getChunksNode(this._rootNode);
        const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);
        this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : void 0);
        this.nodesChanged.clear();
        this.dirtyLength = false;
      }
      clearCache() {
        this.nodes = [];
        this.nodesPopulated = false;
        this.nodesChanged.clear();
        if (this.dirtyLength) {
          this._length = this.type.tree_getLength(this._rootNode);
          this.dirtyLength = false;
        }
      }
    };
    exports.ArrayBasicTreeViewDU = ArrayBasicTreeViewDU;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/listBasic.js
var require_listBasic2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/listBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListBasicTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayBasic_1 = require_arrayBasic3();
    var ListBasicTreeViewDU = class extends arrayBasic_1.ArrayBasicTreeViewDU {
      constructor(type6, _rootNode, cache2) {
        super(type6, _rootNode, cache2);
        this.type = type6;
        this._rootNode = _rootNode;
      }
      /**
       * Adds one value element at the end of the array and adds 1 to the un-commited ViewDU length
       */
      push(value2) {
        if (this._length >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.dirtyLength = true;
        const index = this._length++;
        if (index % this.type.itemsPerChunk === 0) {
          const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
          this.nodes[chunkIndex] = persistent_merkle_tree_1.zeroNode(0);
        }
        this.set(index, value2);
      }
    };
    exports.ListBasicTreeViewDU = ListBasicTreeViewDU;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/array.js
var require_array = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/array.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var composite_1 = require_composite();
    var arrayBasic_1 = require_arrayBasic();
    var ArrayType = class extends composite_1.CompositeType {
      constructor(elementType) {
        super();
        this.elementType = elementType;
      }
      defaultValue() {
        return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);
      }
      // Proofs
      getPropertyType() {
        return this.elementType;
      }
      getPropertyGindex(prop) {
        if (typeof prop !== "number") {
          throw Error(`Invalid array index: ${prop}`);
        }
        const chunkIdx = Math.floor(prop / this.itemsPerChunk);
        return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));
      }
      getIndexProperty(index) {
        return index;
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        let length2;
        if (this.isList) {
          if (!rootNode) {
            throw new Error("List type requires tree argument to get leaves");
          }
          length2 = this.tree_getLength(rootNode);
        } else {
          length2 = this.tree_getLength(null);
        }
        const gindices = [];
        if (composite_1.isCompositeType(this.elementType)) {
          const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));
          const endGindex = startIndex + BigInt(length2);
          const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);
          if (this.elementType.fixedSize === null) {
            if (!rootNode) {
              throw new Error("Array of variable size requires tree argument to get leaves");
            }
            for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {
              gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));
            }
          } else {
            for (let i2 = 0, extendedGindex = extendedStartIndex; i2 < length2; i2++, extendedGindex++) {
              gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));
            }
          }
        } else {
          const chunkCount = Math.ceil(length2 / this.itemsPerChunk);
          const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
          const endGindex = startIndex + BigInt(chunkCount);
          for (let gindex = startIndex; gindex < endGindex; gindex++) {
            gindices.push(gindex);
          }
        }
        if (this.isList) {
          gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);
      }
      toJson(value2) {
        return arrayBasic_1.value_toJsonArray(this.elementType, value2, this);
      }
      clone(value2) {
        return arrayBasic_1.value_cloneArray(this.elementType, value2);
      }
      equals(a, b) {
        return arrayBasic_1.value_equals(this.elementType, a, b);
      }
    };
    exports.ArrayType = ArrayType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/listBasic.js
var require_listBasic3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/listBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListBasicType = void 0;
    var arrayBasic_1 = require_arrayBasic();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var listBasic_1 = require_listBasic();
    var listBasic_2 = require_listBasic2();
    var array_1 = require_array();
    var ListBasicType = class extends array_1.ArrayType {
      constructor(elementType, limit, opts) {
        super(elementType);
        this.elementType = elementType;
        this.limit = limit;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        this.defaultLen = 0;
        if (!elementType.isBasic)
          throw Error("elementType must be basic");
        if (limit === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `List[${elementType.typeName}, ${limit}]`;
        this.itemsPerChunk = 32 / elementType.byteLength;
        this.maxChunkCount = Math.ceil(this.limit * elementType.byteLength / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth + 1;
        this.minSize = 0;
        this.maxSize = this.limit * elementType.maxSize;
      }
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(ListBasicType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new listBasic_1.ListBasicTreeView(this, tree);
      }
      getViewDU(node, cache2) {
        return new listBasic_2.ListBasicTreeViewDU(this, node, cache2);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize(value2) {
        return value2.length * this.elementType.byteLength;
      }
      value_serializeToBytes(output, offset, value2) {
        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value2.length, output, offset, value2);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);
      }
      tree_serializedSize(node) {
        return this.tree_getLength(node) * this.elementType.byteLength;
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length2 = this.tree_getLength(node);
        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, length2, this.chunkDepth, output, offset, chunksNode);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.chunkDepth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength(node) {
        return node.right.getUint(4, 0);
      }
      tree_setLength(tree, length2) {
        tree.rootNode = arrayBasic_1.addLengthNode(tree.rootNode.left, length2);
      }
      tree_getChunksNode(node) {
        return node.left;
      }
      tree_setChunksNode(rootNode, chunksNode, newLength) {
        return arrayBasic_1.setChunksNode(rootNode, chunksNode, newLength);
      }
      // Merkleization
      hashTreeRoot(value2) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value2), value2.length);
      }
      getRoots(value2) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value2));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value2.length, { uint8Array, dataView }, 0, value2);
        return merkleize_1.splitIntoRootChunks(uint8Array);
      }
    };
    exports.ListBasicType = ListBasicType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/arrayComposite.js
var require_arrayComposite = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/arrayComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.value_getRootsArrayComposite = exports.tree_deserializeFromBytesArrayComposite = exports.tree_serializeToBytesArrayComposite = exports.tree_serializedSizeArrayComposite = exports.value_deserializeFromBytesArrayComposite = exports.value_serializeToBytesArrayComposite = exports.value_serializedSizeArrayComposite = exports.maxSizeArrayComposite = exports.minSizeArrayComposite = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayBasic_1 = require_arrayBasic();
    function minSizeArrayComposite(elementType, minCount) {
      if (elementType.fixedSize === null) {
        return minCount * (4 + elementType.minSize);
      } else {
        return minCount * elementType.minSize;
      }
    }
    exports.minSizeArrayComposite = minSizeArrayComposite;
    function maxSizeArrayComposite(elementType, maxCount) {
      if (elementType.fixedSize === null) {
        return maxCount * (4 + elementType.maxSize);
      } else {
        return maxCount * elementType.maxSize;
      }
    }
    exports.maxSizeArrayComposite = maxSizeArrayComposite;
    function value_serializedSizeArrayComposite(elementType, length2, value2) {
      if (elementType.fixedSize === null) {
        let size = 0;
        for (let i2 = 0; i2 < length2; i2++) {
          size += 4 + elementType.value_serializedSize(value2[i2]);
        }
        return size;
      } else {
        return length2 * elementType.fixedSize;
      }
    }
    exports.value_serializedSizeArrayComposite = value_serializedSizeArrayComposite;
    function value_serializeToBytesArrayComposite(elementType, length2, output, offset, value2) {
      if (elementType.fixedSize === null) {
        let variableIndex = offset + length2 * 4;
        for (let i2 = 0; i2 < length2; i2++) {
          output.dataView.setUint32(offset + i2 * 4, variableIndex - offset, true);
          variableIndex = elementType.value_serializeToBytes(output, variableIndex, value2[i2]);
        }
        return variableIndex;
      } else {
        for (let i2 = 0; i2 < length2; i2++) {
          elementType.value_serializeToBytes(output, offset + i2 * elementType.fixedSize, value2[i2]);
        }
        return offset + length2 * elementType.fixedSize;
      }
    }
    exports.value_serializeToBytesArrayComposite = value_serializeToBytesArrayComposite;
    function value_deserializeFromBytesArrayComposite(elementType, data, start, end, arrayProps) {
      const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);
      const length2 = offsets.length;
      const values = new Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        const startEl = start + offsets[i2];
        const endEl = i2 === length2 - 1 ? end : start + offsets[i2 + 1];
        values[i2] = elementType.value_deserializeFromBytes(data, startEl, endEl);
      }
      return values;
    }
    exports.value_deserializeFromBytesArrayComposite = value_deserializeFromBytesArrayComposite;
    function tree_serializedSizeArrayComposite(elementType, length2, depth, node) {
      if (elementType.fixedSize === null) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length2);
        let size = 0;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          size += 4 + elementType.tree_serializedSize(nodes[i2]);
        }
        return size;
      } else {
        return length2 * elementType.fixedSize;
      }
    }
    exports.tree_serializedSizeArrayComposite = tree_serializedSizeArrayComposite;
    function tree_serializeToBytesArrayComposite(elementType, length2, depth, node, output, offset) {
      const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length2);
      if (elementType.fixedSize === null) {
        let variableIndex = offset + length2 * 4;
        const { dataView } = output;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          dataView.setUint32(offset + i2 * 4, variableIndex - offset, true);
          variableIndex = elementType.tree_serializeToBytes(output, variableIndex, nodes[i2]);
        }
        return variableIndex;
      } else {
        for (let i2 = 0; i2 < nodes.length; i2++) {
          offset = elementType.tree_serializeToBytes(output, offset, nodes[i2]);
        }
        return offset;
      }
    }
    exports.tree_serializeToBytesArrayComposite = tree_serializeToBytesArrayComposite;
    function tree_deserializeFromBytesArrayComposite(elementType, chunkDepth, data, start, end, arrayProps) {
      const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);
      const length2 = offsets.length;
      const nodes = new Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        const startEl = start + offsets[i2];
        const endEl = i2 === length2 - 1 ? end : start + offsets[i2 + 1];
        nodes[i2] = elementType.tree_deserializeFromBytes(data, startEl, endEl);
      }
      const chunksNode = persistent_merkle_tree_1.subtreeFillToContents(nodes, chunkDepth);
      if (arrayProps.isList) {
        return arrayBasic_1.addLengthNode(chunksNode, length2);
      } else {
        return chunksNode;
      }
    }
    exports.tree_deserializeFromBytesArrayComposite = tree_deserializeFromBytesArrayComposite;
    function value_getRootsArrayComposite(elementType, length2, value2) {
      const roots = new Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        roots[i2] = elementType.hashTreeRoot(value2[i2]);
      }
      return roots;
    }
    exports.value_getRootsArrayComposite = value_getRootsArrayComposite;
    function readOffsetsArrayComposite(elementFixedSize, data, start, end, arrayProps) {
      const size = end - start;
      let offsets;
      if (elementFixedSize === null) {
        offsets = readVariableOffsetsArrayComposite(data, start, size);
      } else {
        if (elementFixedSize === 0) {
          throw Error("element fixed length is 0");
        }
        if (size % elementFixedSize !== 0) {
          throw Error(`size ${size} is not multiple of element fixedSize ${elementFixedSize}`);
        }
        const length2 = size / elementFixedSize;
        offsets = new Uint32Array(length2);
        for (let i2 = 0; i2 < length2; i2++) {
          offsets[i2] = i2 * elementFixedSize;
        }
      }
      arrayBasic_1.assertValidArrayLength(offsets.length, arrayProps);
      return offsets;
    }
    function readVariableOffsetsArrayComposite(dataView, start, size) {
      if (size === 0) {
        return new Uint32Array(0);
      }
      const firstOffset = dataView.getUint32(start, true);
      const offsetDataLength = firstOffset;
      if (firstOffset === 0) {
        throw Error("First offset must be > 0");
      }
      if (offsetDataLength % 4 !== 0) {
        throw Error("Offset data length not multiple of 4");
      }
      const offsetCount = offsetDataLength / 4;
      const offsets = new Uint32Array(offsetCount);
      offsets[0] = firstOffset;
      for (let offsetIdx = 1; offsetIdx < offsetCount; offsetIdx++) {
        const offset = dataView.getUint32(start + offsetIdx * 4, true);
        offsets[offsetIdx] = offset;
        if (offset > size) {
          throw new Error(`Offset out of bounds ${offset} > ${size}`);
        }
        if (offset < offsets[offsetIdx - 1]) {
          throw new Error(`Offsets must be increasing ${offset} < ${offsets[offsetIdx - 1]}`);
        }
      }
      return offsets;
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/arrayComposite.js
var require_arrayComposite2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/arrayComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayCompositeTreeView = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract2();
    var ArrayCompositeTreeView = class extends abstract_1.TreeView {
      constructor(type6, tree) {
        super();
        this.type = type6;
        this.tree = tree;
      }
      /**
       * Number of elements in the array. Equal to the Uint32 value of the Tree's length node
       */
      get length() {
        return this.type.tree_getLength(this.tree.rootNode);
      }
      /**
       * Returns the View's Tree rootNode
       */
      get node() {
        return this.tree.rootNode;
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type
       */
      get(index) {
        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
        const subtree = this.tree.getSubtree(gindex);
        return this.type.elementType.getView(subtree);
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type.
       * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.
       */
      getReadonly(index) {
        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
        const subtree = new persistent_merkle_tree_1.Tree(this.tree.getNode(gindex));
        return this.type.elementType.getView(subtree);
      }
      /**
       * Set Composite element type `view` at `index`
       */
      set(index, view) {
        const length2 = this.length;
        if (index >= length2) {
          throw Error(`Error setting index over length ${index} > ${length2}`);
        }
        const node = this.type.elementType.commitView(view);
        this.tree.setNodeAtDepth(this.type.depth, index, node);
      }
      /**
       * Returns an array of views of all elements in the array, from index zero to `this.length - 1`.
       * The returned views don't have a parent hook to this View's Tree, so changes in the returned views won't be
       * propagated upwards. To get linked element Views use `this.get()`
       */
      getAllReadonly() {
        const length2 = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length2);
        const views = new Array(length2);
        for (let i2 = 0; i2 < length2; i2++) {
          views[i2] = this.type.elementType.getView(new persistent_merkle_tree_1.Tree(nodes[i2]));
        }
        return views;
      }
      /**
       * Returns an array of values of all elements in the array, from index zero to `this.length - 1`.
       * The returned values are not Views so any changes won't be propagated upwards.
       * To get linked element Views use `this.get()`
       */
      getAllReadonlyValues() {
        const length2 = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length2);
        const values = new Array(length2);
        for (let i2 = 0; i2 < length2; i2++) {
          values[i2] = this.type.elementType.tree_toValue(nodes[i2]);
        }
        return values;
      }
    };
    exports.ArrayCompositeTreeView = ArrayCompositeTreeView;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/listComposite.js
var require_listComposite = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/view/listComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCompositeTreeView = void 0;
    var arrayComposite_1 = require_arrayComposite2();
    var ListCompositeTreeView = class extends arrayComposite_1.ArrayCompositeTreeView {
      constructor(type6, tree) {
        super(type6, tree);
        this.type = type6;
        this.tree = tree;
      }
      /**
       * Adds one view element at the end of the array and adds 1 to the current Tree length.
       */
      push(view) {
        const length2 = this.length;
        if (length2 >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.type.tree_setLength(this.tree, length2 + 1);
        this.set(length2, view);
      }
    };
    exports.ListCompositeTreeView = ListCompositeTreeView;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/arrayComposite.js
var require_arrayComposite3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/arrayComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayCompositeTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var abstract_1 = require_abstract3();
    var ArrayCompositeTreeViewDU = class extends abstract_1.TreeViewDU {
      constructor(type6, _rootNode, cache2) {
        super();
        this.type = type6;
        this._rootNode = _rootNode;
        this.viewsChanged = /* @__PURE__ */ new Map();
        this.dirtyLength = false;
        if (cache2) {
          this.nodes = cache2.nodes;
          this.caches = cache2.caches;
          this._length = cache2.length;
          this.nodesPopulated = cache2.nodesPopulated;
        } else {
          this.nodes = [];
          this.caches = [];
          this._length = this.type.tree_getLength(_rootNode);
          this.nodesPopulated = this._length === 0;
        }
      }
      /**
       * Number of elements in the array. Equal to un-commited length of the array
       */
      get length() {
        return this._length;
      }
      get node() {
        return this._rootNode;
      }
      get cache() {
        return {
          nodes: this.nodes,
          caches: this.caches,
          length: this._length,
          nodesPopulated: this.nodesPopulated
        };
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type.
       *
       * NOTE: Assumes that any view created here will change and will call .commit() on it.
       * .get() should be used only for cases when something may mutate. To get all items without
       * triggering a .commit() in all them use .getAllReadOnly().
       */
      get(index) {
        const viewChanged = this.viewsChanged.get(index);
        if (viewChanged) {
          return viewChanged;
        }
        let node = this.nodes[index];
        if (node === void 0) {
          node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
          this.nodes[index] = node;
        }
        const view = this.type.elementType.getViewDU(node, this.caches[index]);
        if (this.type.elementType.isViewMutable) {
          this.viewsChanged.set(index, view);
        }
        return view;
      }
      /**
       * Get element at `index`. Returns a view of the Composite element type.
       * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.
       */
      getReadonly(index) {
        const viewChanged = this.viewsChanged.get(index);
        if (viewChanged) {
          return viewChanged;
        }
        let node = this.nodes[index];
        if (node === void 0) {
          node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
          this.nodes[index] = node;
        }
        return this.type.elementType.getViewDU(node, this.caches[index]);
      }
      // Did not implemented
      // `getReadonlyValue(index: number): ValueOf<ElementType>`
      // because it can break in unexpected ways if there are pending changes in this.viewsChanged.
      // This function could first check if `this.viewsChanged` has a view for `index` and commit it,
      // but that would be pretty slow, and the same result can be achieved with
      // `this.getReadonly(index).toValue()`
      /**
       * Set Composite element type `view` at `index`
       */
      set(index, view) {
        if (index >= this._length) {
          throw Error(`Error setting index over length ${index} > ${this._length}`);
        }
        this.viewsChanged.set(index, view);
      }
      /**
       * WARNING: Returns all commited changes, if there are any pending changes commit them beforehand
       */
      getAllReadonly() {
        this.populateAllNodes();
        const views = new Array(this._length);
        for (let i2 = 0; i2 < this._length; i2++) {
          views[i2] = this.type.elementType.getViewDU(this.nodes[i2], this.caches[i2]);
        }
        return views;
      }
      /**
       * WARNING: Returns all commited changes, if there are any pending changes commit them beforehand
       */
      getAllReadonlyValues() {
        this.populateAllNodes();
        const values = new Array(this._length);
        for (let i2 = 0; i2 < this._length; i2++) {
          values[i2] = this.type.elementType.tree_toValue(this.nodes[i2]);
        }
        return values;
      }
      commit() {
        if (this.viewsChanged.size === 0) {
          return;
        }
        const nodesChanged = [];
        for (const [index, view] of this.viewsChanged) {
          const node = this.type.elementType.commitViewDU(view);
          this.nodes[index] = node;
          nodesChanged.push({ index, node });
          const cache2 = this.type.elementType.cacheOfViewDU(view);
          if (cache2)
            this.caches[index] = cache2;
        }
        const nodesChangedSorted = nodesChanged.sort((a, b) => a.index - b.index);
        const indexes = nodesChangedSorted.map((entry) => entry.index);
        const nodes = nodesChangedSorted.map((entry) => entry.node);
        const chunksNode = this.type.tree_getChunksNode(this._rootNode);
        const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);
        this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : void 0);
        this.viewsChanged.clear();
        this.dirtyLength = false;
      }
      clearCache() {
        this.nodes = [];
        this.caches = [];
        this.nodesPopulated = false;
        this.viewsChanged.clear();
        if (this.dirtyLength) {
          this._length = this.type.tree_getLength(this._rootNode);
          this.dirtyLength = false;
        }
      }
      populateAllNodes() {
        if (this.viewsChanged.size > 0) {
          throw Error("Must commit changes before reading all nodes");
        }
        if (!this.nodesPopulated) {
          this.nodes = persistent_merkle_tree_1.getNodesAtDepth(this._rootNode, this.type.depth, 0, this.length);
          this.nodesPopulated = true;
        }
      }
    };
    exports.ArrayCompositeTreeViewDU = ArrayCompositeTreeViewDU;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/listComposite.js
var require_listComposite2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/viewDU/listComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCompositeTreeViewDU = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var arrayComposite_1 = require_arrayComposite3();
    var ListCompositeTreeViewDU = class extends arrayComposite_1.ArrayCompositeTreeViewDU {
      constructor(type6, _rootNode, cache2) {
        super(type6, _rootNode, cache2);
        this.type = type6;
        this._rootNode = _rootNode;
      }
      /**
       * Adds one value element at the end of the array and adds 1 to the un-commited ViewDU length
       */
      push(view) {
        if (this._length >= this.type.limit) {
          throw Error("Error pushing over limit");
        }
        this.dirtyLength = true;
        const index = this._length++;
        this.set(index, view);
      }
      /**
       * Returns a new ListCompositeTreeViewDU instance with the values from 0 to `index`.
       * The new list is equivalent to (pseudo-code):
       *
       * ```ts
       * const nodes = getChunkNodes()
       * return listFromChunkNodes(nodes.slice(0, index + 1))
       * ```
       *
       * To achieve it, rebinds the underlying tree zero-ing all nodes right of `index`.
       *
       * Note: Using index = -1, returns an empty list of length 0.
       */
      sliceTo(index) {
        this.commit();
        const rootNode = this._rootNode;
        const length2 = this.type.tree_getLength(rootNode);
        if (index >= length2 - 1) {
          return this;
        }
        const chunksNode = this.type.tree_getChunksNode(rootNode);
        const newChunksNode = persistent_merkle_tree_1.treeZeroAfterIndex(chunksNode, this.type.chunkDepth, index);
        const newLength = index + 1;
        const newRootNode = this.type.tree_setChunksNode(rootNode, newChunksNode, newLength);
        return this.type.getViewDU(newRootNode);
      }
    };
    exports.ListCompositeTreeViewDU = ListCompositeTreeViewDU;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/listComposite.js
var require_listComposite3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/listComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCompositeType = void 0;
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var arrayComposite_1 = require_arrayComposite();
    var listComposite_1 = require_listComposite();
    var listComposite_2 = require_listComposite2();
    var array_1 = require_array();
    var ListCompositeType = class extends array_1.ArrayType {
      constructor(elementType, limit, opts) {
        super(elementType);
        this.elementType = elementType;
        this.limit = limit;
        this.itemsPerChunk = 1;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        this.defaultLen = 0;
        if (elementType.isBasic)
          throw Error("elementType must not be basic");
        if (limit === 0)
          throw Error("List limit must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `List[${elementType.typeName}, ${limit}]`;
        this.maxChunkCount = this.limit;
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth + 1;
        this.minSize = 0;
        this.maxSize = arrayComposite_1.maxSizeArrayComposite(elementType, this.limit);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(ListCompositeType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new listComposite_1.ListCompositeTreeView(this, tree);
      }
      getViewDU(node, cache2) {
        return new listComposite_2.ListCompositeTreeViewDU(this, node, cache2);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize(value2) {
        return arrayComposite_1.value_serializedSizeArrayComposite(this.elementType, value2.length, value2);
      }
      value_serializeToBytes(output, offset, value2) {
        return arrayComposite_1.value_serializeToBytesArrayComposite(this.elementType, value2.length, output, offset, value2);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.value_deserializeFromBytesArrayComposite(this.elementType, data, start, end, this);
      }
      tree_serializedSize(node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length2 = this.tree_getLength(node);
        return arrayComposite_1.tree_serializedSizeArrayComposite(this.elementType, length2, this.chunkDepth, chunksNode);
      }
      tree_serializeToBytes(output, offset, node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length2 = this.tree_getLength(node);
        return arrayComposite_1.tree_serializeToBytesArrayComposite(this.elementType, length2, this.chunkDepth, chunksNode, output, offset);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.tree_deserializeFromBytesArrayComposite(this.elementType, this.chunkDepth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength(node) {
        return arrayBasic_1.getLengthFromRootNode(node);
      }
      tree_setLength(tree, length2) {
        tree.rootNode = arrayBasic_1.addLengthNode(tree.rootNode.left, length2);
      }
      tree_getChunksNode(node) {
        return node.left;
      }
      tree_setChunksNode(rootNode, chunksNode, newLength) {
        return arrayBasic_1.setChunksNode(rootNode, chunksNode, newLength);
      }
      // Merkleization
      hashTreeRoot(value2) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value2), value2.length);
      }
      getRoots(value2) {
        return arrayComposite_1.value_getRootsArrayComposite(this.elementType, value2.length, value2);
      }
    };
    exports.ListCompositeType = ListCompositeType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/none.js
var require_none = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/none.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoneType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var basic_1 = require_basic();
    var NoneType = class extends basic_1.BasicType {
      constructor() {
        super(...arguments);
        this.typeName = "none";
        this.byteLength = 0;
        this.itemsPerChunk = 32;
        this.fixedSize = 0;
        this.minSize = 0;
        this.maxSize = 0;
      }
      defaultValue() {
        return null;
      }
      // bytes serdes
      value_serializeToBytes(output, offset, value2) {
        return offset;
      }
      value_deserializeFromBytes(data, start) {
        return null;
      }
      tree_serializeToBytes(output, offset, node) {
        return offset;
      }
      tree_deserializeFromBytes(data, start, end) {
        return persistent_merkle_tree_1.zeroNode(0);
      }
      // Fast tree opts
      tree_getFromNode(leafNode) {
        return null;
      }
      tree_setToNode(leafNode, value2) {
        return;
      }
      tree_getFromPackedNode(leafNode, index) {
        return null;
      }
      tree_setToPackedNode(leafNode, index, value2) {
        return;
      }
      // JSON
      fromJson(json) {
        if (json !== null) {
          throw Error("JSON invalid type none must be null");
        }
        return null;
      }
      toJson(value2) {
        return null;
      }
    };
    exports.NoneType = NoneType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/uint.js
var require_uint = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/uint.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var named_1 = require_named();
    var basic_1 = require_basic();
    var MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);
    var BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);
    var BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);
    var BIGINT_2_POW_192 = BigInt(2) ** BigInt(192);
    var NUMBER_2_POW_32 = 2 ** 32;
    var NUMBER_32_MAX = 4294967295;
    exports.uintNumberByteLens = [1, 2, 4, 8];
    exports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];
    var UintNumberType = class extends basic_1.BasicType {
      constructor(byteLength2, opts) {
        super();
        this.byteLength = byteLength2;
        if (byteLength2 > 8) {
          throw Error("UintNumber byteLength limit is 8");
        }
        if (Math.log2(byteLength2) % 1 !== 0) {
          throw Error("byteLength must be a power of 2");
        }
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `uint${byteLength2 * 8}`;
        if (opts == null ? void 0 : opts.clipInfinity)
          this.typeName += "Inf";
        if (opts == null ? void 0 : opts.setBitwiseOR)
          this.typeName += "OR";
        this.itemsPerChunk = 32 / this.byteLength;
        this.fixedSize = byteLength2;
        this.minSize = byteLength2;
        this.maxSize = byteLength2;
        this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);
        this.clipInfinity = (opts == null ? void 0 : opts.clipInfinity) === true;
        this.setBitwiseOR = (opts == null ? void 0 : opts.setBitwiseOR) === true;
      }
      static named(byteLength2, opts) {
        return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength2, opts);
      }
      defaultValue() {
        return 0;
      }
      // Serialization + deserialization
      value_serializeToBytes({ dataView }, offset, value2) {
        switch (this.byteLength) {
          case 1:
            dataView.setInt8(offset, value2);
            break;
          case 2:
            dataView.setUint16(offset, value2, true);
            break;
          case 4:
            dataView.setUint32(offset, value2, true);
            break;
          case 8:
            if (value2 === Infinity) {
              dataView.setUint32(offset, 4294967295);
              dataView.setUint32(offset + 4, 4294967295);
            } else {
              dataView.setUint32(offset, value2 & 4294967295, true);
              dataView.setUint32(offset + 4, value2 / NUMBER_2_POW_32 & 4294967295, true);
            }
            break;
        }
        return offset + this.byteLength;
      }
      value_deserializeFromBytes({ dataView }, start, end) {
        this.assertValidSize(end - start);
        switch (this.byteLength) {
          case 1:
            return dataView.getUint8(start);
          case 2:
            return dataView.getUint16(start, true);
          case 4:
            return dataView.getUint32(start, true);
          case 8: {
            const a = dataView.getUint32(start, true);
            const b = dataView.getUint32(start + 4, true);
            if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {
              return Infinity;
            } else {
              return b * NUMBER_2_POW_32 + a;
            }
          }
        }
      }
      tree_serializeToBytes(output, offset, node) {
        const value2 = node.getUint(this.byteLength, 0, this.clipInfinity);
        this.value_serializeToBytes(output, offset, value2);
        return offset + this.byteLength;
      }
      tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const value2 = this.value_deserializeFromBytes(data, start, end);
        const node = persistent_merkle_tree_1.LeafNode.fromZero();
        node.setUint(this.byteLength, 0, value2, this.clipInfinity);
        return node;
      }
      // Fast Tree access
      tree_getFromNode(leafNode) {
        return leafNode.getUint(this.byteLength, 0, this.clipInfinity);
      }
      tree_setToNode(leafNode, value2) {
        this.tree_setToPackedNode(leafNode, 0, value2);
      }
      tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);
      }
      tree_setToPackedNode(leafNode, index, value2) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        if (this.setBitwiseOR) {
          leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value2);
        } else {
          leafNode.setUint(this.byteLength, offsetBytes, value2, this.clipInfinity);
        }
      }
      // JSON
      fromJson(json) {
        if (typeof json === "number") {
          return json;
        } else if (typeof json === "string") {
          if (this.clipInfinity && json === this.maxDecimalStr) {
            return Infinity;
          } else {
            const num = parseInt(json, 10);
            if (isNaN(num)) {
              throw Error("JSON invalid number isNaN");
            } else if (num > Number.MAX_SAFE_INTEGER) {
              throw Error("JSON invalid number > MAX_SAFE_INTEGER");
            } else {
              return num;
            }
          }
        } else if (typeof json === "bigint") {
          if (json > MAX_SAFE_INTEGER_BN) {
            throw Error("JSON invalid number > MAX_SAFE_INTEGER_BN");
          } else {
            return Number(json);
          }
        } else {
          throw Error(`JSON invalid type ${typeof json} expected number`);
        }
      }
      toJson(value2) {
        if (value2 === Infinity) {
          return this.maxDecimalStr;
        } else {
          return value2.toString(10);
        }
      }
    };
    exports.UintNumberType = UintNumberType;
    var UintBigintType = class extends basic_1.BasicType {
      constructor(byteLength2, opts) {
        super();
        this.byteLength = byteLength2;
        if (byteLength2 > 32) {
          throw Error("UintBigint byteLength limit is 32");
        }
        if (Math.log2(byteLength2) % 1 !== 0) {
          throw Error("byteLength must be a power of 2");
        }
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `uintBigint${byteLength2 * 8}`;
        this.byteLength = byteLength2;
        this.itemsPerChunk = 32 / this.byteLength;
        this.fixedSize = byteLength2;
        this.minSize = byteLength2;
        this.maxSize = byteLength2;
      }
      static named(byteLength2, opts) {
        return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength2, opts);
      }
      defaultValue() {
        return BigInt(0);
      }
      // Serialization + deserialization
      value_serializeToBytes({ dataView }, offset, value2) {
        switch (this.byteLength) {
          case 1:
            dataView.setInt8(offset, Number(value2));
            break;
          case 2:
            dataView.setUint16(offset, Number(value2), true);
            break;
          case 4:
            dataView.setUint32(offset, Number(value2), true);
            break;
          case 8:
            dataView.setBigUint64(offset, value2, true);
            break;
          default: {
            for (let i2 = 0; i2 < this.byteLength; i2 += 8) {
              if (i2 > 0)
                value2 = value2 / BIGINT_2_POW_64;
              const lo = BigInt.asUintN(64, value2);
              dataView.setBigUint64(offset + i2, lo, true);
            }
          }
        }
        return offset + this.byteLength;
      }
      value_deserializeFromBytes({ dataView }, start, end) {
        const size = end - start;
        if (size !== this.byteLength) {
          throw Error(`Invalid size ${size} expected ${this.byteLength}`);
        }
        switch (this.byteLength) {
          case 1:
            return BigInt(dataView.getUint8(start));
          case 2:
            return BigInt(dataView.getUint16(start, true));
          case 4:
            return BigInt(dataView.getUint32(start, true));
          case 8:
            return dataView.getBigUint64(start, true);
          case 16: {
            const a = dataView.getBigUint64(start, true);
            const b = dataView.getBigUint64(start + 8, true);
            return b * BIGINT_2_POW_64 + a;
          }
          case 32: {
            const a = dataView.getBigUint64(start, true);
            const b = dataView.getBigUint64(start + 8, true);
            const c = dataView.getBigUint64(start + 16, true);
            const d = dataView.getBigUint64(start + 24, true);
            return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;
          }
        }
      }
      tree_serializeToBytes(output, offset, node) {
        const value2 = node.getUintBigint(this.byteLength, 0);
        this.value_serializeToBytes(output, offset, value2);
        return offset + this.byteLength;
      }
      tree_deserializeFromBytes(data, start, end) {
        const size = end - start;
        if (size !== this.byteLength) {
          throw Error(`Invalid size ${size} expected ${this.byteLength}`);
        }
        const value2 = this.value_deserializeFromBytes(data, start, end);
        const node = persistent_merkle_tree_1.LeafNode.fromZero();
        node.setUintBigint(this.byteLength, 0, value2);
        return node;
      }
      // Fast Tree access
      tree_getFromNode(leafNode) {
        return leafNode.getUintBigint(this.byteLength, 0);
      }
      /** Mutates node to set value */
      tree_setToNode(leafNode, value2) {
        this.tree_setToPackedNode(leafNode, 0, value2);
      }
      /** EXAMPLE of `tree_getFromNode` */
      tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        return leafNode.getUintBigint(this.byteLength, offsetBytes);
      }
      /** Mutates node to set value */
      tree_setToPackedNode(leafNode, index, value2) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        leafNode.setUintBigint(this.byteLength, offsetBytes, value2);
      }
      // JSON
      fromJson(json) {
        if (typeof json === "bigint") {
          return json;
        } else if (typeof json === "string" || typeof json === "number") {
          return BigInt(json);
        } else {
          throw Error(`JSON invalid type ${typeof json} expected bigint`);
        }
      }
      toJson(value2) {
        return value2.toString(10);
      }
    };
    exports.UintBigintType = UintBigintType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/union.js
var require_union = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/union.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnionType = void 0;
    var persistent_merkle_tree_1 = require_lib();
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var composite_1 = require_composite();
    var arrayBasic_1 = require_arrayBasic();
    var none_1 = require_none();
    var VALUE_GINDEX = BigInt(2);
    var SELECTOR_GINDEX = BigInt(3);
    var UnionType = class extends composite_1.CompositeType {
      constructor(types, opts) {
        super();
        this.types = types;
        this.depth = 1;
        this.maxChunkCount = 1;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        if (types.length >= 128) {
          throw Error("Must have less than 128 types");
        }
        if (types.length === 0) {
          throw Error("Must have at least 1 type option");
        }
        if (types[0] instanceof none_1.NoneType && types.length < 2) {
          throw Error("Must have at least 2 type options if the first is None");
        }
        for (let i2 = 1; i2 < types.length; i2++) {
          if (types[i2] instanceof none_1.NoneType) {
            throw Error("None may only be the first option");
          }
        }
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `Union[${types.map((t2) => t2.typeName).join(",")}]`;
        const minLens = [];
        const maxLens = [];
        for (const _type of types) {
          minLens.push(_type.minSize);
          maxLens.push(_type.maxSize);
        }
        this.minSize = 1 + Math.min(...minLens);
        this.maxSize = 1 + Math.max(...maxLens);
        this.maxSelector = this.types.length - 1;
      }
      static named(types, opts) {
        return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);
      }
      defaultValue() {
        return {
          selector: 0,
          value: this.types[0].defaultValue()
        };
      }
      getView(tree) {
        return this.tree_toValue(tree.rootNode);
      }
      getViewDU(node) {
        return this.tree_toValue(node);
      }
      cacheOfViewDU() {
        return;
      }
      commitView(view) {
        return this.value_toTree(view);
      }
      commitViewDU(view) {
        return this.value_toTree(view);
      }
      value_serializedSize(value2) {
        return 1 + this.types[value2.selector].value_serializedSize(value2.value);
      }
      value_serializeToBytes(output, offset, value2) {
        output.uint8Array[offset] = value2.selector;
        return this.types[value2.selector].value_serializeToBytes(output, offset + 1, value2.value);
      }
      value_deserializeFromBytes(data, start, end) {
        const selector = data.uint8Array[start];
        if (selector > this.maxSelector) {
          throw Error(`Invalid selector ${selector}`);
        }
        return {
          selector,
          value: this.types[selector].value_deserializeFromBytes(data, start + 1, end)
        };
      }
      tree_serializedSize(node) {
        const selector = arrayBasic_1.getLengthFromRootNode(node);
        const valueNode = node.left;
        return 1 + this.types[selector].value_serializedSize(valueNode);
      }
      tree_serializeToBytes(output, offset, node) {
        const selector = arrayBasic_1.getLengthFromRootNode(node);
        const valueNode = node.left;
        output.uint8Array[offset] = selector;
        return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);
      }
      tree_deserializeFromBytes(data, start, end) {
        const selector = data.uint8Array[start];
        if (selector > this.maxSelector) {
          throw Error(`Invalid selector ${selector}`);
        }
        const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);
        return arrayBasic_1.addLengthNode(valueNode, selector);
      }
      // Merkleization
      hashTreeRoot(value2) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value2), value2.selector);
      }
      getRoots(value2) {
        const valueRoot = this.types[value2.selector].hashTreeRoot(value2.value);
        return [valueRoot];
      }
      // Proofs
      getPropertyGindex(prop) {
        switch (prop) {
          case "value":
            return VALUE_GINDEX;
          case "selector":
            return SELECTOR_GINDEX;
          default:
            throw new Error(`Invalid Union type property ${prop}`);
        }
      }
      getPropertyType() {
        throw new Error("Not applicable for Union type");
      }
      getIndexProperty(index) {
        if (index === 0)
          return "value";
        if (index === 1)
          return "selector";
        throw Error("Union index of out bounds");
      }
      tree_getLeafGindices(rootGindex, rootNode) {
        if (!rootNode) {
          throw Error("rootNode required");
        }
        const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];
        const selector = arrayBasic_1.getLengthFromRootNode(rootNode);
        const type6 = this.types[selector];
        const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);
        if (composite_1.isCompositeType(type6)) {
          gindices.push(...type6.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));
        } else {
          gindices.push(extendedFieldGindex);
        }
        return gindices;
      }
      // JSON
      fromJson(json) {
        if (typeof json !== "object") {
          throw new Error("JSON must be of type object");
        }
        const union = json;
        if (typeof union.selector !== "number") {
          throw new Error("Invalid JSON Union selector must be number");
        }
        const type6 = this.types[union.selector];
        if (!type6) {
          throw new Error("Invalid JSON Union selector out of range");
        }
        return {
          selector: union.selector,
          value: type6.toJson(union.value)
        };
      }
      toJson(value2) {
        return {
          selector: value2.selector,
          value: this.types[value2.selector].toJson(value2.value)
        };
      }
      clone(value2) {
        return {
          selector: value2.selector,
          value: this.types[value2.selector].clone(value2.value)
        };
      }
      equals(a, b) {
        if (a.selector !== b.selector) {
          return false;
        }
        return this.types[a.selector].equals(a.value, b.value);
      }
    };
    exports.UnionType = UnionType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/vectorBasic.js
var require_vectorBasic = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/vectorBasic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorBasicType = void 0;
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayBasic_1 = require_arrayBasic();
    var arrayBasic_2 = require_arrayBasic2();
    var arrayBasic_3 = require_arrayBasic3();
    var array_1 = require_array();
    var VectorBasicType = class extends array_1.ArrayType {
      constructor(elementType, length2, opts) {
        super(elementType);
        this.elementType = elementType;
        this.length = length2;
        this.isList = false;
        this.isViewMutable = true;
        if (!elementType.isBasic)
          throw Error("elementType must be basic");
        if (length2 === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `Vector[${elementType.typeName}, ${length2}]`;
        this.itemsPerChunk = 32 / elementType.byteLength;
        this.maxChunkCount = Math.ceil(length2 * elementType.byteLength / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = length2 * elementType.byteLength;
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
        this.defaultLen = length2;
      }
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(VectorBasicType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new arrayBasic_2.ArrayBasicTreeView(this, tree);
      }
      getViewDU(node, cache2) {
        return new arrayBasic_3.ArrayBasicTreeViewDU(this, node, cache2);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize() {
        return this.fixedSize;
      }
      value_serializeToBytes(output, offset, value2) {
        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, output, offset, value2);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);
      }
      tree_serializedSize() {
        return this.fixedSize;
      }
      tree_serializeToBytes(output, offset, node) {
        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, output, offset, node);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength() {
        return this.length;
      }
      tree_setLength() {
      }
      tree_getChunksNode(node) {
        return node;
      }
      tree_setChunksNode(rootNode, chunksNode) {
        return chunksNode;
      }
      // Merkleization
      getRoots(value2) {
        const uint8Array = new Uint8Array(this.fixedSize);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, { uint8Array, dataView }, 0, value2);
        return merkleize_1.splitIntoRootChunks(uint8Array);
      }
    };
    exports.VectorBasicType = VectorBasicType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/vectorComposite.js
var require_vectorComposite = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/type/vectorComposite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorCompositeType = void 0;
    var merkleize_1 = require_merkleize();
    var named_1 = require_named();
    var arrayComposite_1 = require_arrayComposite();
    var arrayComposite_2 = require_arrayComposite2();
    var arrayComposite_3 = require_arrayComposite3();
    var array_1 = require_array();
    var VectorCompositeType = class extends array_1.ArrayType {
      constructor(elementType, length2, opts) {
        super(elementType);
        this.elementType = elementType;
        this.length = length2;
        this.itemsPerChunk = 1;
        this.isList = false;
        this.isViewMutable = true;
        if (elementType.isBasic)
          throw Error("elementType must not be basic");
        if (length2 === 0)
          throw Error("Vector length must be > 0");
        this.typeName = (opts == null ? void 0 : opts.typeName) ?? `Vector[${elementType.typeName}, ${length2}]`;
        this.maxChunkCount = length2;
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = elementType.fixedSize === null ? null : length2 * elementType.fixedSize;
        this.minSize = arrayComposite_1.minSizeArrayComposite(elementType, length2);
        this.maxSize = arrayComposite_1.maxSizeArrayComposite(elementType, length2);
        this.defaultLen = length2;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static named(elementType, limit, opts) {
        return new (named_1.namedClass(VectorCompositeType, opts.typeName))(elementType, limit, opts);
      }
      getView(tree) {
        return new arrayComposite_2.ArrayCompositeTreeView(this, tree);
      }
      getViewDU(node, cache2) {
        return new arrayComposite_3.ArrayCompositeTreeViewDU(this, node, cache2);
      }
      commitView(view) {
        return view.node;
      }
      commitViewDU(view) {
        view.commit();
        return view.node;
      }
      cacheOfViewDU(view) {
        return view.cache;
      }
      // Serialization + deserialization
      value_serializedSize(value2) {
        return arrayComposite_1.value_serializedSizeArrayComposite(this.elementType, this.length, value2);
      }
      value_serializeToBytes(output, offset, value2) {
        return arrayComposite_1.value_serializeToBytesArrayComposite(this.elementType, this.length, output, offset, value2);
      }
      value_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.value_deserializeFromBytesArrayComposite(this.elementType, data, start, end, this);
      }
      tree_serializedSize(node) {
        return arrayComposite_1.tree_serializedSizeArrayComposite(this.elementType, this.length, this.depth, node);
      }
      tree_serializeToBytes(output, offset, node) {
        return arrayComposite_1.tree_serializeToBytesArrayComposite(this.elementType, this.length, this.depth, node, output, offset);
      }
      tree_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.tree_deserializeFromBytesArrayComposite(this.elementType, this.depth, data, start, end, this);
      }
      // Helpers for TreeView
      tree_getLength() {
        return this.length;
      }
      tree_setLength() {
      }
      tree_getChunksNode(node) {
        return node;
      }
      tree_setChunksNode(rootNode, chunksNode) {
        return chunksNode;
      }
      // Merkleization
      getRoots(value2) {
        return arrayComposite_1.value_getRootsArrayComposite(this.elementType, this.length, value2);
      }
    };
    exports.VectorCompositeType = VectorCompositeType;
  }
});

// node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@chainsafe/ssz/lib/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash64 = exports.byteArrayEquals = exports.toHexString = exports.fromHexString = exports.getUint8ByteToBitBooleanArray = exports.BitArray = exports.TreeViewDU = exports.TreeView = exports.isCompositeType = exports.CompositeType = exports.isBasicType = exports.BasicType = exports.Type = exports.ByteArrayType = exports.BitArrayType = exports.ArrayType = exports.VectorCompositeType = exports.VectorBasicType = exports.UnionType = exports.UintNumberType = exports.UintBigintType = exports.NoneType = exports.ListCompositeType = exports.ListBasicType = exports.ContainerNodeStructType = exports.ContainerType = exports.ByteVectorType = exports.ByteListType = exports.BooleanType = exports.BitVectorType = exports.BitListType = void 0;
    var bitList_1 = require_bitList();
    Object.defineProperty(exports, "BitListType", { enumerable: true, get: function() {
      return bitList_1.BitListType;
    } });
    var bitVector_1 = require_bitVector();
    Object.defineProperty(exports, "BitVectorType", { enumerable: true, get: function() {
      return bitVector_1.BitVectorType;
    } });
    var boolean_1 = require_boolean();
    Object.defineProperty(exports, "BooleanType", { enumerable: true, get: function() {
      return boolean_1.BooleanType;
    } });
    var byteList_1 = require_byteList();
    Object.defineProperty(exports, "ByteListType", { enumerable: true, get: function() {
      return byteList_1.ByteListType;
    } });
    var byteVector_1 = require_byteVector();
    Object.defineProperty(exports, "ByteVectorType", { enumerable: true, get: function() {
      return byteVector_1.ByteVectorType;
    } });
    var container_1 = require_container3();
    Object.defineProperty(exports, "ContainerType", { enumerable: true, get: function() {
      return container_1.ContainerType;
    } });
    var containerNodeStruct_1 = require_containerNodeStruct3();
    Object.defineProperty(exports, "ContainerNodeStructType", { enumerable: true, get: function() {
      return containerNodeStruct_1.ContainerNodeStructType;
    } });
    var listBasic_1 = require_listBasic3();
    Object.defineProperty(exports, "ListBasicType", { enumerable: true, get: function() {
      return listBasic_1.ListBasicType;
    } });
    var listComposite_1 = require_listComposite3();
    Object.defineProperty(exports, "ListCompositeType", { enumerable: true, get: function() {
      return listComposite_1.ListCompositeType;
    } });
    var none_1 = require_none();
    Object.defineProperty(exports, "NoneType", { enumerable: true, get: function() {
      return none_1.NoneType;
    } });
    var uint_1 = require_uint();
    Object.defineProperty(exports, "UintBigintType", { enumerable: true, get: function() {
      return uint_1.UintBigintType;
    } });
    Object.defineProperty(exports, "UintNumberType", { enumerable: true, get: function() {
      return uint_1.UintNumberType;
    } });
    var union_1 = require_union();
    Object.defineProperty(exports, "UnionType", { enumerable: true, get: function() {
      return union_1.UnionType;
    } });
    var vectorBasic_1 = require_vectorBasic();
    Object.defineProperty(exports, "VectorBasicType", { enumerable: true, get: function() {
      return vectorBasic_1.VectorBasicType;
    } });
    var vectorComposite_1 = require_vectorComposite();
    Object.defineProperty(exports, "VectorCompositeType", { enumerable: true, get: function() {
      return vectorComposite_1.VectorCompositeType;
    } });
    var array_1 = require_array();
    Object.defineProperty(exports, "ArrayType", { enumerable: true, get: function() {
      return array_1.ArrayType;
    } });
    var bitArray_1 = require_bitArray4();
    Object.defineProperty(exports, "BitArrayType", { enumerable: true, get: function() {
      return bitArray_1.BitArrayType;
    } });
    var byteArray_1 = require_byteArray2();
    Object.defineProperty(exports, "ByteArrayType", { enumerable: true, get: function() {
      return byteArray_1.ByteArrayType;
    } });
    var abstract_1 = require_abstract();
    Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
      return abstract_1.Type;
    } });
    var basic_1 = require_basic();
    Object.defineProperty(exports, "BasicType", { enumerable: true, get: function() {
      return basic_1.BasicType;
    } });
    Object.defineProperty(exports, "isBasicType", { enumerable: true, get: function() {
      return basic_1.isBasicType;
    } });
    var composite_1 = require_composite();
    Object.defineProperty(exports, "CompositeType", { enumerable: true, get: function() {
      return composite_1.CompositeType;
    } });
    Object.defineProperty(exports, "isCompositeType", { enumerable: true, get: function() {
      return composite_1.isCompositeType;
    } });
    var abstract_2 = require_abstract2();
    Object.defineProperty(exports, "TreeView", { enumerable: true, get: function() {
      return abstract_2.TreeView;
    } });
    var abstract_3 = require_abstract3();
    Object.defineProperty(exports, "TreeViewDU", { enumerable: true, get: function() {
      return abstract_3.TreeViewDU;
    } });
    var bitArray_2 = require_bitArray();
    Object.defineProperty(exports, "BitArray", { enumerable: true, get: function() {
      return bitArray_2.BitArray;
    } });
    Object.defineProperty(exports, "getUint8ByteToBitBooleanArray", { enumerable: true, get: function() {
      return bitArray_2.getUint8ByteToBitBooleanArray;
    } });
    var byteArray_2 = require_byteArray();
    Object.defineProperty(exports, "fromHexString", { enumerable: true, get: function() {
      return byteArray_2.fromHexString;
    } });
    Object.defineProperty(exports, "toHexString", { enumerable: true, get: function() {
      return byteArray_2.toHexString;
    } });
    Object.defineProperty(exports, "byteArrayEquals", { enumerable: true, get: function() {
      return byteArray_2.byteArrayEquals;
    } });
    var merkleize_1 = require_merkleize();
    Object.defineProperty(exports, "hash64", { enumerable: true, get: function() {
      return merkleize_1.hash64;
    } });
  }
});

// node_modules/@ethereumjs/util/dist/ssz.js
var require_ssz = __commonJS({
  "node_modules/@ethereumjs/util/dist/ssz.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Withdrawals = exports.Withdrawal = exports.Bytes20 = exports.UintBigInt64 = exports.UintNum64 = void 0;
    var ssz_1 = require_lib2();
    var constants_1 = require_constants();
    exports.UintNum64 = new ssz_1.UintNumberType(8);
    exports.UintBigInt64 = new ssz_1.UintBigintType(8);
    exports.Bytes20 = new ssz_1.ByteVectorType(20);
    exports.Withdrawal = new ssz_1.ContainerType({
      index: exports.UintBigInt64,
      validatorIndex: exports.UintBigInt64,
      address: exports.Bytes20,
      amount: exports.UintBigInt64
    }, { typeName: "Withdrawal", jsonCase: "eth2" });
    exports.Withdrawals = new ssz_1.ListCompositeType(exports.Withdrawal, constants_1.MAX_WITHDRAWALS_PER_PAYLOAD);
  }
});

// node_modules/@ethereumjs/util/dist/encoding.js
var require_encoding = __commonJS({
  "node_modules/@ethereumjs/util/dist/encoding.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;
    var hasTerminator = (nibbles) => {
      return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;
    };
    exports.hasTerminator = hasTerminator;
    var nibblesToBytes = (nibbles, bytes) => {
      for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {
        bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];
      }
    };
    exports.nibblesToBytes = nibblesToBytes;
    var nibblesToCompactBytes = (nibbles) => {
      let terminator = 0;
      if ((0, exports.hasTerminator)(nibbles)) {
        terminator = 1;
        nibbles = nibbles.subarray(0, nibbles.length - 1);
      }
      const buf = new Uint8Array(nibbles.length / 2 + 1);
      buf[0] = terminator << 5;
      if ((nibbles.length & 1) === 1) {
        buf[0] |= 1 << 4;
        buf[0] |= nibbles[0];
        nibbles = nibbles.subarray(1);
      }
      (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));
      return buf;
    };
    exports.nibblesToCompactBytes = nibblesToCompactBytes;
    var bytesToNibbles = (str) => {
      const l = str.length * 2 + 1;
      const nibbles = new Uint8Array(l);
      for (let i2 = 0; i2 < str.length; i2++) {
        const b = str[i2];
        nibbles[i2 * 2] = b / 16;
        nibbles[i2 * 2 + 1] = b % 16;
      }
      nibbles[l - 1] = 16;
      return nibbles;
    };
    exports.bytesToNibbles = bytesToNibbles;
    var compactBytesToNibbles = (compact) => {
      if (compact.length === 0) {
        return compact;
      }
      let base = (0, exports.bytesToNibbles)(compact);
      if (base[0] < 2) {
        base = base.subarray(0, base.length - 1);
      }
      const chop = 2 - (base[0] & 1);
      return base.subarray(chop);
    };
    exports.compactBytesToNibbles = compactBytesToNibbles;
  }
});

// node_modules/@ethereumjs/util/dist/asyncEventEmitter.js
var require_asyncEventEmitter = __commonJS({
  "node_modules/@ethereumjs/util/dist/asyncEventEmitter.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncEventEmitter = void 0;
    var events_1 = require_events();
    async function runInSeries(context, tasks, data) {
      let error;
      for await (const task of tasks) {
        try {
          if (task.length < 2) {
            task.call(context, data);
          } else {
            await new Promise((resolve, reject) => {
              task.call(context, data, (error2) => {
                if (error2) {
                  reject(error2);
                } else {
                  resolve();
                }
              });
            });
          }
        } catch (e2) {
          error = e2;
        }
      }
      if (error) {
        throw error;
      }
    }
    var AsyncEventEmitter = class extends events_1.EventEmitter {
      emit(event, ...args) {
        let [data, callback] = args;
        const self2 = this;
        let listeners = self2._events[event] ?? [];
        if (callback === void 0 && typeof data === "function") {
          callback = data;
          data = void 0;
        }
        if (event === "newListener" || event === "removeListener") {
          data = {
            event: data,
            fn: callback
          };
          callback = void 0;
        }
        listeners = Array.isArray(listeners) ? listeners : [listeners];
        runInSeries(self2, listeners.slice(), data).then(callback).catch(callback);
        return self2.listenerCount(event) > 0;
      }
      once(event, listener) {
        const self2 = this;
        let g;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (listener.length >= 2) {
          g = function(e2, next) {
            self2.removeListener(event, g);
            void listener(e2, next);
          };
        } else {
          g = function(e2) {
            self2.removeListener(event, g);
            void listener(e2, g);
          };
        }
        self2.on(event, g);
        return self2;
      }
      first(event, listener) {
        let listeners = this._events[event] ?? [];
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        listeners.unshift(listener);
        return this;
      }
      before(event, target, listener) {
        return this.beforeOrAfter(event, target, listener);
      }
      after(event, target, listener) {
        return this.beforeOrAfter(event, target, listener, "after");
      }
      beforeOrAfter(event, target, listener, beforeOrAfter) {
        let listeners = this._events[event] ?? [];
        let i2;
        let index;
        const add = beforeOrAfter === "after" ? 1 : 0;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (typeof target !== "function") {
          throw new TypeError("target must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        index = listeners.length;
        for (i2 = listeners.length; i2--; ) {
          if (listeners[i2] === target) {
            index = i2 + add;
            break;
          }
        }
        listeners.splice(index, 0, listener);
        return this;
      }
      on(event, listener) {
        return super.on(event, listener);
      }
      addListener(event, listener) {
        return super.addListener(event, listener);
      }
      prependListener(event, listener) {
        return super.prependListener(event, listener);
      }
      prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
      }
      removeAllListeners(event) {
        return super.removeAllListeners(event);
      }
      removeListener(event, listener) {
        return super.removeListener(event, listener);
      }
      eventNames() {
        return super.eventNames();
      }
      listeners(event) {
        return super.listeners(event);
      }
      listenerCount(event) {
        return super.listenerCount(event);
      }
      getMaxListeners() {
        return super.getMaxListeners();
      }
      setMaxListeners(maxListeners) {
        return super.setMaxListeners(maxListeners);
      }
    };
    exports.AsyncEventEmitter = AsyncEventEmitter;
  }
});

// node_modules/@ethereumjs/util/dist/lock.js
var require_lock = __commonJS({
  "node_modules/@ethereumjs/util/dist/lock.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lock = void 0;
    var Lock = class {
      constructor() {
        this.permits = 1;
        this.promiseResolverQueue = [];
      }
      /**
       * Returns a promise used to wait for a permit to become available. This method should be awaited on.
       * @returns  A promise that gets resolved when execution is allowed to proceed.
       */
      async acquire() {
        if (this.permits > 0) {
          this.permits -= 1;
          return Promise.resolve(true);
        }
        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));
      }
      /**
       * Increases the number of permits by one. If there are other functions waiting, one of them will
       * continue to execute in a future iteration of the event loop.
       */
      release() {
        this.permits += 1;
        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
          console.warn("Lock.permits should never be > 0 when there is someone waiting.");
        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
          this.permits -= 1;
          const nextResolver = this.promiseResolverQueue.shift();
          if (nextResolver) {
            nextResolver(true);
          }
        }
      }
    };
    exports.Lock = Lock;
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/micro-ftch/index.js
var require_micro_ftch = __commonJS({
  "node_modules/micro-ftch/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStatusCodeError = exports.InvalidCertError = void 0;
    var DEFAULT_OPT = Object.freeze({
      redirect: true,
      expectStatusCode: 200,
      headers: {},
      full: false,
      keepAlive: true,
      cors: false,
      referrer: false,
      sslAllowSelfSigned: false,
      _redirectCount: 0
    });
    var InvalidCertError = class extends Error {
      constructor(msg, fingerprint256) {
        super(msg);
        this.fingerprint256 = fingerprint256;
      }
    };
    exports.InvalidCertError = InvalidCertError;
    var InvalidStatusCodeError = class extends Error {
      constructor(statusCode) {
        super(`Request Failed. Status Code: ${statusCode}`);
        this.statusCode = statusCode;
      }
    };
    exports.InvalidStatusCodeError = InvalidStatusCodeError;
    function detectType(b, type6) {
      if (!type6 || type6 === "text" || type6 === "json") {
        try {
          let text = new TextDecoder("utf8", { fatal: true }).decode(b);
          if (type6 === "text")
            return text;
          try {
            return JSON.parse(text);
          } catch (err) {
            if (type6 === "json")
              throw err;
            return text;
          }
        } catch (err) {
          if (type6 === "text" || type6 === "json")
            throw err;
        }
      }
      return b;
    }
    var agents = {};
    function fetchNode(url2, _options) {
      var _a;
      let options = { ...DEFAULT_OPT, ..._options };
      const http = require_http();
      const https = require_https();
      const zlib = require_zlib();
      const { promisify } = require_util();
      const { resolve: urlResolve } = require_url();
      const isSecure = !!/^https/.test(url2);
      let opts = {
        method: options.method || "GET",
        headers: { "Accept-Encoding": "gzip, deflate, br" }
      };
      const compactFP = (s) => s.replace(/:| /g, "").toLowerCase();
      if (options.keepAlive) {
        const agentOpt = {
          keepAlive: true,
          keepAliveMsecs: 30 * 1e3,
          maxFreeSockets: 1024,
          maxCachedSessions: 1024
        };
        const agentKey = [
          isSecure,
          isSecure && ((_a = options.sslPinnedCertificates) == null ? void 0 : _a.map((i2) => compactFP(i2)).sort())
        ].join();
        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));
      }
      if (options.type === "json")
        opts.headers["Content-Type"] = "application/json";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      opts.headers = { ...opts.headers, ...options.headers };
      if (options.sslAllowSelfSigned)
        opts.rejectUnauthorized = false;
      const handleRes = async (res) => {
        const status = res.statusCode;
        if (options.redirect && 300 <= status && status < 400 && res.headers["location"]) {
          if (options._redirectCount == 10)
            throw new Error("Request failed. Too much redirects.");
          options._redirectCount += 1;
          return await fetchNode(urlResolve(url2, res.headers["location"]), options);
        }
        if (options.expectStatusCode && status !== options.expectStatusCode) {
          res.resume();
          throw new InvalidStatusCodeError(status);
        }
        let buf = [];
        for await (const chunk of res)
          buf.push(chunk);
        let bytes = Buffer.concat(buf);
        const encoding = res.headers["content-encoding"];
        if (encoding === "br")
          bytes = await promisify(zlib.brotliDecompress)(bytes);
        if (encoding === "gzip" || encoding === "deflate")
          bytes = await promisify(zlib.unzip)(bytes);
        const body = detectType(bytes, options.type);
        if (options.full)
          return { headers: res.headers, status, body };
        return body;
      };
      return new Promise((resolve, reject) => {
        var _a2;
        const handleError = async (err) => {
          if (err && err.code === "DEPTH_ZERO_SELF_SIGNED_CERT") {
            try {
              await fetchNode(url2, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });
            } catch (e2) {
              if (e2 && e2.fingerprint256) {
                err = new InvalidCertError(`Self-signed SSL certificate: ${e2.fingerprint256}`, e2.fingerprint256);
              }
            }
          }
          reject(err);
        };
        const req = (isSecure ? https : http).request(url2, opts, (res) => {
          res.on("error", handleError);
          (async () => {
            try {
              resolve(await handleRes(res));
            } catch (error) {
              reject(error);
            }
          })();
        });
        req.on("error", handleError);
        const pinned = (_a2 = options.sslPinnedCertificates) == null ? void 0 : _a2.map((i2) => compactFP(i2));
        const mfetchSecureConnect = (socket) => {
          var _a3;
          const fp256 = compactFP(((_a3 = socket.getPeerCertificate()) == null ? void 0 : _a3.fingerprint256) || "");
          if (!fp256 && socket.isSessionReused())
            return;
          if (pinned.includes(fp256))
            return;
          req.emit("error", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));
          return req.abort();
        };
        if (options.sslPinnedCertificates) {
          req.on("socket", (socket) => {
            const hasListeners = socket.listeners("secureConnect").map((i2) => (i2.name || "").replace("bound ", "")).includes("mfetchSecureConnect");
            if (hasListeners)
              return;
            socket.on("secureConnect", mfetchSecureConnect.bind(null, socket));
          });
        }
        if (options.keepAlive)
          req.setNoDelay(true);
        if (opts.body)
          req.write(opts.body);
        req.end();
      });
    }
    var SAFE_HEADERS = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((i2) => i2.toLowerCase()));
    var FORBIDDEN_HEADERS = new Set([
      "Accept-Charset",
      "Accept-Encoding",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Connection",
      "Content-Length",
      "Cookie",
      "Cookie2",
      "Date",
      "DNT",
      "Expect",
      "Host",
      "Keep-Alive",
      "Origin",
      "Referer",
      "TE",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Via"
    ].map((i2) => i2.toLowerCase()));
    async function fetchBrowser(url2, _options) {
      let options = { ...DEFAULT_OPT, ..._options };
      const headers = new Headers();
      if (options.type === "json")
        headers.set("Content-Type", "application/json");
      let parsed = new URL(url2);
      if (parsed.username) {
        const auth = btoa(`${parsed.username}:${parsed.password}`);
        headers.set("Authorization", `Basic ${auth}`);
        parsed.username = "";
        parsed.password = "";
      }
      url2 = "" + parsed;
      for (let k in options.headers) {
        const name = k.toLowerCase();
        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name))
          headers.set(k, options.headers[k]);
      }
      let opts = { headers, redirect: options.redirect ? "follow" : "manual" };
      if (!options.referrer)
        opts.referrerPolicy = "no-referrer";
      if (options.cors)
        opts.mode = "cors";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      const res = await fetch(url2, opts);
      if (options.expectStatusCode && res.status !== options.expectStatusCode)
        throw new InvalidStatusCodeError(res.status);
      const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);
      if (options.full)
        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };
      return body;
    }
    var IS_NODE = !!(typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
    function fetchUrl(url2, options) {
      const fn = IS_NODE ? fetchNode : fetchBrowser;
      return fn(url2, options);
    }
    exports.default = fetchUrl;
  }
});

// node_modules/@ethereumjs/util/dist/provider.js
var require_provider = __commonJS({
  "node_modules/@ethereumjs/util/dist/provider.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProvider = exports.fetchFromProvider = void 0;
    var micro_ftch_1 = require_micro_ftch();
    var fetchFromProvider = async (url2, params) => {
      const res = await (0, micro_ftch_1.default)(url2, {
        headers: {
          "content-type": "application/json"
        },
        type: "json",
        data: {
          method: params.method,
          params: params.params,
          jsonrpc: "2.0",
          id: 1
        }
      });
      return res.result;
    };
    exports.fetchFromProvider = fetchFromProvider;
    var getProvider = (provider) => {
      var _a;
      if (typeof provider === "string") {
        return provider;
      } else if (((_a = provider == null ? void 0 : provider.connection) == null ? void 0 : _a.url) !== void 0) {
        return provider.connection.url;
      } else {
        throw new Error("Must provide valid provider URL or Web3Provider");
      }
    };
    exports.getProvider = getProvider;
  }
});

// node_modules/@ethereumjs/util/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@ethereumjs/util/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = exports.ssz = void 0;
    __exportStar(require_constants(), exports);
    __exportStar(require_units(), exports);
    __exportStar(require_account(), exports);
    __exportStar(require_address(), exports);
    __exportStar(require_withdrawal(), exports);
    __exportStar(require_signature(), exports);
    __exportStar(require_bytes(), exports);
    exports.ssz = require_ssz();
    __exportStar(require_types(), exports);
    __exportStar(require_encoding(), exports);
    __exportStar(require_asyncEventEmitter(), exports);
    var internal_1 = require_internal();
    Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
    Object.defineProperty(exports, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    __exportStar(require_lock(), exports);
    __exportStar(require_provider(), exports);
  }
});

// node_modules/bignumber.js/bignumber.mjs
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet2, c, caseChanged, e2, i2, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e2 = 0, i2 = v; i2 >= 10; i2 /= 10, e2++)
            ;
          if (e2 > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e2;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e2 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i2 = str.search(/e/i)) > 0) {
        if (e2 < 0)
          e2 = i2;
        e2 += +str.slice(i2 + 1);
        str = str.substring(0, i2);
      } else if (e2 < 0) {
        e2 = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet2 = ALPHABET.slice(0, b);
      e2 = i2 = 0;
      for (len = str.length; i2 < len; i2++) {
        if (alphabet2.indexOf(c = str.charAt(i2)) < 0) {
          if (c == ".") {
            if (i2 > e2) {
              e2 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i2 = -1;
              e2 = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e2 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e2 = str.length;
    }
    for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i2, ++len)) {
      len -= i2;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e2 = e2 - i2 - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e2 < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e2;
        x.c = [];
        i2 = (e2 + 1) % LOG_BASE;
        if (e2 < 0)
          i2 += LOG_BASE;
        if (i2 < len) {
          if (i2)
            x.c.push(+str.slice(0, i2));
          for (len -= LOG_BASE; i2 < len; ) {
            x.c.push(+str.slice(i2, i2 += LOG_BASE));
          }
          i2 = LOG_BASE - (str = str.slice(i2)).length;
        } else {
          i2 -= len;
        }
        for (; i2--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i2, n2, c = v.c, e2 = v.e, s = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
          if (c[0] === 0) {
            if (e2 === 0 && c.length === 1)
              return true;
            break out;
          }
          i2 = (e2 + 1) % LOG_BASE;
          if (i2 < 1)
            i2 += LOG_BASE;
          if (String(c[0]).length == i2) {
            for (i2 = 0; i2 < c.length; i2++) {
              n2 = c[i2];
              if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2))
                break out;
            }
            if (n2 !== 0)
              return true;
          }
        }
      } else if (c === null && e2 === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, P.lt);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, P.gt);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e2, k, v, i2 = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i2 < k; ) {
            v = a[i2] * 131072 + (a[i2 + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i2] = b[0];
              a[i2 + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i2 += 2;
            }
          }
          i2 = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i2 < k; ) {
            v = (a[i2] & 31) * 281474976710656 + a[i2 + 1] * 1099511627776 + a[i2 + 2] * 4294967296 + a[i2 + 3] * 16777216 + (a[i2 + 4] << 16) + (a[i2 + 5] << 8) + a[i2 + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i2);
            } else {
              c.push(v % 1e14);
              i2 += 7;
            }
          }
          i2 = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i2 < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i2++] = v % 1e14;
        }
      }
      k = c[--i2];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i2] = mathfloor(k / v) * v;
      }
      for (; c[i2] === 0; c.pop(), i2--)
        ;
      if (i2 < 0) {
        c = [e2 = 0];
      } else {
        for (e2 = -1; c[0] === 0; c.splice(0, 1), e2 -= LOG_BASE)
          ;
        for (i2 = 1, v = c[0]; v >= 10; v /= 10, i2++)
          ;
        if (i2 < LOG_BASE)
          e2 -= LOG_BASE - i2;
      }
      rand.e = e2;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i2 < args.length; )
      sum = sum.plus(args[i2++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet2) {
      var j, arr = [0], arrL, i2 = 0, len = str.length;
      for (; i2 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet2.indexOf(str.charAt(i2++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet2, d, e2, k, r2, x, xc, y, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i2 >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i2);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
      e2 = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet2.charAt(0);
      if (i2 < 0) {
        --e2;
      } else {
        x.c = xc;
        x.e = e2;
        x.s = sign2;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r2 = x.r;
        e2 = x.e;
      }
      d = e2 + dp + 1;
      i2 = xc[d];
      k = baseOut / 2;
      r2 = r2 || d < 0 || xc[d + 1] != null;
      r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i2 > k || i2 == k && (rm == 4 || r2 || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
      } else {
        xc.length = d;
        if (r2) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e2;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i2 = 0, str = ""; i2 <= k; str += alphabet2.charAt(xc[i2++]))
          ;
        str = toFixedPoint(str, e2, alphabet2.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i2 = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i2--; ) {
        xlo = x[i2] % SQRT_BASE;
        xhi = x[i2] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i2] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i2, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i2 = cmp = 0; i2 < aL; i2++) {
          if (a[i2] != b[i2]) {
            cmp = a[i2] > b[i2] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i2 = 0;
      for (; aL--; ) {
        a[aL] -= i2;
        i2 = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i2 * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e2, i2, more, n2, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e2 = x.e - y.e;
      s = dp + e2 + 1;
      if (!base) {
        base = BASE;
        e2 = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
        ;
      if (yc[i2] > (xc[i2] || 0))
        e2--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i2 = 0;
        s += 2;
        n2 = mathfloor(base / (yc[0] + 1));
        if (n2 > 1) {
          yc = multiply(yc, n2, base);
          xc = multiply(xc, n2, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n2 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n2 = mathfloor(rem0 / yc0);
            if (n2 > 1) {
              if (n2 >= base)
                n2 = base - 1;
              prod = multiply(yc, n2, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n2--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n2 == 0) {
                cmp = n2 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n2++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n2++;
            rem = [0];
          }
          qc[i2++] = n2;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i2 = 1, s = qc[0]; s >= 10; s /= 10, i2++)
          ;
        round(q, dp + (q.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e2;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n2, i2, rm, id) {
    var c0, e2, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n2.c)
      return n2.toString();
    c0 = n2.c[0];
    ne = n2.e;
    if (i2 == null) {
      str = coeffToString(n2.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n2 = round(new BigNumber2(n2), i2, rm);
      e2 = n2.e;
      str = coeffToString(n2.c);
      len = str.length;
      if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
        for (; len < i2; str += "0", len++)
          ;
        str = toExponential(str, e2);
      } else {
        i2 -= ne;
        str = toFixedPoint(str, e2, "0");
        if (e2 + 1 > len) {
          if (--i2 > 0)
            for (str += "."; i2--; str += "0")
              ;
        } else {
          i2 += e2 - len;
          if (i2 > 0) {
            if (e2 + 1 == len)
              str += ".";
            for (; i2--; str += "0")
              ;
          }
        }
      }
    }
    return n2.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, method) {
    var n2, i2 = 1, m = new BigNumber2(args[0]);
    for (; i2 < args.length; i2++) {
      n2 = new BigNumber2(args[i2]);
      if (!n2.s) {
        m = n2;
        break;
      } else if (method.call(m, n2)) {
        m = n2;
      }
    }
    return m;
  }
  function normalise(n2, c, e2) {
    var i2 = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i2++)
      ;
    if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
      n2.c = n2.e = null;
    } else if (e2 < MIN_EXP) {
      n2.c = [n2.e = 0];
    } else {
      n2.e = e2;
      n2.c = c;
    }
    return n2;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r2) {
    var d, i2, j, k, n2, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
          ;
        i2 = sd - d;
        if (i2 < 0) {
          i2 += LOG_BASE;
          j = sd;
          n2 = xc[ni = 0];
          rd = n2 / pows10[d - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i2 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r2) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n2 = rd = 0;
              d = 1;
              i2 %= LOG_BASE;
              j = i2 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n2 = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++)
              ;
            i2 %= LOG_BASE;
            j = i2 - LOG_BASE + d;
            rd = j < 0 ? 0 : n2 / pows10[d - j - 1] % 10 | 0;
          }
        }
        r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n2 : n2 % pows10[d - j - 1]);
        r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i2 > 0 ? j > 0 ? n2 / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r2) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i2 == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i2];
          xc[ni] = j > 0 ? mathfloor(n2 / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r2) {
          for (; ; ) {
            if (ni == 0) {
              for (i2 = 1, j = xc[0]; j >= 10; j /= 10, i2++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i2 != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i2 = xc.length; xc[--i2] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n2) {
    var str, e2 = n2.e;
    if (e2 === null)
      return n2.toString();
    str = coeffToString(n2.c);
    str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
    return n2.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n2, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n2 = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n2--)
        ;
    if (n2 < 0)
      n2 = 0;
    return n2;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n2, m) {
    var half, isModExp, i2, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n2 = new BigNumber2(n2);
    if (n2.c && !n2.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n2.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n2.c || !n2.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n2.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n2.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n2) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n2.s = 1;
      nIsOdd = isOdd(n2);
    } else {
      i2 = Math.abs(+valueOf(n2));
      nIsOdd = i2 % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i2) {
        i2 = mathfloor(i2 / 2);
        if (i2 === 0)
          break;
        nIsOdd = i2 % 2;
      } else {
        n2 = n2.times(half);
        round(n2, n2.e + 1, 1);
        if (n2.e > 14) {
          nIsOdd = isOdd(n2);
        } else {
          i2 = +valueOf(n2);
          if (i2 === 0)
            break;
          nIsOdd = i2 % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n2 = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n2, n2.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i2, j, t2, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t2 = xc;
      } else {
        ye = xe;
        t2 = yc;
      }
      t2.reverse();
      for (b = a; b--; t2.push(0))
        ;
      t2.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy)
      t2 = xc, xc = yc, yc = t2, y.s = -y.s;
    b = (j = yc.length) - (i2 = xc.length);
    if (b > 0)
      for (; b--; xc[i2++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i2 = j; i2 && !xc[--i2]; xc[i2] = b)
          ;
        --xc[i2];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e2, i2, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e2 = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL)
      zc = xc, xc = yc, yc = zc, i2 = xcL, xcL = ycL, ycL = i2;
    for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i2 = ycL; --i2 >= 0; ) {
      c = 0;
      ylo = yc[i2] % sqrtBase;
      yhi = yc[i2] / sqrtBase | 0;
      for (k = xcL, j = i2 + k; j > i2; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e2;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e2);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t2, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t2 = yc;
      } else {
        a = -a;
        t2 = xc;
      }
      t2.reverse();
      for (; a--; t2.push(0))
        ;
      t2.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0)
      t2 = yc, yc = xc, xc = t2, b = a;
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n2, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n2 = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n2--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n2++)
        ;
    }
    if (sd && x.e + 1 > n2)
      n2 = x.e + 1;
    return n2;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n2, r2, rep, t2, x = this, c = x.c, s = x.s, e2 = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n2 = coeffToString(c);
      if ((n2.length + e2) % 2 == 0)
        n2 += "0";
      s = Math.sqrt(+n2);
      e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
      if (s == 1 / 0) {
        n2 = "5e" + e2;
      } else {
        n2 = s.toExponential();
        n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
      }
      r2 = new BigNumber2(n2);
    } else {
      r2 = new BigNumber2(s + "");
    }
    if (r2.c[0]) {
      e2 = r2.e;
      s = e2 + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t2 = r2;
        r2 = half.times(t2.plus(div(x, t2, dp, 1)));
        if (coeffToString(t2.c).slice(0, s) === (n2 = coeffToString(r2.c)).slice(0, s)) {
          if (r2.e < e2)
            --s;
          n2 = n2.slice(s - 3, s + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              round(t2, t2.e + DECIMAL_PLACES + 2, 0);
              if (t2.times(t2).eq(x)) {
                r2 = t2;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              round(r2, r2.e + DECIMAL_PLACES + 2, 1);
              m = !r2.times(r2).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2)
        i2 = g1, g1 = g2, g2 = i2, len -= i2;
      if (g1 > 0 && len > 0) {
        i2 = len % g1 || g1;
        intPart = intDigits.substr(0, i2);
        for (; i2 < len; i2 += g1)
          intPart += groupSeparator + intDigits.substr(i2, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i2);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e2, exp, n2, n0, n1, q, r2, s, x = this, xc = x.c;
    if (md != null) {
      n2 = new BigNumber2(md);
      if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e2 = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n2.comparedTo(d) > 0 ? e2 > 0 ? d : n1 : n2;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n2 = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n2, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n2.minus(q.times(d2 = d));
      n2 = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e2 = e2 * 2;
    r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e2, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r2;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n2 = this, s = n2.s, e2 = n2.e;
    if (e2 === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b, s, true);
      }
      if (s < 0 && n2.c[0])
        str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n2) {
  var i2 = n2 | 0;
  return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
}
function coeffToString(a) {
  var s, z, i2 = 1, j = a.length, r2 = a[0] + "";
  for (; i2 < j; ) {
    s = a[i2++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s)
      ;
    r2 += s;
  }
  for (j = r2.length; r2.charCodeAt(--j) === 48; )
    ;
  return r2.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i2 = x.s, j = y.s, k = x.e, l = y.e;
  if (!i2 || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i2;
  if (i2 != j)
    return i2;
  a = i2 < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i2 = 0; i2 < j; i2++)
    if (xc[i2] != yc[i2])
      return xc[i2] > yc[i2] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n2, min, max, name) {
  if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
  }
}
function isOdd(n2) {
  var k = n2.c.length - 1;
  return bitFloor(n2.e / LOG_BASE) == k && n2.c[k] % 2 != 0;
}
function toExponential(str, e2) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
}
function toFixedPoint(str, e2, z) {
  var len, zs;
  if (e2 < 0) {
    for (zs = z + "."; ++e2; zs += z)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e2 > len) {
      for (zs = z, e2 -= len; --e2; zs += z)
        ;
      str += zs;
    } else if (e2 < len) {
      str = str.slice(0, e2) + "." + str.slice(e2);
    }
  }
  return str;
}
var isNumeric, mathceil, mathfloor, bignumberError, tooManyDigits, BASE, LOG_BASE, MAX_SAFE_INTEGER, POWS_TEN, SQRT_BASE, MAX, BigNumber, bignumber_default;
var init_bignumber = __esm({
  "node_modules/bignumber.js/bignumber.mjs"() {
    init_process();
    init_buffer();
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
    mathceil = Math.ceil;
    mathfloor = Math.floor;
    bignumberError = "[BigNumber Error] ";
    tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
    BASE = 1e14;
    LOG_BASE = 14;
    MAX_SAFE_INTEGER = 9007199254740991;
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
    SQRT_BASE = 1e7;
    MAX = 1e9;
    BigNumber = clone();
    bignumber_default = BigNumber;
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_randombytes2, import_base64url2, import_keccak2;
var init_openloginUtils_esm2 = __esm({
  "node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js"() {
    init_process();
    init_buffer();
    import_randombytes2 = __toESM(require_browser());
    init_defineProperty();
    import_base64url2 = __toESM(require_base64url2());
    import_keccak2 = __toESM(require_js());
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/classes.js
var require_classes2 = __commonJS({
  "node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_, value2) {
      if (value2 === "[Circular]") {
        return void 0;
      }
      return value2;
    }
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants2 = __commonJS({
  "node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/utils.js
var require_utils6 = __commonJS({
  "node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants2();
    var classes_1 = require_classes2();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError4(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError4;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes2();
    var utils_1 = require_utils6();
    var error_constants_1 = require_error_constants2();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@toruslabs/base-controllers/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes2();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils6();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors2();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants2();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js
function safeApply2(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    setTimeout(() => {
      throw err;
    });
  }
}
function arrayClone2(arr) {
  const n2 = arr.length;
  const copy = new Array(n2);
  for (let i2 = 0; i2 < n2; i2 += 1) {
    copy[i2] = arr[i2];
  }
  return copy;
}
function createAsyncMiddleware2(asyncMiddleware) {
  return async (req, res, next, end) => {
    let resolveNextPromise;
    const nextPromise = new Promise((resolve) => {
      resolveNextPromise = resolve;
    });
    let returnHandlerCallback = null;
    let nextWasCalled = false;
    const asyncNext = async () => {
      nextWasCalled = true;
      next((runReturnHandlersCallback) => {
        returnHandlerCallback = runReturnHandlersCallback;
        resolveNextPromise();
      });
      await nextPromise;
    };
    try {
      await asyncMiddleware(req, res, asyncNext);
      if (nextWasCalled) {
        await nextPromise;
        returnHandlerCallback(null);
      } else {
        end(null);
      }
    } catch (error) {
      if (returnHandlerCallback) {
        returnHandlerCallback(error);
      } else {
        end(error);
      }
    }
  };
}
var import_readable_stream2, import_events2, import_fast_safe_stringify2, import_eth_rpc_errors2, import_end_of_stream2, import_once2, import_pump2, SafeEventEmitter2, IGNORE_SUBSTREAM2;
var init_openloginJrpc_esm2 = __esm({
  "node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    import_readable_stream2 = __toESM(require_readable_browser());
    init_openloginUtils_esm2();
    import_events2 = __toESM(require_events());
    import_fast_safe_stringify2 = __toESM(require_fast_safe_stringify());
    import_eth_rpc_errors2 = __toESM(require_dist4());
    import_end_of_stream2 = __toESM(require_end_of_stream());
    import_once2 = __toESM(require_once());
    import_pump2 = __toESM(require_pump());
    SafeEventEmitter2 = class extends import_events2.EventEmitter {
      emit(type6) {
        let doError = type6 === "error";
        const events = this._events;
        if (events !== void 0) {
          doError = doError && events.error === void 0;
        } else if (!doError) {
          return false;
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (doError) {
          let er;
          if (args.length > 0) {
            [er] = args;
          }
          if (er instanceof Error) {
            throw er;
          }
          const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
          err.context = er;
          throw err;
        }
        const handler = events[type6];
        if (handler === void 0) {
          return false;
        }
        if (typeof handler === "function") {
          safeApply2(handler, this, args);
        } else {
          const len = handler.length;
          const listeners = arrayClone2(handler);
          for (let i2 = 0; i2 < len; i2 += 1) {
            safeApply2(listeners[i2], this, args);
          }
        }
        return true;
      }
    };
    IGNORE_SUBSTREAM2 = Symbol("IGNORE_SUBSTREAM");
  }
});

// node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/json-rpc-random-id/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max);
      return function createRandomId3() {
        idCounter = idCounter % max;
        return idCounter++;
      };
    }
  }
});

// node_modules/bowser/src/constants.js
var BROWSER_ALIASES_MAP, BROWSER_MAP, PLATFORMS_MAP, OS_MAP, ENGINE_MAP;
var init_constants = __esm({
  "node_modules/bowser/src/constants.js"() {
    init_process();
    init_buffer();
    BROWSER_ALIASES_MAP = {
      "Amazon Silk": "amazon_silk",
      "Android Browser": "android",
      Bada: "bada",
      BlackBerry: "blackberry",
      Chrome: "chrome",
      Chromium: "chromium",
      Electron: "electron",
      Epiphany: "epiphany",
      Firefox: "firefox",
      Focus: "focus",
      Generic: "generic",
      "Google Search": "google_search",
      Googlebot: "googlebot",
      "Internet Explorer": "ie",
      "K-Meleon": "k_meleon",
      Maxthon: "maxthon",
      "Microsoft Edge": "edge",
      "MZ Browser": "mz",
      "NAVER Whale Browser": "naver",
      Opera: "opera",
      "Opera Coast": "opera_coast",
      PhantomJS: "phantomjs",
      Puffin: "puffin",
      QupZilla: "qupzilla",
      QQ: "qq",
      QQLite: "qqlite",
      Safari: "safari",
      Sailfish: "sailfish",
      "Samsung Internet for Android": "samsung_internet",
      SeaMonkey: "seamonkey",
      Sleipnir: "sleipnir",
      Swing: "swing",
      Tizen: "tizen",
      "UC Browser": "uc",
      Vivaldi: "vivaldi",
      "WebOS Browser": "webos",
      WeChat: "wechat",
      "Yandex Browser": "yandex",
      Roku: "roku"
    };
    BROWSER_MAP = {
      amazon_silk: "Amazon Silk",
      android: "Android Browser",
      bada: "Bada",
      blackberry: "BlackBerry",
      chrome: "Chrome",
      chromium: "Chromium",
      electron: "Electron",
      epiphany: "Epiphany",
      firefox: "Firefox",
      focus: "Focus",
      generic: "Generic",
      googlebot: "Googlebot",
      google_search: "Google Search",
      ie: "Internet Explorer",
      k_meleon: "K-Meleon",
      maxthon: "Maxthon",
      edge: "Microsoft Edge",
      mz: "MZ Browser",
      naver: "NAVER Whale Browser",
      opera: "Opera",
      opera_coast: "Opera Coast",
      phantomjs: "PhantomJS",
      puffin: "Puffin",
      qupzilla: "QupZilla",
      qq: "QQ Browser",
      qqlite: "QQ Browser Lite",
      safari: "Safari",
      sailfish: "Sailfish",
      samsung_internet: "Samsung Internet for Android",
      seamonkey: "SeaMonkey",
      sleipnir: "Sleipnir",
      swing: "Swing",
      tizen: "Tizen",
      uc: "UC Browser",
      vivaldi: "Vivaldi",
      webos: "WebOS Browser",
      wechat: "WeChat",
      yandex: "Yandex Browser"
    };
    PLATFORMS_MAP = {
      tablet: "tablet",
      mobile: "mobile",
      desktop: "desktop",
      tv: "tv"
    };
    OS_MAP = {
      WindowsPhone: "Windows Phone",
      Windows: "Windows",
      MacOS: "macOS",
      iOS: "iOS",
      Android: "Android",
      WebOS: "WebOS",
      BlackBerry: "BlackBerry",
      Bada: "Bada",
      Tizen: "Tizen",
      Linux: "Linux",
      ChromeOS: "Chrome OS",
      PlayStation4: "PlayStation 4",
      Roku: "Roku"
    };
    ENGINE_MAP = {
      EdgeHTML: "EdgeHTML",
      Blink: "Blink",
      Trident: "Trident",
      Presto: "Presto",
      Gecko: "Gecko",
      WebKit: "WebKit"
    };
  }
});

// node_modules/bowser/src/utils.js
var Utils;
var init_utils = __esm({
  "node_modules/bowser/src/utils.js"() {
    init_process();
    init_buffer();
    init_constants();
    Utils = class {
      /**
       * Get first matched item for a string
       * @param {RegExp} regexp
       * @param {String} ua
       * @return {Array|{index: number, input: string}|*|boolean|string}
       */
      static getFirstMatch(regexp, ua) {
        const match = ua.match(regexp);
        return match && match.length > 0 && match[1] || "";
      }
      /**
       * Get second matched item for a string
       * @param regexp
       * @param {String} ua
       * @return {Array|{index: number, input: string}|*|boolean|string}
       */
      static getSecondMatch(regexp, ua) {
        const match = ua.match(regexp);
        return match && match.length > 1 && match[2] || "";
      }
      /**
       * Match a regexp and return a constant or undefined
       * @param {RegExp} regexp
       * @param {String} ua
       * @param {*} _const Any const that will be returned if regexp matches the string
       * @return {*}
       */
      static matchAndReturnConst(regexp, ua, _const) {
        if (regexp.test(ua)) {
          return _const;
        }
        return void 0;
      }
      static getWindowsVersionName(version) {
        switch (version) {
          case "NT":
            return "NT";
          case "XP":
            return "XP";
          case "NT 5.0":
            return "2000";
          case "NT 5.1":
            return "XP";
          case "NT 5.2":
            return "2003";
          case "NT 6.0":
            return "Vista";
          case "NT 6.1":
            return "7";
          case "NT 6.2":
            return "8";
          case "NT 6.3":
            return "8.1";
          case "NT 10.0":
            return "10";
          default:
            return void 0;
        }
      }
      /**
       * Get macOS version name
       *    10.5 - Leopard
       *    10.6 - Snow Leopard
       *    10.7 - Lion
       *    10.8 - Mountain Lion
       *    10.9 - Mavericks
       *    10.10 - Yosemite
       *    10.11 - El Capitan
       *    10.12 - Sierra
       *    10.13 - High Sierra
       *    10.14 - Mojave
       *    10.15 - Catalina
       *
       * @example
       *   getMacOSVersionName("10.14") // 'Mojave'
       *
       * @param  {string} version
       * @return {string} versionName
       */
      static getMacOSVersionName(version) {
        const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
        v.push(0);
        if (v[0] !== 10)
          return void 0;
        switch (v[1]) {
          case 5:
            return "Leopard";
          case 6:
            return "Snow Leopard";
          case 7:
            return "Lion";
          case 8:
            return "Mountain Lion";
          case 9:
            return "Mavericks";
          case 10:
            return "Yosemite";
          case 11:
            return "El Capitan";
          case 12:
            return "Sierra";
          case 13:
            return "High Sierra";
          case 14:
            return "Mojave";
          case 15:
            return "Catalina";
          default:
            return void 0;
        }
      }
      /**
       * Get Android version name
       *    1.5 - Cupcake
       *    1.6 - Donut
       *    2.0 - Eclair
       *    2.1 - Eclair
       *    2.2 - Froyo
       *    2.x - Gingerbread
       *    3.x - Honeycomb
       *    4.0 - Ice Cream Sandwich
       *    4.1 - Jelly Bean
       *    4.4 - KitKat
       *    5.x - Lollipop
       *    6.x - Marshmallow
       *    7.x - Nougat
       *    8.x - Oreo
       *    9.x - Pie
       *
       * @example
       *   getAndroidVersionName("7.0") // 'Nougat'
       *
       * @param  {string} version
       * @return {string} versionName
       */
      static getAndroidVersionName(version) {
        const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
        v.push(0);
        if (v[0] === 1 && v[1] < 5)
          return void 0;
        if (v[0] === 1 && v[1] < 6)
          return "Cupcake";
        if (v[0] === 1 && v[1] >= 6)
          return "Donut";
        if (v[0] === 2 && v[1] < 2)
          return "Eclair";
        if (v[0] === 2 && v[1] === 2)
          return "Froyo";
        if (v[0] === 2 && v[1] > 2)
          return "Gingerbread";
        if (v[0] === 3)
          return "Honeycomb";
        if (v[0] === 4 && v[1] < 1)
          return "Ice Cream Sandwich";
        if (v[0] === 4 && v[1] < 4)
          return "Jelly Bean";
        if (v[0] === 4 && v[1] >= 4)
          return "KitKat";
        if (v[0] === 5)
          return "Lollipop";
        if (v[0] === 6)
          return "Marshmallow";
        if (v[0] === 7)
          return "Nougat";
        if (v[0] === 8)
          return "Oreo";
        if (v[0] === 9)
          return "Pie";
        return void 0;
      }
      /**
       * Get version precisions count
       *
       * @example
       *   getVersionPrecision("1.10.3") // 3
       *
       * @param  {string} version
       * @return {number}
       */
      static getVersionPrecision(version) {
        return version.split(".").length;
      }
      /**
       * Calculate browser version weight
       *
       * @example
       *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
       *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
       *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
       *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
       *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
       *
       * @param {String} versionA versions versions to compare
       * @param {String} versionB versions versions to compare
       * @param {boolean} [isLoose] enable loose comparison
       * @return {Number} comparison result: -1 when versionA is lower,
       * 1 when versionA is bigger, 0 when both equal
       */
      /* eslint consistent-return: 1 */
      static compareVersions(versionA, versionB, isLoose = false) {
        const versionAPrecision = Utils.getVersionPrecision(versionA);
        const versionBPrecision = Utils.getVersionPrecision(versionB);
        let precision = Math.max(versionAPrecision, versionBPrecision);
        let lastPrecision = 0;
        const chunks = Utils.map([versionA, versionB], (version) => {
          const delta = precision - Utils.getVersionPrecision(version);
          const _version = version + new Array(delta + 1).join(".0");
          return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
        });
        if (isLoose) {
          lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
        }
        precision -= 1;
        while (precision >= lastPrecision) {
          if (chunks[0][precision] > chunks[1][precision]) {
            return 1;
          }
          if (chunks[0][precision] === chunks[1][precision]) {
            if (precision === lastPrecision) {
              return 0;
            }
            precision -= 1;
          } else if (chunks[0][precision] < chunks[1][precision]) {
            return -1;
          }
        }
        return void 0;
      }
      /**
       * Array::map polyfill
       *
       * @param  {Array} arr
       * @param  {Function} iterator
       * @return {Array}
       */
      static map(arr, iterator) {
        const result = [];
        let i2;
        if (Array.prototype.map) {
          return Array.prototype.map.call(arr, iterator);
        }
        for (i2 = 0; i2 < arr.length; i2 += 1) {
          result.push(iterator(arr[i2]));
        }
        return result;
      }
      /**
       * Array::find polyfill
       *
       * @param  {Array} arr
       * @param  {Function} predicate
       * @return {Array}
       */
      static find(arr, predicate) {
        let i2;
        let l;
        if (Array.prototype.find) {
          return Array.prototype.find.call(arr, predicate);
        }
        for (i2 = 0, l = arr.length; i2 < l; i2 += 1) {
          const value2 = arr[i2];
          if (predicate(value2, i2)) {
            return value2;
          }
        }
        return void 0;
      }
      /**
       * Object::assign polyfill
       *
       * @param  {Object} obj
       * @param  {Object} ...objs
       * @return {Object}
       */
      static assign(obj, ...assigners) {
        const result = obj;
        let i2;
        let l;
        if (Object.assign) {
          return Object.assign(obj, ...assigners);
        }
        for (i2 = 0, l = assigners.length; i2 < l; i2 += 1) {
          const assigner = assigners[i2];
          if (typeof assigner === "object" && assigner !== null) {
            const keys = Object.keys(assigner);
            keys.forEach((key) => {
              result[key] = assigner[key];
            });
          }
        }
        return obj;
      }
      /**
       * Get short version/alias for a browser name
       *
       * @example
       *   getBrowserAlias('Microsoft Edge') // edge
       *
       * @param  {string} browserName
       * @return {string}
       */
      static getBrowserAlias(browserName) {
        return BROWSER_ALIASES_MAP[browserName];
      }
      /**
       * Get short version/alias for a browser name
       *
       * @example
       *   getBrowserAlias('edge') // Microsoft Edge
       *
       * @param  {string} browserAlias
       * @return {string}
       */
      static getBrowserTypeByAlias(browserAlias) {
        return BROWSER_MAP[browserAlias] || "";
      }
    };
  }
});

// node_modules/bowser/src/parser-browsers.js
var commonVersionIdentifier, browsersList, parser_browsers_default;
var init_parser_browsers = __esm({
  "node_modules/bowser/src/parser-browsers.js"() {
    init_process();
    init_buffer();
    init_utils();
    commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
    browsersList = [
      /* Googlebot */
      {
        test: [/googlebot/i],
        describe(ua) {
          const browser = {
            name: "Googlebot"
          };
          const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      /* Opera < 13.0 */
      {
        test: [/opera/i],
        describe(ua) {
          const browser = {
            name: "Opera"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      /* Opera > 13.0 */
      {
        test: [/opr\/|opios/i],
        describe(ua) {
          const browser = {
            name: "Opera"
          };
          const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/SamsungBrowser/i],
        describe(ua) {
          const browser = {
            name: "Samsung Internet for Android"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/Whale/i],
        describe(ua) {
          const browser = {
            name: "NAVER Whale Browser"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/MZBrowser/i],
        describe(ua) {
          const browser = {
            name: "MZ Browser"
          };
          const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/focus/i],
        describe(ua) {
          const browser = {
            name: "Focus"
          };
          const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/swing/i],
        describe(ua) {
          const browser = {
            name: "Swing"
          };
          const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/coast/i],
        describe(ua) {
          const browser = {
            name: "Opera Coast"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/opt\/\d+(?:.?_?\d+)+/i],
        describe(ua) {
          const browser = {
            name: "Opera Touch"
          };
          const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/yabrowser/i],
        describe(ua) {
          const browser = {
            name: "Yandex Browser"
          };
          const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/ucbrowser/i],
        describe(ua) {
          const browser = {
            name: "UC Browser"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/Maxthon|mxios/i],
        describe(ua) {
          const browser = {
            name: "Maxthon"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/epiphany/i],
        describe(ua) {
          const browser = {
            name: "Epiphany"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/puffin/i],
        describe(ua) {
          const browser = {
            name: "Puffin"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/sleipnir/i],
        describe(ua) {
          const browser = {
            name: "Sleipnir"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/k-meleon/i],
        describe(ua) {
          const browser = {
            name: "K-Meleon"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/micromessenger/i],
        describe(ua) {
          const browser = {
            name: "WeChat"
          };
          const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/qqbrowser/i],
        describe(ua) {
          const browser = {
            name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
          };
          const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/msie|trident/i],
        describe(ua) {
          const browser = {
            name: "Internet Explorer"
          };
          const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/\sedg\//i],
        describe(ua) {
          const browser = {
            name: "Microsoft Edge"
          };
          const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/edg([ea]|ios)/i],
        describe(ua) {
          const browser = {
            name: "Microsoft Edge"
          };
          const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/vivaldi/i],
        describe(ua) {
          const browser = {
            name: "Vivaldi"
          };
          const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/seamonkey/i],
        describe(ua) {
          const browser = {
            name: "SeaMonkey"
          };
          const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/sailfish/i],
        describe(ua) {
          const browser = {
            name: "Sailfish"
          };
          const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/silk/i],
        describe(ua) {
          const browser = {
            name: "Amazon Silk"
          };
          const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/phantom/i],
        describe(ua) {
          const browser = {
            name: "PhantomJS"
          };
          const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/slimerjs/i],
        describe(ua) {
          const browser = {
            name: "SlimerJS"
          };
          const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
        describe(ua) {
          const browser = {
            name: "BlackBerry"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/(web|hpw)[o0]s/i],
        describe(ua) {
          const browser = {
            name: "WebOS Browser"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/bada/i],
        describe(ua) {
          const browser = {
            name: "Bada"
          };
          const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/tizen/i],
        describe(ua) {
          const browser = {
            name: "Tizen"
          };
          const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/qupzilla/i],
        describe(ua) {
          const browser = {
            name: "QupZilla"
          };
          const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/firefox|iceweasel|fxios/i],
        describe(ua) {
          const browser = {
            name: "Firefox"
          };
          const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/electron/i],
        describe(ua) {
          const browser = {
            name: "Electron"
          };
          const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/MiuiBrowser/i],
        describe(ua) {
          const browser = {
            name: "Miui"
          };
          const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/chromium/i],
        describe(ua) {
          const browser = {
            name: "Chromium"
          };
          const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/chrome|crios|crmo/i],
        describe(ua) {
          const browser = {
            name: "Chrome"
          };
          const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      {
        test: [/GSA/i],
        describe(ua) {
          const browser = {
            name: "Google Search"
          };
          const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      /* Android Browser */
      {
        test(parser) {
          const notLikeAndroid = !parser.test(/like android/i);
          const butAndroid = parser.test(/android/i);
          return notLikeAndroid && butAndroid;
        },
        describe(ua) {
          const browser = {
            name: "Android Browser"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      /* PlayStation 4 */
      {
        test: [/playstation 4/i],
        describe(ua) {
          const browser = {
            name: "PlayStation 4"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      /* Safari */
      {
        test: [/safari|applewebkit/i],
        describe(ua) {
          const browser = {
            name: "Safari"
          };
          const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
          if (version) {
            browser.version = version;
          }
          return browser;
        }
      },
      /* Something else */
      {
        test: [/.*/i],
        describe(ua) {
          const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
          const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
          const hasDeviceSpec = ua.search("\\(") !== -1;
          const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
          return {
            name: Utils.getFirstMatch(regexp, ua),
            version: Utils.getSecondMatch(regexp, ua)
          };
        }
      }
    ];
    parser_browsers_default = browsersList;
  }
});

// node_modules/bowser/src/parser-os.js
var parser_os_default;
var init_parser_os = __esm({
  "node_modules/bowser/src/parser-os.js"() {
    init_process();
    init_buffer();
    init_utils();
    init_constants();
    parser_os_default = [
      /* Roku */
      {
        test: [/Roku\/DVP/],
        describe(ua) {
          const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
          return {
            name: OS_MAP.Roku,
            version
          };
        }
      },
      /* Windows Phone */
      {
        test: [/windows phone/i],
        describe(ua) {
          const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
          return {
            name: OS_MAP.WindowsPhone,
            version
          };
        }
      },
      /* Windows */
      {
        test: [/windows /i],
        describe(ua) {
          const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
          const versionName = Utils.getWindowsVersionName(version);
          return {
            name: OS_MAP.Windows,
            version,
            versionName
          };
        }
      },
      /* Firefox on iPad */
      {
        test: [/Macintosh(.*?) FxiOS(.*?)\//],
        describe(ua) {
          const result = {
            name: OS_MAP.iOS
          };
          const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
          if (version) {
            result.version = version;
          }
          return result;
        }
      },
      /* macOS */
      {
        test: [/macintosh/i],
        describe(ua) {
          const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
          const versionName = Utils.getMacOSVersionName(version);
          const os = {
            name: OS_MAP.MacOS,
            version
          };
          if (versionName) {
            os.versionName = versionName;
          }
          return os;
        }
      },
      /* iOS */
      {
        test: [/(ipod|iphone|ipad)/i],
        describe(ua) {
          const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
          return {
            name: OS_MAP.iOS,
            version
          };
        }
      },
      /* Android */
      {
        test(parser) {
          const notLikeAndroid = !parser.test(/like android/i);
          const butAndroid = parser.test(/android/i);
          return notLikeAndroid && butAndroid;
        },
        describe(ua) {
          const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
          const versionName = Utils.getAndroidVersionName(version);
          const os = {
            name: OS_MAP.Android,
            version
          };
          if (versionName) {
            os.versionName = versionName;
          }
          return os;
        }
      },
      /* WebOS */
      {
        test: [/(web|hpw)[o0]s/i],
        describe(ua) {
          const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
          const os = {
            name: OS_MAP.WebOS
          };
          if (version && version.length) {
            os.version = version;
          }
          return os;
        }
      },
      /* BlackBerry */
      {
        test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
        describe(ua) {
          const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
          return {
            name: OS_MAP.BlackBerry,
            version
          };
        }
      },
      /* Bada */
      {
        test: [/bada/i],
        describe(ua) {
          const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
          return {
            name: OS_MAP.Bada,
            version
          };
        }
      },
      /* Tizen */
      {
        test: [/tizen/i],
        describe(ua) {
          const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
          return {
            name: OS_MAP.Tizen,
            version
          };
        }
      },
      /* Linux */
      {
        test: [/linux/i],
        describe() {
          return {
            name: OS_MAP.Linux
          };
        }
      },
      /* Chrome OS */
      {
        test: [/CrOS/],
        describe() {
          return {
            name: OS_MAP.ChromeOS
          };
        }
      },
      /* Playstation 4 */
      {
        test: [/PlayStation 4/],
        describe(ua) {
          const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
          return {
            name: OS_MAP.PlayStation4,
            version
          };
        }
      }
    ];
  }
});

// node_modules/bowser/src/parser-platforms.js
var parser_platforms_default;
var init_parser_platforms = __esm({
  "node_modules/bowser/src/parser-platforms.js"() {
    init_process();
    init_buffer();
    init_utils();
    init_constants();
    parser_platforms_default = [
      /* Googlebot */
      {
        test: [/googlebot/i],
        describe() {
          return {
            type: "bot",
            vendor: "Google"
          };
        }
      },
      /* Huawei */
      {
        test: [/huawei/i],
        describe(ua) {
          const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
          const platform = {
            type: PLATFORMS_MAP.mobile,
            vendor: "Huawei"
          };
          if (model) {
            platform.model = model;
          }
          return platform;
        }
      },
      /* Nexus Tablet */
      {
        test: [/nexus\s*(?:7|8|9|10).*/i],
        describe() {
          return {
            type: PLATFORMS_MAP.tablet,
            vendor: "Nexus"
          };
        }
      },
      /* iPad */
      {
        test: [/ipad/i],
        describe() {
          return {
            type: PLATFORMS_MAP.tablet,
            vendor: "Apple",
            model: "iPad"
          };
        }
      },
      /* Firefox on iPad */
      {
        test: [/Macintosh(.*?) FxiOS(.*?)\//],
        describe() {
          return {
            type: PLATFORMS_MAP.tablet,
            vendor: "Apple",
            model: "iPad"
          };
        }
      },
      /* Amazon Kindle Fire */
      {
        test: [/kftt build/i],
        describe() {
          return {
            type: PLATFORMS_MAP.tablet,
            vendor: "Amazon",
            model: "Kindle Fire HD 7"
          };
        }
      },
      /* Another Amazon Tablet with Silk */
      {
        test: [/silk/i],
        describe() {
          return {
            type: PLATFORMS_MAP.tablet,
            vendor: "Amazon"
          };
        }
      },
      /* Tablet */
      {
        test: [/tablet(?! pc)/i],
        describe() {
          return {
            type: PLATFORMS_MAP.tablet
          };
        }
      },
      /* iPod/iPhone */
      {
        test(parser) {
          const iDevice = parser.test(/ipod|iphone/i);
          const likeIDevice = parser.test(/like (ipod|iphone)/i);
          return iDevice && !likeIDevice;
        },
        describe(ua) {
          const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
          return {
            type: PLATFORMS_MAP.mobile,
            vendor: "Apple",
            model
          };
        }
      },
      /* Nexus Mobile */
      {
        test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
        describe() {
          return {
            type: PLATFORMS_MAP.mobile,
            vendor: "Nexus"
          };
        }
      },
      /* Mobile */
      {
        test: [/[^-]mobi/i],
        describe() {
          return {
            type: PLATFORMS_MAP.mobile
          };
        }
      },
      /* BlackBerry */
      {
        test(parser) {
          return parser.getBrowserName(true) === "blackberry";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.mobile,
            vendor: "BlackBerry"
          };
        }
      },
      /* Bada */
      {
        test(parser) {
          return parser.getBrowserName(true) === "bada";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.mobile
          };
        }
      },
      /* Windows Phone */
      {
        test(parser) {
          return parser.getBrowserName() === "windows phone";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.mobile,
            vendor: "Microsoft"
          };
        }
      },
      /* Android Tablet */
      {
        test(parser) {
          const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
          return parser.getOSName(true) === "android" && osMajorVersion >= 3;
        },
        describe() {
          return {
            type: PLATFORMS_MAP.tablet
          };
        }
      },
      /* Android Mobile */
      {
        test(parser) {
          return parser.getOSName(true) === "android";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.mobile
          };
        }
      },
      /* desktop */
      {
        test(parser) {
          return parser.getOSName(true) === "macos";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.desktop,
            vendor: "Apple"
          };
        }
      },
      /* Windows */
      {
        test(parser) {
          return parser.getOSName(true) === "windows";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.desktop
          };
        }
      },
      /* Linux */
      {
        test(parser) {
          return parser.getOSName(true) === "linux";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.desktop
          };
        }
      },
      /* PlayStation 4 */
      {
        test(parser) {
          return parser.getOSName(true) === "playstation 4";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.tv
          };
        }
      },
      /* Roku */
      {
        test(parser) {
          return parser.getOSName(true) === "roku";
        },
        describe() {
          return {
            type: PLATFORMS_MAP.tv
          };
        }
      }
    ];
  }
});

// node_modules/bowser/src/parser-engines.js
var parser_engines_default;
var init_parser_engines = __esm({
  "node_modules/bowser/src/parser-engines.js"() {
    init_process();
    init_buffer();
    init_utils();
    init_constants();
    parser_engines_default = [
      /* EdgeHTML */
      {
        test(parser) {
          return parser.getBrowserName(true) === "microsoft edge";
        },
        describe(ua) {
          const isBlinkBased = /\sedg\//i.test(ua);
          if (isBlinkBased) {
            return {
              name: ENGINE_MAP.Blink
            };
          }
          const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
          return {
            name: ENGINE_MAP.EdgeHTML,
            version
          };
        }
      },
      /* Trident */
      {
        test: [/trident/i],
        describe(ua) {
          const engine = {
            name: ENGINE_MAP.Trident
          };
          const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            engine.version = version;
          }
          return engine;
        }
      },
      /* Presto */
      {
        test(parser) {
          return parser.test(/presto/i);
        },
        describe(ua) {
          const engine = {
            name: ENGINE_MAP.Presto
          };
          const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            engine.version = version;
          }
          return engine;
        }
      },
      /* Gecko */
      {
        test(parser) {
          const isGecko = parser.test(/gecko/i);
          const likeGecko = parser.test(/like gecko/i);
          return isGecko && !likeGecko;
        },
        describe(ua) {
          const engine = {
            name: ENGINE_MAP.Gecko
          };
          const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            engine.version = version;
          }
          return engine;
        }
      },
      /* Blink */
      {
        test: [/(apple)?webkit\/537\.36/i],
        describe() {
          return {
            name: ENGINE_MAP.Blink
          };
        }
      },
      /* WebKit */
      {
        test: [/(apple)?webkit/i],
        describe(ua) {
          const engine = {
            name: ENGINE_MAP.WebKit
          };
          const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
          if (version) {
            engine.version = version;
          }
          return engine;
        }
      }
    ];
  }
});

// node_modules/bowser/src/parser.js
var Parser, parser_default;
var init_parser = __esm({
  "node_modules/bowser/src/parser.js"() {
    init_process();
    init_buffer();
    init_parser_browsers();
    init_parser_os();
    init_parser_platforms();
    init_parser_engines();
    init_utils();
    Parser = class {
      /**
       * Create instance of Parser
       *
       * @param {String} UA User-Agent string
       * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
       * improvements if you need to make a more particular parsing
       * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
       *
       * @throw {Error} in case of empty UA String
       *
       * @constructor
       */
      constructor(UA, skipParsing = false) {
        if (UA === void 0 || UA === null || UA === "") {
          throw new Error("UserAgent parameter can't be empty");
        }
        this._ua = UA;
        this.parsedResult = {};
        if (skipParsing !== true) {
          this.parse();
        }
      }
      /**
       * Get UserAgent string of current Parser instance
       * @return {String} User-Agent String of the current <Parser> object
       *
       * @public
       */
      getUA() {
        return this._ua;
      }
      /**
       * Test a UA string for a regexp
       * @param {RegExp} regex
       * @return {Boolean}
       */
      test(regex) {
        return regex.test(this._ua);
      }
      /**
       * Get parsed browser object
       * @return {Object}
       */
      parseBrowser() {
        this.parsedResult.browser = {};
        const browserDescriptor = Utils.find(parser_browsers_default, (_browser) => {
          if (typeof _browser.test === "function") {
            return _browser.test(this);
          }
          if (_browser.test instanceof Array) {
            return _browser.test.some((condition) => this.test(condition));
          }
          throw new Error("Browser's test function is not valid");
        });
        if (browserDescriptor) {
          this.parsedResult.browser = browserDescriptor.describe(this.getUA());
        }
        return this.parsedResult.browser;
      }
      /**
       * Get parsed browser object
       * @return {Object}
       *
       * @public
       */
      getBrowser() {
        if (this.parsedResult.browser) {
          return this.parsedResult.browser;
        }
        return this.parseBrowser();
      }
      /**
       * Get browser's name
       * @return {String} Browser's name or an empty string
       *
       * @public
       */
      getBrowserName(toLowerCase) {
        if (toLowerCase) {
          return String(this.getBrowser().name).toLowerCase() || "";
        }
        return this.getBrowser().name || "";
      }
      /**
       * Get browser's version
       * @return {String} version of browser
       *
       * @public
       */
      getBrowserVersion() {
        return this.getBrowser().version;
      }
      /**
       * Get OS
       * @return {Object}
       *
       * @example
       * this.getOS();
       * {
       *   name: 'macOS',
       *   version: '10.11.12'
       * }
       */
      getOS() {
        if (this.parsedResult.os) {
          return this.parsedResult.os;
        }
        return this.parseOS();
      }
      /**
       * Parse OS and save it to this.parsedResult.os
       * @return {*|{}}
       */
      parseOS() {
        this.parsedResult.os = {};
        const os = Utils.find(parser_os_default, (_os) => {
          if (typeof _os.test === "function") {
            return _os.test(this);
          }
          if (_os.test instanceof Array) {
            return _os.test.some((condition) => this.test(condition));
          }
          throw new Error("Browser's test function is not valid");
        });
        if (os) {
          this.parsedResult.os = os.describe(this.getUA());
        }
        return this.parsedResult.os;
      }
      /**
       * Get OS name
       * @param {Boolean} [toLowerCase] return lower-cased value
       * @return {String} name of the OS — macOS, Windows, Linux, etc.
       */
      getOSName(toLowerCase) {
        const { name } = this.getOS();
        if (toLowerCase) {
          return String(name).toLowerCase() || "";
        }
        return name || "";
      }
      /**
       * Get OS version
       * @return {String} full version with dots ('10.11.12', '5.6', etc)
       */
      getOSVersion() {
        return this.getOS().version;
      }
      /**
       * Get parsed platform
       * @return {{}}
       */
      getPlatform() {
        if (this.parsedResult.platform) {
          return this.parsedResult.platform;
        }
        return this.parsePlatform();
      }
      /**
       * Get platform name
       * @param {Boolean} [toLowerCase=false]
       * @return {*}
       */
      getPlatformType(toLowerCase = false) {
        const { type: type6 } = this.getPlatform();
        if (toLowerCase) {
          return String(type6).toLowerCase() || "";
        }
        return type6 || "";
      }
      /**
       * Get parsed platform
       * @return {{}}
       */
      parsePlatform() {
        this.parsedResult.platform = {};
        const platform = Utils.find(parser_platforms_default, (_platform) => {
          if (typeof _platform.test === "function") {
            return _platform.test(this);
          }
          if (_platform.test instanceof Array) {
            return _platform.test.some((condition) => this.test(condition));
          }
          throw new Error("Browser's test function is not valid");
        });
        if (platform) {
          this.parsedResult.platform = platform.describe(this.getUA());
        }
        return this.parsedResult.platform;
      }
      /**
       * Get parsed engine
       * @return {{}}
       */
      getEngine() {
        if (this.parsedResult.engine) {
          return this.parsedResult.engine;
        }
        return this.parseEngine();
      }
      /**
       * Get engines's name
       * @return {String} Engines's name or an empty string
       *
       * @public
       */
      getEngineName(toLowerCase) {
        if (toLowerCase) {
          return String(this.getEngine().name).toLowerCase() || "";
        }
        return this.getEngine().name || "";
      }
      /**
       * Get parsed platform
       * @return {{}}
       */
      parseEngine() {
        this.parsedResult.engine = {};
        const engine = Utils.find(parser_engines_default, (_engine) => {
          if (typeof _engine.test === "function") {
            return _engine.test(this);
          }
          if (_engine.test instanceof Array) {
            return _engine.test.some((condition) => this.test(condition));
          }
          throw new Error("Browser's test function is not valid");
        });
        if (engine) {
          this.parsedResult.engine = engine.describe(this.getUA());
        }
        return this.parsedResult.engine;
      }
      /**
       * Parse full information about the browser
       * @returns {Parser}
       */
      parse() {
        this.parseBrowser();
        this.parseOS();
        this.parsePlatform();
        this.parseEngine();
        return this;
      }
      /**
       * Get parsed result
       * @return {ParsedResult}
       */
      getResult() {
        return Utils.assign({}, this.parsedResult);
      }
      /**
       * Check if parsed browser matches certain conditions
       *
       * @param {Object} checkTree It's one or two layered object,
       * which can include a platform or an OS on the first layer
       * and should have browsers specs on the bottom-laying layer
       *
       * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
       * Returns `undefined` when the browser is no described in the checkTree object.
       *
       * @example
       * const browser = Bowser.getParser(window.navigator.userAgent);
       * if (browser.satisfies({chrome: '>118.01.1322' }))
       * // or with os
       * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
       * // or with platforms
       * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
       */
      satisfies(checkTree) {
        const platformsAndOSes = {};
        let platformsAndOSCounter = 0;
        const browsers = {};
        let browsersCounter = 0;
        const allDefinitions = Object.keys(checkTree);
        allDefinitions.forEach((key) => {
          const currentDefinition = checkTree[key];
          if (typeof currentDefinition === "string") {
            browsers[key] = currentDefinition;
            browsersCounter += 1;
          } else if (typeof currentDefinition === "object") {
            platformsAndOSes[key] = currentDefinition;
            platformsAndOSCounter += 1;
          }
        });
        if (platformsAndOSCounter > 0) {
          const platformsAndOSNames = Object.keys(platformsAndOSes);
          const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
          if (OSMatchingDefinition) {
            const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
            if (osResult !== void 0) {
              return osResult;
            }
          }
          const platformMatchingDefinition = Utils.find(
            platformsAndOSNames,
            (name) => this.isPlatform(name)
          );
          if (platformMatchingDefinition) {
            const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
            if (platformResult !== void 0) {
              return platformResult;
            }
          }
        }
        if (browsersCounter > 0) {
          const browserNames = Object.keys(browsers);
          const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
          if (matchingDefinition !== void 0) {
            return this.compareVersion(browsers[matchingDefinition]);
          }
        }
        return void 0;
      }
      /**
       * Check if the browser name equals the passed string
       * @param browserName The string to compare with the browser name
       * @param [includingAlias=false] The flag showing whether alias will be included into comparison
       * @returns {boolean}
       */
      isBrowser(browserName, includingAlias = false) {
        const defaultBrowserName = this.getBrowserName().toLowerCase();
        let browserNameLower = browserName.toLowerCase();
        const alias = Utils.getBrowserTypeByAlias(browserNameLower);
        if (includingAlias && alias) {
          browserNameLower = alias.toLowerCase();
        }
        return browserNameLower === defaultBrowserName;
      }
      compareVersion(version) {
        let expectedResults = [0];
        let comparableVersion = version;
        let isLoose = false;
        const currentBrowserVersion = this.getBrowserVersion();
        if (typeof currentBrowserVersion !== "string") {
          return void 0;
        }
        if (version[0] === ">" || version[0] === "<") {
          comparableVersion = version.substr(1);
          if (version[1] === "=") {
            isLoose = true;
            comparableVersion = version.substr(2);
          } else {
            expectedResults = [];
          }
          if (version[0] === ">") {
            expectedResults.push(1);
          } else {
            expectedResults.push(-1);
          }
        } else if (version[0] === "=") {
          comparableVersion = version.substr(1);
        } else if (version[0] === "~") {
          isLoose = true;
          comparableVersion = version.substr(1);
        }
        return expectedResults.indexOf(
          Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
        ) > -1;
      }
      isOS(osName) {
        return this.getOSName(true) === String(osName).toLowerCase();
      }
      isPlatform(platformType) {
        return this.getPlatformType(true) === String(platformType).toLowerCase();
      }
      isEngine(engineName) {
        return this.getEngineName(true) === String(engineName).toLowerCase();
      }
      /**
       * Is anything? Check if the browser is called "anything",
       * the OS called "anything" or the platform called "anything"
       * @param {String} anything
       * @param [includingAlias=false] The flag showing whether alias will be included into comparison
       * @returns {Boolean}
       */
      is(anything, includingAlias = false) {
        return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
      }
      /**
       * Check if any of the given values satisfies this.is(anything)
       * @param {String[]} anythings
       * @returns {Boolean}
       */
      some(anythings = []) {
        return anythings.some((anything) => this.is(anything));
      }
    };
    parser_default = Parser;
  }
});

// node_modules/bowser/src/bowser.js
var Bowser, bowser_default;
var init_bowser = __esm({
  "node_modules/bowser/src/bowser.js"() {
    init_process();
    init_buffer();
    init_parser();
    init_constants();
    Bowser = class {
      /**
       * Creates a {@link Parser} instance
       *
       * @param {String} UA UserAgent string
       * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
       * explicitly. Same as `skipParsing` for {@link Parser}.
       * @returns {Parser}
       * @throws {Error} when UA is not a String
       *
       * @example
       * const parser = Bowser.getParser(window.navigator.userAgent);
       * const result = parser.getResult();
       */
      static getParser(UA, skipParsing = false) {
        if (typeof UA !== "string") {
          throw new Error("UserAgent should be a string");
        }
        return new parser_default(UA, skipParsing);
      }
      /**
       * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
       *
       * @param UA
       * @return {ParsedResult}
       *
       * @example
       * const result = Bowser.parse(window.navigator.userAgent);
       */
      static parse(UA) {
        return new parser_default(UA).getResult();
      }
      static get BROWSER_MAP() {
        return BROWSER_MAP;
      }
      static get ENGINE_MAP() {
        return ENGINE_MAP;
      }
      static get OS_MAP() {
        return OS_MAP;
      }
      static get PLATFORMS_MAP() {
        return PLATFORMS_MAP;
      }
    };
    bowser_default = Bowser;
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/util.js
function isPromise(obj) {
  if (obj && typeof obj.then === "function") {
    return true;
  } else {
    return false;
  }
}
function sleep(time, resolveWith) {
  if (!time)
    time = 0;
  return new Promise(function(res) {
    return setTimeout(function() {
      return res(resolveWith);
    }, time);
  });
}
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
function microSeconds() {
  var ms = (/* @__PURE__ */ new Date()).getTime();
  if (ms === lastMs) {
    additional++;
    return ms * 1e3 + additional;
  } else {
    lastMs = ms;
    additional = 0;
    return ms * 1e3;
  }
}
function are3PCSupported() {
  if (typeof navigator === "undefined")
    return false;
  var browserInfo = bowser_default.parse(navigator.userAgent);
  log3.info(JSON.stringify(browserInfo), "current browser info");
  var thirdPartyCookieSupport = true;
  if (navigator.brave) {
    thirdPartyCookieSupport = false;
  }
  if (browserInfo.engine.name === bowser_default.ENGINE_MAP.WebKit || browserInfo.engine.name === bowser_default.ENGINE_MAP.Gecko) {
    thirdPartyCookieSupport = false;
  }
  return thirdPartyCookieSupport;
}
var import_loglevel3, PROMISE_RESOLVED_FALSE, PROMISE_RESOLVED_TRUE, PROMISE_RESOLVED_VOID, lastMs, additional, log3;
var init_util = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/util.js"() {
    init_process();
    init_buffer();
    init_bowser();
    import_loglevel3 = __toESM(require_loglevel());
    PROMISE_RESOLVED_FALSE = Promise.resolve(false);
    PROMISE_RESOLVED_TRUE = Promise.resolve(true);
    PROMISE_RESOLVED_VOID = Promise.resolve();
    lastMs = 0;
    additional = 0;
    log3 = import_loglevel3.default.getLogger("broadcast-channel");
    log3.setLevel("error");
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/native.js
function create(channelName) {
  var state = {
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state.bc.onmessage = function(msg) {
    if (state.messagesCallback) {
      state.messagesCallback(msg.data);
    }
  };
  return state;
}
function close(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed(options) {
  if (typeof window === "undefined")
    return false;
  if (!options.support3PC)
    return false;
  if (typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else
    return false;
}
function averageResponseTime() {
  return 150;
}
var microSeconds2, type, native_default;
var init_native = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/native.js"() {
    init_process();
    init_buffer();
    init_util();
    microSeconds2 = microSeconds;
    type = "native";
    native_default = {
      create,
      close,
      onMessage,
      postMessage,
      canBeUsed,
      type,
      averageResponseTime,
      microSeconds: microSeconds2
    };
  }
});

// node_modules/oblivious-set/dist/es/index.js
function removeTooOldValues(obliviousSet) {
  var olderThen = now() - obliviousSet.ttl;
  var iterator = obliviousSet.map[Symbol.iterator]();
  while (true) {
    var next = iterator.next().value;
    if (!next) {
      return;
    }
    var value2 = next[0];
    var time = next[1];
    if (time < olderThen) {
      obliviousSet.map.delete(value2);
    } else {
      return;
    }
  }
}
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var ObliviousSet;
var init_es = __esm({
  "node_modules/oblivious-set/dist/es/index.js"() {
    init_process();
    init_buffer();
    ObliviousSet = /** @class */
    function() {
      function ObliviousSet2(ttl) {
        this.ttl = ttl;
        this.map = /* @__PURE__ */ new Map();
        this._to = false;
      }
      ObliviousSet2.prototype.has = function(value2) {
        return this.map.has(value2);
      };
      ObliviousSet2.prototype.add = function(value2) {
        var _this = this;
        this.map.set(value2, now());
        if (!this._to) {
          this._to = true;
          setTimeout(function() {
            _this._to = false;
            removeTooOldValues(_this);
          }, 0);
        }
      };
      ObliviousSet2.prototype.clear = function() {
        this.map.clear();
      };
      return ObliviousSet2;
    }();
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/options.js
function fillOptionsWithDefaults() {
  var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options.support3PC === "undefined")
    options.support3PC = are3PCSupported();
  if (typeof options.webWorkerSupport === "undefined")
    options.webWorkerSupport = true;
  if (!options.idb)
    options.idb = {};
  if (!options.idb.ttl)
    options.idb.ttl = 1e3 * 45;
  if (!options.idb.fallbackInterval)
    options.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function")
    options.idb.onclose = originalOptions.idb.onclose;
  if (!options.localstorage)
    options.localstorage = {};
  if (!options.localstorage.removeTimeout)
    options.localstorage.removeTimeout = 1e3 * 60;
  if (!options.server)
    options.server = {};
  if (!options.server.url)
    options.server.url = "https://broadcast-server.tor.us";
  if (!options.server.removeTimeout)
    options.server.removeTimeout = 1e3 * 60 * 5;
  if (originalOptions.methods)
    options.methods = originalOptions.methods;
  return options;
}
var init_options = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/options.js"() {
    init_process();
    init_buffer();
    init_util();
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/indexed-db.js
function getIdb() {
  if (typeof indexedDB !== "undefined")
    return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined")
      return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined")
      return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined")
      return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();
  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function(ev) {
    var db = ev.target.result;
    db.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  var dbPromise = new Promise(function(res, rej) {
    openRequest.onerror = function(ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function() {
      res(openRequest.result);
    };
  });
  return dbPromise;
}
function writeMessage(db, readerUuid, messageJson) {
  var time = (/* @__PURE__ */ new Date()).getTime();
  var writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  var tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(res, rej) {
    tx.oncomplete = function() {
      return res();
    };
    tx.onerror = function(ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getMessagesHigherThan(db, lastCursorId) {
  var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function(res, rej) {
      getAllRequest.onerror = function(err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function(e2) {
        res(e2.target.result);
      };
    });
  }
  function openCursor() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e2) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function(res, rej) {
    var openCursorRequest = openCursor();
    openCursorRequest.onerror = function(err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor) {
        if (cursor.value.id < lastCursorId + 1) {
          cursor["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor.value);
          cursor["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(db, ids) {
  var tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function(id) {
    var deleteRequest = objectStore["delete"](id);
    return new Promise(function(res) {
      deleteRequest.onsuccess = function() {
        return res();
      };
    });
  }));
}
function getOldMessages(db, ttl) {
  var olderThen = (/* @__PURE__ */ new Date()).getTime() - ttl;
  var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor) {
        var msgObk = cursor.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor["continue"]();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
          return;
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages(db, ttl) {
  return getOldMessages(db, ttl).then(function(tooOld) {
    return removeMessagesById(db, tooOld.map(function(msg) {
      return msg.id;
    }));
  });
}
function create2(channelName, options) {
  options = fillOptionsWithDefaults(options);
  return createDatabase(channelName).then(function(db) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options,
      uuid: randomToken(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parrallel
      writeBlockPromise: PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db
    };
    db.onclose = function() {
      state.closed = true;
      if (options.idb.onclose)
        options.idb.onclose();
    };
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed)
    return;
  readNewMessages(state).then(function() {
    return sleep(state.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(state);
  });
}
function _filterMessage(msgObj, state) {
  if (msgObj.uuid === state.uuid)
    return false;
  if (state.eMIs.has(msgObj.id))
    return false;
  if (msgObj.data.time < state.messagesCallbackTime)
    return false;
  return true;
}
function readNewMessages(state) {
  if (state.closed)
    return PROMISE_RESOLVED_VOID;
  if (!state.messagesCallback)
    return PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
    var useMessages = newerMessages.filter(function(msgObj) {
      return !!msgObj;
    }).map(function(msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function(msgObj) {
      return _filterMessage(msgObj, state);
    }).sort(function(msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    });
    useMessages.forEach(function(msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return PROMISE_RESOLVED_VOID;
  });
}
function close2(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage2(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
    return writeMessage(channelState.db, channelState.uuid, messageJson);
  }).then(function() {
    if (randomInt(0, 10) === 0) {
      cleanOldMessages(channelState.db, channelState.options.idb.ttl);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage2(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}
function canBeUsed2(options) {
  if (!options.support3PC)
    return false;
  var idb = getIdb();
  if (!idb)
    return false;
  return true;
}
function averageResponseTime2(options) {
  return options.idb.fallbackInterval * 2;
}
var microSeconds3, DB_PREFIX, OBJECT_STORE_ID, TRANSACTION_SETTINGS, type2, indexed_db_default;
var init_indexed_db = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/indexed-db.js"() {
    init_process();
    init_buffer();
    init_util();
    init_es();
    init_options();
    microSeconds3 = microSeconds;
    DB_PREFIX = "pubkey.broadcast-channel-0-";
    OBJECT_STORE_ID = "messages";
    TRANSACTION_SETTINGS = {
      durability: "relaxed"
    };
    type2 = "idb";
    indexed_db_default = {
      create: create2,
      close: close2,
      onMessage: onMessage2,
      postMessage: postMessage2,
      canBeUsed: canBeUsed2,
      type: type2,
      averageResponseTime: averageResponseTime2,
      microSeconds: microSeconds3
    };
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/localstorage.js
function getLocalStorage() {
  var localStorage2;
  if (typeof window === "undefined")
    return null;
  try {
    localStorage2 = window.localStorage;
    localStorage2 = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e2) {
  }
  return localStorage2;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage3(channelState, messageJson) {
  return new Promise(function(res) {
    sleep().then(function() {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: randomToken(),
        time: (/* @__PURE__ */ new Date()).getTime(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value2 = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value2);
      var ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value2;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn) {
  var key = storageKey(channelName);
  var listener = function listener2(ev) {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener("storage", listener);
}
function create3(channelName, options) {
  options = fillOptionsWithDefaults(options);
  if (!canBeUsed3(options)) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  var uuid = randomToken();
  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);
  var state = {
    channelName,
    uuid,
    eMIs
    // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, function(msgObj) {
    if (!state.messagesCallback)
      return;
    if (msgObj.uuid === uuid)
      return;
    if (!msgObj.token || eMIs.has(msgObj.token))
      return;
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime)
      return;
    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close3(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage3(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed3(options) {
  if (!options.support3PC)
    return false;
  var ls = getLocalStorage();
  if (!ls)
    return false;
  try {
    var key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e2) {
    return false;
  }
  return true;
}
function averageResponseTime3() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}
var microSeconds4, KEY_PREFIX, type3, localstorage_default;
var init_localstorage = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/localstorage.js"() {
    init_process();
    init_buffer();
    init_es();
    init_options();
    init_util();
    microSeconds4 = microSeconds;
    KEY_PREFIX = "pubkey.broadcastChannel-";
    type3 = "localstorage";
    localstorage_default = {
      create: create3,
      close: close3,
      onMessage: onMessage3,
      postMessage: postMessage3,
      canBeUsed: canBeUsed3,
      type: type3,
      averageResponseTime: averageResponseTime3,
      microSeconds: microSeconds4
    };
  }
});

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET;
var init_commons = __esm({
  "node_modules/engine.io-parser/build/esm/commons.js"() {
    init_process();
    init_buffer();
    PACKET_TYPES = /* @__PURE__ */ Object.create(null);
    PACKET_TYPES["open"] = "0";
    PACKET_TYPES["close"] = "1";
    PACKET_TYPES["ping"] = "2";
    PACKET_TYPES["pong"] = "3";
    PACKET_TYPES["message"] = "4";
    PACKET_TYPES["upgrade"] = "5";
    PACKET_TYPES["noop"] = "6";
    PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
    Object.keys(PACKET_TYPES).forEach((key) => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
    });
    ERROR_PACKET = { type: "error", data: "parser error" };
  }
});

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob, withNativeArrayBuffer, isView, encodePacket, encodeBlobAsBase64, encodePacket_browser_default;
var init_encodePacket_browser = __esm({
  "node_modules/engine.io-parser/build/esm/encodePacket.browser.js"() {
    init_process();
    init_buffer();
    init_commons();
    withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
    withNativeArrayBuffer = typeof ArrayBuffer === "function";
    isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
    };
    encodePacket = ({ type: type6, data }, supportsBinary, callback) => {
      if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(data, callback);
        }
      } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(new Blob([data]), callback);
        }
      }
      return callback(PACKET_TYPES[type6] + (data || ""));
    };
    encodeBlobAsBase64 = (data, callback) => {
      const fileReader = new FileReader();
      fileReader.onload = function() {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
      };
      return fileReader.readAsDataURL(data);
    };
    encodePacket_browser_default = encodePacket;
  }
});

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars, lookup, decode;
var init_base64_arraybuffer = __esm({
  "node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js"() {
    init_process();
    init_buffer();
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (let i2 = 0; i2 < chars.length; i2++) {
      lookup[chars.charCodeAt(i2)] = i2;
    }
    decode = (base64) => {
      let bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup[base64.charCodeAt(i2)];
        encoded2 = lookup[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup[base64.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  }
});

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2, decodePacket, decodeBase64Packet, mapBinary, decodePacket_browser_default;
var init_decodePacket_browser = __esm({
  "node_modules/engine.io-parser/build/esm/decodePacket.browser.js"() {
    init_process();
    init_buffer();
    init_commons();
    init_base64_arraybuffer();
    withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
    decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
        return {
          type: "message",
          data: mapBinary(encodedPacket, binaryType)
        };
      }
      const type6 = encodedPacket.charAt(0);
      if (type6 === "b") {
        return {
          type: "message",
          data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
      }
      const packetType = PACKET_TYPES_REVERSE[type6];
      if (!packetType) {
        return ERROR_PACKET;
      }
      return encodedPacket.length > 1 ? {
        type: PACKET_TYPES_REVERSE[type6],
        data: encodedPacket.substring(1)
      } : {
        type: PACKET_TYPES_REVERSE[type6]
      };
    };
    decodeBase64Packet = (data, binaryType) => {
      if (withNativeArrayBuffer2) {
        const decoded = decode(data);
        return mapBinary(decoded, binaryType);
      } else {
        return { base64: true, data };
      }
    };
    mapBinary = (data, binaryType) => {
      switch (binaryType) {
        case "blob":
          return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
          return data;
      }
    };
    decodePacket_browser_default = decodePacket;
  }
});

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR, encodePayload, decodePayload, protocol;
var init_esm = __esm({
  "node_modules/engine.io-parser/build/esm/index.js"() {
    init_process();
    init_buffer();
    init_encodePacket_browser();
    init_decodePacket_browser();
    SEPARATOR = String.fromCharCode(30);
    encodePayload = (packets, callback) => {
      const length2 = packets.length;
      const encodedPackets = new Array(length2);
      let count = 0;
      packets.forEach((packet, i2) => {
        encodePacket_browser_default(packet, false, (encodedPacket) => {
          encodedPackets[i2] = encodedPacket;
          if (++count === length2) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i2 = 0; i2 < encodedPackets.length; i2++) {
        const decodedPacket = decodePacket_browser_default(encodedPackets[i2], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };
    protocol = 4;
  }
});

// node_modules/@socket.io/component-emitter/index.mjs
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
var init_component_emitter = __esm({
  "node_modules/@socket.io/component-emitter/index.mjs"() {
    init_process();
    init_buffer();
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on2() {
        this.off(event, on2);
        fn.apply(this, arguments);
      }
      on2.fn = fn;
      this.on(event, on2);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i2 = 0; i2 < callbacks.length; i2++) {
        cb = callbacks[i2];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i2, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
          callbacks[i2].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.emitReserved = Emitter.prototype.emit;
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/engine.io-client/build/esm/globalThis.browser.js
var globalThisShim;
var init_globalThis_browser = __esm({
  "node_modules/engine.io-client/build/esm/globalThis.browser.js"() {
    init_process();
    init_buffer();
    globalThisShim = (() => {
      if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    })();
  }
});

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length2 = 0;
  for (let i2 = 0, l = str.length; i2 < l; i2++) {
    c = str.charCodeAt(i2);
    if (c < 128) {
      length2 += 1;
    } else if (c < 2048) {
      length2 += 2;
    } else if (c < 55296 || c >= 57344) {
      length2 += 3;
    } else {
      i2++;
      length2 += 4;
    }
  }
  return length2;
}
var NATIVE_SET_TIMEOUT, NATIVE_CLEAR_TIMEOUT, BASE64_OVERHEAD;
var init_util2 = __esm({
  "node_modules/engine.io-client/build/esm/util.js"() {
    init_process();
    init_buffer();
    init_globalThis_browser();
    NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
    NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
    BASE64_OVERHEAD = 1.33;
  }
});

// node_modules/engine.io-client/build/esm/transport.js
var TransportError, Transport;
var init_transport = __esm({
  "node_modules/engine.io-client/build/esm/transport.js"() {
    init_process();
    init_buffer();
    init_esm();
    init_component_emitter();
    init_util2();
    TransportError = class extends Error {
      constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
      }
    };
    Transport = class extends Emitter {
      /**
       * Transport abstract constructor.
       *
       * @param {Object} opts - options
       * @protected
       */
      constructor(opts) {
        super();
        this.writable = false;
        installTimerFunctions(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
      }
      /**
       * Emits an error.
       *
       * @param {String} reason
       * @param description
       * @param context - the error context
       * @return {Transport} for chaining
       * @protected
       */
      onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
      }
      /**
       * Opens the transport.
       */
      open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
      }
      /**
       * Closes the transport.
       */
      close() {
        if (this.readyState === "opening" || this.readyState === "open") {
          this.doClose();
          this.onClose();
        }
        return this;
      }
      /**
       * Sends multiple packets.
       *
       * @param {Array} packets
       */
      send(packets) {
        if (this.readyState === "open") {
          this.write(packets);
        } else {
        }
      }
      /**
       * Called upon open
       *
       * @protected
       */
      onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
      }
      /**
       * Called with data.
       *
       * @param {String} data
       * @protected
       */
      onData(data) {
        const packet = decodePacket_browser_default(data, this.socket.binaryType);
        this.onPacket(packet);
      }
      /**
       * Called with a decoded packet.
       *
       * @protected
       */
      onPacket(packet) {
        super.emitReserved("packet", packet);
      }
      /**
       * Called upon close.
       *
       * @protected
       */
      onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
      }
      /**
       * Pauses the transport, in order not to lose packets during an upgrade.
       *
       * @param onPause
       */
      pause(onPause) {
      }
    };
  }
});

// node_modules/engine.io-client/build/esm/contrib/yeast.js
function encode(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now2 = encode(+/* @__PURE__ */ new Date());
  if (now2 !== prev)
    return seed = 0, prev = now2;
  return now2 + "." + encode(seed++);
}
var alphabet, length, map, seed, i, prev;
var init_yeast = __esm({
  "node_modules/engine.io-client/build/esm/contrib/yeast.js"() {
    "use strict";
    init_process();
    init_buffer();
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
    length = 64;
    map = {};
    seed = 0;
    i = 0;
    for (; i < length; i++)
      map[alphabet[i]] = i;
  }
});

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode2(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode2(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
var init_parseqs = __esm({
  "node_modules/engine.io-client/build/esm/contrib/parseqs.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value, hasCORS;
var init_has_cors = __esm({
  "node_modules/engine.io-client/build/esm/contrib/has-cors.js"() {
    init_process();
    init_buffer();
    value = false;
    try {
      value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
    } catch (err) {
    }
    hasCORS = value;
  }
});

// node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e2) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e2) {
    }
  }
}
var init_xmlhttprequest_browser = __esm({
  "node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js"() {
    init_process();
    init_buffer();
    init_has_cors();
    init_globalThis_browser();
  }
});

// node_modules/engine.io-client/build/esm/transports/polling.js
function empty() {
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
var hasXHR2, Polling, Request;
var init_polling = __esm({
  "node_modules/engine.io-client/build/esm/transports/polling.js"() {
    init_process();
    init_buffer();
    init_transport();
    init_yeast();
    init_parseqs();
    init_esm();
    init_xmlhttprequest_browser();
    init_component_emitter();
    init_util2();
    init_globalThis_browser();
    hasXHR2 = function() {
      const xhr = new XHR({
        xdomain: false
      });
      return null != xhr.responseType;
    }();
    Polling = class extends Transport {
      /**
       * XHR Polling constructor.
       *
       * @param {Object} opts
       * @package
       */
      constructor(opts) {
        super(opts);
        this.polling = false;
        if (typeof location !== "undefined") {
          const isSSL = "https:" === location.protocol;
          let port = location.port;
          if (!port) {
            port = isSSL ? "443" : "80";
          }
          this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        }
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
      }
      get name() {
        return "polling";
      }
      /**
       * Opens the socket (triggers polling). We write a PING message to determine
       * when the transport is open.
       *
       * @protected
       */
      doOpen() {
        this.poll();
      }
      /**
       * Pauses polling.
       *
       * @param {Function} onPause - callback upon buffers are flushed and transport is paused
       * @package
       */
      pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
          this.readyState = "paused";
          onPause();
        };
        if (this.polling || !this.writable) {
          let total = 0;
          if (this.polling) {
            total++;
            this.once("pollComplete", function() {
              --total || pause();
            });
          }
          if (!this.writable) {
            total++;
            this.once("drain", function() {
              --total || pause();
            });
          }
        } else {
          pause();
        }
      }
      /**
       * Starts polling cycle.
       *
       * @private
       */
      poll() {
        this.polling = true;
        this.doPoll();
        this.emitReserved("poll");
      }
      /**
       * Overloads onData to detect payloads.
       *
       * @protected
       */
      onData(data) {
        const callback = (packet) => {
          if ("opening" === this.readyState && packet.type === "open") {
            this.onOpen();
          }
          if ("close" === packet.type) {
            this.onClose({ description: "transport closed by the server" });
            return false;
          }
          this.onPacket(packet);
        };
        decodePayload(data, this.socket.binaryType).forEach(callback);
        if ("closed" !== this.readyState) {
          this.polling = false;
          this.emitReserved("pollComplete");
          if ("open" === this.readyState) {
            this.poll();
          } else {
          }
        }
      }
      /**
       * For polling, send a close packet.
       *
       * @protected
       */
      doClose() {
        const close7 = () => {
          this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
          close7();
        } else {
          this.once("open", close7);
        }
      }
      /**
       * Writes a packets payload.
       *
       * @param {Array} packets - data packets
       * @protected
       */
      write(packets) {
        this.writable = false;
        encodePayload(packets, (data) => {
          this.doWrite(data, () => {
            this.writable = true;
            this.emitReserved("drain");
          });
        });
      }
      /**
       * Generates uri for connection.
       *
       * @private
       */
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";
        if (false !== this.opts.timestampRequests) {
          query[this.opts.timestampParam] = yeast();
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        const encodedQuery = encode2(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      /**
       * Creates a request.
       *
       * @param {String} method
       * @private
       */
      request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
      }
      /**
       * Sends data.
       *
       * @param {String} data to send.
       * @param {Function} called upon flush.
       * @private
       */
      doWrite(data, fn) {
        const req = this.request({
          method: "POST",
          data
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr post error", xhrStatus, context);
        });
      }
      /**
       * Starts a poll cycle.
       *
       * @private
       */
      doPoll() {
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
      }
    };
    Request = class extends Emitter {
      /**
       * Request constructor
       *
       * @param {Object} options
       * @package
       */
      constructor(uri, opts) {
        super();
        installTimerFunctions(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = false !== opts.async;
        this.data = void 0 !== opts.data ? opts.data : null;
        this.create();
      }
      /**
       * Creates the XHR object and sends the request.
       *
       * @private
       */
      create() {
        const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        const xhr = this.xhr = new XHR(opts);
        try {
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.opts.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (let i2 in this.opts.extraHeaders) {
                if (this.opts.extraHeaders.hasOwnProperty(i2)) {
                  xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
                }
              }
            }
          } catch (e2) {
          }
          if ("POST" === this.method) {
            try {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e2) {
            }
          }
          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e2) {
          }
          if ("withCredentials" in xhr) {
            xhr.withCredentials = this.opts.withCredentials;
          }
          if (this.opts.requestTimeout) {
            xhr.timeout = this.opts.requestTimeout;
          }
          xhr.onreadystatechange = () => {
            if (4 !== xhr.readyState)
              return;
            if (200 === xhr.status || 1223 === xhr.status) {
              this.onLoad();
            } else {
              this.setTimeoutFn(() => {
                this.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
          xhr.send(this.data);
        } catch (e2) {
          this.setTimeoutFn(() => {
            this.onError(e2);
          }, 0);
          return;
        }
        if (typeof document !== "undefined") {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      }
      /**
       * Called upon error.
       *
       * @private
       */
      onError(err) {
        this.emitReserved("error", err, this.xhr);
        this.cleanup(true);
      }
      /**
       * Cleans up house.
       *
       * @private
       */
      cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
          return;
        }
        this.xhr.onreadystatechange = empty;
        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e2) {
          }
        }
        if (typeof document !== "undefined") {
          delete Request.requests[this.index];
        }
        this.xhr = null;
      }
      /**
       * Called upon load.
       *
       * @private
       */
      onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
          this.emitReserved("data", data);
          this.emitReserved("success");
          this.cleanup();
        }
      }
      /**
       * Aborts the request.
       *
       * @package
       */
      abort() {
        this.cleanup();
      }
    };
    Request.requestsCount = 0;
    Request.requests = {};
    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }
  }
});

// node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js
var nextTick, WebSocket, usingBrowserWebSocket, defaultBinaryType;
var init_websocket_constructor_browser = __esm({
  "node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js"() {
    init_process();
    init_buffer();
    init_globalThis_browser();
    nextTick = (() => {
      const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
      if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
      } else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
      }
    })();
    WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
    usingBrowserWebSocket = true;
    defaultBinaryType = "arraybuffer";
  }
});

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative, WS;
var init_websocket = __esm({
  "node_modules/engine.io-client/build/esm/transports/websocket.js"() {
    init_process();
    init_buffer();
    init_transport();
    init_parseqs();
    init_yeast();
    init_util2();
    init_websocket_constructor_browser();
    init_esm();
    isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
    WS = class extends Transport {
      /**
       * WebSocket transport constructor.
       *
       * @param {Object} opts - connection options
       * @protected
       */
      constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
      }
      get name() {
        return "websocket";
      }
      doOpen() {
        if (!this.check()) {
          return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
          opts.headers = this.opts.extraHeaders;
        }
        try {
          this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
        this.addEventListeners();
      }
      /**
       * Adds event listeners to the socket
       *
       * @private
       */
      addEventListeners() {
        this.ws.onopen = () => {
          if (this.opts.autoUnref) {
            this.ws._socket.unref();
          }
          this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
          description: "websocket connection closed",
          context: closeEvent
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e2) => this.onError("websocket error", e2);
      }
      write(packets) {
        this.writable = false;
        for (let i2 = 0; i2 < packets.length; i2++) {
          const packet = packets[i2];
          const lastPacket = i2 === packets.length - 1;
          encodePacket_browser_default(packet, this.supportsBinary, (data) => {
            const opts = {};
            if (!usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (this.opts.perMessageDeflate) {
                const len = (
                  // @ts-ignore
                  "string" === typeof data ? Buffer.byteLength(data) : data.length
                );
                if (len < this.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (usingBrowserWebSocket) {
                this.ws.send(data);
              } else {
                this.ws.send(data, opts);
              }
            } catch (e2) {
            }
            if (lastPacket) {
              nextTick(() => {
                this.writable = true;
                this.emitReserved("drain");
              }, this.setTimeoutFn);
            }
          });
        }
      }
      doClose() {
        if (typeof this.ws !== "undefined") {
          this.ws.close();
          this.ws = null;
        }
      }
      /**
       * Generates uri for connection.
       *
       * @private
       */
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";
        if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        if (this.opts.timestampRequests) {
          query[this.opts.timestampParam] = yeast();
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        const encodedQuery = encode2(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      /**
       * Feature detection for WebSocket.
       *
       * @return {Boolean} whether this transport is available.
       * @private
       */
      check() {
        return !!WebSocket;
      }
    };
  }
});

// node_modules/engine.io-client/build/esm/transports/index.js
var transports;
var init_transports = __esm({
  "node_modules/engine.io-client/build/esm/transports/index.js"() {
    init_process();
    init_buffer();
    init_polling();
    init_websocket();
    transports = {
      websocket: WS,
      polling: Polling
    };
  }
});

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
function parse(str) {
  const src = str, b = str.indexOf("["), e2 = str.indexOf("]");
  if (b != -1 && e2 != -1) {
    str = str.substring(0, b) + str.substring(b, e2).replace(/:/g, ";") + str.substring(e2, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b != -1 && e2 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
var re, parts;
var init_parseuri = __esm({
  "node_modules/engine.io-client/build/esm/contrib/parseuri.js"() {
    init_process();
    init_buffer();
    re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    parts = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ];
  }
});

// node_modules/engine.io-client/build/esm/socket.js
var Socket;
var init_socket = __esm({
  "node_modules/engine.io-client/build/esm/socket.js"() {
    init_process();
    init_buffer();
    init_transports();
    init_util2();
    init_parseqs();
    init_parseuri();
    init_component_emitter();
    init_esm();
    Socket = class extends Emitter {
      /**
       * Socket constructor.
       *
       * @param {String|Object} uri - uri or options
       * @param {Object} opts - options
       */
      constructor(uri, opts = {}) {
        super();
        this.writeBuffer = [];
        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = parse(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === "https" || uri.protocol === "wss";
          opts.port = uri.port;
          if (uri.query)
            opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = parse(opts.host).host;
        }
        installTimerFunctions(this, opts);
        this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
          opts.port = this.secure ? "443" : "80";
        }
        this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
        this.transports = opts.transports || ["polling", "websocket"];
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
          path: "/engine.io",
          agent: false,
          withCredentials: false,
          upgrade: true,
          timestampParam: "t",
          rememberUpgrade: false,
          addTrailingSlash: true,
          rejectUnauthorized: true,
          perMessageDeflate: {
            threshold: 1024
          },
          transportOptions: {},
          closeOnBeforeunload: true
        }, opts);
        this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
          this.opts.query = decode2(this.opts.query);
        }
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
          if (this.opts.closeOnBeforeunload) {
            this.beforeunloadEventListener = () => {
              if (this.transport) {
                this.transport.removeAllListeners();
                this.transport.close();
              }
            };
            addEventListener("beforeunload", this.beforeunloadEventListener, false);
          }
          if (this.hostname !== "localhost") {
            this.offlineEventListener = () => {
              this.onClose("transport close", {
                description: "network connection lost"
              });
            };
            addEventListener("offline", this.offlineEventListener, false);
          }
        }
        this.open();
      }
      /**
       * Creates transport of the given type.
       *
       * @param {String} name - transport name
       * @return {Transport}
       * @private
       */
      createTransport(name) {
        const query = Object.assign({}, this.opts.query);
        query.EIO = protocol;
        query.transport = name;
        if (this.id)
          query.sid = this.id;
        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
          query,
          socket: this,
          hostname: this.hostname,
          secure: this.secure,
          port: this.port
        });
        return new transports[name](opts);
      }
      /**
       * Initializes transport to use and starts probe.
       *
       * @private
       */
      open() {
        let transport;
        if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
          transport = "websocket";
        } else if (0 === this.transports.length) {
          this.setTimeoutFn(() => {
            this.emitReserved("error", "No transports available");
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = "opening";
        try {
          transport = this.createTransport(transport);
        } catch (e2) {
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      }
      /**
       * Sets the current transport. Disables the existing one (if any).
       *
       * @private
       */
      setTransport(transport) {
        if (this.transport) {
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
      }
      /**
       * Probes a transport.
       *
       * @param {String} name - transport name
       * @private
       */
      probe(name) {
        let transport = this.createTransport(name);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
          if (failed)
            return;
          transport.send([{ type: "ping", data: "probe" }]);
          transport.once("packet", (msg) => {
            if (failed)
              return;
            if ("pong" === msg.type && "probe" === msg.data) {
              this.upgrading = true;
              this.emitReserved("upgrading", transport);
              if (!transport)
                return;
              Socket.priorWebsocketSuccess = "websocket" === transport.name;
              this.transport.pause(() => {
                if (failed)
                  return;
                if ("closed" === this.readyState)
                  return;
                cleanup();
                this.setTransport(transport);
                transport.send([{ type: "upgrade" }]);
                this.emitReserved("upgrade", transport);
                transport = null;
                this.upgrading = false;
                this.flush();
              });
            } else {
              const err = new Error("probe error");
              err.transport = transport.name;
              this.emitReserved("upgradeError", err);
            }
          });
        };
        function freezeTransport() {
          if (failed)
            return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        const onerror = (err) => {
          const error = new Error("probe error: " + err);
          error.transport = transport.name;
          freezeTransport();
          this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
          onerror("transport closed");
        }
        function onclose() {
          onerror("socket closed");
        }
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            freezeTransport();
          }
        }
        const cleanup = () => {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);
          this.off("close", onclose);
          this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
      }
      /**
       * Called when connection is deemed open.
       *
       * @private
       */
      onOpen() {
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
        if ("open" === this.readyState && this.opts.upgrade) {
          let i2 = 0;
          const l = this.upgrades.length;
          for (; i2 < l; i2++) {
            this.probe(this.upgrades[i2]);
          }
        }
      }
      /**
       * Handles a packet.
       *
       * @private
       */
      onPacket(packet) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          this.emitReserved("packet", packet);
          this.emitReserved("heartbeat");
          switch (packet.type) {
            case "open":
              this.onHandshake(JSON.parse(packet.data));
              break;
            case "ping":
              this.resetPingTimeout();
              this.sendPacket("pong");
              this.emitReserved("ping");
              this.emitReserved("pong");
              break;
            case "error":
              const err = new Error("server error");
              err.code = packet.data;
              this.onError(err);
              break;
            case "message":
              this.emitReserved("data", packet.data);
              this.emitReserved("message", packet.data);
              break;
          }
        } else {
        }
      }
      /**
       * Called upon handshake completion.
       *
       * @param {Object} data - handshake obj
       * @private
       */
      onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.maxPayload = data.maxPayload;
        this.onOpen();
        if ("closed" === this.readyState)
          return;
        this.resetPingTimeout();
      }
      /**
       * Sets and resets ping timeout timer based on server pings.
       *
       * @private
       */
      resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
          this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
          this.pingTimeoutTimer.unref();
        }
      }
      /**
       * Called on `drain` event
       *
       * @private
       */
      onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
          this.emitReserved("drain");
        } else {
          this.flush();
        }
      }
      /**
       * Flush write buffers.
       *
       * @private
       */
      flush() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          const packets = this.getWritablePackets();
          this.transport.send(packets);
          this.prevBufferLen = packets.length;
          this.emitReserved("flush");
        }
      }
      /**
       * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
       * long-polling)
       *
       * @private
       */
      getWritablePackets() {
        const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
          return this.writeBuffer;
        }
        let payloadSize = 1;
        for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
          const data = this.writeBuffer[i2].data;
          if (data) {
            payloadSize += byteLength(data);
          }
          if (i2 > 0 && payloadSize > this.maxPayload) {
            return this.writeBuffer.slice(0, i2);
          }
          payloadSize += 2;
        }
        return this.writeBuffer;
      }
      /**
       * Sends a message.
       *
       * @param {String} msg - message.
       * @param {Object} options.
       * @param {Function} callback function.
       * @return {Socket} for chaining.
       */
      write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      /**
       * Sends a packet.
       *
       * @param {String} type: packet type.
       * @param {String} data.
       * @param {Object} options.
       * @param {Function} fn - callback function.
       * @private
       */
      sendPacket(type6, data, options, fn) {
        if ("function" === typeof data) {
          fn = data;
          data = void 0;
        }
        if ("function" === typeof options) {
          fn = options;
          options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
          return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
          type: type6,
          data,
          options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
          this.once("flush", fn);
        this.flush();
      }
      /**
       * Closes the connection.
       */
      close() {
        const close7 = () => {
          this.onClose("forced close");
          this.transport.close();
        };
        const cleanupAndClose = () => {
          this.off("upgrade", cleanupAndClose);
          this.off("upgradeError", cleanupAndClose);
          close7();
        };
        const waitForUpgrade = () => {
          this.once("upgrade", cleanupAndClose);
          this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
          this.readyState = "closing";
          if (this.writeBuffer.length) {
            this.once("drain", () => {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close7();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close7();
          }
        }
        return this;
      }
      /**
       * Called upon transport error
       *
       * @private
       */
      onError(err) {
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
      }
      /**
       * Called upon transport close.
       *
       * @private
       */
      onClose(reason, description) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.transport.removeAllListeners("close");
          this.transport.close();
          this.transport.removeAllListeners();
          if (typeof removeEventListener === "function") {
            removeEventListener("beforeunload", this.beforeunloadEventListener, false);
            removeEventListener("offline", this.offlineEventListener, false);
          }
          this.readyState = "closed";
          this.id = null;
          this.emitReserved("close", reason, description);
          this.writeBuffer = [];
          this.prevBufferLen = 0;
        }
      }
      /**
       * Filters upgrades, returning only those matching client transports.
       *
       * @param {Array} upgrades - server upgrades
       * @private
       */
      filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i2 = 0;
        const j = upgrades.length;
        for (; i2 < j; i2++) {
          if (~this.transports.indexOf(upgrades[i2]))
            filteredUpgrades.push(upgrades[i2]);
        }
        return filteredUpgrades;
      }
    };
    Socket.protocol = protocol;
  }
});

// node_modules/engine.io-client/build/esm/index.js
var protocol2;
var init_esm2 = __esm({
  "node_modules/engine.io-client/build/esm/index.js"() {
    init_process();
    init_buffer();
    init_socket();
    init_transport();
    init_transports();
    init_util2();
    init_parseuri();
    init_websocket_constructor_browser();
    protocol2 = Socket.protocol;
  }
});

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
var init_url = __esm({
  "node_modules/socket.io-client/build/esm/url.js"() {
    init_process();
    init_buffer();
    init_esm2();
  }
});

// node_modules/socket.io-parser/build/esm/is-binary.js
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
var withNativeArrayBuffer3, isView2, toString, withNativeBlob2, withNativeFile;
var init_is_binary = __esm({
  "node_modules/socket.io-parser/build/esm/is-binary.js"() {
    init_process();
    init_buffer();
    withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
    isView2 = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    toString = Object.prototype.toString;
    withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
    withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
  }
});

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
var init_binary = __esm({
  "node_modules/socket.io-parser/build/esm/binary.js"() {
    init_process();
    init_buffer();
    init_is_binary();
  }
});

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  PacketType: () => PacketType,
  protocol: () => protocol3
});
var protocol3, PacketType, Encoder, Decoder, BinaryReconstructor;
var init_esm3 = __esm({
  "node_modules/socket.io-parser/build/esm/index.js"() {
    init_process();
    init_buffer();
    init_component_emitter();
    init_binary();
    init_is_binary();
    protocol3 = 5;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType || (PacketType = {}));
    Encoder = class {
      /**
       * Encoder constructor
       *
       * @param {function} replacer - custom replacer to pass down to JSON.parse
       */
      constructor(replacer) {
        this.replacer = replacer;
      }
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       */
      encode(obj) {
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if (hasBinary(obj)) {
            return this.encodeAsBinary({
              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
              nsp: obj.nsp,
              data: obj.data,
              id: obj.id
            });
          }
        }
        return [this.encodeAsString(obj)];
      }
      /**
       * Encode packet as string.
       */
      encodeAsString(obj) {
        let str = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && "/" !== obj.nsp) {
          str += obj.nsp + ",";
        }
        if (null != obj.id) {
          str += obj.id;
        }
        if (null != obj.data) {
          str += JSON.stringify(obj.data, this.replacer);
        }
        return str;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */
      encodeAsBinary(obj) {
        const deconstruction = deconstructPacket(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack);
        return buffers;
      }
    };
    Decoder = class extends Emitter {
      /**
       * Decoder constructor
       *
       * @param {function} reviver - custom reviver to pass down to JSON.stringify
       */
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       */
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          if (this.reconstructor) {
            throw new Error("got plaintext data when reconstructing a packet");
          }
          packet = this.decodeString(obj);
          const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if (isBinary(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */
      decodeString(str) {
        let i2 = 0;
        const p = {
          type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === void 0) {
          throw new Error("unknown packet type " + p.type);
        }
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i2 + 1;
          while (str.charAt(++i2) !== "-" && i2 != str.length) {
          }
          const buf = str.substring(start, i2);
          if (buf != Number(buf) || str.charAt(i2) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf);
        }
        if ("/" === str.charAt(i2 + 1)) {
          const start = i2 + 1;
          while (++i2) {
            const c = str.charAt(i2);
            if ("," === c)
              break;
            if (i2 === str.length)
              break;
          }
          p.nsp = str.substring(start, i2);
        } else {
          p.nsp = "/";
        }
        const next = str.charAt(i2 + 1);
        if ("" !== next && Number(next) == next) {
          const start = i2 + 1;
          while (++i2) {
            const c = str.charAt(i2);
            if (null == c || Number(c) != c) {
              --i2;
              break;
            }
            if (i2 === str.length)
              break;
          }
          p.id = Number(str.substring(start, i2 + 1));
        }
        if (str.charAt(++i2)) {
          const payload = this.tryParse(str.substr(i2));
          if (Decoder.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        return p;
      }
      tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e2) {
          return false;
        }
      }
      static isPayloadValid(type6, payload) {
        switch (type6) {
          case PacketType.CONNECT:
            return typeof payload === "object";
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || typeof payload === "object";
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && payload.length > 0;
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      /**
       * Deallocates a parser's resources
       */
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
          this.reconstructor = null;
        }
      }
    };
    BinaryReconstructor = class {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       */
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    };
  }
});

// node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
var init_on = __esm({
  "node_modules/socket.io-client/build/esm/on.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS, Socket2;
var init_socket2 = __esm({
  "node_modules/socket.io-client/build/esm/socket.js"() {
    init_process();
    init_buffer();
    init_esm3();
    init_on();
    init_component_emitter();
    RESERVED_EVENTS = Object.freeze({
      connect: 1,
      connect_error: 1,
      disconnect: 1,
      disconnecting: 1,
      // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
      newListener: 1,
      removeListener: 1
    });
    Socket2 = class extends Emitter {
      /**
       * `Socket` constructor.
       */
      constructor(io, nsp, opts) {
        super();
        this.connected = false;
        this.recovered = false;
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this._queue = [];
        this._queueSeq = 0;
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
          this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
          this.open();
      }
      /**
       * Whether the socket is currently disconnected
       *
       * @example
       * const socket = io();
       *
       * socket.on("connect", () => {
       *   console.log(socket.disconnected); // false
       * });
       *
       * socket.on("disconnect", () => {
       *   console.log(socket.disconnected); // true
       * });
       */
      get disconnected() {
        return !this.connected;
      }
      /**
       * Subscribe to open, close and packet events
       *
       * @private
       */
      subEvents() {
        if (this.subs)
          return;
        const io = this.io;
        this.subs = [
          on(io, "open", this.onopen.bind(this)),
          on(io, "packet", this.onpacket.bind(this)),
          on(io, "error", this.onerror.bind(this)),
          on(io, "close", this.onclose.bind(this))
        ];
      }
      /**
       * Whether the Socket will try to reconnect when its Manager connects or reconnects.
       *
       * @example
       * const socket = io();
       *
       * console.log(socket.active); // true
       *
       * socket.on("disconnect", (reason) => {
       *   if (reason === "io server disconnect") {
       *     // the disconnection was initiated by the server, you need to manually reconnect
       *     console.log(socket.active); // false
       *   }
       *   // else the socket will automatically try to reconnect
       *   console.log(socket.active); // true
       * });
       */
      get active() {
        return !!this.subs;
      }
      /**
       * "Opens" the socket.
       *
       * @example
       * const socket = io({
       *   autoConnect: false
       * });
       *
       * socket.connect();
       */
      connect() {
        if (this.connected)
          return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
          this.io.open();
        if ("open" === this.io._readyState)
          this.onopen();
        return this;
      }
      /**
       * Alias for {@link connect()}.
       */
      open() {
        return this.connect();
      }
      /**
       * Sends a `message` event.
       *
       * This method mimics the WebSocket.send() method.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
       *
       * @example
       * socket.send("hello");
       *
       * // this is equivalent to
       * socket.emit("message", "hello");
       *
       * @return self
       */
      send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
      }
      /**
       * Override `emit`.
       * If the event is in `events`, it's emitted normally.
       *
       * @example
       * socket.emit("hello", "world");
       *
       * // all serializable datastructures are supported (no need to call JSON.stringify)
       * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
       *
       * // with an acknowledgement from the server
       * socket.emit("hello", "world", (val) => {
       *   // ...
       * });
       *
       * @return self
       */
      emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
          throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
          this._addToQueue(args);
          return this;
        }
        const packet = {
          type: PacketType.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        if ("function" === typeof args[args.length - 1]) {
          const id = this.ids++;
          const ack = args.pop();
          this._registerAckCallback(id, ack);
          packet.id = id;
        }
        const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
        } else if (this.connected) {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
      }
      /**
       * @private
       */
      _registerAckCallback(id, ack) {
        var _a;
        const timeout2 = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout2 === void 0) {
          this.acks[id] = ack;
          return;
        }
        const timer = this.io.setTimeoutFn(() => {
          delete this.acks[id];
          for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
            if (this.sendBuffer[i2].id === id) {
              this.sendBuffer.splice(i2, 1);
            }
          }
          ack.call(this, new Error("operation has timed out"));
        }, timeout2);
        this.acks[id] = (...args) => {
          this.io.clearTimeoutFn(timer);
          ack.apply(this, [null, ...args]);
        };
      }
      /**
       * Emits an event and waits for an acknowledgement
       *
       * @example
       * // without timeout
       * const response = await socket.emitWithAck("hello", "world");
       *
       * // with a specific timeout
       * try {
       *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
       * } catch (err) {
       *   // the server did not acknowledge the event in the given delay
       * }
       *
       * @return a Promise that will be fulfilled when the server acknowledges the event
       */
      emitWithAck(ev, ...args) {
        const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
        return new Promise((resolve, reject) => {
          args.push((arg1, arg2) => {
            if (withErr) {
              return arg1 ? reject(arg1) : resolve(arg2);
            } else {
              return resolve(arg1);
            }
          });
          this.emit(ev, ...args);
        });
      }
      /**
       * Add the packet to the queue.
       * @param args
       * @private
       */
      _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
          ack = args.pop();
        }
        const packet = {
          id: this._queueSeq++,
          tryCount: 0,
          pending: false,
          args,
          flags: Object.assign({ fromQueue: true }, this.flags)
        };
        args.push((err, ...responseArgs) => {
          if (packet !== this._queue[0]) {
            return;
          }
          const hasError = err !== null;
          if (hasError) {
            if (packet.tryCount > this._opts.retries) {
              this._queue.shift();
              if (ack) {
                ack(err);
              }
            }
          } else {
            this._queue.shift();
            if (ack) {
              ack(null, ...responseArgs);
            }
          }
          packet.pending = false;
          return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
      }
      /**
       * Send the first packet of the queue, and wait for an acknowledgement from the server.
       * @param force - whether to resend a packet that has not been acknowledged yet
       *
       * @private
       */
      _drainQueue(force = false) {
        if (!this.connected || this._queue.length === 0) {
          return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
          return;
        }
        packet.pending = true;
        packet.tryCount++;
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
      }
      /**
       * Sends a packet.
       *
       * @param packet
       * @private
       */
      packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
      }
      /**
       * Called upon engine `open`.
       *
       * @private
       */
      onopen() {
        if (typeof this.auth == "function") {
          this.auth((data) => {
            this._sendConnectPacket(data);
          });
        } else {
          this._sendConnectPacket(this.auth);
        }
      }
      /**
       * Sends a CONNECT packet to initiate the Socket.IO session.
       *
       * @param data
       * @private
       */
      _sendConnectPacket(data) {
        this.packet({
          type: PacketType.CONNECT,
          data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
        });
      }
      /**
       * Called upon engine or manager `error`.
       *
       * @param err
       * @private
       */
      onerror(err) {
        if (!this.connected) {
          this.emitReserved("connect_error", err);
        }
      }
      /**
       * Called upon engine `close`.
       *
       * @param reason
       * @param description
       * @private
       */
      onclose(reason, description) {
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
      }
      /**
       * Called with socket packet.
       *
       * @param packet
       * @private
       */
      onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
          return;
        switch (packet.type) {
          case PacketType.CONNECT:
            if (packet.data && packet.data.sid) {
              this.onconnect(packet.data.sid, packet.data.pid);
            } else {
              this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
            }
            break;
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case PacketType.DISCONNECT:
            this.ondisconnect();
            break;
          case PacketType.CONNECT_ERROR:
            this.destroy();
            const err = new Error(packet.data.message);
            err.data = packet.data.data;
            this.emitReserved("connect_error", err);
            break;
        }
      }
      /**
       * Called upon a server event.
       *
       * @param packet
       * @private
       */
      onevent(packet) {
        const args = packet.data || [];
        if (null != packet.id) {
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          this.emitEvent(args);
        } else {
          this.receiveBuffer.push(Object.freeze(args));
        }
      }
      emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, args);
          }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
          this._lastOffset = args[args.length - 1];
        }
      }
      /**
       * Produces an ack callback to emit with an event.
       *
       * @private
       */
      ack(id) {
        const self2 = this;
        let sent = false;
        return function(...args) {
          if (sent)
            return;
          sent = true;
          self2.packet({
            type: PacketType.ACK,
            id,
            data: args
          });
        };
      }
      /**
       * Called upon a server acknowlegement.
       *
       * @param packet
       * @private
       */
      onack(packet) {
        const ack = this.acks[packet.id];
        if ("function" === typeof ack) {
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        } else {
        }
      }
      /**
       * Called upon server connect.
       *
       * @private
       */
      onconnect(id, pid) {
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid;
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
      }
      /**
       * Emit buffered events (received and emitted).
       *
       * @private
       */
      emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        });
        this.sendBuffer = [];
      }
      /**
       * Called upon server disconnect.
       *
       * @private
       */
      ondisconnect() {
        this.destroy();
        this.onclose("io server disconnect");
      }
      /**
       * Called upon forced client/server side disconnections,
       * this method ensures the manager stops tracking us and
       * that reconnections don't get triggered for this.
       *
       * @private
       */
      destroy() {
        if (this.subs) {
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs = void 0;
        }
        this.io["_destroy"](this);
      }
      /**
       * Disconnects the socket manually. In that case, the socket will not try to reconnect.
       *
       * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
       *
       * @example
       * const socket = io();
       *
       * socket.on("disconnect", (reason) => {
       *   // console.log(reason); prints "io client disconnect"
       * });
       *
       * socket.disconnect();
       *
       * @return self
       */
      disconnect() {
        if (this.connected) {
          this.packet({ type: PacketType.DISCONNECT });
        }
        this.destroy();
        if (this.connected) {
          this.onclose("io client disconnect");
        }
        return this;
      }
      /**
       * Alias for {@link disconnect()}.
       *
       * @return self
       */
      close() {
        return this.disconnect();
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * socket.compress(false).emit("hello");
       *
       * @param compress - if `true`, compresses the sending data
       * @return self
       */
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
       * ready to send messages.
       *
       * @example
       * socket.volatile.emit("hello"); // the server may or may not receive it
       *
       * @returns self
       */
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
       * given number of milliseconds have elapsed without an acknowledgement from the server:
       *
       * @example
       * socket.timeout(5000).emit("my-event", (err) => {
       *   if (err) {
       *     // the server did not acknowledge the event in the given delay
       *   }
       * });
       *
       * @returns self
       */
      timeout(timeout2) {
        this.flags.timeout = timeout2;
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * @example
       * socket.onAny((event, ...args) => {
       *   console.log(`got ${event}`);
       * });
       *
       * @param listener
       */
      onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @example
       * socket.prependAny((event, ...args) => {
       *   console.log(`got event ${event}`);
       * });
       *
       * @param listener
       */
      prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @example
       * const catchAllListener = (event, ...args) => {
       *   console.log(`got event ${event}`);
       * }
       *
       * socket.onAny(catchAllListener);
       *
       * // remove a specific listener
       * socket.offAny(catchAllListener);
       *
       * // or remove all listeners
       * socket.offAny();
       *
       * @param listener
       */
      offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyListeners;
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listener === listeners[i2]) {
              listeners.splice(i2, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAny() {
        return this._anyListeners || [];
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * Note: acknowledgements sent to the server are not included.
       *
       * @example
       * socket.onAnyOutgoing((event, ...args) => {
       *   console.log(`sent event ${event}`);
       * });
       *
       * @param listener
       */
      onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * Note: acknowledgements sent to the server are not included.
       *
       * @example
       * socket.prependAnyOutgoing((event, ...args) => {
       *   console.log(`sent event ${event}`);
       * });
       *
       * @param listener
       */
      prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @example
       * const catchAllListener = (event, ...args) => {
       *   console.log(`sent event ${event}`);
       * }
       *
       * socket.onAnyOutgoing(catchAllListener);
       *
       * // remove a specific listener
       * socket.offAnyOutgoing(catchAllListener);
       *
       * // or remove all listeners
       * socket.offAnyOutgoing();
       *
       * @param [listener] - the catch-all listener (optional)
       */
      offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyOutgoingListeners;
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listener === listeners[i2]) {
              listeners.splice(i2, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      /**
       * Notify the listeners for each packet sent
       *
       * @param packet
       *
       * @private
       */
      notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const listeners = this._anyOutgoingListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, packet.data);
          }
        }
      }
    };
  }
});

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
var init_backo2 = __esm({
  "node_modules/socket.io-client/build/esm/contrib/backo2.js"() {
    init_process();
    init_buffer();
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }
});

// node_modules/socket.io-client/build/esm/manager.js
var Manager;
var init_manager = __esm({
  "node_modules/socket.io-client/build/esm/manager.js"() {
    init_process();
    init_buffer();
    init_esm2();
    init_socket2();
    init_esm3();
    init_on();
    init_backo2();
    init_component_emitter();
    Manager = class extends Emitter {
      constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = void 0;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        installTimerFunctions(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1e3);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new Backoff({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || esm_exports;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
          this.open();
      }
      reconnection(v) {
        if (!arguments.length)
          return this._reconnection;
        this._reconnection = !!v;
        return this;
      }
      reconnectionAttempts(v) {
        if (v === void 0)
          return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      }
      reconnectionDelay(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
      }
      randomizationFactor(v) {
        var _a;
        if (v === void 0)
          return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
      }
      reconnectionDelayMax(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
      }
      timeout(v) {
        if (!arguments.length)
          return this._timeout;
        this._timeout = v;
        return this;
      }
      /**
       * Starts trying to reconnect if reconnection is enabled and we have not
       * started reconnecting yet
       *
       * @private
       */
      maybeReconnectOnOpen() {
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      }
      /**
       * Sets the current transport `socket`.
       *
       * @param {Function} fn - optional, callback
       * @return self
       * @public
       */
      open(fn) {
        if (~this._readyState.indexOf("open"))
          return this;
        this.engine = new Socket(this.uri, this.opts);
        const socket = this.engine;
        const self2 = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        const openSubDestroy = on(socket, "open", function() {
          self2.onopen();
          fn && fn();
        });
        const errorSub = on(socket, "error", (err) => {
          self2.cleanup();
          self2._readyState = "closed";
          this.emitReserved("error", err);
          if (fn) {
            fn(err);
          } else {
            self2.maybeReconnectOnOpen();
          }
        });
        if (false !== this._timeout) {
          const timeout2 = this._timeout;
          if (timeout2 === 0) {
            openSubDestroy();
          }
          const timer = this.setTimeoutFn(() => {
            openSubDestroy();
            socket.close();
            socket.emit("error", new Error("timeout"));
          }, timeout2);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
      }
      /**
       * Alias for open()
       *
       * @return self
       * @public
       */
      connect(fn) {
        return this.open(fn);
      }
      /**
       * Called upon transport open.
       *
       * @private
       */
      onopen() {
        this.cleanup();
        this._readyState = "open";
        this.emitReserved("open");
        const socket = this.engine;
        this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
      }
      /**
       * Called upon a ping.
       *
       * @private
       */
      onping() {
        this.emitReserved("ping");
      }
      /**
       * Called with data.
       *
       * @private
       */
      ondata(data) {
        try {
          this.decoder.add(data);
        } catch (e2) {
          this.onclose("parse error", e2);
        }
      }
      /**
       * Called when parser fully decodes a packet.
       *
       * @private
       */
      ondecoded(packet) {
        nextTick(() => {
          this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
      }
      /**
       * Called upon socket error.
       *
       * @private
       */
      onerror(err) {
        this.emitReserved("error", err);
      }
      /**
       * Creates a new socket for the given `nsp`.
       *
       * @return {Socket}
       * @public
       */
      socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
          socket = new Socket2(this, nsp, opts);
          this.nsps[nsp] = socket;
        } else if (this._autoConnect && !socket.active) {
          socket.connect();
        }
        return socket;
      }
      /**
       * Called upon a socket close.
       *
       * @param socket
       * @private
       */
      _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
          const socket2 = this.nsps[nsp];
          if (socket2.active) {
            return;
          }
        }
        this._close();
      }
      /**
       * Writes a packet.
       *
       * @param packet
       * @private
       */
      _packet(packet) {
        const encodedPackets = this.encoder.encode(packet);
        for (let i2 = 0; i2 < encodedPackets.length; i2++) {
          this.engine.write(encodedPackets[i2], packet.options);
        }
      }
      /**
       * Clean up transport subscriptions and packet buffer.
       *
       * @private
       */
      cleanup() {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
      }
      /**
       * Close the current socket.
       *
       * @private
       */
      _close() {
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine)
          this.engine.close();
      }
      /**
       * Alias for close()
       *
       * @private
       */
      disconnect() {
        return this._close();
      }
      /**
       * Called upon engine close.
       *
       * @private
       */
      onclose(reason, description) {
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      }
      /**
       * Attempt a reconnection.
       *
       * @private
       */
      reconnect() {
        if (this._reconnecting || this.skipReconnect)
          return this;
        const self2 = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          this.backoff.reset();
          this.emitReserved("reconnect_failed");
          this._reconnecting = false;
        } else {
          const delay = this.backoff.duration();
          this._reconnecting = true;
          const timer = this.setTimeoutFn(() => {
            if (self2.skipReconnect)
              return;
            this.emitReserved("reconnect_attempt", self2.backoff.attempts);
            if (self2.skipReconnect)
              return;
            self2.open((err) => {
              if (err) {
                self2._reconnecting = false;
                self2.reconnect();
                this.emitReserved("reconnect_error", err);
              } else {
                self2.onreconnect();
              }
            });
          }, delay);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
      }
      /**
       * Called upon successful reconnect.
       *
       * @private
       */
      onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
      }
    };
  }
});

// node_modules/socket.io-client/build/esm/index.js
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
var cache;
var init_esm4 = __esm({
  "node_modules/socket.io-client/build/esm/index.js"() {
    init_process();
    init_buffer();
    init_url();
    init_manager();
    init_socket2();
    init_esm3();
    cache = {};
    Object.assign(lookup2, {
      Manager,
      Socket: Socket2,
      io: lookup2,
      connect: lookup2
    });
  }
});

// node_modules/@toruslabs/broadcast-channel/node_modules/@toruslabs/eccrypto/browser.js
var require_browser2 = __commonJS({
  "node_modules/@toruslabs/broadcast-channel/node_modules/@toruslabs/eccrypto/browser.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var EC = require_elliptic().ec;
    var ec2 = new EC("secp256k1");
    var browserCrypto = globalThis.crypto || globalThis.msCrypto || {};
    var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    var nodeCrypto = require_crypto();
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var ZERO32 = Buffer.alloc(32, 0);
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failed");
      }
    }
    function isScalar(x) {
      return Buffer.isBuffer(x) && x.length === 32;
    }
    function isValidPrivateKey(privateKey) {
      if (!isScalar(privateKey)) {
        return false;
      }
      return privateKey.compare(ZERO32) > 0 && // > 0
      privateKey.compare(EC_GROUP_ORDER) < 0;
    }
    function equalConstTime(b1, b2) {
      if (b1.length !== b2.length) {
        return false;
      }
      var res = 0;
      for (var i2 = 0; i2 < b1.length; i2++) {
        res |= b1[i2] ^ b2[i2];
      }
      return res === 0;
    }
    function randomBytes(size) {
      var arr = new Uint8Array(size);
      if (typeof browserCrypto.getRandomValues === "undefined") {
        return Buffer.from(nodeCrypto.randomBytes(size));
      } else {
        browserCrypto.getRandomValues(arr);
      }
      return Buffer.from(arr);
    }
    function sha512(msg) {
      return new Promise(function(resolve) {
        var hash = nodeCrypto.createHash("sha512");
        var result = hash.update(msg).digest();
        resolve(new Uint8Array(result));
      });
    }
    function getAes(op) {
      return function(iv, key, data) {
        return new Promise(function(resolve) {
          if (subtle) {
            var importAlgorithm = { name: "AES-CBC" };
            var keyp = subtle.importKey("raw", key, importAlgorithm, false, [op]);
            return keyp.then(function(cryptoKey) {
              var encAlgorithm = { name: "AES-CBC", iv };
              return subtle[op](encAlgorithm, cryptoKey, data);
            }).then(function(result) {
              resolve(Buffer.from(new Uint8Array(result)));
            });
          } else {
            if (op === "encrypt") {
              var cipher = nodeCrypto.createCipheriv("aes-256-cbc", key, iv);
              let firstChunk = cipher.update(data);
              let secondChunk = cipher.final();
              resolve(Buffer.concat([firstChunk, secondChunk]));
            } else if (op === "decrypt") {
              var decipher = nodeCrypto.createDecipheriv("aes-256-cbc", key, iv);
              let firstChunk = decipher.update(data);
              let secondChunk = decipher.final();
              resolve(Buffer.concat([firstChunk, secondChunk]));
            }
          }
        });
      };
    }
    var aesCbcEncrypt = getAes("encrypt");
    var aesCbcDecrypt = getAes("decrypt");
    function hmacSha256Sign(key, msg) {
      return new Promise(function(resolve) {
        var hmac = nodeCrypto.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var result = hmac.digest();
        resolve(result);
      });
    }
    function hmacSha256Verify(key, msg, sig) {
      return new Promise(function(resolve) {
        var hmac = nodeCrypto.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var expectedSig = hmac.digest();
        resolve(equalConstTime(expectedSig, sig));
      });
    }
    exports.generatePrivate = function() {
      var privateKey = randomBytes(32);
      while (!isValidPrivateKey(privateKey)) {
        privateKey = randomBytes(32);
      }
      return privateKey;
    };
    var getPublic3 = exports.getPublic = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      return Buffer.from(ec2.keyFromPrivate(privateKey).getPublic("arr"));
    };
    var getPublicCompressed = exports.getPublicCompressed = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      let compressed = true;
      return Buffer.from(ec2.keyFromPrivate(privateKey).getPublic(compressed, "arr"));
    };
    exports.sign = function(privateKey, msg) {
      return new Promise(function(resolve) {
        assert(privateKey.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKey), "Bad private key");
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        resolve(Buffer.from(ec2.sign(msg, privateKey, { canonical: true }).toDER()));
      });
    };
    exports.verify = function(publicKey, msg, sig) {
      return new Promise(function(resolve, reject) {
        assert(publicKey.length === 65 || publicKey.length === 33, "Bad public key");
        if (publicKey.length === 65) {
          assert(publicKey[0] === 4, "Bad public key");
        }
        if (publicKey.length === 33) {
          assert(publicKey[0] === 2 || publicKey[0] === 3, "Bad public key");
        }
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        if (ec2.verify(msg, sig, publicKey)) {
          resolve(null);
        } else {
          reject(new Error("Bad signature"));
        }
      });
    };
    var deriveUnpadded = exports.derive = function(privateKeyA, publicKeyB) {
      return new Promise(function(resolve) {
        assert(Buffer.isBuffer(privateKeyA), "Bad private key");
        assert(Buffer.isBuffer(publicKeyB), "Bad public key");
        assert(privateKeyA.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKeyA), "Bad private key");
        assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
        if (publicKeyB.length === 65) {
          assert(publicKeyB[0] === 4, "Bad public key");
        }
        if (publicKeyB.length === 33) {
          assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
        }
        var keyA = ec2.keyFromPrivate(privateKeyA);
        var keyB = ec2.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic());
        resolve(Buffer.from(Px.toArray()));
      });
    };
    var derivePadded = exports.derivePadded = function(privateKeyA, publicKeyB) {
      return new Promise(function(resolve) {
        assert(Buffer.isBuffer(privateKeyA), "Bad private key");
        assert(Buffer.isBuffer(publicKeyB), "Bad public key");
        assert(privateKeyA.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKeyA), "Bad private key");
        assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
        if (publicKeyB.length === 65) {
          assert(publicKeyB[0] === 4, "Bad public key");
        }
        if (publicKeyB.length === 33) {
          assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
        }
        var keyA = ec2.keyFromPrivate(privateKeyA);
        var keyB = ec2.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic());
        resolve(Buffer.from(Px.toString(16, 64), "hex"));
      });
    };
    exports.encrypt = function(publicKeyTo, msg, opts) {
      opts = opts || {};
      var iv, ephemPublicKey, ciphertext, macKey;
      return new Promise(function(resolve) {
        var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        while (!isValidPrivateKey(ephemPrivateKey)) {
          ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        }
        ephemPublicKey = getPublic3(ephemPrivateKey);
        resolve(deriveUnpadded(ephemPrivateKey, publicKeyTo));
      }).then(function(Px) {
        return sha512(Px);
      }).then(function(hash) {
        iv = opts.iv || randomBytes(16);
        var encryptionKey = hash.slice(0, 32);
        macKey = hash.slice(32);
        return aesCbcEncrypt(iv, encryptionKey, msg);
      }).then(function(data) {
        ciphertext = data;
        var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
        return hmacSha256Sign(macKey, dataToMac);
      }).then(function(mac) {
        return {
          iv,
          ephemPublicKey,
          ciphertext,
          mac
        };
      });
    };
    var decrypt2 = function(privateKey, opts, padding = false) {
      var encryptionKey;
      const derive = padding ? derivePadded : deriveUnpadded;
      return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
        return sha512(Px);
      }).then(function(hash) {
        encryptionKey = hash.slice(0, 32);
        var macKey = hash.slice(32);
        var dataToMac = Buffer.concat([
          opts.iv,
          opts.ephemPublicKey,
          opts.ciphertext
        ]);
        return hmacSha256Verify(macKey, dataToMac, opts.mac);
      }).then(function(macGood) {
        if (!macGood && padding === false) {
          return decrypt2(privateKey, opts, true);
        } else if (!macGood && padding === true) {
          throw new Error("bad MAC after trying padded");
        }
        return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext).then(function(msg) {
          return Buffer.from(new Uint8Array(msg));
        });
      });
    };
    exports.decrypt = decrypt2;
  }
});

// node_modules/@toruslabs/metadata-helpers/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
var import_lodash2, import_loglevel4, log4;
var init_httpHelpers_esm2 = __esm({
  "node_modules/@toruslabs/metadata-helpers/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    import_lodash2 = __toESM(require_lodash2());
    import_loglevel4 = __toESM(require_loglevel());
    log4 = import_loglevel4.default.getLogger("http-helpers");
    log4.setLevel(import_loglevel4.levels.INFO);
  }
});

// node_modules/jsonify/lib/parse.js
var require_parse = __commonJS({
  "node_modules/jsonify/lib/parse.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var at;
    var ch;
    var escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    };
    var text;
    function error(m) {
      throw {
        name: "SyntaxError",
        message: m,
        at,
        text
      };
    }
    function next(c) {
      if (c && c !== ch) {
        error("Expected '" + c + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }
    function number() {
      var num;
      var str = "";
      if (ch === "-") {
        str = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        str += ch;
        next();
      }
      if (ch === ".") {
        str += ".";
        while (next() && ch >= "0" && ch <= "9") {
          str += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        str += ch;
        next();
        if (ch === "-" || ch === "+") {
          str += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          str += ch;
          next();
        }
      }
      num = Number(str);
      if (!isFinite(num)) {
        error("Bad number");
      }
      return num;
    }
    function string() {
      var hex;
      var i2;
      var str = "";
      var uffff;
      if (ch === '"') {
        while (next()) {
          if (ch === '"') {
            next();
            return str;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i2 = 0; i2 < 4; i2 += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              str += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              str += escapee[ch];
            } else {
              break;
            }
          } else {
            str += ch;
          }
        }
      }
      error("Bad string");
    }
    function white() {
      while (ch && ch <= " ") {
        next();
      }
    }
    function word() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
        default:
          error("Unexpected '" + ch + "'");
      }
    }
    function array() {
      var arr = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return arr;
        }
        while (ch) {
          arr.push(value2());
          white();
          if (ch === "]") {
            next("]");
            return arr;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    }
    function object() {
      var key;
      var obj = {};
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return obj;
        }
        while (ch) {
          key = string();
          white();
          next(":");
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            error('Duplicate key "' + key + '"');
          }
          obj[key] = value2();
          white();
          if (ch === "}") {
            next("}");
            return obj;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    }
    function value2() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    }
    module.exports = function(source, reviver) {
      var result;
      text = source;
      at = 0;
      ch = " ";
      result = value2();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key) {
        var k;
        var v;
        var val = holder[key];
        if (val && typeof val === "object") {
          for (k in value2) {
            if (Object.prototype.hasOwnProperty.call(val, k)) {
              v = walk(val, k);
              if (typeof v === "undefined") {
                delete val[k];
              } else {
                val[k] = v;
              }
            }
          }
        }
        return reviver.call(holder, key, val);
      }({ "": result }, "") : result;
    };
  }
});

// node_modules/jsonify/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/jsonify/lib/stringify.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var gap;
    var indent;
    var meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c = meta[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i2;
      var k;
      var v;
      var length2;
      var mind = gap;
      var partial;
      var value2 = holder[key];
      if (value2 && typeof value2 === "object" && typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key);
      }
      if (typeof rep === "function") {
        value2 = rep.call(holder, key, value2);
      }
      switch (typeof value2) {
        case "string":
          return quote(value2);
        case "number":
          return isFinite(value2) ? String(value2) : "null";
        case "boolean":
        case "null":
          return String(value2);
        case "object":
          if (!value2) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value2) === "[object Array]") {
            length2 = value2.length;
            for (i2 = 0; i2 < length2; i2 += 1) {
              partial[i2] = str(i2, value2) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length2 = rep.length;
            for (i2 = 0; i2 < length2; i2 += 1) {
              k = rep[i2];
              if (typeof k === "string") {
                v = str(k, value2);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            for (k in value2) {
              if (Object.prototype.hasOwnProperty.call(value2, k)) {
                v = str(k, value2);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
        default:
      }
    }
    module.exports = function(value2, replacer, space) {
      var i2;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i2 = 0; i2 < space; i2 += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str("", { "": value2 });
    };
  }
});

// node_modules/jsonify/index.js
var require_jsonify = __commonJS({
  "node_modules/jsonify/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    exports.parse = require_parse();
    exports.stringify = require_stringify();
  }
});

// node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = __commonJS({
  "node_modules/json-stable-stringify/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var json = typeof JSON !== "undefined" ? JSON : require_jsonify();
    var isArray = Array.isArray || function(x) {
      return {}.toString.call(x) === "[object Array]";
    };
    var objectKeys = Object.keys || function(obj) {
      var has = Object.prototype.hasOwnProperty || function() {
        return true;
      };
      var keys = [];
      for (var key in obj) {
        if (has.call(obj, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    module.exports = function(obj, opts) {
      if (!opts) {
        opts = {};
      }
      if (typeof opts === "function") {
        opts = { cmp: opts };
      }
      var space = opts.space || "";
      if (typeof space === "number") {
        space = Array(space + 1).join(" ");
      }
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var replacer = opts.replacer || function(key, value2) {
        return value2;
      };
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify4(parent, key, node, level) {
        var indent = space ? "\n" + new Array(level + 1).join(space) : "";
        var colonSeparator = space ? ": " : ":";
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        node = replacer.call(parent, key, node);
        if (node === void 0) {
          return;
        }
        if (typeof node !== "object" || node === null) {
          return json.stringify(node);
        }
        if (isArray(node)) {
          var out = [];
          for (var i2 = 0; i2 < node.length; i2++) {
            var item = stringify4(node, i2, node[i2], level + 1) || json.stringify(null);
            out.push(indent + space + item);
          }
          return "[" + out.join(",") + indent + "]";
        }
        if (seen.indexOf(node) !== -1) {
          if (cycles) {
            return json.stringify("__cycle__");
          }
          throw new TypeError("Converting circular structure to JSON");
        } else {
          seen.push(node);
        }
        var keys = objectKeys(node).sort(cmp && cmp(node));
        var out = [];
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          var value2 = stringify4(node, key, node[key], level + 1);
          if (!value2) {
            continue;
          }
          var keyValue = json.stringify(key) + colonSeparator + value2;
          out.push(indent + space + keyValue);
        }
        seen.splice(seen.indexOf(node), 1);
        return "{" + out.join(",") + indent + "}";
      }({ "": obj }, "", obj, 0);
    };
  }
});

// node_modules/@toruslabs/metadata-helpers/node_modules/@toruslabs/eccrypto/browser.js
var require_browser3 = __commonJS({
  "node_modules/@toruslabs/metadata-helpers/node_modules/@toruslabs/eccrypto/browser.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var EC = require_elliptic().ec;
    var ec2 = new EC("secp256k1");
    var browserCrypto = globalThis.crypto || globalThis.msCrypto || {};
    var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    var nodeCrypto = require_crypto();
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var ZERO32 = Buffer.alloc(32, 0);
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failed");
      }
    }
    function isScalar(x) {
      return Buffer.isBuffer(x) && x.length === 32;
    }
    function isValidPrivateKey(privateKey) {
      if (!isScalar(privateKey)) {
        return false;
      }
      return privateKey.compare(ZERO32) > 0 && // > 0
      privateKey.compare(EC_GROUP_ORDER) < 0;
    }
    function equalConstTime(b1, b2) {
      if (b1.length !== b2.length) {
        return false;
      }
      var res = 0;
      for (var i2 = 0; i2 < b1.length; i2++) {
        res |= b1[i2] ^ b2[i2];
      }
      return res === 0;
    }
    function randomBytes(size) {
      var arr = new Uint8Array(size);
      if (typeof browserCrypto.getRandomValues === "undefined") {
        return Buffer.from(nodeCrypto.randomBytes(size));
      } else {
        browserCrypto.getRandomValues(arr);
      }
      return Buffer.from(arr);
    }
    function sha512(msg) {
      return new Promise(function(resolve) {
        var hash = nodeCrypto.createHash("sha512");
        var result = hash.update(msg).digest();
        resolve(new Uint8Array(result));
      });
    }
    function getAes(op) {
      return function(iv, key, data) {
        return new Promise(function(resolve) {
          if (subtle) {
            var importAlgorithm = { name: "AES-CBC" };
            var keyp = subtle.importKey("raw", key, importAlgorithm, false, [op]);
            return keyp.then(function(cryptoKey) {
              var encAlgorithm = { name: "AES-CBC", iv };
              return subtle[op](encAlgorithm, cryptoKey, data);
            }).then(function(result) {
              resolve(Buffer.from(new Uint8Array(result)));
            });
          } else {
            if (op === "encrypt") {
              var cipher = nodeCrypto.createCipheriv("aes-256-cbc", key, iv);
              let firstChunk = cipher.update(data);
              let secondChunk = cipher.final();
              resolve(Buffer.concat([firstChunk, secondChunk]));
            } else if (op === "decrypt") {
              var decipher = nodeCrypto.createDecipheriv("aes-256-cbc", key, iv);
              let firstChunk = decipher.update(data);
              let secondChunk = decipher.final();
              resolve(Buffer.concat([firstChunk, secondChunk]));
            }
          }
        });
      };
    }
    var aesCbcEncrypt = getAes("encrypt");
    var aesCbcDecrypt = getAes("decrypt");
    function hmacSha256Sign(key, msg) {
      return new Promise(function(resolve) {
        var hmac = nodeCrypto.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var result = hmac.digest();
        resolve(result);
      });
    }
    function hmacSha256Verify(key, msg, sig) {
      return new Promise(function(resolve) {
        var hmac = nodeCrypto.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var expectedSig = hmac.digest();
        resolve(equalConstTime(expectedSig, sig));
      });
    }
    exports.generatePrivate = function() {
      var privateKey = randomBytes(32);
      while (!isValidPrivateKey(privateKey)) {
        privateKey = randomBytes(32);
      }
      return privateKey;
    };
    var getPublic3 = exports.getPublic = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      return Buffer.from(ec2.keyFromPrivate(privateKey).getPublic("arr"));
    };
    var getPublicCompressed = exports.getPublicCompressed = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      let compressed = true;
      return Buffer.from(ec2.keyFromPrivate(privateKey).getPublic(compressed, "arr"));
    };
    exports.sign = function(privateKey, msg) {
      return new Promise(function(resolve) {
        assert(privateKey.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKey), "Bad private key");
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        resolve(Buffer.from(ec2.sign(msg, privateKey, { canonical: true }).toDER()));
      });
    };
    exports.verify = function(publicKey, msg, sig) {
      return new Promise(function(resolve, reject) {
        assert(publicKey.length === 65 || publicKey.length === 33, "Bad public key");
        if (publicKey.length === 65) {
          assert(publicKey[0] === 4, "Bad public key");
        }
        if (publicKey.length === 33) {
          assert(publicKey[0] === 2 || publicKey[0] === 3, "Bad public key");
        }
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        if (ec2.verify(msg, sig, publicKey)) {
          resolve(null);
        } else {
          reject(new Error("Bad signature"));
        }
      });
    };
    var deriveUnpadded = exports.derive = function(privateKeyA, publicKeyB) {
      return new Promise(function(resolve) {
        assert(Buffer.isBuffer(privateKeyA), "Bad private key");
        assert(Buffer.isBuffer(publicKeyB), "Bad public key");
        assert(privateKeyA.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKeyA), "Bad private key");
        assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
        if (publicKeyB.length === 65) {
          assert(publicKeyB[0] === 4, "Bad public key");
        }
        if (publicKeyB.length === 33) {
          assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
        }
        var keyA = ec2.keyFromPrivate(privateKeyA);
        var keyB = ec2.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic());
        resolve(Buffer.from(Px.toArray()));
      });
    };
    var derivePadded = exports.derivePadded = function(privateKeyA, publicKeyB) {
      return new Promise(function(resolve) {
        assert(Buffer.isBuffer(privateKeyA), "Bad private key");
        assert(Buffer.isBuffer(publicKeyB), "Bad public key");
        assert(privateKeyA.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKeyA), "Bad private key");
        assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
        if (publicKeyB.length === 65) {
          assert(publicKeyB[0] === 4, "Bad public key");
        }
        if (publicKeyB.length === 33) {
          assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
        }
        var keyA = ec2.keyFromPrivate(privateKeyA);
        var keyB = ec2.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic());
        resolve(Buffer.from(Px.toString(16, 64), "hex"));
      });
    };
    exports.encrypt = function(publicKeyTo, msg, opts) {
      opts = opts || {};
      var iv, ephemPublicKey, ciphertext, macKey;
      return new Promise(function(resolve) {
        var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        while (!isValidPrivateKey(ephemPrivateKey)) {
          ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        }
        ephemPublicKey = getPublic3(ephemPrivateKey);
        resolve(deriveUnpadded(ephemPrivateKey, publicKeyTo));
      }).then(function(Px) {
        return sha512(Px);
      }).then(function(hash) {
        iv = opts.iv || randomBytes(16);
        var encryptionKey = hash.slice(0, 32);
        macKey = hash.slice(32);
        return aesCbcEncrypt(iv, encryptionKey, msg);
      }).then(function(data) {
        ciphertext = data;
        var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
        return hmacSha256Sign(macKey, dataToMac);
      }).then(function(mac) {
        return {
          iv,
          ephemPublicKey,
          ciphertext,
          mac
        };
      });
    };
    var decrypt2 = function(privateKey, opts, padding = false) {
      var encryptionKey;
      const derive = padding ? derivePadded : deriveUnpadded;
      return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
        return sha512(Px);
      }).then(function(hash) {
        encryptionKey = hash.slice(0, 32);
        var macKey = hash.slice(32);
        var dataToMac = Buffer.concat([
          opts.iv,
          opts.ephemPublicKey,
          opts.ciphertext
        ]);
        return hmacSha256Verify(macKey, dataToMac, opts.mac);
      }).then(function(macGood) {
        if (!macGood && padding === false) {
          return decrypt2(privateKey, opts, true);
        } else if (!macGood && padding === true) {
          throw new Error("bad MAC after trying padded");
        }
        return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext).then(function(msg) {
          return Buffer.from(new Uint8Array(msg));
        });
      });
    };
    exports.decrypt = decrypt2;
  }
});

// node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js
function encParamsHexToBuf(encParamsHex) {
  return {
    iv: Buffer.from(encParamsHex.iv, "hex"),
    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, "hex"),
    ciphertext: Buffer.from(encParamsHex.ciphertext, "hex"),
    mac: Buffer.from(encParamsHex.mac, "hex")
  };
}
function encParamsBufToHex(encParams) {
  return {
    iv: Buffer.from(encParams.iv).toString("hex"),
    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString("hex"),
    ciphertext: Buffer.from(encParams.ciphertext).toString("hex"),
    mac: Buffer.from(encParams.mac).toString("hex")
  };
}
async function encryptData(privKeyHex, d) {
  const serializedDec = JSON.stringify(d);
  const serializedBuf = Buffer.from(serializedDec, "utf-8");
  const encParams = await (0, import_eccrypto.encrypt)((0, import_eccrypto.getPublic)(Buffer.from(privKeyHex, "hex")), serializedBuf);
  const encParamsHex = encParamsBufToHex(encParams);
  const sData = JSON.stringify(encParamsHex);
  return sData;
}
async function decryptData(privKeyHex, d) {
  const encParamsHex = JSON.parse(d);
  const encParams = encParamsHexToBuf(encParamsHex);
  const keyPair = ec.keyFromPrivate(privKeyHex);
  const serializedBuf = await (0, import_eccrypto.decrypt)(Buffer.from(keyPair.getPrivate().toString("hex", 64), "hex"), encParams);
  const serializedDec = serializedBuf.toString("utf-8");
  const data = JSON.parse(serializedDec);
  return data;
}
var import_json_stable_stringify, import_elliptic, import_keccak3, import_eccrypto, ec;
var init_metadataHelpers_esm = __esm({
  "node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    init_httpHelpers_esm2();
    import_json_stable_stringify = __toESM(require_json_stable_stringify());
    import_elliptic = __toESM(require_elliptic());
    import_keccak3 = __toESM(require_js());
    import_eccrypto = __toESM(require_browser3());
    ec = new import_elliptic.ec("secp256k1");
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/server.js
function keccak256(a) {
  return (0, import_keccak4.default)("keccak256").update(a).digest();
}
function storageKey2(channelName) {
  return KEY_PREFIX2 + channelName;
}
function postMessage4(channelState, messageJson) {
  return new Promise(function(res, rej) {
    sleep().then(_asyncToGenerator(import_regenerator3.default.mark(function _callee() {
      var key, channelEncPrivKey, encData, body;
      return import_regenerator3.default.wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              key = storageKey2(channelState.channelName);
              channelEncPrivKey = keccak256(key);
              _context.next = 4;
              return encryptData(channelEncPrivKey.toString("hex"), {
                token: randomToken(),
                time: (/* @__PURE__ */ new Date()).getTime(),
                data: messageJson,
                uuid: channelState.uuid
              });
            case 4:
              encData = _context.sent;
              _context.t0 = (0, import_eccrypto2.getPublic)(channelEncPrivKey).toString("hex");
              _context.t1 = encData;
              _context.next = 9;
              return (0, import_eccrypto2.sign)(channelEncPrivKey, keccak256(encData));
            case 9:
              _context.t2 = _context.sent.toString("hex");
              body = {
                key: _context.t0,
                data: _context.t1,
                signature: _context.t2
              };
              if (channelState.timeout)
                body.timeout = channelState.timeout;
              return _context.abrupt("return", fetch(channelState.serverUrl + "/channel/set", {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                  "Content-Type": "application/json; charset=utf-8"
                }
              }).then(res)["catch"](rej));
            case 13:
            case "end":
              return _context.stop();
          }
      }, _callee);
    })));
  });
}
function getSocketInstance(serverUrl) {
  if (SOCKET_CONN_INSTANCE) {
    return SOCKET_CONN_INSTANCE;
  }
  var SOCKET_CONN = lookup2(serverUrl, {
    transports: ["websocket", "polling"],
    // use WebSocket first, if available
    withCredentials: true,
    reconnectionDelayMax: 1e4,
    reconnectionAttempts: 10
  });
  SOCKET_CONN.on("connect_error", function(err) {
    SOCKET_CONN.io.opts.transports = ["polling", "websocket"];
    log3.error("connect error", err);
  });
  SOCKET_CONN.on("connect", _asyncToGenerator(import_regenerator3.default.mark(function _callee2() {
    var engine;
    return import_regenerator3.default.wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            engine = SOCKET_CONN.io.engine;
            log3.debug("initially connected to", engine.transport.name);
            engine.once("upgrade", function() {
              log3.debug("upgraded", engine.transport.name);
            });
            engine.once("close", function(reason) {
              log3.debug("connection closed", reason);
            });
          case 4:
          case "end":
            return _context2.stop();
        }
    }, _callee2);
  })));
  SOCKET_CONN.on("error", function(err) {
    log3.error("socket errored", err);
    SOCKET_CONN.disconnect();
  });
  SOCKET_CONN_INSTANCE = SOCKET_CONN;
  return SOCKET_CONN;
}
function setupSocketConnection(serverUrl, channelName, fn) {
  var socketConn = getSocketInstance(serverUrl);
  var key = storageKey2(channelName);
  var channelEncPrivKey = keccak256(key);
  var channelPubKey = (0, import_eccrypto2.getPublic)(channelEncPrivKey).toString("hex");
  if (socketConn.connected) {
    socketConn.emit("check_auth_status", channelPubKey);
  } else {
    socketConn.once("connect", function() {
      log3.debug("connected with socket");
      socketConn.emit("check_auth_status", channelPubKey);
    });
  }
  var reconnect = function reconnect2() {
    socketConn.once("connect", _asyncToGenerator(import_regenerator3.default.mark(function _callee3() {
      return import_regenerator3.default.wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              socketConn.emit("check_auth_status", channelPubKey);
            case 1:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    })));
  };
  var visibilityListener = function visibilityListener2() {
    if (!socketConn) {
      document.removeEventListener("visibilitychange", visibilityListener2);
      return;
    }
    if (!socketConn.connected && document.visibilityState === "visible") {
      reconnect();
    }
  };
  var listener = function() {
    var _ref4 = _asyncToGenerator(import_regenerator3.default.mark(function _callee4(ev) {
      var decData;
      return import_regenerator3.default.wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return decryptData(channelEncPrivKey.toString("hex"), ev);
            case 3:
              decData = _context4.sent;
              log3.info(decData);
              fn(decData);
              _context4.next = 11;
              break;
            case 8:
              _context4.prev = 8;
              _context4.t0 = _context4["catch"](0);
              log3.error(_context4.t0);
            case 11:
            case "end":
              return _context4.stop();
          }
      }, _callee4, null, [[0, 8]]);
    }));
    return function listener2(_x) {
      return _ref4.apply(this, arguments);
    };
  }();
  socketConn.on("disconnect", function() {
    log3.debug("socket disconnected");
    if (runningChannels.has(channelName)) {
      log3.error("socket disconnected unexpectedly, reconnecting socket");
      reconnect();
    }
  });
  socketConn.on(channelPubKey + "_success", listener);
  if (typeof document !== "undefined")
    document.addEventListener("visibilitychange", visibilityListener);
  return socketConn;
}
function create4(channelName, options) {
  options = fillOptionsWithDefaults(options);
  if (!canBeUsed4(options)) {
    throw new Error("BroadcastChannel: server cannot be used");
  }
  var uuid = randomToken();
  var eMIs = new ObliviousSet(options.server.removeTimeout);
  var state = {
    channelName,
    uuid,
    eMIs,
    // emittedMessagesIds
    serverUrl: options.server.url
  };
  if (options.server.timeout)
    state.timeout = options.server.timeout;
  setupSocketConnection(options.server.url, channelName, function(msgObj) {
    if (!state.messagesCallback)
      return;
    if (msgObj.uuid === state.uuid)
      return;
    if (!msgObj.token || state.eMIs.has(msgObj.token))
      return;
    state.eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  runningChannels.add(channelName);
  return state;
}
function close4(channelState) {
  runningChannels["delete"](channelState.channelName);
}
function onMessage4(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed4() {
  return true;
}
function averageResponseTime4() {
  var defaultTime = 500;
  return defaultTime;
}
var import_regenerator3, import_eccrypto2, import_keccak4, microSeconds5, KEY_PREFIX2, type4, SOCKET_CONN_INSTANCE, runningChannels, server_default;
var init_server = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/server.js"() {
    init_process();
    init_buffer();
    init_asyncToGenerator();
    import_regenerator3 = __toESM(require_regenerator());
    init_es();
    init_esm4();
    import_eccrypto2 = __toESM(require_browser2());
    init_metadataHelpers_esm();
    import_keccak4 = __toESM(require_js());
    init_util();
    init_options();
    init_util();
    microSeconds5 = microSeconds;
    KEY_PREFIX2 = "pubkey.broadcastChannel-";
    type4 = "server";
    SOCKET_CONN_INSTANCE = null;
    runningChannels = /* @__PURE__ */ new Set();
    server_default = {
      create: create4,
      close: close4,
      onMessage: onMessage4,
      postMessage: postMessage4,
      canBeUsed: canBeUsed4,
      type: type4,
      averageResponseTime: averageResponseTime4,
      microSeconds: microSeconds5
    };
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/simulate.js
function create5(channelName) {
  var state = {
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close5(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
function postMessage5(channelState, messageJson) {
  return new Promise(function(res) {
    return setTimeout(function() {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.filter(function(channel) {
        return channel.name === channelState.name;
      }).filter(function(channel) {
        return channel !== channelState;
      }).filter(function(channel) {
        return !!channel.messagesCallback;
      }).forEach(function(channel) {
        return channel.messagesCallback(messageJson);
      });
      res();
    }, 5);
  });
}
function onMessage5(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed5() {
  return true;
}
function averageResponseTime5() {
  return 5;
}
var microSeconds6, type5, SIMULATE_CHANNELS, simulate_default;
var init_simulate = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/simulate.js"() {
    init_process();
    init_buffer();
    init_util();
    microSeconds6 = microSeconds;
    type5 = "simulate";
    SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
    simulate_default = {
      create: create5,
      close: close5,
      onMessage: onMessage5,
      postMessage: postMessage5,
      canBeUsed: canBeUsed5,
      type: type5,
      averageResponseTime: averageResponseTime5,
      microSeconds: microSeconds6
    };
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/method-chooser.js
function chooseMethod(options) {
  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
  if (options.type) {
    if (options.type === "simulate") {
      return simulate_default;
    }
    var ret = chooseMethods.find(function(m) {
      return m.type === options.type;
    });
    if (!ret)
      throw new Error("method-type " + options.type + " not found");
    else
      return ret;
  }
  if (!options.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function(m) {
      return m.type !== "idb";
    });
  }
  var useMethod = chooseMethods.find(function(method) {
    return method.canBeUsed(options);
  });
  if (!useMethod)
    throw new Error("No useable method found in " + JSON.stringify(METHODS.map(function(m) {
      return m.type;
    })));
  else
    return useMethod;
}
var METHODS;
var init_method_chooser = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/method-chooser.js"() {
    init_process();
    init_buffer();
    init_native();
    init_indexed_db();
    init_localstorage();
    init_server();
    init_simulate();
    METHODS = [
      native_default,
      // fastest
      indexed_db_default,
      localstorage_default,
      server_default
    ];
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/broadcast-channel.js
function _post(broadcastChannel, type6, msg) {
  var time = broadcastChannel.method.microSeconds();
  var msgObj = {
    time,
    type: type6,
    data: msg
  };
  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function() {
    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
    broadcastChannel._uMP.add(sendPromise);
    sendPromise["catch"]().then(function() {
      return broadcastChannel._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if (isPromise(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function(s) {
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0)
    return true;
  if (channel._addEL.internal.length > 0)
    return true;
  return false;
}
function _addListenerObject(channel, type6, obj) {
  channel._addEL[type6].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type6, obj) {
  channel._addEL[type6] = channel._addEL[type6].filter(function(o2) {
    return o2 !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    var listenerFn = function listenerFn2(msgObj) {
      channel._addEL[msgObj.type].forEach(function(listenerObject) {
        var hundredMsInMicro = 100 * 1e3;
        var minMessageTime = listenerObject.time - hundredMsInMicro;
        if (msgObj.time >= minMessageTime) {
          listenerObject.fn(msgObj.data);
        } else if (channel.method.type === "server") {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function() {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    var time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}
var OPEN_BROADCAST_CHANNELS, lastId, BroadcastChannel2, ENFORCED_OPTIONS;
var init_broadcast_channel = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/broadcast-channel.js"() {
    init_process();
    init_buffer();
    init_util();
    init_method_chooser();
    init_options();
    OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
    lastId = 0;
    BroadcastChannel2 = function BroadcastChannel3(name, options) {
      this.id = lastId++;
      OPEN_BROADCAST_CHANNELS.add(this);
      this.name = name;
      if (ENFORCED_OPTIONS) {
        options = ENFORCED_OPTIONS;
      }
      this.options = fillOptionsWithDefaults(options);
      this.method = chooseMethod(this.options);
      this._iL = false;
      this._onML = null;
      this._addEL = {
        message: [],
        internal: []
      };
      this._uMP = /* @__PURE__ */ new Set();
      this._befC = [];
      this._prepP = null;
      _prepareChannel(this);
    };
    BroadcastChannel2._pubkey = true;
    BroadcastChannel2.prototype = {
      postMessage: function postMessage6(msg) {
        if (this.closed) {
          throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
           * In the past when this error appeared, it was realy hard to debug.
           * So now we log the msg together with the error so it at least
           * gives some clue about where in your application this happens.
           */
          JSON.stringify(msg));
        }
        return _post(this, "message", msg);
      },
      postInternal: function postInternal(msg) {
        return _post(this, "internal", msg);
      },
      set onmessage(fn) {
        var time = this.method.microSeconds();
        var listenObj = {
          time,
          fn
        };
        _removeListenerObject(this, "message", this._onML);
        if (fn && typeof fn === "function") {
          this._onML = listenObj;
          _addListenerObject(this, "message", listenObj);
        } else {
          this._onML = null;
        }
      },
      addEventListener: function addEventListener2(type6, fn) {
        var time = this.method.microSeconds();
        var listenObj = {
          time,
          fn
        };
        _addListenerObject(this, type6, listenObj);
      },
      removeEventListener: function removeEventListener2(type6, fn) {
        var obj = this._addEL[type6].find(function(obj2) {
          return obj2.fn === fn;
        });
        _removeListenerObject(this, type6, obj);
      },
      close: function close6() {
        var _this = this;
        if (this.closed) {
          return;
        }
        OPEN_BROADCAST_CHANNELS["delete"](this);
        this.closed = true;
        var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
        this._onML = null;
        this._addEL.message = [];
        return awaitPrepare.then(function() {
          return Promise.all(Array.from(_this._uMP));
        }).then(function() {
          return Promise.all(_this._befC.map(function(fn) {
            return fn();
          }));
        }).then(function() {
          return _this.method.close(_this._state);
        });
      },
      get type() {
        return this.method.type;
      },
      get isClosed() {
        return this.closed;
      }
    };
  }
});

// node_modules/@toruslabs/broadcast-channel/dist/esbrowser/index.js
var init_esbrowser = __esm({
  "node_modules/@toruslabs/broadcast-channel/dist/esbrowser/index.js"() {
    init_process();
    init_buffer();
    init_broadcast_channel();
  }
});

// node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
var import_lodash3, import_loglevel5, log5;
var init_httpHelpers_esm3 = __esm({
  "node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    import_lodash3 = __toESM(require_lodash2());
    import_loglevel5 = __toESM(require_loglevel());
    log5 = import_loglevel5.default.getLogger("http-helpers");
    log5.setLevel(import_loglevel5.levels.INFO);
  }
});

// node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getRawListeners(eventEmitter, name) {
  return typeof eventEmitter.rawListeners !== "undefined" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);
}
function createEventEmitterProxy(initialTarget, opts) {
  const finalOpts = opts || {};
  let eventFilter = finalOpts.eventFilter || filterNoop;
  if (typeof eventFilter === "string" && eventFilter === "skipInternal")
    eventFilter = externalEventFilter;
  if (typeof eventFilter !== "function")
    throw new Error("createEventEmitterProxy - Invalid eventFilter");
  let target = initialTarget;
  let setTarget = (newTarget) => {
    const oldTarget = target;
    target = newTarget;
    oldTarget.eventNames().filter(eventFilter).forEach((name) => {
      getRawListeners(oldTarget, name).forEach((handler) => newTarget.on(name, handler));
    });
    oldTarget.removeAllListeners();
  };
  const proxy = new Proxy({}, {
    get: (_, name) => {
      if (name === "setTarget")
        return setTarget;
      return target[name];
    },
    set: (_, name, value2) => {
      if (name === "setTarget") {
        setTarget = value2;
        return true;
      }
      target[name] = value2;
      return true;
    }
  });
  return proxy;
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function providerFromEngine(engine) {
  const provider = new SafeEventEmitter2();
  provider.sendAsync = async (req) => {
    const res = await engine.handle(req);
    if (res.error) {
      var _res$error, _res$error2;
      const err = (0, import_eth_rpc_errors3.serializeError)(res.error, {
        fallbackError: {
          message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),
          code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603
        }
      });
      throw import_eth_rpc_errors3.ethErrors.rpc.internal(err);
    }
    return res.result;
  };
  provider.send = (req, callback) => {
    if (typeof callback !== "function") {
      throw new Error('Must provide callback to "send" method.');
    }
    engine.handle(req, callback);
  };
  if (engine.on) {
    engine.on("notification", (message) => {
      provider.emit("data", null, message);
    });
  }
  provider.request = async (args) => {
    const req = _objectSpread$2(_objectSpread$2({}, args), {}, {
      id: createRandomId(),
      jsonrpc: "2.0"
    });
    const res = await provider.sendAsync(req);
    return res;
  };
  return provider;
}
function padWithZeroes(hexString, targetLength) {
  if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
    throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
  }
  if (targetLength < 0) {
    throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
  }
  return String.prototype.padStart.call(hexString, targetLength, "0");
}
function concatSig(v, r2, s) {
  const rSig = (0, import_util14.fromSigned)(r2);
  const sSig = (0, import_util14.fromSigned)(s);
  const vSig = (0, import_util14.bufferToBigInt)(v);
  const rStr = padWithZeroes((0, import_util14.toUnsigned)(rSig).toString("hex"), 64);
  const sStr = padWithZeroes((0, import_util14.toUnsigned)(sSig).toString("hex"), 64);
  const vStr = (0, import_util14.stripHexPrefix)((0, import_util14.bigIntToHex)(vSig));
  return (0, import_util14.addHexPrefix)(rStr.concat(sStr, vStr));
}
function checkForHttpErrors(fetchRes) {
  switch (fetchRes.status) {
    case 405:
      throw import_eth_rpc_errors3.ethErrors.rpc.methodNotFound();
    case 418:
      throw import_eth_rpc_errors3.ethErrors.rpc.internal({
        message: `Request is being rate limited.`
      });
    case 503:
    case 504:
      throw import_eth_rpc_errors3.ethErrors.rpc.internal({
        message: `Gateway timeout. The request took too long to process.This can happen when querying over too wide a block range.`
      });
  }
}
function timeout(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function parseResponse(fetchRes, body) {
  if (fetchRes.status !== 200) {
    throw import_eth_rpc_errors3.ethErrors.rpc.internal({
      message: `Non-200 status code: '${fetchRes.status}'`,
      data: body
    });
  }
  if (body.error) {
    throw import_eth_rpc_errors3.ethErrors.rpc.internal({
      data: body.error
    });
  }
  return body.result;
}
function createFetchConfigFromReq(_ref) {
  let {
    req,
    rpcTarget,
    originHttpHeaderKey
  } = _ref;
  const parsedUrl = new URL(rpcTarget);
  const payload = {
    id: req.id,
    jsonrpc: req.jsonrpc,
    method: req.method,
    params: req.params
  };
  const originDomain = req.origin;
  const serializedPayload = JSON.stringify(payload);
  const fetchParams = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: serializedPayload
  };
  if (originHttpHeaderKey && originDomain) {
    fetchParams.headers[originHttpHeaderKey] = originDomain;
  }
  return {
    fetchUrl: parsedUrl.href,
    fetchParams
  };
}
function createFetchMiddleware(_ref2) {
  let {
    rpcTarget,
    originHttpHeaderKey
  } = _ref2;
  return createAsyncMiddleware2(async (req, res, _next) => {
    const {
      fetchUrl,
      fetchParams
    } = createFetchConfigFromReq({
      req,
      rpcTarget,
      originHttpHeaderKey
    });
    const maxAttempts = 5;
    const retryInterval = 1e3;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const fetchRes = await fetch(fetchUrl, fetchParams);
        checkForHttpErrors(fetchRes);
        const fetchBody = await fetchRes.json();
        const result = parseResponse(fetchRes, fetchBody);
        res.result = result;
        return;
      } catch (err) {
        const errMsg = err.toString();
        const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
        if (!isRetriable) {
          throw err;
        }
      }
      await timeout(retryInterval);
    }
  });
}
var import_eth_rpc_errors3, import_json_rpc_random_id, import_util14, import_loglevel6, import_lodash4, BaseController, filterNoop, internalEvents, externalEventFilter, createRandomId, LOGIN_PROVIDER, signMessage, RETRIABLE_ERRORS, ACCOUNT_CATEGORY, DEFAULT_INTERVAL, DEFAULT_PREFERENCES, TransactionStatus;
var init_baseControllers_esm = __esm({
  "node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js"() {
    init_process();
    init_buffer();
    init_defineProperty();
    init_openloginJrpc_esm2();
    import_eth_rpc_errors3 = __toESM(require_dist4());
    import_json_rpc_random_id = __toESM(require_json_rpc_random_id());
    import_util14 = __toESM(require_dist3());
    init_bignumber();
    import_loglevel6 = __toESM(require_loglevel());
    init_esbrowser();
    init_httpHelpers_esm3();
    init_bowser();
    import_lodash4 = __toESM(require_lodash());
    BaseController = class extends SafeEventEmitter2 {
      /**
       * Default options used to configure this controller
       */
      /**
       * Default state set on this controller
       */
      /**
       * Determines if listeners are notified of state changes
       */
      /**
       * Name of this controller used during composition
       */
      /**
       * Creates a BaseController instance. Both initial state and initial
       * configuration options are merged with defaults upon initialization.
       *
       * @param config - Initial options used to configure this controller
       * @param state - Initial state to set on this controller
       */
      constructor(_ref) {
        let {
          config = {},
          state = {}
        } = _ref;
        super();
        _defineProperty(this, "defaultConfig", {});
        _defineProperty(this, "defaultState", {});
        _defineProperty(this, "disabled", false);
        _defineProperty(this, "name", "BaseController");
        _defineProperty(this, "initialConfig", void 0);
        _defineProperty(this, "initialState", void 0);
        _defineProperty(this, "internalConfig", this.defaultConfig);
        _defineProperty(this, "internalState", this.defaultState);
        this.initialState = state;
        this.initialConfig = config;
      }
      /**
       * Retrieves current controller configuration options
       *
       * @returns - Current configuration
       */
      get config() {
        return this.internalConfig;
      }
      /**
       * Retrieves current controller state
       *
       * @returns - Current state
       */
      get state() {
        return this.internalState;
      }
      /**
       * Updates controller configuration
       *
       * @param config - New configuration options
       * @param overwrite - Overwrite config instead of merging
       * @param fullUpdate - Boolean that defines if the update is partial or not
       */
      configure(config) {
        let overwrite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        let fullUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        if (fullUpdate) {
          this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);
          for (const key in this.internalConfig) {
            if (typeof this.internalConfig[key] !== "undefined") {
              this[key] = this.internalConfig[key];
            }
          }
        } else {
          for (const key in config) {
            if (typeof this.internalConfig[key] !== "undefined") {
              this.internalConfig[key] = config[key];
              this[key] = config[key];
            }
          }
        }
      }
      /**
       * Updates controller state
       *
       * @param state - New state
       * @param overwrite - Overwrite state instead of merging
       */
      update(state) {
        let overwrite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);
        this.emit("store", this.internalState);
      }
      /**
       * Enables the controller. This sets each config option as a member
       * variable on this instance and triggers any defined setters. This
       * also sets initial state and triggers any listeners.
       *
       * @returns - This controller instance
       */
      initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
      }
    };
    filterNoop = () => true;
    internalEvents = ["newListener", "removeListener"];
    externalEventFilter = (name) => !internalEvents.includes(name);
    createRandomId = (0, import_json_rpc_random_id.default)();
    LOGIN_PROVIDER = {
      GOOGLE: "google",
      FACEBOOK: "facebook",
      REDDIT: "reddit",
      DISCORD: "discord",
      TWITCH: "twitch",
      APPLE: "apple",
      LINE: "line",
      GITHUB: "github",
      KAKAO: "kakao",
      LINKEDIN: "linkedin",
      TWITTER: "twitter",
      WEIBO: "weibo",
      WECHAT: "wechat",
      EMAIL_PASSWORDLESS: "email_passwordless"
    };
    signMessage = (privateKey, data) => {
      const privKey = Buffer.from(privateKey, "hex");
      const message = (0, import_util14.stripHexPrefix)(data);
      const msgSig = (0, import_util14.ecsign)(Buffer.from(message, "hex"), privKey);
      const rawMsgSig = concatSig((0, import_util14.bigIntToBuffer)(msgSig.v), msgSig.r, msgSig.s);
      return rawMsgSig;
    };
    RETRIABLE_ERRORS = [
      // ignore server overload errors
      "Gateway timeout",
      "ETIMEDOUT",
      // ignore server sent html error pages
      // or truncated json responses
      "failed to parse response body",
      // ignore errors where http req failed to establish
      "Failed to fetch"
    ];
    ACCOUNT_CATEGORY = {
      NORMAL: "normal",
      THRESHOLD: "threshold",
      IMPORTED: "imported"
    };
    DEFAULT_INTERVAL = 180 * 1e3;
    DEFAULT_PREFERENCES = {
      selectedCurrency: "USD",
      theme: "dark",
      locale: "en-US",
      accountType: ACCOUNT_CATEGORY.NORMAL,
      contacts: [],
      jwtToken: "",
      fetchedPastTx: [],
      pastTransactions: [],
      paymentTx: [],
      defaultPublicAddress: "",
      customTokens: [],
      customNfts: [],
      crashReport: true,
      userInfo: {
        aggregateVerifier: "",
        email: "",
        name: "",
        profileImage: "",
        typeOfLogin: LOGIN_PROVIDER.GOOGLE,
        verifier: "",
        verifierId: ""
      }
    };
    (function(TransactionStatus2) {
      TransactionStatus2["approved"] = "approved";
      TransactionStatus2["cancelled"] = "cancelled";
      TransactionStatus2["confirmed"] = "confirmed";
      TransactionStatus2["failed"] = "failed";
      TransactionStatus2["finalized"] = "finalized";
      TransactionStatus2["processed"] = "processed";
      TransactionStatus2["rejected"] = "rejected";
      TransactionStatus2["signed"] = "signed";
      TransactionStatus2["submitted"] = "submitted";
      TransactionStatus2["unapproved"] = "unapproved";
      TransactionStatus2["dropped"] = "dropped";
      TransactionStatus2["expired"] = "expired";
    })(TransactionStatus || (TransactionStatus = {}));
  }
});

// node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/classes.js
var require_classes3 = __commonJS({
  "node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_, value2) {
      if (value2 === "[Circular]") {
        return void 0;
      }
      return value2;
    }
  }
});

// node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants3 = __commonJS({
  "node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/utils.js
var require_utils7 = __commonJS({
  "node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants3();
    var classes_1 = require_classes3();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError4(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError4;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/errors.js
var require_errors3 = __commonJS({
  "node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes3();
    var utils_1 = require_utils7();
    var error_constants_1 = require_error_constants3();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@web3auth/base-provider/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes3();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils7();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors3();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants3();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@web3auth/base-provider/dist/baseProvider.esm.js
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var import_eth_rpc_errors4, import_regenerator4, import_json_rpc_random_id2, BaseProvider, CommonPrivateKeyProvider, createRandomId2;
var init_baseProvider_esm = __esm({
  "node_modules/@web3auth/base-provider/dist/baseProvider.esm.js"() {
    init_process();
    init_buffer();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_get();
    init_getPrototypeOf();
    init_defineProperty();
    init_baseControllers_esm();
    init_base_esm();
    import_eth_rpc_errors4 = __toESM(require_dist5());
    init_asyncToGenerator();
    import_regenerator4 = __toESM(require_regenerator());
    init_openloginJrpc_esm();
    import_json_rpc_random_id2 = __toESM(require_json_rpc_random_id());
    BaseProvider = function(_BaseController) {
      _inherits(BaseProvider2, _BaseController);
      var _super = _createSuper4(BaseProvider2);
      function BaseProvider2(_ref) {
        var _thisSuper, _this;
        var config = _ref.config, state = _ref.state;
        _classCallCheck(this, BaseProvider2);
        _this = _super.call(this, {
          config,
          state
        });
        _defineProperty(_assertThisInitialized(_this), "_providerEngineProxy", null);
        if (!config.chainConfig)
          throw WalletInitializationError.invalidProviderConfigError("Please provide chainConfig");
        if (!config.chainConfig.chainId)
          throw WalletInitializationError.invalidProviderConfigError("Please provide chainId inside chainConfig");
        if (!config.chainConfig.rpcTarget)
          throw WalletInitializationError.invalidProviderConfigError("Please provide rpcTarget inside chainConfig");
        _this.defaultState = {
          chainId: "loading"
        };
        _this.defaultConfig = {
          chainConfig: config.chainConfig,
          networks: _defineProperty({}, config.chainConfig.chainId, config.chainConfig)
        };
        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(BaseProvider2.prototype)), "initialize", _thisSuper).call(_thisSuper);
        return _this;
      }
      _createClass(BaseProvider2, [{
        key: "provider",
        get: function get2() {
          return this._providerEngineProxy;
        },
        set: function set(_) {
          throw new Error("Method not implemented.");
        }
      }, {
        key: "addChain",
        value: function addChain(chainConfig) {
          if (!chainConfig.chainId)
            throw import_eth_rpc_errors4.ethErrors.rpc.invalidParams("chainId is required");
          if (!chainConfig.rpcTarget)
            throw import_eth_rpc_errors4.ethErrors.rpc.invalidParams("chainId is required");
          this.configure({
            networks: _objectSpread4(_objectSpread4({}, this.config.networks), {}, _defineProperty({}, chainConfig.chainId, chainConfig))
          });
        }
      }, {
        key: "getChainConfig",
        value: function getChainConfig3(chainId) {
          var _this$config$networks;
          var chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];
          if (!chainConfig)
            throw import_eth_rpc_errors4.ethErrors.rpc.invalidRequest("Chain ".concat(chainId, " is not supported, please add chainConfig for it"));
          return chainConfig;
        }
      }, {
        key: "getProviderEngineProxy",
        value: function getProviderEngineProxy() {
          return this._providerEngineProxy;
        }
      }, {
        key: "updateProviderEngineProxy",
        value: function updateProviderEngineProxy(providerEngineProxy) {
          if (this._providerEngineProxy) {
            this._providerEngineProxy.setTarget(providerEngineProxy);
          } else {
            this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);
          }
        }
      }]);
      return BaseProvider2;
    }(BaseController);
    CommonPrivateKeyProvider = function() {
      function CommonPrivateKeyProvider2() {
        _classCallCheck(this, CommonPrivateKeyProvider2);
        _defineProperty(this, "_providerEngineProxy", null);
      }
      _createClass(CommonPrivateKeyProvider2, [{
        key: "provider",
        get: function get2() {
          return this._providerEngineProxy;
        },
        set: function set(_) {
          throw new Error("Method not implemented.");
        }
      }, {
        key: "addChain",
        value: function addChain(_) {
          throw new Error("Method not implemented.");
        }
      }, {
        key: "setupProvider",
        value: function() {
          var _setupProvider = _asyncToGenerator(import_regenerator4.default.mark(function _callee(privKey) {
            var privKeyMiddleware, engine, provider;
            return import_regenerator4.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    privKeyMiddleware = this.getPrivKeyMiddleware(privKey);
                    engine = new JRPCEngine();
                    engine.push(privKeyMiddleware);
                    provider = providerFromEngine(engine);
                    this.updateProviderEngineProxy(provider);
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function setupProvider(_x) {
            return _setupProvider.apply(this, arguments);
          }
          return setupProvider;
        }()
      }, {
        key: "switchChain",
        value: function() {
          var _switchChain = _asyncToGenerator(import_regenerator4.default.mark(function _callee2(_) {
            return import_regenerator4.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", Promise.resolve());
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          function switchChain(_x2) {
            return _switchChain.apply(this, arguments);
          }
          return switchChain;
        }()
      }, {
        key: "getProviderEngineProxy",
        value: function getProviderEngineProxy() {
          return this._providerEngineProxy;
        }
      }, {
        key: "updateProviderEngineProxy",
        value: function updateProviderEngineProxy(providerEngineProxy) {
          if (this._providerEngineProxy) {
            this._providerEngineProxy.setTarget(providerEngineProxy);
          } else {
            this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);
          }
        }
      }, {
        key: "getPrivKeyMiddleware",
        value: function getPrivKeyMiddleware(privKey) {
          var middleware = {
            getPrivatekey: function() {
              var _getPrivatekey = _asyncToGenerator(import_regenerator4.default.mark(function _callee3() {
                return import_regenerator4.default.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        return _context3.abrupt("return", privKey);
                      case 1:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));
              function getPrivatekey() {
                return _getPrivatekey.apply(this, arguments);
              }
              return getPrivatekey;
            }()
          };
          return this.createPrivKeyMiddleware(middleware);
        }
      }, {
        key: "createPrivKeyMiddleware",
        value: function createPrivKeyMiddleware(_ref) {
          var getPrivatekey = _ref.getPrivatekey;
          function getPrivatekeyHandler(_x3, _x4) {
            return _getPrivatekeyHandler.apply(this, arguments);
          }
          function _getPrivatekeyHandler() {
            _getPrivatekeyHandler = _asyncToGenerator(import_regenerator4.default.mark(function _callee4(_, res) {
              return import_regenerator4.default.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return getPrivatekey();
                    case 2:
                      res.result = _context4.sent;
                    case 3:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));
            return _getPrivatekeyHandler.apply(this, arguments);
          }
          return createScaffoldMiddleware({
            private_key: createAsyncMiddleware(getPrivatekeyHandler)
          });
        }
      }]);
      return CommonPrivateKeyProvider2;
    }();
    _defineProperty(CommonPrivateKeyProvider, "getProviderInstance", function() {
      var _ref2 = _asyncToGenerator(import_regenerator4.default.mark(function _callee5(params) {
        var providerFactory;
        return import_regenerator4.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                providerFactory = new CommonPrivateKeyProvider();
                _context5.next = 3;
                return providerFactory.setupProvider(params.privKey);
              case 3:
                return _context5.abrupt("return", providerFactory);
              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return function(_x5) {
        return _ref2.apply(this, arguments);
      };
    }());
    createRandomId2 = (0, import_json_rpc_random_id2.default)();
  }
});

export {
  _asyncToGenerator,
  init_asyncToGenerator,
  _classCallCheck,
  init_classCallCheck,
  _typeof,
  init_typeof,
  _createClass,
  init_createClass,
  _assertThisInitialized,
  init_assertThisInitialized,
  _inherits,
  init_inherits,
  _possibleConstructorReturn,
  init_possibleConstructorReturn,
  _getPrototypeOf,
  init_getPrototypeOf,
  _defineProperty,
  init_defineProperty,
  require_typeof,
  require_regenerator,
  _get,
  init_get,
  randomId,
  base64url,
  safeatob,
  keccak,
  jsonToBase64,
  init_openloginUtils_esm,
  require_fast_safe_stringify,
  _slicedToArray,
  init_slicedToArray,
  require_pump,
  SafeEventEmitter,
  getRpcPromiseCallback,
  createStreamMiddleware,
  createScaffoldMiddleware,
  createIdRemapMiddleware,
  createAsyncMiddleware,
  JRPCEngine,
  mergeMiddleware,
  setupMultiplex,
  PostMessageStream,
  init_openloginJrpc_esm,
  require_lodash2 as require_lodash,
  require_loglevel,
  CHAIN_NAMESPACES,
  ADAPTER_NAMESPACES,
  getChainConfig,
  Web3AuthError,
  WalletInitializationError,
  WalletLoginError,
  WALLET_ADAPTERS,
  ADAPTER_CATEGORY,
  ADAPTER_STATUS,
  ADAPTER_EVENTS,
  BaseAdapter,
  log2 as log,
  storageAvailable,
  isHexStrict,
  checkIfTokenIsExpired,
  signChallenge,
  verifySignedChallenge,
  getSavedToken,
  saveToken,
  clearToken,
  base_esm_exports,
  init_base_esm,
  require_dist2 as require_dist,
  require_url,
  require_dist3 as require_dist2,
  BigNumber,
  bignumber_default,
  init_bignumber,
  providerFromEngine,
  signMessage,
  createFetchMiddleware,
  init_baseControllers_esm,
  BaseProvider,
  CommonPrivateKeyProvider,
  init_baseProvider_esm
};
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

bowser/src/bowser.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=chunk-FEAYSPVD.js.map
