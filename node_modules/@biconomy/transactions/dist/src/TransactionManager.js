"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_types_1 = require("@biconomy/core-types");
const Estimator_1 = require("./Estimator");
const common_1 = require("@biconomy/common");
const Utils_1 = require("./Utils");
class TransactionManager {
    constructor(smartAccountState) {
        this.smartAccountState = smartAccountState;
        this.utils = new Utils_1.Utils();
    }
    // smart account config and context
    async initialize(relayer, nodeClient, contractUtils) {
        // Note: smart account is state specific so we may end up using chain specific transaction managers as discussed.
        this.nodeClient = nodeClient;
        // this.nodeClient = new NodeClient({ txServiceUrl: config.backendUrl })
        this.contractUtils = contractUtils;
        this.relayer = relayer;
        // estimator init
        this.estimator = new Estimator_1.Estimator(this.nodeClient, this.contractUtils);
    }
    setRelayer(relayer) {
        this.relayer = relayer;
        return this;
    }
    getContractUtilInstance() {
        return this.contractUtils;
    }
    getEstimatorInstance() {
        return this.estimator;
    }
    // review return type
    getNodeClient() {
        return this.nodeClient;
    }
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is without fee refund (gasless)
     * @param transactionDto
     * @returns
     */
    async createTransaction(transactionDto) {
        const { transaction, chainId, version } = transactionDto;
        const batchId = 1; // fixed nonce space for forward
        const multiSendContract = this.contractUtils.multiSendContract[chainId][version].getContract();
        const isDelegate = transactionDto.transaction.to === multiSendContract.address ? true : false;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        // NOTE : If the wallet is not deployed yet then nonce would be zero
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        walletContract = walletContract.attach(smartAccountState.address);
        let nonce = 0;
        if (await this.contractUtils.isDeployed(chainId, smartAccountState.address)) {
            nonce = (await walletContract.getNonce(batchId)).toNumber();
        }
        common_1.Logger.log('nonce: ', nonce);
        const operation = isDelegate ? 1 : 0;
        const walletTx = this.utils.buildSmartAccountTransaction({
            to: transaction.to,
            value: transaction.value,
            data: transaction.data,
            nonce,
            operation
        });
        return walletTx;
    }
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is without fee refund (gasless)
     * @param transaction
     * @param chainId
     * @returns
     */
    async createTransactionBatch(transactionBatchDto) {
        const { transactions, chainId, version } = transactionBatchDto;
        // NOTE : If the wallet is not deployed yet then nonce would be zero
        const batchId = 1; //fixed nonce space for forward
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        walletContract = walletContract.attach(smartAccountState.address);
        // NOTE : If the wallet is not deployed yet then nonce would be zero
        let nonce = 0;
        if (await this.contractUtils.isDeployed(chainId, smartAccountState.address)) {
            nonce = (await walletContract.getNonce(batchId)).toNumber();
        }
        common_1.Logger.log('nonce: ', nonce);
        const txs = [];
        for (let i = 0; i < transactions.length; i++) {
            const innerTx = this.utils.buildSmartAccountTransaction({
                to: transactions[i].to,
                value: transactions[i].value,
                data: transactions[i].data,
                nonce: 0
            });
            txs.push(innerTx);
        }
        const walletTx = this.utils.buildMultiSendSmartAccountTx(this.contractUtils.multiSendContract[chainId][version].getContract(), txs, nonce);
        common_1.Logger.log('wallet txn without refund ', walletTx);
        return walletTx;
    }
    async estimateTransaction(prepareTransactionDto) {
        const { transaction, chainId, version } = prepareTransactionDto;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        // OR just like contractUtils manages context, this class manages state getState(chainId) method
        // const state = await this.getSmartAccountState(chainId);
        // try catch
        const tx = await this.createTransaction({ version, transaction, chainId: chainId });
        // try catch
        const estimatedGasUsed = await this.estimator.estimateTransaction(prepareTransactionDto, tx, smartAccountState);
        return estimatedGasUsed;
    }
    // Get Fee Options from relayer and make it available for display
    // We can also show list of transactions to be processed (decodeContractCall)
    /**
     *
     * @param getFeeQuotesDto
     */
    async getFeeQuotes(getFeeQuotesDto) {
        const { transaction, chainId, version } = getFeeQuotesDto;
        const gasPriceQuotesResponse = await this.relayer.getFeeOptions(chainId);
        const feeOptionsAvailable = gasPriceQuotesResponse.data.response;
        const feeQuotes = [];
        // 1. If wallet is deployed
        // 2. If wallet is not deployed (batch wallet deployment on multisend)
        // actual estimation with dummy sig
        // eth_call to rescue : undeployed /deployed wallet with override bytecode SmartWalletNoAuth
        const estimatedGasUsed = await this.estimateTransaction({
            version,
            transaction,
            chainId: chainId
        });
        // also relayer would give feeReceiver that becomes part of feeQuote
        feeOptionsAvailable.forEach((feeOption) => {
            const feeTokenTransferGas = feeOption.feeTokenTransferGas;
            const tokenGasPrice = feeOption.tokenGasPrice || 0;
            const offset = feeOption.offset || 1;
            const payment = (tokenGasPrice * (estimatedGasUsed + feeTokenTransferGas)) / offset;
            const feeQuote = {
                symbol: feeOption.symbol,
                address: feeOption.address,
                decimal: feeOption.decimal,
                logoUrl: feeOption.logoUrl,
                tokenGasPrice: feeOption.tokenGasPrice,
                offset: feeOption.offset,
                payment: payment,
                refundReceiver: feeOption.refundReceiver
            };
            feeQuotes.push(feeQuote);
        });
        return feeQuotes;
    }
    async estimateTransactionBatch(getFeeQuotesForBatchDto) {
        const { transactions, chainId, version } = getFeeQuotesForBatchDto;
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        const tx = await this.createTransactionBatch({
            version,
            transactions,
            chainId: chainId
        });
        // try catch
        const estimatedGasUsed = await this.estimator.estimateTransactionBatch(getFeeQuotesForBatchDto, tx, smartAccountState);
        return estimatedGasUsed;
    }
    // Get Fee Options from relayer and make it available for display
    // We can also show list of transactions to be processed (decodeContractCall)
    /**
     *
     * @param getFeeQuotesForBatchDto
     */
    async getFeeQuotesForBatch(getFeeQuotesForBatchDto) {
        const { transactions, chainId, version } = getFeeQuotesForBatchDto;
        const gasPriceQuotesResponse = await this.relayer.getFeeOptions(chainId);
        const feeOptionsAvailable = gasPriceQuotesResponse.data.response;
        const feeQuotes = [];
        // 1. If wallet is deployed
        // 2. If wallet is not deployed (batch wallet deployment on multisend)
        // actual estimation with dummy sig
        // eth_call to rescue : undeployed /deployed wallet with override bytecode SmartWalletNoAuth
        // this.createTransaction
        // pass to estimator method
        const estimatedGasUsed = await this.estimateTransactionBatch({
            version,
            transactions,
            chainId: chainId
        });
        feeOptionsAvailable.forEach((feeOption) => {
            const feeTokenTransferGas = feeOption.feeTokenTransferGas;
            const tokenGasPrice = feeOption.tokenGasPrice || 0;
            const offset = feeOption.offset || 1;
            const payment = (tokenGasPrice * (estimatedGasUsed + feeTokenTransferGas)) / offset;
            const feeQuote = {
                symbol: feeOption.symbol,
                address: feeOption.address,
                decimal: feeOption.decimal,
                logoUrl: feeOption.logoUrl,
                tokenGasPrice: feeOption.tokenGasPrice,
                offset: feeOption.offset,
                payment: payment,
                refundReceiver: feeOption.refundReceiver
            };
            feeQuotes.push(feeQuote);
        });
        return feeQuotes;
    }
    async estimateSmartAccountDeployment(estimateSmartAccountDeploymentDto) {
        // Try catch
        const estimateWalletDeployment = await this.estimator.estimateSmartAccountDeployment(estimateSmartAccountDeploymentDto);
        return estimateWalletDeployment;
    }
    async estimateGasUsed(target, data, chainId) {
        const gasUsed = await this.estimator.estimateGasUsed(target, data, chainId);
        return gasUsed;
    }
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
     * @param createUserPaidTransactionDto
     * @returns
     */
    async createUserPaidTransaction(createUserPaidTransactionDto) {
        const { transaction, feeQuote, chainId, version } = createUserPaidTransactionDto;
        const batchId = 1; // Fixed nonce space for forward
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        walletContract = walletContract.attach(smartAccountState.address);
        let additionalBaseGas = 0;
        // NOTE : If the wallet is not deployed yet then nonce would be zero
        let nonce = 0;
        const isDeployed = await this.contractUtils.isDeployed(chainId, smartAccountState.address);
        if (isDeployed) {
            nonce = (await walletContract.getNonce(batchId)).toNumber();
        }
        else {
            const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
                chainId: chainId,
                version,
                owner: smartAccountState.owner
            });
            // We know it's going to get deployed by Relayer but we handle refund cost here..
            additionalBaseGas += estimateWalletDeployment; // wallet deployment gas
        }
        common_1.Logger.log('nonce: ', nonce);
        // in terms of calculating baseGas we should know if wallet is deployed or not otherwise it needs to consider deployment cost
        // (will get batched by relayer)
        const internalTx = {
            to: transaction.to,
            value: transaction.value || 0,
            data: transaction.data || '0x',
            operation: core_types_1.OperationType.Call
        };
        common_1.Logger.log('internalTx: ', internalTx);
        let targetTxGas, baseGas, handlePaymentEstimate;
        const regularOffSet = core_types_1.GAS_USAGE_OFFSET;
        if (!isDeployed) {
            // Regular APIs will return 0 for handlePayment and requiredTxGas for undeployed wallet
            // targetTxGas?
            // i. use really high value
            // ii. estimate using different wallet bytecode using eth_call [ not guaranteed as might depend on wallet state !]
            const estimateRequiredTxGas = {
                chainId: chainId,
                walletAddress: smartAccountState.address,
                transaction: internalTx
            };
            const response = await this.nodeClient.estimateRequiredTxGasOverride(estimateRequiredTxGas);
            const requiredTxGasEstimate = Number(response.data.gas) + 700000;
            common_1.Logger.log('required txgas estimate (with override) ', requiredTxGasEstimate);
            targetTxGas = requiredTxGasEstimate;
            // baseGas?
            // Depending on feeToken provide baseGas! We could use constant value provided by the relayer
            const refundDetails = {
                gasUsed: requiredTxGasEstimate,
                baseGas: requiredTxGasEstimate,
                gasPrice: feeQuote.tokenGasPrice,
                tokenGasPriceFactor: feeQuote.offset || 1,
                gasToken: feeQuote.address,
                refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
            };
            const estimateHandlePaymentGas = {
                chainId: chainId,
                version: version,
                walletAddress: smartAccountState.address,
                feeRefund: refundDetails
            };
            const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGasOverride(estimateHandlePaymentGas);
            handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
            common_1.Logger.log('handlePaymentEstimate (with override) ', handlePaymentEstimate);
            baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas;
        }
        else {
            const estimateRequiredTxGas = {
                chainId: chainId,
                walletAddress: smartAccountState.address,
                transaction: internalTx
            };
            const response = await this.nodeClient.estimateRequiredTxGas(estimateRequiredTxGas);
            // TODO
            // handle exception responses and when gas returned is 0
            const requiredTxGasEstimate = Number(response.data.gas) + 30000;
            common_1.Logger.log('required txgas estimate ', requiredTxGasEstimate);
            targetTxGas = requiredTxGasEstimate;
            const refundDetails = {
                gasUsed: requiredTxGasEstimate,
                baseGas: requiredTxGasEstimate,
                gasPrice: feeQuote.tokenGasPrice,
                tokenGasPriceFactor: feeQuote.offset || 1,
                gasToken: feeQuote.address,
                refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
            };
            const estimateHandlePaymentGas = {
                chainId: chainId,
                version: version,
                walletAddress: smartAccountState.address,
                feeRefund: refundDetails
            };
            const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGas(estimateHandlePaymentGas);
            handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
            common_1.Logger.log('handlePaymentEstimate ', handlePaymentEstimate);
            baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas; // delegate call + event emission + state updates + potential deployment
        }
        const walletTx = this.utils.buildSmartAccountTransaction({
            to: transaction.to,
            value: transaction.value,
            data: transaction.data,
            targetTxGas: targetTxGas,
            baseGas,
            refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS,
            gasPrice: feeQuote.tokenGasPrice.toString(),
            tokenGasPriceFactor: feeQuote.offset || 1,
            gasToken: feeQuote.address,
            nonce
        });
        return walletTx;
    }
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
     * @param createUserPaidTransactionBatchDto
     * @returns
     */
    async createUserPaidTransactionBatch(createUserPaidTransactionBatchDto) {
        const { transactions, feeQuote, chainId, version } = createUserPaidTransactionBatchDto;
        const batchId = 1; // Fixed nonce space for Forward
        const smartAccountState = await this.contractUtils.getSmartAccountState();
        let walletContract = this.contractUtils.smartWalletContract[chainId][version].getContract();
        const connectedWallet = smartAccountState.address;
        walletContract = walletContract.attach(connectedWallet);
        const isDeployed = smartAccountState.isDeployed;
        // await this.contractUtils.isDeployed(chainId, version, smartAccountState.address);
        let additionalBaseGas = 0;
        // NOTE : If the wallet is not deployed yet then nonce would be zero
        let nonce = 0;
        if (isDeployed) {
            nonce = (await walletContract.getNonce(batchId)).toNumber();
        }
        else {
            // TODO : estimation cost can be passed which is constant for biconomy smart account deployment
            const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
                chainId: chainId,
                version,
                owner: smartAccountState.owner
            });
            // We know it's going to get deployed by Relayer but we handle refund cost here..
            common_1.Logger.log('estimateWalletDeployment ', estimateWalletDeployment);
            // We know it's going to get deployed by Relayer
            // but we handle refund cost here..
            additionalBaseGas += estimateWalletDeployment; // wallet deployment gas
        }
        common_1.Logger.log('nonce: ', nonce);
        const txs = this.utils.buildSmartAccountTransactions(transactions);
        const walletTx = this.utils.buildMultiSendSmartAccountTx(this.contractUtils.multiSendContract[chainId][version].getContract(), txs, nonce);
        common_1.Logger.log('wallet txn with refund ', walletTx);
        const internalTx = {
            to: walletTx.to,
            value: walletTx.value || 0,
            data: walletTx.data || '0x',
            operation: walletTx.operation
        };
        common_1.Logger.log('internalTx ', internalTx);
        let targetTxGas, baseGas;
        const regularOffSet = core_types_1.GAS_USAGE_OFFSET;
        if (!isDeployed) {
            // Regular APIs will return 0 for handlePayment and requiredTxGas for undeployed wallet
            // targetTxGas?
            // i. use really high value
            // ii. estimate using different wallet bytecode using eth_call [ not guaranteed as might depend on wallet state !]
            const estimateRequiredTxGas = {
                chainId: chainId,
                walletAddress: smartAccountState.address,
                transaction: internalTx
            };
            const response = await this.nodeClient.estimateRequiredTxGasOverride(estimateRequiredTxGas);
            // not getting accurate value for undeployed wallet
            // TODO
            const requiredTxGasEstimate = Number(response.data.gas) + 700000;
            common_1.Logger.log('required txgas estimate (with override) ', requiredTxGasEstimate);
            targetTxGas = requiredTxGasEstimate;
            // baseGas?
            // Allow overriding wallet address just for this estimations
            // Depending on feeToken provide baseGas! We could use constant value provided by the relayer
            const refundDetails = {
                gasUsed: requiredTxGasEstimate,
                baseGas: requiredTxGasEstimate,
                gasPrice: feeQuote.tokenGasPrice,
                tokenGasPriceFactor: feeQuote.offset || 1,
                gasToken: feeQuote.address,
                refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
            };
            const estimateHandlePaymentGas = {
                chainId: chainId,
                version: version,
                walletAddress: smartAccountState.address,
                feeRefund: refundDetails
            };
            const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGasOverride(estimateHandlePaymentGas);
            const handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
            common_1.Logger.log('handlePaymentEstimate (with override) ', handlePaymentEstimate);
            baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas;
        }
        else {
            const estimateRequiredTxGas = {
                chainId: chainId,
                walletAddress: smartAccountState.address,
                transaction: internalTx
            };
            const response = await this.nodeClient.estimateRequiredTxGas(estimateRequiredTxGas);
            // considerable offset ref gnosis safe service client safeTxGas
            // TODO
            // handle exception responses and when gas returned is 0
            // We could stop the further flow
            const requiredTxGasEstimate = Number(response.data.gas) + 30000;
            common_1.Logger.log('required txgas estimate ', requiredTxGasEstimate);
            targetTxGas = requiredTxGasEstimate;
            const refundDetails = {
                gasUsed: requiredTxGasEstimate,
                baseGas: requiredTxGasEstimate,
                gasPrice: feeQuote.tokenGasPrice,
                tokenGasPriceFactor: feeQuote.offset || 1,
                gasToken: feeQuote.address,
                refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS
            };
            const estimateHandlePaymentGas = {
                chainId: chainId,
                version: version,
                walletAddress: smartAccountState.address,
                feeRefund: refundDetails
            };
            const handlePaymentResponse = await this.nodeClient.estimateHandlePaymentGas(estimateHandlePaymentGas);
            const handlePaymentEstimate = Number(handlePaymentResponse.data.gas);
            common_1.Logger.log('handlePaymentEstimate ', handlePaymentEstimate);
            baseGas = handlePaymentEstimate + regularOffSet + additionalBaseGas; // delegate call + event emission + state updates + potential deployment
        }
        const finalWalletTx = this.utils.buildSmartAccountTransaction({
            to: walletTx.to,
            value: walletTx.value,
            data: walletTx.data,
            operation: walletTx.operation,
            targetTxGas: targetTxGas,
            baseGas: baseGas,
            refundReceiver: feeQuote.refundReceiver || core_types_1.ZERO_ADDRESS,
            gasPrice: feeQuote.tokenGasPrice.toString(),
            tokenGasPriceFactor: feeQuote.offset || 1,
            gasToken: feeQuote.address,
            nonce
        });
        return finalWalletTx;
    }
    ethersAdapter(chainId) {
        return this.contractUtils.ethAdapter[chainId];
    }
}
exports.default = TransactionManager;
//# sourceMappingURL=TransactionManager.js.map