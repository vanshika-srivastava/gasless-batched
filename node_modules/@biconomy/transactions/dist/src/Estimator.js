"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Estimator = void 0;
const ethers_1 = require("ethers");
const assets_1 = require("./assets");
const core_types_1 = require("@biconomy/core-types");
const common_1 = require("@biconomy/common");
class Estimator {
    // Note: Smart account state should Not be part of constructor
    constructor(nodeClient, contractUtils) {
        this.nodeClient = nodeClient;
        this.contractUtils = contractUtils;
    }
    async estimateTransaction(prepareTransactionDto, createdTransaction, smartAccountState) {
        const { chainId, version } = prepareTransactionDto;
        let estimatedGasUsed = 0;
        // Check if available from current state
        const isDeployed = await this.contractUtils.isDeployed(chainId, smartAccountState.address // SmartAccountState
        );
        if (!isDeployed) {
            const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
                chainId,
                version,
                owner: smartAccountState.owner
            });
            common_1.Logger.log('estimateWalletDeployment ', estimateWalletDeployment);
            estimatedGasUsed += estimateWalletDeployment;
        }
        const txn = {
            to: createdTransaction.to,
            value: createdTransaction.value,
            data: createdTransaction.data,
            operation: createdTransaction.operation,
            targetTxGas: createdTransaction.targetTxGas
        };
        // to avoid failing eth_call override with undeployed wallet
        txn.targetTxGas = 500000;
        const refundInfo = {
            baseGas: createdTransaction.baseGas,
            gasPrice: createdTransaction.gasPrice,
            tokenGasPriceFactor: createdTransaction.tokenGasPriceFactor,
            gasToken: createdTransaction.gasToken,
            refundReceiver: createdTransaction.refundReceiver
        };
        const estimateUndeployedContractGasDto = {
            chainId,
            version,
            transaction: txn,
            walletAddress: smartAccountState.address,
            feeRefund: refundInfo,
            signature: core_types_1.FAKE_SIGNATURE
        };
        const ethCallOverrideResponse = await this.nodeClient.estimateUndeployedContractGas(estimateUndeployedContractGasDto);
        const noAuthEstimate = Number(ethCallOverrideResponse.data.gas) + Number(ethCallOverrideResponse.data.txBaseGas);
        common_1.Logger.warn('no auth no refund estimate', noAuthEstimate);
        estimatedGasUsed += noAuthEstimate;
        return estimatedGasUsed;
    }
    async estimateTransactionBatch(getFeeQuotesForBatchDto, createdTransaction, smartAccountState) {
        const { chainId, version } = getFeeQuotesForBatchDto;
        let estimatedGasUsed = 0;
        // Check if available from current state
        const isDeployed = await this.contractUtils.isDeployed(chainId, smartAccountState.address);
        if (!isDeployed) {
            const estimateWalletDeployment = await this.estimateSmartAccountDeployment({
                chainId,
                version,
                owner: smartAccountState.owner
            });
            common_1.Logger.log('estimateWalletDeployment ', estimateWalletDeployment);
            estimatedGasUsed += estimateWalletDeployment;
        }
        const txn = {
            to: createdTransaction.to,
            value: createdTransaction.value,
            data: createdTransaction.data,
            operation: createdTransaction.operation,
            targetTxGas: createdTransaction.targetTxGas
        };
        // to avoid failing eth_call override with undeployed wallet
        txn.targetTxGas = 500000;
        const refundInfo = {
            baseGas: createdTransaction.baseGas,
            gasPrice: createdTransaction.gasPrice,
            tokenGasPriceFactor: createdTransaction.tokenGasPriceFactor,
            gasToken: createdTransaction.gasToken,
            refundReceiver: createdTransaction.refundReceiver
        };
        const estimateUndeployedContractGasDto = {
            chainId,
            version,
            transaction: txn,
            walletAddress: smartAccountState.address,
            feeRefund: refundInfo,
            signature: core_types_1.FAKE_SIGNATURE
        };
        const ethCallOverrideResponse = await this.nodeClient.estimateUndeployedContractGas(estimateUndeployedContractGasDto);
        const noAuthEstimate = Number(ethCallOverrideResponse.data.gas) + Number(ethCallOverrideResponse.data.txBaseGas);
        common_1.Logger.log('no auth no refund estimate', noAuthEstimate);
        estimatedGasUsed += noAuthEstimate;
        return estimatedGasUsed;
    }
    // Generic function to estimate gas used for any contract call
    async estimateGasUsed(target, data, chainId) {
        const estimatorInterface = new ethers_1.ethers.utils.Interface(assets_1.GasEstimator.abi);
        const encodedEstimateData = estimatorInterface.encodeFunctionData('estimate', [target, data]);
        const estimateGasUsedResponse = await this.nodeClient.estimateExternalGas({
            chainId,
            encodedData: encodedEstimateData
        });
        return Number(estimateGasUsedResponse.data.gas);
    }
    async estimateSmartAccountDeployment(estimateSmartAccountDeploymentDto) {
        const estimatorInterface = new ethers_1.ethers.utils.Interface(assets_1.GasEstimator.abi);
        const { chainId, version, owner } = estimateSmartAccountDeploymentDto;
        const walletFactoryInterface = this.contractUtils.smartWalletFactoryContract[chainId][version].getInterface();
        const encodedEstimateData = estimatorInterface.encodeFunctionData('estimate', [
            this.contractUtils.smartWalletFactoryContract[chainId][version].getAddress(),
            walletFactoryInterface.encodeFunctionData('deployCounterFactualAccount', [owner, 0])
        ]);
        common_1.Logger.log('encodedEstimate ', encodedEstimateData);
        const deployCostresponse = await this.nodeClient.estimateExternalGas({
            chainId,
            encodedData: encodedEstimateData
        });
        const estimateWalletDeployment = Number(deployCostresponse.data.gas);
        common_1.Logger.log('estimateWalletDeployment ', estimateWalletDeployment);
        return estimateWalletDeployment;
    }
}
exports.Estimator = Estimator;
//# sourceMappingURL=Estimator.js.map