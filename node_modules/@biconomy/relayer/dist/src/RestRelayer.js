"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _RestRelayer_relayServiceBaseUrl, _RestRelayer_socketServerUrl;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestRelayer = void 0;
const ethers_1 = require("ethers");
const common_1 = require("@biconomy/common");
const MultiSend_1 = require("./utils/MultiSend");
const HttpRequests_1 = require("./utils/HttpRequests");
const gasless_messaging_sdk_1 = require("@biconomy/gasless-messaging-sdk");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
/**
 * Relayer class that would be used via REST API to execute transactions
 */
class RestRelayer {
    constructor(options) {
        _RestRelayer_relayServiceBaseUrl.set(this, void 0);
        _RestRelayer_socketServerUrl.set(this, void 0);
        const { url, socketServerUrl } = options;
        this.relayerNodeEthersProvider = {};
        __classPrivateFieldSet(this, _RestRelayer_relayServiceBaseUrl, url, "f");
        __classPrivateFieldSet(this, _RestRelayer_socketServerUrl, socketServerUrl, "f");
    }
    setRelayerNodeEthersProvider(chainId) {
        if (!this.relayerNodeEthersProvider[chainId]) {
            this.relayerNodeEthersProvider[chainId] = new ethers_1.ethers.providers.JsonRpcProvider(__classPrivateFieldGet(this, _RestRelayer_relayServiceBaseUrl, "f"), {
                name: 'Not actually connected to network, only talking to the Relayer!',
                chainId: chainId
            });
        }
    }
    prepareWalletDeploy(
    // owner, entryPoint, handler, index
    deployWallet
    // context: WalletContext
    ) {
        const { config, context, index = 0 } = deployWallet;
        const { walletFactory } = context;
        const { owner } = config;
        const factoryInterface = walletFactory.getInterface();
        return {
            to: walletFactory.getAddress(),
            data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deployCounterFactualAccount'), [owner, index])
        };
    }
    // if the wallet is deployed baseGas would be coming as part of struct in rawtx
    async relay(relayTransaction, engine) {
        const socketServerUrl = __classPrivateFieldGet(this, _RestRelayer_socketServerUrl, "f");
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
            await clientMessenger.connect();
            common_1.Logger.log('socket connect success');
        }
        const { config, signedTx, context, gasLimit } = relayTransaction;
        const { isDeployed, address } = config;
        const chainId = signedTx.rawTx.chainId;
        // Creates an instance of relayer node ethers provider for chain not already discovered
        this.setRelayerNodeEthersProvider(chainId);
        const { multiSendCall } = context; // multisend has to be multiSendCallOnly here!
        let finalRawRx;
        if (!isDeployed) {
            const prepareWalletDeploy = {
                config,
                context,
                index: 0
            };
            const { to, data } = this.prepareWalletDeploy(prepareWalletDeploy);
            const txs = [
                {
                    to,
                    value: 0,
                    data,
                    operation: 0
                },
                {
                    to: address,
                    value: 0,
                    data: signedTx.rawTx.data || '',
                    operation: 0
                }
            ];
            const txnData = multiSendCall
                .getInterface()
                .encodeFunctionData('multiSend', [(0, MultiSend_1.encodeMultiSend)(txs)]);
            finalRawRx = {
                to: multiSendCall.getAddress(),
                data: txnData,
                chainId: signedTx.rawTx.chainId,
                value: 0
            };
        }
        else {
            finalRawRx = signedTx.rawTx;
        }
        common_1.Logger.log('finalRawTx', finalRawRx);
        // based on the flag make rpc call to relayer code service with necessary rawTx data
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        const response = await (0, HttpRequests_1.sendRequest)({
            url: `${__classPrivateFieldGet(this, _RestRelayer_relayServiceBaseUrl, "f")}`,
            method: HttpRequests_1.HttpMethod.Post,
            body: {
                method: 'eth_sendSmartContractWalletTransaction',
                params: [
                    {
                        ...finalRawRx,
                        // Could send custom high instead of undefined
                        gasLimit: gasLimit ? gasLimit.hex : undefined,
                        walletInfo: {
                            address: address
                        },
                        refundInfo: {
                            tokenGasPrice: signedTx.tx.gasPrice,
                            gasToken: signedTx.tx.gasToken
                        }
                    }
                ],
                id: 1234,
                jsonrpc: '2.0'
            }
        });
        if (response.data) {
            const transactionId = response.data.transactionId;
            const connectionUrl = response.data.connectionUrl;
            clientMessenger.createTransactionNotifier(transactionId, {
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onMined: (tx) => {
                    const txId = tx.transactionId;
                    clientMessenger.unsubscribe(txId);
                    common_1.Logger.log('Tx Hash mined message received at client', {
                        transactionId: txId,
                        hash: tx.transactionHash,
                        receipt: tx.receipt
                    });
                    engine.emit('txMined', {
                        msg: 'txn mined',
                        id: txId,
                        hash: tx.transactionHash,
                        receipt: tx.receipt
                    });
                },
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onHashGenerated: async (tx) => {
                    const txHash = tx.transactionHash;
                    const txId = tx.transactionId;
                    common_1.Logger.log('Tx Hash generated message received at client ', {
                        transactionId: txId,
                        hash: txHash
                    });
                    engine.emit('txHashGenerated', {
                        id: tx.transactionId,
                        hash: tx.transactionHash,
                        msg: 'txn hash generated'
                    });
                },
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onHashChanged: async (tx) => {
                    if (tx) {
                        const txHash = tx.transactionHash;
                        const txId = tx.transactionId;
                        common_1.Logger.log('Tx Hash changed message received at client ', {
                            transactionId: txId,
                            hash: txHash
                        });
                        engine.emit('txHashChanged', {
                            id: tx.transactionId,
                            hash: tx.transactionHash,
                            msg: 'txn hash changed'
                        });
                    }
                },
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                onError: async (tx) => {
                    common_1.Logger.error('Error message received at client', tx);
                    const err = tx.error;
                    const txId = tx.transactionId;
                    clientMessenger.unsubscribe(txId);
                    engine.emit('error', {
                        id: tx.transactionId,
                        error: err,
                        msg: 'error in txn'
                    });
                }
            });
            return {
                connectionUrl: connectionUrl,
                transactionId: transactionId
            };
        }
        else {
            return {
                error: response.error || 'transaction failed'
            };
        }
    }
    async getFeeOptions(chainId) {
        return (0, HttpRequests_1.sendRequest)({
            url: `${__classPrivateFieldGet(this, _RestRelayer_relayServiceBaseUrl, "f")}/feeOptions?chainId=${chainId}`,
            method: HttpRequests_1.HttpMethod.Get
        });
    }
}
exports.RestRelayer = RestRelayer;
_RestRelayer_relayServiceBaseUrl = new WeakMap(), _RestRelayer_socketServerUrl = new WeakMap();
//# sourceMappingURL=RestRelayer.js.map