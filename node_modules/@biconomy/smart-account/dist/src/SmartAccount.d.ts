/// <reference types="node" />
import { SignUserPaidTransactionDto, SendUserPaidTransactionDto, SendUserPaidSignedTransactionDto, GetFeeQuotesDto, GetFeeQuotesForBatchDto, CreateUserPaidTransactionDto, CreateUserPaidTransactionBatchDto, TransactionDto, TransactionBatchDto, IWalletTransaction, SmartAccountVersion, ChainId, SmartAccountContext, SmartWalletFactoryContract, MultiSendContract, SmartWalletContract, AddressForCounterFactualWalletDto, SmartAccountState, FeeQuote, SmartAccountConfig, NetworkConfig } from '@biconomy/core-types';
import NodeClient, { ISmartAccount, ChainConfig, SmartAccountsResponse, SmartAccountByOwnerDto, SCWTransactionResponse, BalancesResponse, BalancesDto, UsdBalanceResponse } from '@biconomy/node-client';
import { JsonRpcProvider, Web3Provider } from '@ethersproject/providers';
import { IRelayer, IFallbackRelayer } from '@biconomy/relayer';
import TransactionManager, { ContractUtils } from '@biconomy/transactions';
import EventEmitter from 'events';
import { TransactionResponse } from '@ethersproject/providers';
import { ERC4337EthersProvider, BaseAccountAPI } from '@biconomy/account-abstraction';
import { Signer } from 'ethers';
import { Transaction } from '@biconomy/core-types';
declare class SmartAccount extends EventEmitter {
    #private;
    DEFAULT_VERSION: SmartAccountVersion;
    context: {
        [chainId: number]: SmartAccountContext;
    };
    supportedNetworkIds: ChainId[];
    chainConfig: ChainConfig[];
    provider: JsonRpcProvider;
    aaProvider: {
        [chainId: number]: ERC4337EthersProvider;
    };
    signer: Signer;
    nodeClient: NodeClient;
    contractUtils: ContractUtils;
    transactionManager: TransactionManager;
    relayer: IRelayer;
    fallbackRelayer: IFallbackRelayer;
    private signingService;
    owner: string;
    address: string;
    smartAccountState: SmartAccountState;
    /**
     * Constructor for the Smart Account. If config is not provided it makes Smart Account available using default configuration
     * If you wish to use your own backend server and relayer service, pass the URLs here
     */
    constructor(signerOrProvider: Web3Provider | Signer, config?: Partial<SmartAccountConfig>);
    getConfig(): SmartAccountConfig;
    getsigner(): Signer;
    getSmartAccountAPI(chainId: ChainId): BaseAccountAPI;
    getProviderUrl(network: ChainConfig): string;
    getNetworkConfigValues(chainId: ChainId): Promise<NetworkConfig>;
    initializeAtChain(chainId: ChainId): Promise<void>;
    init(): Promise<this>;
    sendFallbackTransaction(transactionDto: TransactionDto): Promise<TransactionResponse>;
    /**
     * @description this function will make complete transaction data for updateImplementationTrx
     * @param chainId
     * @returns
     */
    updateImplementationTrx(chainId: ChainId): Promise<Transaction>;
    /**
     * @description this function will make complete transaction data for updateFallBackHandlerTrx
     * @param chainId
     * @returns
     */
    updateFallBackHandlerTrx(chainId: ChainId): Promise<Transaction>;
    /**
     * @description this function will let dapp to update Base wallet Implemenation to Latest
     * @returns
     */
    updateFallbackHandler(): Promise<TransactionResponse>;
    /**
     * @description this function will let dapp to update FallBackHandler to Latest
     * @returns
     */
    updateImplementation(): Promise<TransactionResponse>;
    sendTransaction(transactionDto: TransactionDto): Promise<TransactionResponse>;
    sendTransactionBatch(transactionBatchDto: TransactionBatchDto): Promise<TransactionResponse>;
    deployWalletUsingPaymaster(): Promise<TransactionResponse>;
    /**
     *
     * @param smartAccountVersion
     * @description // set wallet version to be able to interact with different deployed versions
     */
    setSmartAccountVersion(smartAccountVersion: SmartAccountVersion): Promise<SmartAccount>;
    getAlltokenBalances(balancesDto: BalancesDto): Promise<BalancesResponse>;
    getTotalBalanceInUsd(balancesDto: BalancesDto): Promise<UsdBalanceResponse>;
    getSmartAccountsByOwner(smartAccountByOwnerDto: SmartAccountByOwnerDto): Promise<SmartAccountsResponse>;
    getTransactionByAddress(chainId: number, address: string): Promise<SCWTransactionResponse[]>;
    getTransactionByHash(txHash: string): Promise<SCWTransactionResponse>;
    /**
     * Assigns transaction relayer to this smart wallet instance
     * @notice Assumption is that relayer will accept calls for all supported chains
     * @param relayer Relayer client to be associated with this smart account
     * @returns this/self
     */
    setRelayer(relayer: IRelayer): Promise<SmartAccount>;
    /**
     * Allows to change default active chain of the Smart Account
     * @param chainId
     * @returns self/this
     */
    setActiveChain(chainId: ChainId): Promise<SmartAccount>;
    /**
     *
     * @notice personal sign is used currently (Signer should be able to use _typedSignData)
     * @param tx IWalletTransaction Smart Account Transaction object prepared
     * @param chainId optional chainId
     * @returns:string Signature
     */
    signUserPaidTransaction(signUserPaidTransactionDto: SignUserPaidTransactionDto): Promise<string>;
    /**
     * Prepares encoded wallet transaction, gets signature from the signer and dispatches to the blockchain using relayer
     * @param tx IWalletTransaction Smart Account Transaction object prepared
     * @param chainId optional chainId
     * @returns transactionId : transaction identifier
     */
    sendUserPaidTransaction(sendUserPaidTransactionDto: SendUserPaidTransactionDto): Promise<string>;
    sendSignedTransactionWithFeeQuote(sendUserPaidSignedTransactionDto: SendUserPaidSignedTransactionDto): Promise<string>;
    /**
     *
     * @param getFeeQuotesDto
     */
    getFeeQuotes(getFeeQuotesDto: GetFeeQuotesDto): Promise<FeeQuote[]>;
    /**
     *
     * @param getFeeQuotesForBatchDto
     */
    getFeeQuotesForBatch(getFeeQuotesForBatchDto: GetFeeQuotesForBatchDto): Promise<FeeQuote[]>;
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
     * @param createUserPaidTransactionDto
     * @returns
     */
    createUserPaidTransaction(createUserPaidTransactionDto: CreateUserPaidTransactionDto): Promise<IWalletTransaction>;
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is without fee refund (gasless)
     * @param transactionDto
     * @returns
     */
    createTransaction(transactionDto: TransactionDto): Promise<IWalletTransaction>;
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is without fee refund (gasless)
     * @param transaction
     * @param chainId
     * @returns
     */
    createTransactionBatch(transactionBatchDto: TransactionBatchDto): Promise<IWalletTransaction>;
    /**
     * Prepares compatible IWalletTransaction object based on Transaction Request
     * @notice This transaction is with fee refund (smart account pays using it's own assets accepted by relayers)
     * @param createUserPaidTransactionBatchDto
     * @returns
     */
    createUserPaidTransactionBatch(createUserPaidTransactionBatchDto: CreateUserPaidTransactionBatchDto): Promise<IWalletTransaction>;
    /**
     *
     * @param chainId optional chainId
     * @returns Smart Wallet Contract instance attached with current smart account address (proxy)
     */
    smartAccount(chainId?: ChainId): SmartWalletContract;
    /**
     *
     * @param address EOA address
     * @param chainId optional chainId
     * @param index optional index for counterfactual address
     * @returns SmartAccount address for given EOA address
     */
    getSmartAccountAddress(owner: string, chainId?: ChainId, index?: number): Promise<string>;
    /**
     *
     * @param chainId optional chainId
     * @returns Smart Wallet Factory instance for requested chainId
     */
    factory(chainId?: ChainId): SmartWalletFactoryContract;
    multiSend(chainId?: ChainId): MultiSendContract;
    getAddress(addressForCounterFactualWalletDto: AddressForCounterFactualWalletDto): Promise<ISmartAccount>;
    /**
     * Allows one to check if the smart account is already deployed on requested chainOd
     * @notice the check is made on Wallet Factory state with current address in Smart Account state
     * @param chainId optional chainId : Default is current active
     * @returns
     */
    isDeployed(chainId: ChainId): Promise<boolean>;
    /**
     * @param chainId requested chain : default is active chain
     * @returns object containing infromation (owner, relevant contract addresses, isDeployed) about Smart Account for requested chain
     */
    getSmartAccountState(): Promise<SmartAccountState>;
    /**
     * Serves smart contract instances associated with Smart Account for requested ChainId
     * Context is useful when relayer is deploying a wallet
     * @param chainId requested chain : default is active chain
     * @returns object containing relevant contract instances
     */
    getSmartAccountContext(chainId?: ChainId): SmartAccountContext;
}
export default SmartAccount;
