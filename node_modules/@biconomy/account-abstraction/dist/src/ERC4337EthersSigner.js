"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC4337EthersSigner = void 0;
const properties_1 = require("@ethersproject/properties");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const ethers_1 = require("ethers");
const ethers_2 = require("ethers");
const common_1 = require("@biconomy/common");
const gasless_messaging_sdk_1 = require("@biconomy/gasless-messaging-sdk");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
class ERC4337EthersSigner extends abstract_signer_1.Signer {
    constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {
        super();
        this.config = config;
        this.originalSigner = originalSigner;
        this.erc4337provider = erc4337provider;
        this.httpRpcClient = httpRpcClient;
        this.smartAccountAPI = smartAccountAPI;
        (0, properties_1.defineReadOnly)(this, 'provider', erc4337provider);
    }
    // This one is called by Contract. It signs the request and passes in to Provider to be sent.
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    async sendTransaction(transaction, walletDeployOnly = false, engine // EventEmitter
    ) {
        var _a, _b;
        const socketServerUrl = this.config.socketServerUrl;
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
            try {
                await clientMessenger.connect();
                common_1.Logger.log('socket connection success', { socketServerUrl });
            }
            catch (err) {
                common_1.Logger.error('socket connection failure', err);
            }
        }
        common_1.Logger.log('received transaction ', transaction);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const customData = transaction.customData;
        common_1.Logger.log('customData', customData);
        // customise gasLimit help dapps to supply gasLimit of their choice
        if (customData && (customData.isBatchedToMultiSend || !customData.isDeployed)) {
            if (customData.appliedGasLimit) {
                transaction.gasLimit = customData.appliedGasLimit;
                common_1.Logger.log('gaslimit applied from custom data...', transaction.gasLimit);
            }
        }
        delete transaction.customData;
        let userOperation;
        if (walletDeployOnly === true) {
            userOperation = await this.smartAccountAPI.createSignedUserOp({
                target: [''],
                data: [''],
                value: [0],
                gasLimit: [21000]
            });
        }
        else {
            // Removing populate transaction all together
            // const tx: TransactionRequest = await this.populateTransaction(transaction)
            this.verifyAllNecessaryFields(transaction);
            userOperation = await this.smartAccountAPI.createSignedUserOp({
                target: transaction.to ? [transaction.to] : [ethers_1.ethers.constants.AddressZero],
                data: ((_a = transaction.data) === null || _a === void 0 ? void 0 : _a.toString()) ? [(_b = transaction.data) === null || _b === void 0 ? void 0 : _b.toString()] : ['0x'],
                value: transaction.value ? [transaction.value] : [0],
                gasLimit: transaction.gasLimit
            });
        }
        common_1.Logger.log('signed userOp ', userOperation);
        let bundlerServiceResponse;
        try {
            bundlerServiceResponse = await this.httpRpcClient.sendUserOpToBundler(userOperation);
            common_1.Logger.log('bundlerServiceResponse', bundlerServiceResponse);
        }
        catch (error) {
            // console.error('sendUserOpToBundler failed', error)
            throw this.unwrapError(error);
        }
        if (clientMessenger && clientMessenger.socketClient.isConnected()) {
            clientMessenger.createTransactionNotifier(bundlerServiceResponse.transactionId, {
                onHashGenerated: async (tx) => {
                    if (tx) {
                        const txHash = tx.transactionHash;
                        const txId = tx.transactionId;
                        common_1.Logger.log('Tx Hash generated message received at client', {
                            transactionId: txId,
                            hash: txHash
                        });
                        engine &&
                            engine.emit('txHashGenerated', {
                                id: tx.transactionId,
                                hash: tx.transactionHash,
                                msg: 'txn hash generated'
                            });
                    }
                },
                onHashChanged: async (tx) => {
                    if (tx) {
                        const txHash = tx.transactionHash;
                        const txId = tx.transactionId;
                        common_1.Logger.log('Tx Hash changed message received at client', {
                            transactionId: txId,
                            hash: txHash
                        });
                        engine &&
                            engine.emit('txHashChanged', {
                                id: tx.transactionId,
                                hash: tx.transactionHash,
                                msg: 'txn hash changed'
                            });
                    }
                },
                onError: async (tx) => {
                    if (tx) {
                        common_1.Logger.error('Error message received at client', JSON.stringify(tx));
                        const err = tx.error;
                        const txId = tx.transactionId;
                        clientMessenger.unsubscribe(txId);
                        // event emitter
                        engine &&
                            engine.emit('error', {
                                id: tx.transactionId,
                                error: err,
                                msg: 'txn hash generated'
                            });
                        throw new Error(err);
                    }
                }
            });
        }
        const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation, bundlerServiceResponse.transactionId, engine);
        return transactionResponse;
    }
    async sendTransactionBatch(transactions, engine // EventEmitter
    ) {
        const socketServerUrl = this.config.socketServerUrl;
        const clientMessenger = new gasless_messaging_sdk_1.ClientMessenger(socketServerUrl, isomorphic_ws_1.default);
        if (!clientMessenger.socketClient.isConnected()) {
            try {
                await clientMessenger.connect();
                common_1.Logger.log('socket connection success', { socketServerUrl });
            }
            catch (err) {
                common_1.Logger.error('socket connection failure', err);
            }
        }
        common_1.Logger.log('received transaction ', transactions);
        // Removing populate transaction all together
        // const tx: TransactionRequest = await this.populateTransaction(transaction)
        transactions.map(this.verifyAllNecessaryFields);
        // let target = transactions.map(({ target }) => target)
        const target = transactions.map((element) => { var _a; return (_a = element.to) !== null && _a !== void 0 ? _a : ethers_1.ethers.constants.AddressZero; });
        const data = transactions.map((element) => { var _a; return (_a = element.data) !== null && _a !== void 0 ? _a : '0x'; });
        const value = transactions.map((element) => { var _a; return (_a = element.value) !== null && _a !== void 0 ? _a : ethers_2.BigNumber.from(0); });
        const userOperation = await this.smartAccountAPI.createSignedUserOp({
            target,
            data,
            value
        });
        common_1.Logger.log('signed userOp ', userOperation);
        let bundlerServiceResponse;
        try {
            bundlerServiceResponse = await this.httpRpcClient.sendUserOpToBundler(userOperation);
            common_1.Logger.log('bundlerServiceResponse', bundlerServiceResponse);
        }
        catch (error) {
            // console.error('sendUserOpToBundler failed', error)
            throw this.unwrapError(error);
        }
        if (clientMessenger && clientMessenger.socketClient.isConnected()) {
            clientMessenger.createTransactionNotifier(bundlerServiceResponse.transactionId, {
                onHashGenerated: async (tx) => {
                    if (tx) {
                        const txHash = tx.transactionHash;
                        const txId = tx.transactionId;
                        common_1.Logger.log('Tx Hash generated message received at client', {
                            transactionId: txId,
                            hash: txHash
                        });
                        engine &&
                            engine.emit('txHashGenerated', {
                                id: tx.transactionId,
                                hash: tx.transactionHash,
                                msg: 'txn hash generated'
                            });
                    }
                },
                onHashChanged: async (tx) => {
                    if (tx) {
                        const txHash = tx.transactionHash;
                        const txId = tx.transactionId;
                        common_1.Logger.log('Tx Hash changed message received at client', {
                            transactionId: txId,
                            hash: txHash
                        });
                        engine &&
                            engine.emit('txHashChanged', {
                                id: tx.transactionId,
                                hash: tx.transactionHash,
                                msg: 'txn hash changed'
                            });
                    }
                },
                onError: async (tx) => {
                    if (tx) {
                        common_1.Logger.error('Error message received at client', JSON.stringify(tx));
                        const err = tx.error;
                        const txId = tx.transactionId;
                        clientMessenger.unsubscribe(txId);
                        // event emitter
                        engine &&
                            engine.emit('error', {
                                id: tx.transactionId,
                                error: err,
                                msg: 'txn hash generated'
                            });
                        throw new Error(err);
                    }
                }
            });
        }
        const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation, bundlerServiceResponse.transactionId, engine);
        // const receipt = await transactionResponse.wait()
        // console.log('transactionResponse in sendTransaction', receipt)
        return transactionResponse;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    unwrapError(errorIn) {
        var _a;
        if (errorIn.body != null) {
            const errorBody = JSON.parse(errorIn.body);
            let paymasterInfo = '';
            let failedOpMessage = (_a = errorBody === null || errorBody === void 0 ? void 0 : errorBody.error) === null || _a === void 0 ? void 0 : _a.message;
            if ((failedOpMessage === null || failedOpMessage === void 0 ? void 0 : failedOpMessage.includes('FailedOp')) === true) {
                const matched = failedOpMessage.match(/FailedOp\((.*)\)/);
                if (matched != null) {
                    const split = matched[1].split(',');
                    paymasterInfo = `(paymaster address: ${split[1]})`;
                    failedOpMessage = split[2];
                }
            }
            const error = new Error(`The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo})`);
            error.stack = errorIn.stack;
            return error;
        }
        return errorIn;
    }
    verifyAllNecessaryFields(transactionRequest) {
        if (transactionRequest.to == null) {
            throw new Error('Missing call target');
        }
        if (transactionRequest.data == null && transactionRequest.value == null) {
            // TBD: banning no-op UserOps seems to make sense on provider level
            throw new Error('Missing call data or value');
        }
    }
    connect(provider) {
        common_1.Logger.log('changing providers connect called', provider);
        throw new Error('changing providers is not supported');
    }
    async getAddress() {
        if (this.address == null) {
            this.address = await this.erc4337provider.getSenderAccountAddress();
        }
        return this.address;
    }
    async signMessage(message) {
        return await this.originalSigner.signMessage(message);
    }
    async signTransaction(transaction) {
        common_1.Logger.log('signTransaction called', transaction);
        throw new Error('not implemented');
    }
    async signUserOperation(userOperation) {
        const message = await this.smartAccountAPI.getUserOpHash(userOperation);
        return await this.originalSigner.signMessage(message);
    }
}
exports.ERC4337EthersSigner = ERC4337EthersSigner;
//# sourceMappingURL=ERC4337EthersSigner.js.map