"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAccountAPI = void 0;
const ethers_1 = require("ethers");
const ethers_lib_1 = require("@biconomy/ethers-lib");
const utils_1 = require("ethers/lib/utils");
const common_1 = require("@biconomy/common");
/**
 * Base class for all Smart Wallet ERC-4337 Clients to implement.
 * Subclass should inherit 5 methods to support a specific wallet contract:
 *
 * - getAccountInitCode - return the value to put into the "initCode" field, if the account is not yet deployed. should create the account instance using a factory contract.
 * - getNonce - return current account's nonce value
 * - encodeExecute - encode the call from entryPoint through our account to the target contract.
 * - signUserOpHash - sign the hash of a UserOp.
 *
 * The user can use the following APIs:
 * - createUnsignedUserOp - given "target" and "calldata", fill userOp to perform that operation from the account.
 * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it
 */
// Note: Resembles SmartAccount methods itself. Could be sperated out across smart-account & || transactions || new package and reclaim
class BaseAccountAPI {
    /**
     * base constructor.
     * subclass SHOULD add parameters that define the owner (signer) of this wallet
     * @param provider - read-only provider for view calls
     * @param entryPointAddress - the entryPoint to send requests through (used to calculate the request-id, and for gas estimations)
     * @param accountAddress. may be empty for new wallet (using factory to determine address)
     */
    constructor(provider, entryPoint, // we could just get an address : evaluate
    clientConfig, // review the need to get entire clientconfig
    accountAddress, overheads) {
        this.provider = provider;
        this.entryPoint = entryPoint;
        this.clientConfig = clientConfig;
        this.accountAddress = accountAddress;
        this.overheads = overheads;
        this.isDeployed = false;
        // factory "connect" define the contract address. the contract "connect" defines the "from" address.
        // this.entryPointView = EntryPoint__factory.connect(entryPointAddress, provider).connect(ethers.constants.AddressZero)
    }
    // placeholder to replace paymaster
    connectPaymaster(newPaymasterAPI) {
        this.paymasterAPI = newPaymasterAPI;
        return this;
    }
    // based on provider chainId we maintain smartWalletContract..
    async _getSmartAccountContract() {
        if (this.accountContract == null) {
            // may rename if to account factory
            this.accountContract = ethers_lib_1.SmartWalletFactoryV100.connect(await this.getAccountAddress(), this.provider);
        }
        return this.accountContract;
    }
    async init() {
        // Check entry point must be deployed
        /*
        if (await this.provider.getCode(this.entryPoint.address) === '0x') {
          throw new Error(`entryPoint not deployed at ${this.entryPoint.address}`)
        }
        */
        await this.getAccountAddress();
        return this;
    }
    /**
     * check if the wallet is already deployed.
     */
    async checkAccountDeployed() {
        if (this.isDeployed) {
            // already deployed. no need to check anymore.
            return this.isDeployed;
        }
        const senderAddressCode = await this.provider.getCode(await this.getAccountAddress());
        if (senderAddressCode.length > 2) {
            common_1.Logger.log('Smart account Contract already deployed at', this.senderAddress);
            this.isDeployed = true;
        }
        else {
        }
        return this.isDeployed;
    }
    /**
     * calculate the wallet address even before it is deployed
     */
    async getCounterFactualAddress() {
        const initCode = await this.getAccountInitCode();
        // use entryPoint to query account address (factory can provide a helper method to do the same, but
        // this method attempts to be generic
        try {
            await this.entryPoint.callStatic.getSenderAddress(initCode);
            /* eslint-disable  @typescript-eslint/no-explicit-any */
        }
        catch (e) {
            return e.errorArgs.sender;
        }
        throw new Error('must handle revert');
    }
    /**
     * return initCode value to into the UserOp.
     * (either deployment code, or empty hex if contract already deployed)
     */
    async getInitCode() {
        if (!(await this.checkAccountDeployed())) {
            return await this.getAccountInitCode();
        }
        return '0x';
    }
    /**
     * ABI-encode a user operation. used for calldata cost estimation
     */
    packUserOp(userOp) {
        return (0, common_1.packUserOp)(userOp, false);
    }
    async encodeUserOpCallDataAndGasLimit(detailsForUserOp) {
        var _a;
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        function parseNumber(a) {
            if (a == null || a === '')
                return null;
            return ethers_1.BigNumber.from(a.toString());
        }
        let callData;
        if (detailsForUserOp.target.length == 1) {
            if (detailsForUserOp &&
                detailsForUserOp.target[0] === '' &&
                detailsForUserOp.data[0] === '') {
                return {
                    callData: '0x',
                    callGasLimit: ethers_1.BigNumber.from('21000')
                };
            }
            const value = (_a = parseNumber(detailsForUserOp.value[0])) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from(0);
            callData = await this.encodeExecuteCall(detailsForUserOp.target[0], value, detailsForUserOp.data[0]);
        }
        else {
            callData = await this.encodeExecuteBatchCall(detailsForUserOp.target, detailsForUserOp.value, detailsForUserOp.data);
        }
        let callGasLimit = ethers_1.BigNumber.from(0);
        // If wallet is not deployed giving a hardcoded value
        // first set the actual status by calling this below
        await this.checkAccountDeployed();
        if (!this.isDeployed) {
            // Review
            callGasLimit = ethers_1.BigNumber.from(600000);
            return {
                callData,
                callGasLimit
            };
        }
        common_1.Logger.log('detailsForUserOp.gasLimit ', detailsForUserOp.gasLimit);
        if (!detailsForUserOp.gasLimit) {
            const chainId = this.clientConfig.chainId;
            common_1.Logger.log('chainId is ', chainId);
            try {
                callGasLimit = await this.provider.estimateGas({
                    from: this.entryPoint.address,
                    to: await this.getAccountAddress(),
                    data: callData
                });
            }
            catch (error) {
                common_1.Logger.log('gas estimation failed for chainId ', chainId);
                common_1.Logger.error(' Call Gas Limit Estimation Failed with error', error.toString());
                throw new Error(' Call Gas Limit Estimation Failed ');
            }
        }
        else {
            callGasLimit = ethers_1.BigNumber.from(detailsForUserOp.gasLimit);
        }
        return {
            callData,
            callGasLimit
        };
    }
    /**
     * return userOpHash for signing.
     * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)
     * @param userOp userOperation, (signature field ignored)
     */
    async getUserOpHash(userOp) {
        const chainId = await this.provider.getNetwork().then((net) => net.chainId);
        const userOpHash = (0, utils_1.keccak256)((0, common_1.packUserOp)(userOp, true));
        const enc = utils_1.defaultAbiCoder.encode(['bytes32', 'address', 'uint256'], [userOpHash, this.entryPoint.address, chainId]);
        return (0, utils_1.keccak256)(enc);
    }
    /**
     * return the wallet's address.
     * this value is valid even before deploying the wallet.
     */
    async getAccountAddress() {
        if (this.senderAddress == null) {
            if (this.accountAddress != null) {
                this.senderAddress = this.accountAddress;
            }
            else {
                this.senderAddress = await this.getCounterFactualAddress();
            }
        }
        return this.senderAddress;
    }
    async estimateCreationGas(initCode) {
        if (initCode == null || initCode === '0x')
            return 0;
        const deployerAddress = initCode.substring(0, 42);
        const deployerCallData = '0x' + initCode.substring(42);
        return await this.provider.estimateGas({ to: deployerAddress, data: deployerCallData });
    }
    /**
     * Sign the filled userOp.
     * @param userOp the UserOperation to sign (with signature field ignored)
     */
    // Note: could be moved in Account specific API class
    // for example BiconomySmartAccountAPI could reject if length is not accurate
    async signUserOp(userOp) {
        common_1.Logger.log('signUserOp', userOp);
        const userOpHash = await this.getUserOpHash(userOp);
        let signature = await this.signUserOpHash(userOpHash);
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== '0x')
            signature = '0x' + signature;
        common_1.Logger.log('userOp signature: ', signature);
        return {
            ...userOp,
            signature
        };
    }
    /**
     * helper method: create and sign a user operation.
     * @param info transaction details for the userOp
     */
    async createSignedUserOp(info) {
        return await this.signUserOp(await this.createUnsignedUserOp(info));
    }
    /**
     * get the transaction that has this userOpHash mined, or null if not found
     * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)
     * @param timeout stop waiting after this timeout
     * @param interval time to wait between polls.
     * @return the transactionHash this userOp was mined, or null if not found.
     */
    async getUserOpReceipt(userOpHash, timeout = 30000, interval = 5000) {
        const endtime = Date.now() + timeout;
        while (Date.now() < endtime) {
            // Review entryPointView -> entryPoint
            const events = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationEvent(userOpHash));
            if (events.length > 0) {
                return events[0].transactionHash;
            }
            await new Promise((resolve) => setTimeout(resolve, interval));
        }
        return null;
    }
}
exports.BaseAccountAPI = BaseAccountAPI;
//# sourceMappingURL=BaseAccountAPI.js.map