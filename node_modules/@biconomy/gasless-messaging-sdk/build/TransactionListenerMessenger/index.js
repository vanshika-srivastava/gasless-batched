"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const amqplib_1 = require("amqplib");
const cent_js_1 = require("cent.js");
const centrifuge_1 = __importDefault(require("centrifuge"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const ws_1 = require("ws");
const TransactionMessenger_1 = __importDefault(require("./TransactionMessenger"));
class TransactionListnerMessenger {
    constructor(transactionListenerId, socketClientEndpoint, socketAdminEndpoint, socketAdminSecret, socketApiKey, queue, onTransactionHashChanged, onTransactionHashGenerated) {
        this.socketClient = new centrifuge_1.default(socketClientEndpoint, {
            debug: process.env.BICONOMY_SDK_DEBUG === 'true' || process.env.REACT_APP_BICONOMY_SDK_DEBUG === 'true',
            websocket: ws_1.WebSocket,
        });
        const token = jsonwebtoken_1.default.sign({ sub: `TransactionListener_${transactionListenerId}` }, socketAdminSecret);
        this.socketClient.setToken(token);
        this.socketAdmin = new cent_js_1.CentClient({
            url: socketAdminEndpoint,
            token: socketApiKey,
        });
        this.onTransactionHashChanged = onTransactionHashChanged;
        this.onTransactionHashGenerated = onTransactionHashGenerated;
        this.queue = queue;
    }
    transactionListenerMessageHandler(messageCtx) {
        const { transactionId, event, transactionHash, relayerAddress, networkId, } = messageCtx.data;
        if (!transactionId)
            throw new Error(`Invalid message received: ${JSON.stringify(messageCtx, undefined, 4)}`);
        // if subscriped to this transaction ID
        if (event === 'transactionHashChanged') {
            this.onTransactionHashChanged(new TransactionMessenger_1.default(transactionId, transactionHash, networkId, relayerAddress, this.socketClient, this.socketAdmin));
            // deleting the handler on dropped or mined
            // this prevents memory leaks and also provides deduplication
        }
        else if (event === 'transactionHashGenerated') {
            this.onTransactionHashGenerated(new TransactionMessenger_1.default(transactionId, transactionHash, networkId, relayerAddress, this.socketClient, this.socketAdmin));
        }
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            // consume it from queue
            const connection = yield (0, amqplib_1.connect)(this.queue.url);
            const channel = yield connection.createChannel();
            channel.assertQueue(this.queue.name, {
                durable: true,
            });
            channel.consume(this.queue.name, (msg) => __awaiter(this, void 0, void 0, function* () {
                const data = JSON.parse(msg.content.toString());
                this.transactionListenerMessageHandler({
                    data,
                });
                channel.ack(msg);
            }));
        });
    }
}
exports.default = TransactionListnerMessenger;
//# sourceMappingURL=index.js.map